Ext.data.JsonP.getting_started({"guide":"<h1 id='getting_started-section-getting-started-with-affinity'>Getting Started with Affinity</h1>\n<div class='toc'>\n<p><strong>Contents</strong></p>\n<ol>\n<li><a href='#!/guide/getting_started-section-relations'>Relations</a></li>\n<li><a href='#!/guide/getting_started-section-performing-operations'>Performing Operations</a></li>\n<li><a href='#!/guide/getting_started-section-restriction-and-extend-operations'>Restriction and Extend Operations</a></li>\n</ol>\n</div>\n\n<h2 id='getting_started-section-relations'>Relations</h2>\n\n<p>Relations are very much like tables. They are a set of tuples conforming to\na header. They implement the basic set operations (set difference, ...)\nbut also add other operations and constraints.</p>\n\n<p>For example, relations cannot contain null values, nor duplicates.</p>\n\n<p>This is a relation (the attribute ordering is always arbitrary)</p>\n\n<pre><code>+-----------------------+----------------------+------------------+\n| firstName : TString   | lastName : TString   | age : TInteger   |\n+=======================+======================+==================+\n| Maybelline            | Durocher             | 23               |\n+-----------------------+----------------------+------------------+\n| Danella               | Barbara              | 23               |\n+-----------------------+----------------------+------------------+\n| Daniel                | Bandy                | 87               |\n+-----------------------+----------------------+------------------+\n| Bobo                  | Dada                 | 34               |\n+-----------------------+----------------------+------------------+\n</code></pre>\n\n<h3 id='getting_started-section-the-header-%28or-heading%29'>The Header (or heading)</h3>\n\n<p>The Header is an ordered Set of attributes.</p>\n\n<pre><code>+-----------------------+----------------------+------------------+\n| firstName : TString   | lastName : TString   | age : TInteger   |\n+=======================+======================+==================+\n</code></pre>\n\n<h3 id='getting_started-section-the-attributes'>The Attributes</h3>\n\n<p>An Attribute is an ordered pair (Name : Type).</p>\n\n<pre><code>+------------------+\n| age : TInteger   |\n+==================+\n</code></pre>\n\n<h3 id='getting_started-section-the-body'>The Body</h3>\n\n<p>The Body is the Set of Tuples a Relation contains. All Tuples in a Relation\nmust conform to the Relation Header.</p>\n\n<pre><code>+=======================+======================+==================+\n| Maybelline            | Durocher             | 23               |\n+-----------------------+----------------------+------------------+\n| Danella               | Barbara              | 23               |\n+-----------------------+----------------------+------------------+\n| Daniel                | Bandy                | 87               |\n+-----------------------+----------------------+------------------+\n| Bobo                  | Dada                 | 34               |\n+-----------------------+----------------------+------------------+\n</code></pre>\n\n<h3 id='getting_started-section-a-tuple'>A Tuple</h3>\n\n<p>A Tuple is an ordered set, each value being identified by it's name.\nIn this case :</p>\n\n<pre><code>var tuple = new Tuple(firstName : 'Danella', lastName : 'Barbara', age : 23);\n\n+-----------------------+----------------------+------------------+\n| Danella               | Barbara              | 23               |\n+-----------------------+----------------------+------------------+\n</code></pre>\n\n<h3 id='getting_started-section-declaring-relations'>Declaring Relations</h3>\n\n<p>To declare relations, you must specify a Header and a Body.</p>\n\n<pre><code>var relation = new affinity.Relation([\n    { firstName : { type : affinity.String}},\n    { lastName : { type : affinity.String}},\n    { age : { type : affinity.Integer}}\n],[\n    ['John', 'Wilson', 34],\n    ['Mary', 'McGibbins', 32],\n    ['Lucy', 'Dandy', 31],\n    ['Mark', 'Galiper', 39],\n]);\n</code></pre>\n\n<p>When declaring a relation, the order in which you declare the attributes\nwill be the order in which you will declare the tuples attribute values.\n(firstName first, lastName second, age third).</p>\n\n<p>This is against the \"grain\" of the relational definition of a Relation. Why?\nBecause attributes are not supposed to be ordered in a Relation Header. They are ordered\nbecause they have a name, but there is no \"first\" or \"second\" attribute. So saying\nthat the \"first\" attribute of a Tuple is \"John\" or \"Mary\" makes no sense.\nThis declaration API is simply a nicer way to define a Relation.</p>\n\n<p>Though, if you want, you can define a header like this :</p>\n\n<pre><code>var header = new affinity.Header({\n    firstName : { type : affinity.String}},\n    lastName : { type : affinity.String}},\n    age : { type : affinity.Integer}},\n)\n</code></pre>\n\n<p>And you won't be able to pass the body as :</p>\n\n<pre><code>var relation = new affinity.Relation(header,[\n    [ 'John', 'Wilson', 34 ] // Not Good\n]);\n</code></pre>\n\n<p>But you will have to pass the body like this :</p>\n\n<pre><code>var relation = new affinity.Relation(header, [\n    { firstName : 'John', lastName : 'Wilson', age : 34 } // Good\n]);\n</code></pre>\n\n<p>Or like this :</p>\n\n<pre><code>var relation = new affinity.Relation(header, [\n        new affinity.Tuple({ firstName : 'John', lastName : 'Wilson', age : 34 }) // Good\n    ]);\n</code></pre>\n\n<h2 id='getting_started-section-performing-operations'>Performing Operations</h2>\n\n<p>Now that you have a relation, you're happy. But you want to be able to\nperform relational operations on that relation. Let's say we wanted to\nperform a union on two relations.</p>\n\n<pre><code>var A = new affinity.Relation([\n        { firstName : { type : affinity.String}},\n        { lastName : { type : affinity.String}},\n        { age : { type : affinity.Integer}}\n    ],[\n        ['John', 'Wilson', 34],\n        ['Mary', 'McGibbins', 32],\n        ['Lucy', 'Dandy', 31],\n        ['Mark', 'Galiper', 39],\n    ]);\n\nvar B = new affinity.Relation([\n        { firstName : { type : affinity.String}},\n        { lastName : { type : affinity.String}},\n        { age : { type : affinity.Integer}}\n    ],[\n        ['Natalia', 'Bali', 24],\n        ['Suma', 'Gandi', 45],\n        ['Rob', 'Sneizer', 10],\n        ['Mark', 'Galiper', 39],\n    ]);\n\nvar C = A.union(B);\n\nC.print();\n\n// +-----------------------+----------------------+------------------+\n// | firstName : TString   | lastName : TString   | age : TInteger   |\n// +=======================+======================+==================+\n// | John                  | Wilson               | 34               |\n// +-----------------------+----------------------+------------------+\n// | Mary                  | McGibbins            | 32               |\n// +-----------------------+----------------------+------------------+\n// | Lucy                  | Dandy                | 31               |\n// +-----------------------+----------------------+------------------+\n// | Mark                  | Galiper              | 39               |\n// +-----------------------+----------------------+------------------+\n// | Natalia               | Bali                 | 24               |\n// +-----------------------+----------------------+------------------+\n// | Suma                  | Gandi                | 45               |\n// +-----------------------+----------------------+------------------+\n// | Rob                   | Sneizer              | 10               |\n// +-----------------------+----------------------+------------------+\n</code></pre>\n\n<p>Note that Mark Galiper has not been added twice to our Union relation.\nThis is because nor Relations nor Sets allow duplicate elements. Otherwise,\nthey wouldn't be relations nor sets anymore.</p>\n\n<p>Union is a simple relational operator. But there are other more exotic ones. Check in the\nOperators package.</p>\n\n<h2 id='getting_started-section-restriction-and-extend-operations'>Restriction and Extend Operations</h2>\n\n<p>The Restriction and Extend operators must be constructed with a predicate or expression.</p>\n\n<p>In the case of the Restriction, the predicate will be evaluated on a Tuple to check if\nit is eligible or not. In the case of an Extension, the expression will return the value\nof an added calculated attribute.</p>\n\n<p>While you can use custom callbacks for this purpose, I advise against it because in the\nnear future, Affinity will be an SQL parser and won't be able to determine what\nkind of operations were used in custom callbacks.</p>\n\n<p>Note that for restriction, the predicate must return a boolean. For extensions,\nit may return any type.</p>\n\n<p>Restriction Example :</p>\n\n<pre><code>var firstName = A.get('firstName');\nvar lastName = A.get('lastName');\nvar age = A.get('age');\n\nvar restricted = A.restrict(firstName.substr(0,1).eq('M').or(age.div(3).gt(lastName.length())))\n\n// Would translate to (firstName.substr(0,1) === 'M') || (age/3 &gt; lastName.length);\n</code></pre>\n\n<p>Extension Example :</p>\n\n<pre><code>var extended = A.extend([ { nameUpper : firstName.uppercase() } ], { firstUpper : nameUpper.substr(0,1) });\n\n// +-----------------------+----------------------+------------------+---------------------+----------------------+\n// | firstName : TString   | lastName : TString   | age : TInteger   | nameUpper : TString | firstUpper : TString |\n// +=======================+======================+==================+=====================+======================+\n// | John                  | Wilson               | 34               | JOHN                | J                    |\n// +-----------------------+----------------------+------------------+---------------------+----------------------+\n// | Mary                  | McGibbins            | 32               | MARY                | M                    |\n// +-----------------------+----------------------+------------------+---------------------+----------------------+\n// | Lucy                  | Dandy                | 31               | LUCY                | L                    |\n// +-----------------------+----------------------+------------------+---------------------+----------------------+\n// | Mark                  | Galiper              | 39               | MARK                | M                    |\n// +-----------------------+----------------------+------------------+---------------------+----------------------+\n</code></pre>\n\n<p>Custom Callback Function :</p>\n\n<pre><code>var extended = A.extend([ \n\n{ nameUpper : function(tuple){\n    return tuple.get('firstName').toUppercase();\n}, type : affinity.String }, \n\n{ firstUpper : function(tuple){\n    return tuple.get('nameUpper').substr(0,1);\n}, type : affinity.String }\n\n]);\n</code></pre>\n\n<p>Custom callbacks API does not allow an extension with the name \"type\", which is stupid.\nIt will be corrected very soon.</p>\n\n<h3 id='getting_started-section-note-on-operation-precedence'>Note on operation precedence</h3>\n\n<p>Normally in mathematics when you have</p>\n\n<pre><code>a+b/c\n</code></pre>\n\n<p>It would be evaluated as</p>\n\n<pre><code>a+(b/c) \n</code></pre>\n\n<p>and not</p>\n\n<pre><code>(a+b)/c. \n</code></pre>\n\n<p>We do not currently have a system to determine which operator has which precedence\non which. So to write this equation, you would write:</p>\n\n<pre><code>a.plus(b.div(c)) // Good\n</code></pre>\n\n<p>Because</p>\n\n<pre><code>a.plus(b).div(c) // Not good\n</code></pre>\n\n<p>Would evaluate to</p>\n\n<pre><code>(a+b)/c\n</code></pre>\n","title":"Getting Started with Affinity"});