(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.affinity = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = require('./lib');
},{"./lib":101}],2:[function(require,module,exports){
var Base = require('./Base.js');
var Type = require('./Type.js');
var _ = require('lodash');

var Attribute = Base.extend(

    {

        /**
         * @class Attribute
         * @extends Base
         * @param {Object} args
         * @param {String|null} [args.name] The name of the {@link Attribute}
         * @param {Type|null} [args.type] The {@link Type} of the {@link Attribute}
         * @param {*} [args.default] The default value of the Attribute
         *
         *
         * A {@link Relation}'s {@link Header} is composed of Attributes.
         *
         * An {@link Attribute} is simply an ordered {@link Set} {name : String, type : {@link Type}}
         *
         * The {@link Type} of an {@link Attribute} is a class that is mainly used to compare the values of the
         * Relation's tuples for this attibute.
         *
         * For example,
         * when running an {@link Operators.Union} on a {@link Relation}, the {@link Tuple}s will be tested for equality so that the
         * {@link Relation} does not include duplicates (as the mathematical definition of a {@link Set} tells us).
         * To do this, we compare two {@link Tuple} by comparing the value of their {@link Attribute}s. If for these two
         * {@link Tuple}s, all their {@link Attribute} values are equal, the two {@link Tuple}s are said to be equal.
         *
         * To test the equality of primitive {@link Attribute}s (String, Boolean, Integer...), this is easy.
         * We test the equality of two {@link Attribute}s with the equality operator "==".
         *
         * Though, when it comes to Object {@link Attribute}s, it is not possible to test the equality with the equality operator
         * "==". We need a function that will test the two objects for equality and that will return true/false.
         *
         * To resume, the {@link Type} of an {@link Attribute} must implement the methods used to compare the corresponding
         * {@link Tuple} {@link Attribute} values.
         *
         * For {@link Types.Numeric} {@link Type}s, the {@link Type} will also implement other comparison operators such as LargerThan (.lt()) ...
         *
         * For {@link Types.Date} {@link Type}s, the {@link Type} will also implement other operators such as DayOfWeek, ...
         *
         *     var fn = new affinity.Attribute({name : 'FirstName', type : 'affinity.String'})
         *     var ln = new affinity.Attribute({name : 'LastName', type : 'affinity.String'})
         *
         */
        constructor: function (args) {

            /**
             * Tells if the attribute was _negated in an expression
             * @private
             * @type {boolean}
             */
            this._negated = false;

            /**
             * Default value for the attribute
             * @type {undefined}
             * @private
             */
            this._default = undefined;

            /**
             * Tells if the attribute is an auto incrementing attribute
             * @type {boolean}
             * @private
             */
            this._autoIncrement = false;

            /**
             * Tells if the attribute is a calculated attribute
             * @type {boolean}
             * @private
             */
            this._calculated = false;

            /**
             * Name of the attribute
             * @type {String}
             */
            this.name = undefined;

            /**
             * Type of the attribute
             * @type {Type}
             */
            this.type = undefined;

            // Check if the args are given
            if (args) {

                // Check if the name arg is given
                if (args.name) {

                    // Check if the name arg is of good type
                    if (!_.isString(args.name)) {

                        // If the name is not a string, throw
                        throw new TypeError('Name is of wrong type');

                    } else {

                        // Name arg seems to be legit
                        this.name = args.name;
                    }
                } else {

                    // If the name arg is not given, set it to null
                    this.name = null;
                }

                // Check if the type arg is given
                if (args.type) {

                    // Check if the type arg is of good type
                    if (!(args.type.prototype instanceof Type) && !(args.type.__proto__ instanceof Type)) {

                        // If the type arg is not of type Type, throw
                        throw new TypeError('Type is of wrong type')

                    } else {
                        // Type arg seems to be legit
                        this.type = args.type;

                        _.forIn(args.type.payload, function(mix){

                            _.forIn(mix, function (mixin, key) {

                                this[key] = mixin;

                            },this)

                        },this);

                    }

                } else {
                    // If the type arg is not given, set it to null
                    this.type = null;
                }

                if (args.hasOwnProperty('default')){
                    this._default = args.default;
                }

                if (args.hasOwnProperty('autoIncrement')){
                    this._autoIncrement = args.autoIncrement;
                }

            }

            Base.apply(this, arguments);
        },

        /**
         * Calculted Property getter setter
         * @param {Boolean} isCalculated
         * @return {undefined|Boolean}
         */
        calculated : function(isCalculated){

            if(_.isBoolean(isCalculated)){
                this._calculated = isCalculated;
            } else {
                return this._calculated;
            }

        },

        /**
         * Clones the Attribute object
         * @return {Attribute} cloned attribute
         *
         *     var fn = new affinity.Attribute({name : 'FirstName',affinity.String});
         *
         *     var ln = attribute.clone();
         *
         *     ln.equal(fn) // true
         *
         *     ln.name = 'LastName';
         *
         *     ln.equal(fn) // false
         *
         *
         */
        clone: function () {

            var attr = new this.constructor({type: this.type, name: this.name});

            if (this.relationHeader) {
                attr.relationHeader = this.relationHeader;
;           }

            if (this.wrappedAttributes){
                attr.wrappedAttributes = this.wrappedAttributes;
            }

            attr.calculated(this.calculated());

            return attr;
        },

        /**
         * Checks if the attribute is being _negated in a predicate
         * @param expression
         * @returns {*}
         * @private
         */
        _checkNegatedAttribute: function (expression) {

            if (this._negated) {
                this._negated = false;
                return new (require('./functions/connective/Not.js'))(expression);

            } else {

                return expression;
            }

        },

        /**
         * String representation of the attribute. Used to print a Relation into console
         * as a Unicode Table
         * @private
         */
        toString: function () {

            return this.name + ' : ' + this.type.toString();

        },

        /**
         * Checks if two attributes are equal
         * @param attribute
         * @returns {boolean}
         */
        equal : function(attribute){

            return this.constructor.equal(this, attribute);

        },

        default : function(){

            if(this._autoIncrement){
                return this.header.relation.length() + this.header.relation._deletedCount;
            }

            return this._default;
        }

    }, {

        type : 'Attribute',

        /**
         * Asserts that a given name is valid for an attribute
         * @private
         * @param name
         */
        assertValidName : function(name){

            if(!_.isString(name)){
                throw new Error('Name must be a string')
            }

            if(name === ''){
                throw new Error('Attribute name cannot be empty string');
            }

        },

        /**
         * Tests for equality between two attributes
         *
         * This method returns a Boolean. It cannot be part of a predicate.
         *
         * @param {Attribute} attribute1
         * @param {Attribute} attribute2
         * @returns {boolean}
         * @static

         */
        equal: function (attribute1, attribute2) {

            return ((attribute1.name === attribute2.name) && (attribute1.type === attribute2.type))

        },

        /**
         * Coerces an arbitrary object to type Attribute
         * @param {Attribute|Object} attribute
         * @returns {Attribute}
         * @static
         *
         *     var fn1 = new affinity.Attribute({name : 'FirstName', type : affinity.String});
         *
         *     var fn2 = {name : 'FirstName' , type : affinity.String}
         *
         *     affinity.Attribute.coerce(fn1) === fn1 // true, the object was already an Attribute.
         *     affinity.Attribute.coerce(fn2) === fn2 // false, the object had to be coerced
         *
         *     affinity.Attribute.coerce(fn2).equal(fn1) // true
         *
         */
        coerce: function (attribute) {


            var name;
            var type;
            var attr;
            var keys;
            var autoIncrement;
            var defaultValue;

            if (attribute instanceof Attribute) {

                return attribute;

            }

            if(_.isObject(attribute)){

                // Attribute is of the type {name : <name>, type : <type>}
                if(attribute.type && attribute.name){

                    name = attribute.name;
                    type = attribute.type;
                    autoIncrement = attribute.autoIncrement;
                    defaultValue = attribute.default;

                } else {

                    // Attribute is either
                    // { <name> : { type : <type> } }
                    // { <name> : <Attribute> }

                    keys = _.keys(attribute);

                    if (keys.length !== 1){
                        throw new Error('Unsupported Attribute declaration');
                    }

                    // Name of the Attribute
                    name = keys[0];

                    // Attribute object
                    attr = attribute[name];


                    if(attr instanceof Attribute){

                        // Attribute is { <name> : <Attribute>}

                        attr.name = name;

                        return attr;

                    } else if(attr.type){

                        // Attribute is { <name> : { type : <type> } }

                        type = attribute[name].type;
                        autoIncrement = attribute[name].autoIncrement;
                        defaultValue = attribute[name].default;

                    }

                }

            }

            return new Attribute({name : name, type : type, autoIncrement : autoIncrement, default : defaultValue});

        }

    });

module.exports = Attribute;

},{"./Base.js":3,"./Type.js":12,"./functions/connective/Not.js":45,"lodash":103}],3:[function(require,module,exports){
var _ = require('lodash');
// Helper function to correctly set up the prototype chain, for subclasses.
// Similar to `goog.inherits`, but uses a hash of prototype properties and
// class properties to be extended.
var extend = function (protoProps, staticProps) {

    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
        child = protoProps.constructor;
    } else {
        child = function () {
            return parent.apply(this, arguments);
        };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function () {
        this.constructor = child;
    };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;

};

/**
 * @class Base
 */
var Base = function () {

};

/**
 * @member Base
 * @method extend
 */
Base.extend = extend;

/**
 * @member Base
 */
Base.mixin = function(mixin){
    _.extend(this.prototype, mixin);
};

module.exports = Base;
},{"lodash":103}],4:[function(require,module,exports){
var Base = require('./Base'),
    Index = require('./Index'),
    Header = require('./Header'),
    _ = require('lodash'),
    Attribute = require('./Attribute'),
    Tuple = require('./Tuple'),
    debug = require('./helpers/debug'),
    equal = require('./helpers/equal');

var ForeignKey = Base.extend({

    /**
     * @class ForeignKey
     * @extends Base
     * @param {Object} params
     * @param {Relation} params.relation
     * @param {string|string[]|Header} params.columnNames
     * @param {Relation} params.referencedRelation
     * @param {string|string[]|Header} params.referencedColumnNames
     * @param {string} params.onUpdate
     * @param {string} params.onDelete
     *
     * The ForeignKey class represents foreign keys to a relation.
     *
     * The foreign key enforces the relational integrity of different relations.
     *
     *
     *     var dogs = new affinity.Relation([
     *          {id : {type : affinity.Integer}},
     *          {ownerId : {type : affinity.Integer}},
     *          {name : {type : affinity.Integer}},
     *      ],[
     *          [0, 0, 'Fido'],
     *          [1, 0, 'Bobby'],
     *          [2, 1, 'Stacey'],
     *          [3, 2, 'Ceasar'],
     *      ],{
     *          pk : ['id'],
     *          fk : [
     *              {
     *                  columnNames           : ['ownerId'],
     *                  referencedRelation    : people,
     *                  referencedColumnNames : ['id'],
     *                  onUpdate              : 'cascade',
     *                  onDelete              : 'restrict'
 *                  },
     *              ...
     *          ]
     *      });
     */
    constructor: function (params) {

        debug.foreignKey.trace('#constructor');

        // relation, columnNames, referencedRelation, referencedColumnNames, onUpdate, onDelete

        /** @property {Header} columns */
        this.columns = null;

        /** @property {Header} referencedColumns */
        this.referencedColumns = null;

        /** @property {Relation} relation */
        this.relation = params.relation;

        /** @property {Relation} referencedRelation */
        this.referencedRelation = params.selfReferencing ? this.relation : params.referencedRelation;

        // Validate columnNames parameter

        if (params.columnNames instanceof Header) {

            // columnNames is already a header
            if (!params.columnNames.isSubset(relation.header()))
                throw new Error('Parameter columnNames passed as invalid Header. ');

            this.columns = params.columnNames;

        } else {

            if(!_.isArray(params.columnNames)){
                params.columnNames = [params.columnNames];
            }

            this.columns =  this.relation.header().clone().project(params.columnNames);

        }


        // Validate referencedColumnNames parameter

        if (params.referencedColumnNames instanceof Header) {

            // referencedColumnNames is already a header
            if (!params.referencedColumnNames.isSubset(params.referencedRelation.header()))
                throw new Error('Parameter referencedColumnNames passed as invalid Header. ');

            this.referencedColumns = params.referencedColumnNames;

        } else {

            if(!_.isArray(params.referencedColumnNames)){
                params.referencedColumnNames = [params.referencedColumnNames];
            }
            this.referencedColumns = this.referencedRelation.header().clone().project(params.referencedColumnNames);

        }

        //todo : Verify onUpdate
        //todo : Verify onDelete

        var that = this;


        // Check that the added tuple respects the foreign key constraint before adding the tuple

        this.relation.ee.on('afterAdd', function(tuple, tupleIndex){

            debug.foreignKey.trace('#beforeAdd');

            try {

                that.checkForeignKeyConstraint(tuple);

            } catch (err) {

                that.relation.removeAt(tupleIndex);

                throw(err);

            }

        });

        // Remove then add the tuple from index before the tuple update

        this.relation.ee.on('beforeUpdate', function(tuple, attributeName, attributeValue){

            debug.foreignKey.trace('#beforeUpdate');

            var projectedTuple = tuple.clone();

            projectedTuple.set(attributeName, attributeValue);

            that.checkForeignKeyConstraint(projectedTuple);

        });

    },

    checkForeignKeyConstraint : function(tuple){

        debug.foreignKey.trace('#checkForeignKeyConstraint');

        var that = this,
            keyTuple,
            temporaryRelation,
            Relation,
            projectedReferencedRelation,
            intersectedRelation;


        /// Build a tuple containing the required values for the given referenced columns

        keyTuple = new Tuple();

        that.referencedColumns.each(function(referencedAttribute, attributeIndex){

            var attribute = that.columns.atIndex(attributeIndex);

            keyTuple.set(referencedAttribute.name, tuple.get(attribute.name));

        });

        that.referencedRelation.each(function(tuple, index){

            var result = true;

            keyTuple.each(function(attribute){

                if (!equal(null, keyTuple.get(attribute), tuple.get(attribute))){
                    result = false;
                    return false;
                }

            });

            if (result == false){
                throw new Error('Foreign key constraint check fail')
            }

        });

    }

},{

    cascadeValues : ['cascade', 'prevent']

});

module.exports = ForeignKey;
},{"./Attribute":2,"./Base":3,"./Header":6,"./Index":7,"./Tuple":11,"./helpers/debug":82,"./helpers/equal":83,"lodash":103}],5:[function(require,module,exports){
var Base = require('./Base.js');
var _ = require('lodash');
var Attribute = require('./Attribute');

var Function = Base.extend(

    {

        /**
         * @class Function
         * @param parameters
         * @property [Array] parameters
         */
        constructor: function (parameters) {

            this.parameters = [];


            for (var i = 0, j = arguments.length; i < j; i++) {

                this.parameters.push(arguments[i]);

            }

            Base.apply(this, arguments);

        },

        /**
         * Sets the function's parameter
         * @param {Object} param The parameter of the function to set
         * @returns {Function} Returns this to chain call
         */
        set: function (param) {

            for (var a in param) {
                if (param.hasOwnProperty(a))
                    this[a] = param[a];
            }

            _.forEach(this.args, function (arg) {
                if (arg instanceof Function) {
                    arg.set(param);
                }
            });

            return this;

        },

        /**
         * Helper function used to convert attributes objects into functions that will get the tuple
         * value for that attribute
         */
        convertAttributeToTuple: function () {

            _.forEach(this.parameters, function (parameter, index) {

                if (_.isFunction(parameter.convertAttributeToTuple)) {
                    parameter.convertAttributeToTuple();
                }

                if (parameter instanceof Attribute) {

                    var newFunc = new (require('./functions/tuple/Attribute'))(parameter.name);

                    newFunc.type = parameter.type;

                    this.parameters[index] = newFunc;
                }

            }, this);

        },

        assignTuple : function(tuple){

            _.forEach(this.parameters, function (parameter, index) {

                if (parameter instanceof Function) {

                    parameter.assignTuple(tuple);

                }

            }, this);

            return this;

        },


        type : function(type){

            if(type){

                this._type = type;

                _.forIn(type.payload, function (mix) {

                    _.forIn(mix, function(mixin, key){

                        this[key] = mixin;

                    }, this)

                }, this)

            } else {
                return this._type;
            }

        }

    });

module.exports = Function;
},{"./Attribute":2,"./Base.js":3,"./functions/tuple/Attribute":78,"lodash":103}],6:[function(require,module,exports){
var Attribute = require('./Attribute.js');
var Set = require('./Set.js');
var _ = require('lodash');
var TString = require('./types/String');
var TType = require('./types/Type');
var debug = require('./helpers/debug.js');

var Header = Set.extend(

    {

        /**
         * Header object constructor.
         *
         * @class Header
         * @extends Set
         * @param {Object} [attributes]
         * @throws The attributes are not passed in Array format
         *
         *
         * A {@link Header} is one of the two main parts of a
         * {@link Relation}, along with the Body (which is a {@link Set}).
         *
         * It is a {@link Set} of {@link Attribute}s. It defines the structure of the
         * {@link Tuple}s that will be part of the body of the
         * {@link Relation}. Each {@link Tuple} in a
         * {@link Relation} must match its {@link Header}
         *
         *     var header = new affinity.header([
         *          {firstname : affinity.string},
         *          {lastname : affinity.string}
         *     ])
         *
         *     var relation = new affinity.relation(); // create an empty relation without a header and without body
         *
         *     relation.header(header); // sets the relation's header
         *
         *     relation.add({firstName : 'John', lastName : 'Doe'}); // Add a tuple in the Relation that matches the header
         *
         *
         */
        constructor: function (attributes) {

            debug.header.trace('#constructor');

            var result = [];

            /**
             * Attributes of the relation
             * @type {Object}
             * @private
             */
            this._attributes = {};

            /**
             * Tells if the relation was declared in an ordered way or not
             * @type {boolean}
             * @private
             */
            this._orderedDeclaration = false;

            if (attributes) {

                // There are attributes in the arguments

                if(_.isObject(attributes)){

                    // Attributes is either an array or an object

                    if(!_.isArray(attributes)){

                        // Attributes is an Object
                        // { <name> : {type : <type>}, <name> : {type : <type>}, ... }
                        // { <name> : <attribute>, <name> : <attribute>, <name> : <attribute>, ... }

                        _.forOwn(attributes, function(attribute, key){

                            var attr = {};
                            attr[key] = attribute;
                            result.push(attr);

                        });

                    } else {

                        // Attributes is an Array
                        // [ { <name> : {type : <type>} }, { <name> : {type : <type>} }, ... ]
                        // [{ <name> : <attribute>}, {<name> : <attribute>}, {<name> : <attribute>}, ... ]

                        this._orderedDeclaration = true;

                        _.forEach(attributes, function (attribute, key) {

                            result.push(attribute);

                        },this)

                    }

                } else {
                    throw new TypeError('Unsupported attribute declaration format');
                }

            } else {

                result = []

            }

            Set.call(this, {type: Attribute, elements: result});

        },

        /**
         * Binds the events for the object
         */
        bindEvents: function () {

            debug.header.trace('#bindEvents');

            var that = this;

            this.ee.on('beforeAdd', function (element) {

                if (that._attributes.hasOwnProperty(element.name)) {
                    throw new Error('Attribute with name ' + element.name + ' already exists in header');
                }

            });

            this.ee.on('afterAdd', function (element, index) {

                that._attributes[element.name] = index;

                element.header = that;

            });

            this.ee.on('afterRemove', function (element) {
                delete that._attributes[element.name];
                that.refreshAttributes();
            });
        },

        /**
         * Refreshes the list of attributes
         */
        refreshAttributes: function () {

            debug.header.trace('#refreshAttributes');

            this._attributes = {};

            this.each(function (element, index) {

                if(!_.isUndefined(element)){
                    this._attributes[element.name] = index;
                }

            }, this)

        },

        /**
         * Gets one of the header attributes
         * @param {Attribute|String} key
         * @returns {Attribute|null}
         */
        get: function (key) {

            debug.header.trace('#get');

            if(key instanceof Attribute){

                if (!this._attributes.hasOwnProperty(key.name)) {
                    return null;
                }

                var attr = this.get(key.name);

                if(!attr.equals(key)){
                    return null;
                } else {
                    return attr;
                }

            } else if (_.isString(key)){

                if (!this._attributes.hasOwnProperty(key)) {
                    return null;
                }

                return this.elements()[this._attributes[key]];

            }

        },

        /**
         * Gets the index of an attribute in the header
         * @param {String} name
         * @returns {null|Attribute}
         */
        getIndex: function (name) {

            debug.header.trace('#getIndex');

            if (!this._attributes.hasOwnProperty(name)) {
                return null;
            }

            return this._attributes[name];

        },

        /**
         * Gets an attribute at the specified index
         * @param index
         * @returns {Attribute|null}
         */
        getAt : function(index){

            if(this._elements[index] !== undefined){
                return this._elements[index];
            }
            return null;

        },

        /**
         * Gets or sets the header attributes list
         * @param {*[]} attributes
         * @returns {undefined|null|Array}
         */
        attributes: function (attributes) {

            debug.header.trace('#attributes');

            if (attributes) {

                return this.elements(attributes);

            } else {

                return this.elements();

            }

        },

        /**
         * Clones a header and its attributes
         * @returns {Header}
         */
        clone: function () {

            debug.header.trace('#clone');

            var newHeader = new this.constructor();

            this.each(function (element) {

                if(!_.isUndefined(element)){
                    newHeader.add(element.clone(), false);
                }

            });

            return newHeader;

        },

        /**
         * Project operation on Header object
         * @param {String[]|Attribute[]} projectedAttributes
         * @returns {Header}
         */
        project: function (projectedAttributes) {

            debug.header.trace('#project');

            var resultAttributes = {},
                a;

            a = projectedAttributes.length;

            while (a--) {

                var projectedAttribute = projectedAttributes[a];

                // If string given, find the attribute with this name
                if (_.isString(projectedAttribute)) {

                    var attributeName = projectedAttribute;

                    projectedAttribute = this.get(attributeName);

                    if (projectedAttribute === null) {
                        throw new ReferenceError('Attribute with name ' + attributeName + ' not found in header');
                    }

                } else if (projectedAttribute instanceof Attribute) {

                    // Find attribute in the header

                    var found = _.find(this.elements(), function (attribute) {
                        return attribute === projectedAttribute;
                    }, this);

                    if (!found) {
                        throw new ReferenceError('Attribute not found in the header');
                    }

                } else {
                    throw new TypeError('Wrong format given for attributes in Header project operation');
                }

                resultAttributes[projectedAttribute.name] = projectedAttribute.clone();
            }

            return new Header(resultAttributes);
        },


        /**
         * Perform a removal operation on the header
         * @param {Attribute[]|String[]|Attribute|String} attributesToRemove attributes to remove from the header
         * @return {Header} the resulting header
         */
        remove: function (attributesToRemove) {

            debug.header.trace('#remove');

            var resultHeader = this.clone(),
                a,
                attribute,
                attributeName;

            // Coerce the arguments to an array
            if (_.isString(attributesToRemove) || attributesToRemove instanceof Attribute) {

                attributesToRemove = [attributesToRemove];

            } else if (!_.isArray(attributesToRemove)) {

                throw new TypeError('Wrong argument type for removal operation');

            }

            a = attributesToRemove.length;

            // Loop through each given attributes to remove

            while (a--) {

                // Check that given attributesToRemove are in the header

                if (_.isString(attributesToRemove[a])) {

                    // Passed attribute is a string.
                    // We will check if the attribute name exists.

                    attributeName = attributesToRemove[a];

                    attribute = attributesToRemove[a] = this.get(attributeName);

                    if (attribute === null) {
                        throw new ReferenceError('Attribute with name ' + attributeName + ' not found in header');
                    }

                } else {

                    // Passed attribute is an Attribute object
                    // We will check if it exists in the header

                    attribute = attributesToRemove[a];

                    attributeName = attribute.name;

                    if (!this._attributes.hasOwnProperty(attributeName)) {

                        // The attribute name doesn't exist in the header

                        throw new ReferenceError('Attribute with name ' + attributeName + ' not found in header');

                    } else if (this.get(attributeName).equal(attribute) === false) {

                        // The attribute is found but doesn't have the same type

                        throw new ReferenceError('Attribute object found in the header but not of same type');
                    }

                }

                // Delete the found attributes from the resulting header

                resultHeader.removeAt(resultHeader.getIndex(attributeName));

            }

            return resultHeader;
        },

        /**
         * Rename operation on the header
         * @param {Object} attributes
         * @returns {Header} The new set
         *
         *     var newHeader = Header.rename( { oldName : 'newName' } );
         *
         */
        rename: function (attributes) {

            debug.header.trace('#rename');

            var resultHeader = this.clone(),
                key;

            if (_.isObject(attributes)) {

                for (key in attributes) {

                    if (attributes.hasOwnProperty(key)) {

                        var newName = attributes[key];

                        // Check if the specified name is a string
                        if (!_.isString(newName)) {
                            throw new TypeError('New name for attribute ' + key + ' must be a string');
                        }

                        var targetAttribute = this.get(key);

                        // Check if the key exists in the current header
                        if (targetAttribute === null) {
                            throw new ReferenceError('Attribute with name ' + key + ' doesn\'t exist in header');
                        }

                        // Check if the renamed operation does not overwrite an existing key in the header
                        if (this._attributes.hasOwnProperty(newName) && newName !== key) {
                            throw new ReferenceError('New attribute name ' + newName + ' already exists in the header');
                        }

                        // Check if the new name is not the same as the old name
                        if (newName === key) {
                            debug.header.warn('Useless renaming operations : ' + key + ' -> ' + newName);
                        }

                        // Check if two renamed attributes don't have the same target name
                        for (var a in attributes) {
                            if (attributes.hasOwnProperty(a) && a !== key) {
                                if (newName === attributes[a]) {
                                    throw new ReferenceError('Two renamed attributes have the same target name');
                                }
                            }
                        }

                        resultHeader._attributes[newName] = resultHeader._attributes[key];

                        if (key !== newName) {
                            delete resultHeader._attributes[key];
                        }

                        resultHeader.get(newName).name = newName;

                    }
                }

            } else {

                throw new TypeError('Wrong argument type for rename operation');
            }

            return resultHeader;

        },

        /**
         * @returns {Relation} The relation representation of the header
         *
         *     var header = new affinity.Header({ a : affinity.String, b : affinity.String });
         *
         *     var headerRelation = header.toRelation();
         *
         *     headerRelation.print();
         *
         *     // +---------------+-------------+
         *     // | name : String | type : Type |
         *     // +---------------+-------------+
         *     // | a             | String      |
         *     // +---------------+-------------+
         *     // | b             | String      |
         *     // +---------------+-------------+
         *
         */
        toRelation: function () {

            debug.header.trace('#toRelation');

            var rel = new (require('./Relation.js'))([
                {name: {type: TString}},
                {type: {type: TType}}
            ]);

            this.each(function (attribute) {
                rel.add({name: attribute.name, type: attribute.type});
            });

            return rel;

        },

        /**
         * @returns {string[]} An array containing the names of the attributes
         */
        toNameArray : function(){
            var result = [];

            this.each(function(attribute){
                result.push(attribute.name);
            });

            return result;

        },

        /**
         *
         * Converts a relation to a header. The relation must have a name : string and type : type structure.
         * Inverse of {@link Header#toRelation}
         * @param relation
         * @returns {Header}
         */
        fromRelation : function(relation){

            // Check that the relation has the right header
            if(!relation.header().exists({name : 'name', type : TString}) || !relation.header().exists({ name : 'type', type : TType}) || !(relation.header().length()==2)){
                throw new Error('Cannot convert relation to header');
            }

            relation.each(function(tuple){
                this.add({name : tuple.get('name'), type : tuple.get('type')}, false);
            }, this);

            return this;

        },

        /**
         * Copies attributes from a relation to another
         * @param {Header} header
         * @param {Header|string[]|Set} [attributesArgument=[]]
         * @param {Boolean} [exclude=false]
         * @returns {Header}
         */
        copy : function(header, attributesArgument, exclude){

            var that = this;

            if(exclude !== true && exclude !== false){
                exclude = false;
            }

            if (attributesArgument){

                // Coerce the attributesArgument arguments to a header argument

                if(!(attributesArgument instanceof Header)){

                    var tempHeader = new Header();

                    if(attributesArgument instanceof Set){

                        attributesArgument.each(function(attribute){
                            if(_.isString(attribute)){


                                var attr = header.get(attribute);


                                if(attr === null){
                                    throw new Error('Attribute with name "' + attribute + '" not found in the header');
                                }

                                tempHeader.add(header.get(attribute).clone());


                            } else if(attribute instanceof Attribute) {

                                if(header.get(attribute.name) === null){
                                    throw new Error('Attribute with name "' + attribute.name + '" not found in the header');
                                }

                                tempHeader.add(attribute.clone());

                            }
                        })

                    } else if (_.isArray(attributesArgument)){

                        _.forEach(attributesArgument, function(attribute){
                            if(_.isString(attribute)){

                                var attr = header.get(attribute);

                                if(attr === null){
                                    throw new Error('Attribute with name "' + attribute + '" not found in the header');
                                }

                                tempHeader.add(attr.clone());

                            } else if(attribute instanceof Attribute) {

                                if(header.get(attribute.name) === null){
                                    throw new Error('Attribute with name "' + attribute.name + '" not found in the header');
                                }

                                tempHeader.add(attribute.clone());

                            }
                        })

                    } else if (_.isString(attributesArgument)){

                        var attr = header.get(attributesArgument);

                        if(attr === null){
                            throw new Error('Attribute with name ' + attributesArgument + ' not found in the header');
                        }

                        tempHeader.add(attr);

                    }

                    attributesArgument = tempHeader;

                } else {

                    attributesArgument.each(function(attribute){

                        if(header.get(attribute.name) === null){
                            throw new Error('Attribute with name ' + attribute.name + ' not found in the header');
                        }

                    })

                }

            }

            if (exclude && attributesArgument){

                header.each(function(attribute){

                    var isExcluded = false;

                    attributesArgument.each(function(excludedAttribute){
                        if(attribute.equal(excludedAttribute)){
                            isExcluded = true;
                        }
                    }, this);

                    if(!isExcluded){
                        this.add(attribute.clone());
                    }

                }, this)


            } else if (!exclude && attributesArgument){

                attributesArgument.each(function(includedAttribute){

                    this.add(header.get(includedAttribute.name).clone());

                }, this)

            } else {

                header.each(function(attribute){
                    this.add(attribute.clone());
                },this)
            }

            return this;

        }


    }, {

        /**
         * @static
         * @param {Header} header
         * @param {string[]|Attribute[]} attributes
         */
        assertAttributesExist : function(header, attributes){

            var mismatch = false;

            _.forEach(attributes, function(attribute){

                if(_.isString(attribute)){
                    if(header.get(attribute) === null){
                        throw new Error('Attribute with name ' + attribute + ' does not exist in the header');
                    }
                } else if (attribute instanceof Attribute){
                    if(!header.exists(attribute)){
                        throw new Error('Attribute with name ' + attribute.name + ' does not exist in the header');
                    }
                } else {
                    throw new Error('Attribute is of wrong type');
                }

            });

        },

        /**
         * @static
         * @param {Header} header1
         * @param {Header} header2
         */
        assertSameNameSameType : function(header1, header2){

            header1.each(function(attribute1){

                header2.each(function(attribute2){

                    if(attribute1.name === attribute2.name && attribute1.type !== attribute2.type){
                        throw new Error('Headers must have same type on attributes of same naem');
                    }

                })

            })

        },

        /**
         * @static
         * @param {Header} header1
         * @param {Header} header2
         */
        assertUnionCompatible : function(header1, header2){

            if (!this.equal(header1, header2)) {
                throw new Error('Relations are not union compatible');
            }

        },

        /**
         * @static
         * @param {Header} header1
         * @param {Header} header2
         */
        assertDisjoint : function(header1, header2){

            if(!this.disjoint(header1, header2)){
                throw new Error('Headers must be disjoint');
            }

        },

        /**
         * @static
         * @param {Header} header1
         * @param {Header} header2
         * @returns {Set|*}
         */
        commonAttributes : function(header1, header2){

            return header1.setIntersection(header2);

        },

        /**
         * Converts a relation into a header.
         * The relation must have the header only with attributes name : TString and type : TType.
         * @static
         * @param relation
         * @returns {Header}
         */
        fromRelation : function(relation){

            var header = new Header();

            return header.fromRelation(relation);

        },

        /**
         * @static
         * @param {Header} header1
         * @param {Header} header2
         * @returns {boolean}
         */
        equal: function (header1, header2) {

            debug.header.trace('Header.equal');

            if (Object.keys(header1._attributes).length !== Object.keys(header2._attributes).length) {
                return false;
            }

            var mismatch = false;

            header1.each(function (attribute1) {

                var attribute1Name = attribute1.name;

                if (!header2._attributes.hasOwnProperty(attribute1Name)) {
                    mismatch = true;
                    return false;
                }

                if (!Attribute.equal(attribute1, header2.get(attribute1.name))) {
                    mismatch = true;
                    return false;
                }


            });

            return !mismatch;

        },

        /**
         * @static
         * @param {Header} header1
         * @param {Header} header2
         * @returns {boolean}
         */
        disjoint: function (header1, header2) {

            debug.header.trace('Header.disjoint');

            var headers = header1.length() > header2.length() ? [header1,header2] : [header2,header1];

            var different = true;

            // Check that header have no common attribute names
            headers[0].each(function (attribute1) {

                if (headers[1].get(attribute1.name) !== null) {
                    different = false;
                    return false;
                }

            });

            return different;

        },

        /**
         * @static
         * @param {Header|*} header
         * @returns {Header}
         */
        coerce : function(header){

            if(header instanceof this){
                return header;
            } else {
                return new Header(header);
            }
        }

    });

module.exports = Header;
},{"./Attribute.js":2,"./Relation.js":9,"./Set.js":10,"./helpers/debug.js":82,"./types/String":99,"./types/Type":100,"lodash":103}],7:[function(require,module,exports){
var Base = require('./Base');
var debug = require('./helpers/debug');

var Index = Base.extend(
    {

        /**
         * The Index class is a simple utility class allowing tuples to be indexed.
         * It speeds up operations on relations as iterations are reduced.
         * @class Index
         * @extends Base
         */
        constructor: function (header) {

            debug.index.trace('#constructor');

            /** @property {Header} header */
            this.header = header;

            /** @property {number} levels */
            this.levels = header.length();

            /** @property {Object} elements */
            this.elements = {};

            /** @property {Array} headerLevels */
            this.headerLevels = [];

            /* Recursively iterating through the header and populating the headerLevels array*/

            var targetHeader = this.header.clone();

            for(var k = 0; k < this.levels; k++){

                this.headerLevels[k] = targetHeader;
                targetHeader = targetHeader.remove(targetHeader.first());

            }

        },

        /**
         * Adds a tuple to the index
         * @param {Tuple} tuple
         * @param {number} index
         */
        add: function (tuple, index) {

            debug.index.trace('#add');

            var context = this;

            var headerCount = this.header.length();

            for (var a = 0; a <= headerCount - 1; a++) {

                var attribute = context.header.first();
                var tupleAttributeValue;

                if(!attribute.type.primitive){
                    tupleAttributeValue = attribute.type.serialize(tuple.get(attribute.name));
                } else {
                    tupleAttributeValue = tuple.get(attribute.name);
                }

                if (a === headerCount - 1) {

                    context.elements[tupleAttributeValue] = index

                } else {

                    if (!context.elements.hasOwnProperty(tupleAttributeValue)) {

                        var newIndex = new Index(this.headerLevels[a+1]);

                        context.elements[tupleAttributeValue] = newIndex;

                        context = newIndex;

                    } else {

                        context = context.elements[tupleAttributeValue];

                    }

                }

            }

        },

        /**
         * Get the index for a tuple
         * @param {Tuple} tuple
         * @returns {number|null}
         */
        getIndex: function (tuple) {

            debug.index.trace('#getIndex');

            var context = this;

            var headerCount = this.header.length();

            for (var a = 0; a <= headerCount - 1; a++) {

                var attribute = context.header.first();
                var tupleAttributeValue;

                if(!attribute.type.primitive){
                    tupleAttributeValue = attribute.type.serialize(tuple.get(attribute.name));
                } else {
                    tupleAttributeValue = tuple.get(attribute.name);
                }

                if (a === headerCount - 1) {

                    if (!context.elements.hasOwnProperty(tupleAttributeValue)) {
                        return null;
                    }

                    return context.elements[tupleAttributeValue];

                } else {

                    if (!context.elements.hasOwnProperty(tupleAttributeValue)) {

                        return null;

                    }

                    context = context.elements[tupleAttributeValue];


                }

            }

        },

        /**
         * Removes a tuple from the index
         * @param {Tuple} tuple
         * @returns {boolean} True if removed, false otherwise
         */
        remove: function (tuple) {

            debug.index.trace('#remove');

            var context = this;

            var headerCount = this.header.length();

            for (var a = 0; a <= headerCount - 1; a++) {

                var attribute = context.header.first();
                var tupleAttributeValue;

                if(!attribute.type.primitive){
                    tupleAttributeValue = attribute.type.serialize(tuple.get(attribute.name));
                } else {
                    tupleAttributeValue = tuple.get(attribute.name);
                }

                if (a === headerCount - 1) {

                    if (!context.elements.hasOwnProperty(tupleAttributeValue)) {
                        return false;
                    }

                    delete context.elements[tupleAttributeValue];

                    return true;

                } else {

                    if (!context.elements.hasOwnProperty(tupleAttributeValue)) {

                        return false;

                    }

                    context = context.elements[tupleAttributeValue];

                }

            }

        }

    });

module.exports = Index;
},{"./Base":3,"./helpers/debug":82}],8:[function(require,module,exports){
var Type = require('./Type'),
    Index = require('./Index'),
    Header = require('./Header'),
    _ = require('lodash'),
    debug = require('./helpers/debug');

var Key = Type.extend({

        /**
         * @class Key
         * @extends Base
         *
         * The Key class represents keys to a relation.
         *
         * When keys are not defined on a relation, a key is assumed on all attributes of the relation.
         * Though, when a key is defined on a subset of a relation's attributes, the uniqueness
         * of the tuples will be calculated only on those attributes.
         *
         * Also, a Key will index the tuples for its attributes, making operations a lot faster.
         *
         *
         *     var relation = new affinity.Relation([
         *          {attribute1 : {type : affinity.Integer}},
         *          {attribute2 : {type : affinity.Integer}},
         *          {attribute3 : {type : affinity.Integer}},
         *      ],[
         *          [1, 2, 3],
         *          [4, 2, 3], // -> Will fail to be added, as it does not respects the unique key constraint
         *          [1, 8, 9], // -> Will fail to be added, as it does not respected the pk constraint
         *          [10, 11, 12],
         *      ],{
         *          pk : ['attribute1'],
         *          unique : [['attribute2', 'attribute3']]
         *      });
         */
        constructor: function (relation, attributes) {

            debug.key.trace('#constructor');

            if(!_.isArray(attributes)){
                attributes = [attributes];
            }

            /**
             * @property {Header} header
             */
            var header = this.header = new Header();
            
            header.relation = relation;

            header.copy(relation.header(),attributes);

            /**
             * @property {Index} index
             */
            var index = this.index = new Index(this.header);

            // Add the tuple to the index after it is added in the relation
            relation.ee.on('afterAdd', function(tuple, tupleIndex){

                debug.key.trace('#afterAdd');

                index.add(tuple, tupleIndex);

            });

            // Remove the tuple from the before it is deleted
            relation.ee.on('beforeDelete', function(tuple, tupleIndex){

                debug.key.trace('#beforeDelete');

                index.remove(tuple, tupleIndex);

            });


            // Remove then add the tuple from index before the tuple update

            relation.ee.on('beforeUpdate', function(tuple, attributeName){

                debug.key.trace('#beforeUpdate');

                if(header.get(attributeName) !== null){
                    var tupleIndex = index.getIndex(tuple);
                    index.remove(tuple, tupleIndex);
                }

            });

            relation.ee.on('afterUpdate', function(tuple, attributeName){

                debug.key.trace('#afterUpdate');

                if(header.get(attributeName) !== null){
                    var tupleIndex = index.getIndex(tuple);
                    index.add(tuple, tupleIndex);
                }

            });

        }

    });

module.exports = Key;
},{"./Header":6,"./Index":7,"./Type":12,"./helpers/debug":82,"lodash":103}],9:[function(require,module,exports){
var Header = require('./Header.js');
var Tuple = require('./Tuple.js');
var Type = require('./Type.js');
var _ = require('lodash');
var Set = require('./Set');
var debug = require('./helpers/debug');
var coerce = require('./helpers/coerce');
var Key = require('./Key');
var ForeignKey = require('./ForeignKey');

var Relation = Set.extend(
    {

        /**
         *
         * @class Relation
         * @param {Header|Object[]|Attribute[]} header Header of the Relation
         * @param {Tuple[]|Object[]} body Body of the Relation
         * @param {Object} constraints Constraints for the relation
         * @param {String[]} constraints.pk Fields that will constitute primary key
         * @param {String[][]} constraints.unique Unique field definition
         * @param {Object[]} constraints.fk Foreign key definitions
         * @extends Set
         *
         * Relation constructor
         *
         * A Relation is basically a {@link Set}, implementing the basic set operators (Union, Difference, Intersection, Product)
         * and adding more operators. It also has a {@link Header}, and adds constraints to the basic {@link Set} behavior.
         *
         *     var relation = new affinity.Relation([
         *          {id : {type : affinity.Integer}},
         *          {name : {type : affinity.String}},
         *          {born : {type : affinity.Date}},
         *     ],[
         *          [1, 'John Doe', new Date(1934, 10, 20)],
         *          [2, 'John Wilson', new Date(1922, 7, 5)],
         *     ]);
         */
        constructor: function (header, body, constraints) {

            debug.relation.trace('#constructor');

            /**
             * @property {{pk: String, unique: String[][], fk: Object[]}} _constraintArguments
             * @private
             */
            this._constraintArguments = constraints;

            /**
             * @property {Key} _pk The Primary Key for the Relation
             * @private
             */
            this._pk = undefined;

            /**
             * @property {Set} _uks The Primary Keys for the Relation
             * @private
             */
            this._uks = undefined;

            /**
             * @property {Set} _fks The Foreign Keys for the Relation
             * @private
             */
            this._fks = undefined;

            /**
             * @property {Header} _header The relation header
             * @private
             */
            this.header(Header.coerce(header));

            Set.call(this, {type: Tuple, elements: body});

        },

        bindEvents: function () {

            debug.relation.trace('#bindEvents');

            var that = this;

            this.ee.on('beforeGetElements', function () {
                that.ee.emit('beforeGetBody');
            });

            this.ee.on('beforeAdd', function (tuple) {

                // Add default values
                that.header().each(function(attribute){

                    var tupleAttributeValue = tuple.get(attribute.name);

                    if(tupleAttributeValue === null || tupleAttributeValue === undefined || tupleAttributeValue === ''){

                        tuple.set(attribute.name, attribute.default());

                    }

                });

                // Coerce tuple attributes
                that.header().each(function(attribute){

                    var attributeValue, attributeType;

                    attributeValue = tuple.get(attribute.name);

                    attributeType = attribute.type;

                    attributeValue = coerce(attributeType, attributeValue);

                    tuple.set(attribute.name, attributeValue);

                });

                // Check that the tuple is union-compatible with the relation
                if (!that.isCompatible(tuple)) {
                    throw new Error('Tuple is not union compatible');
                }

                tuple.relation = that;

            });

            this.ee.once('beforeGetElements', function () {

                var constraintArguments = that._constraintArguments;

                // Parse constraint arguments
                if (constraintArguments) {

                    // Parse primary key argument
                    if (constraintArguments.pk) {

                        that.pk(constraintArguments.pk);

                    }

                    // Parse unique key arguments
                    if (constraintArguments.unique) {

                        _.forEach(constraintArguments.unique, function (unique) {

                            that.uks().add(new Key(that, unique));

                        }, that);

                    }

                    // Parse foreign key arguments
                    if (constraintArguments.fk) {
                        _.forEach(constraintArguments.fk, function (fkArgs) {

                            fkArgs.relation = that;

                            var fk = new ForeignKey(fkArgs);

                            that.fks().add(new ForeignKey(fkArgs));
                        })
                    }



                }

            });

            this.uks().ee.on('beforeAdd', function(constraint){

                // Insure corresponding key types has serialize method
                that._assertKeySerialize(constraint);

                // Check that the keys are unique
                that._assertKeysUnique(constraint);

                // Check that the keys are irreducible
                that._assertKeysIrreducible(constraint);

            });

            this.ee.on('afterAdd', function(tuple, index){
                tuple.index = index;
                tuple.relation = that;
            });

        },

        _assertKeySerialize : function(newKey){

            // Check that if the constraint applies on an object, that
            // its type has the serialize method

            newKey.header.each(

                function (attribute) {
                    if (!attribute.type.primitive && !_.isFunction(attribute.type.serialize)) {
                        throw new Error(
                            'Cannot index attribute "' + attribute.name + '". ' +
                            'Its type "' + attribute.type.type + '" must' +
                            'have a "serialize" method for it to be indexable.');
                    }
                });

        },

        _assertKeysUnique : function(newKey){

            var existingKeys = this.uks();

            existingKeys.each(function(key){

                if (key.header.equal(newKey.header)){
                    throw new Error('Constraints must be unique');
                }

            });

        },

        _assertKeysIrreducible : function(newKey){

            var existingKeys = this.uks();

            existingKeys.each(function(key){

                if (newKey.header.setIntersection(key.header).length() !== 0) {
                    throw new Error('Constraint must be irreducible');
                }

            });

        },

        /**
         * Delete or add tuples to match a given relation
         * @param {Relation} relation
         */
        adjustTo: function(relation){

            this.compute();

            relation.compute();

            var that = this;

            // 1. Delete tuples that do not exist in the given relation

            // Loop through each tuple
            that.each(function(tuple, index){

                // Check if the tuple exists in the given relation
                if (!relation.exists(tuple)){
                    that.removeAt(index);
                }

            });

            // 2. Add tuples that do not exist in the relation

            // Loop through each tuple of the given relation
            relation.each(function(tuple){

                // Check if the tuple is present in this relation
                if (!that.exists(tuple)){

                    that.add(tuple.clone());

                }

            });

        },

        _index: function (element) {

            // Look for the tuple in the PK if it exists

            if (this._pk) {

                var index = this._pk.index.getIndex(element);

                if (index !== null) {
                    return index;
                }

            }

            var result = null;

            this.uks().any(function (uniqueConstraint) {

                result = uniqueConstraint.index.getIndex(element);

                if (result !== null){
                    console.log('found by uk');
                    return false;
                }


            }, this);

            return result;

        },

        /**
         * Gets the specified attribute object by name
         * @param {String} attribute Attribute name
         * @returns {Attribute|null} The attribute or null if not found
         *
         *     var fn = new affinity.Attribute({name : 'firstName', type : affinity.String})
         *     var ln = new affinity.Attribute({name : 'lastName', type : affinity.String})
         *
         *     var relation = new affinity.Relation([
         *              fn,
         *              ln
         *          ],[
         *              ['John','Doe'],
         *              ['Hello','World'],
         *              ['Super','Duper'],
         *          ]);
         *
         *     relation.get('firstName') === fn // true
         *
         *
         */
        get: function (attribute) {

            debug.relation.trace('#get');

            return this.header().get(attribute);

        },

        /**
         * Get the tuple at the given index
         * @param {number} index The index of the tuple
         * @returns {*|null}
         *
         *     var relation = new affinity.Relation([
         *              { 'firstName' : {type : affinity.String}}
         *              { 'LastName'  : {type : affinity.String}}
         *          ],[
         *              ['John','Doe'],
         *              ['Hello','World'],
         *              ['Super','Duper'],
         *          ]);
         *
         *     relation.each(function(tuple, index){
         *
         *          console.log(relation.atIndex(index) === tuple) // true
         *
         *     })
         *
         * console.log(relation.atIndex(0).get('firstName')) // John
         *
         */
        atIndex: function (index) {

            debug.relation.trace('#atIndex');

            return this.elements()[index];

        },

        /**
         * @param {Set} [tuples] The new set of body
         * @returns {Set|Relation} The body/null if getter, this if setter
         *
         * Getter/Setter for the body property
         *
         * You will more likely always use the getter (Relation.body()) than the setter
         * (Relation.body(body)) part for this method.
         *     var relation = new affinity.Relation([
         *              { 'firstName' : {type : affinity.String}}
         *              { 'LastName'  : {type : affinity.String}}
         *          ]);
         *
         *     var set = new affinity.Set();
         *
         *     set.add(new affinity.Tuple({firstName : 'John', lastName : 'Doe'}))
         *     set.add(new affinity.Tuple({firstName : 'Hello', lastName : 'World'}))
         *     set.add(new affinity.Tuple({firstName : 'John', lastName : 'Cage'}))
         *
         *     relation.body(set); // Sets the relation's body
         *
         *     relation.body() // Gets the relation's body
         *
         *     console.log(relation.body() === set) // true
         *
         */
        body: function (tuples) {

            debug.relation.trace('#body');

            if (tuples) {

                this.elements(tuples);

                return this

            } else {

                this.ee.emit('beforeGetBody');

                return this.elements();

            }

        },

        /**
         * @return {Relation} Returns this for chaining
         *
         * Calculates the relation. Because the relations are only calculated when their header or their body
         * are requested, you must explicitly call compute() if you want to calculate a relation.
         *
         * You should not need to use this function. Calling body() or header() calculates the relation
         * automatically
         *
         *     var product = relation1.product(relation2);
         *
         *     // At this point, nothing has been calculated.
         *
         *     product.header() // Because we requested the header, it is calculated
         *
         *     product.body() // Because we requested the body, it is calculated
         *
         *     var product2 = relation1.product(relation2);
         *
         *     product2.compute(); // Calculates the header and the body;
         *
         */
        compute: function () {

            debug.relation.trace('#compute');

            this.header();
            this.body();

            return this;

        },

        /**
         * @param {Header} [header]
         * @returns {null|{Header}}
         *
         * Gets or sets the relation's header
         */
        header: function (header) {

            if (header) {

                debug.relation.trace('#header (set)');

                this._header = header;

                header.relation = this;

            } else {

                debug.relation.trace('#header (get)');

                this.ee.emit('beforeGetHeader');

                return this._header;

            }

        },

        /**
         * Gets / Sets the relation's primary key
         * @param {String} [primaryKeyName]
         */
        pk : function(primaryKeyName){

            if (primaryKeyName){

                if(this._pk !== undefined){
                    this.uks().remove(this._pk);
                }

                this._pk = new Key(this, primaryKeyName);

                this.uks().add(this._pk);

            } else {

                return this._pk;

            }

        },

        /**
         * Gets the foreign keys set
         * @returns {Set}
         */
        fks : function(){

            if (this._fks === undefined){
                this._fks = new Set({ type : ForeignKey});
            }

            return this._fks;
        },

        /**
         * Gets the unique keys set
         * @returns {Set}
         */
        uks : function(){

            if (this._uks === undefined){
                this._uks = new Set({ type : Key});
            }

            return this._uks;
        },

        /**
         * @param {Tuple|Object} tuple
         * @returns {boolean}
         *
         * Check if a tuple is compatible with the relation
         */
        isCompatible: function (tuple) {

            debug.relation.trace('#isCompatible');

            tuple = Tuple.coerce(tuple);

            var tupleKeys = Object.keys(tuple.attributes);
            var tupleKeyCount = tupleKeys.length;
            var headerKeys = Object.keys(this.header()._attributes);
            var headerKeyCount = headerKeys.length;


            /// Check if the given tuple has the same header as the relation

            // Header and Tuple must have the same number of attributes
            if (tupleKeyCount !== headerKeyCount) {
                return false;
            }

            // Header and Tuple must have the same attribute names
            return !_.some(headerKeys, function (headerAttribute) {

                // Loop through each attributes of the tuple
                return !_.some(tupleKeys, function (tupleAttribute) {

                    // Found a match
                    return (tupleAttribute === headerAttribute && (tuple.get(tupleAttribute) !== undefined) && (tuple.get(tupleAttribute) !== null));

                });

            });

        },

        /**
         * @param {Relation} relation The relation to compare to
         * @returns {boolean} If the relations are equal or not
         *
         * Tests if the relation is equal to another one
         */
        equal: function (relation) {

            debug.relation.trace('#equal');

            return this.constructor.equal(this, relation);
        },

        /**
         * Clones a relation
         * @param {boolean} [withTuples=true] Copies the tuples
         * @returns {Relation}
         */
        clone : function(withTuples){

            withTuples = !!(withTuples === undefined || withTuples === null);

            var newHeader = this.header().clone();

            var newRelation = new Relation(newHeader);

            // Clone the pk

            //todo PK Clone

            // Clone the uks

            //todo UKS clone

            // Clone the fks

            //todo FKS clone

            if (withTuples){
                this.each(function(tuple){
                    newRelation.add(tuple.clone());
                });
            }

            return newRelation;

        },

        /**
         * Prints the printable representation of the Relation to console
         */
        print: function () {

            debug.relation.trace('#print');

            console.log(this.toString());
        },

        /**
         * Gets the string representation of the relation
         * @returns {String} The string print representation of the relation
         */
        toString: function () {

            var hspacing = 1,
                vspacing = 1,
                arr = this.arr = [],
                headerRow = [],
                maxWidths = [],
                maxHeights = [];

            debug.relation.trace('#getPrintString');

            this.compute();

            this.header().each(function (attribute) {

                headerRow.push({ width: null, height: null, lines: null, attribute: attribute, string: attribute.toString()})

            }, this);

            // [ {width, height, lines, string},{width, height, lines, string},... ] ]

            arr.push(headerRow);

            this.each(function (tuple) {

                var tupleRow = [];

                _.forEach(headerRow, function (attr) {
                    tupleRow.push({ width: null, height: null, lines: null, string: tuple.get(attr.attribute.name).toString()})
                }, this);

                arr.push(tupleRow);

            }, this);

            function findHeight(string) {

                return string.split("\n").length;

            }

            function findWidth(string) {

                var lines = string.split('\n'),
                    max = 0;

                _.forEach(lines, function (line) {

                    var lineLength = line.length;

                    if (lineLength > max)
                        max = lineLength;

                }, this);

                return max;

            }

            function findMaxWidth(arr) {

                var max = 0;

                _.forEach(arr, function (obj) {

                    var lineWidth = obj.width;

                    if (lineWidth > max)
                        max = lineWidth;

                }, this);

                return max;
            }

            function findMaxHeight(arr) {

                var max = 0;

                _.forEach(arr, function (obj) {

                    var lineHeight = obj.height;

                    if (lineHeight > max)
                        max = lineHeight;

                }, this);

                return max;

            }

            function parseLines(string) {
                return string.split("\n");
            }

            // [
            //   [{width, height, lines, string},{width, height, lines, string},... ],
            //   [{width, height, lines, string},{width, height, lines, string},... ],
            //   [{width, height, lines, string},{width, height, lines, string},... ],
            //   ...
            // ]


            _.forEach(arr, function (row, rowIndex) {

                _.forEach(row, function (col, colIndex) {

                    col.width = findWidth(col.string);
                    col.height = findHeight(col.string);
                    col.lines = parseLines(col.string);

                    if (!maxWidths[colIndex] || maxWidths[colIndex] < col.width) {
                        maxWidths[colIndex] = col.width;
                    }

                    if (!maxHeights[rowIndex] || maxHeights[rowIndex] < col.height) {
                        maxHeights[rowIndex] = col.height;
                    }

                }, this);

            }, this);

            var result = '\n';


            // Printing the top border

            result += '+';

            _.forEach(maxWidths, function (maxWidth, index) {

                for (var a = 0; a < maxWidths[index] + hspacing * 2 + 2; a++) {
                    result += '-'
                }

                result += '+'

            }, this);

            result += '\n';

            // Printing the attributes

            _.forEach(arr, function (row, rowIndex) {

                var maxHeight = maxHeights[rowIndex];

                for (var a = 0; a < maxHeight; a++) {

                    result += '|';

                    _.forEach(row, function (col, colIndex) {

                        var maxWidth = maxWidths[colIndex];

                        var line = col.lines[a];

                        if (!line) line = '';

                        for (var i = 0; i < hspacing; i++) {
                            result += ' ';
                        }

                        var lineLength = line.length;

                        result += line;

                        for (var k = 0; k < hspacing; k++) {
                            result += ' ';
                        }

                        for (var b = 0; b < maxWidth - lineLength + 2 * hspacing; b++) {
                            result += ' ';
                        }

                        result += '|';

                    }, this);

                    result += '\n';

                }

                result += '+';

                _.forEach(maxWidths, function (maxWidth, index) {

                    for (var a = 0; a < maxWidths[index] + hspacing * 2 + 2; a++) {
                        if (rowIndex === 0) {
                            result += '='
                        } else {
                            result += '-'
                        }

                    }

                    result += '+'

                }, this);


                if (rowIndex != arr.length - 1) result += '\n';


            }, this);

            return result;

        },


        /**
         * Updates tuples in the relation
         * @param predicate
         * @param values
         *
         * Example
         *
         *     relation.update(age.gt(20), { age : age.old().plus(10), name : name.old().substr(0,1) });
         */
        update : function(predicate, values){

            predicate.convertAttributeToTuple();

            _.forEach(values, function(value){

                if(_.isFunction(value)){
                    value.convertAttributeToTuple()
                }

            });

            this.each(function(tuple){

                if(predicate.assignTuple(tuple).value() === true){

                    _.forEach(values, function(expression, key){

                        var value = _.isFunction(expression) ? expression.assignTuple(tuple).value() : expression;

                        tuple.set(key, value);

                    })

                }

            })

        },

        /**
         * Removes tuples from a relation based on a predicate
         * @param predicate
         */
        removeWhere : function(predicate){

            predicate.convertAttributeToTuple();

            var that = this;

            this.each(function(tuple, index){

                if(predicate.assignTuple(tuple).value() === true){

                    that.removeAt(index);

                }

            })

        },


        //region Operations

        /**
         *
         * @param {Relation} relation The relation to compute difference against
         * @returns {Operators.Difference} The resulting relation
         *
         * Shortcut to create a Difference relation based on this relation and the specified one
         *
         *     var relation1 = new affinity.Relation([
         *              {firstName : {type : affinity.String}}
         *              {lastName : {type : affinity.String}}
         *          ],[
         *              ['John','Doe'],
         *              ['Lucino','Veo'],
         *              ['Mary','Poppins'],
         *          ]);
         *
         *     var relation2 = new affinity.Relation([
         *              {firstName : {type : affinity.String}}
         *              {lastName : {type : affinity.String}}
         *          ],[
         *              ['John','Doe']
         *          ]);
         *
         *     var diff = relation1.difference(relation2);
         *
         *     // +---------------------+--------------------+
         *     // | firstName : TString | lastName : TString |
         *     // +---------------------+--------------------+
         *     // | Lucino              | Veo                |
         *     // +---------------------+--------------------+
         *     // | Mary                | Poppins            |
         *     // +---------------------+--------------------+
         */
        difference: function (relation) {

            debug.relation.trace('#difference');

            return new (require('./algebra/Difference'))(this, relation);
        },

        /**
         * @param {Relation} relation The relation to compute intersection against
         * @returns {Operators.Intersection} The resulting relation
         *
         * Shortcut to create an Intersect relation based on this relation and the specified one
         *
         *     var relation1 = new affinity.Relation([
         *              {firstName : {type : affinity.String}}
         *              {lastName : {type : affinity.String}}
         *          ],[
         *              ['John','Doe'],
         *              ['Lucino','Veo'],
         *              ['Mary','Poppins'],
         *          ]);
         *
         *     var relation2 = new affinity.Relation([
         *              {firstName : {type : affinity.String}}
         *              {lastName : {type : affinity.String}}
         *          ],[
         *              ['John','Doe']
         *          ]);
         *
         *     var intersection = relation1.intersect(relation2);
         *
         *     // +---------------------+--------------------+
         *     // | firstName : TString | lastName : TString |
         *     // +---------------------+--------------------+
         *     // | John                | Doe                |
         *     // +---------------------+--------------------+
         */
        intersect: function (relation) {

            debug.relation.trace('#intersect');

            var Intersection = require('./algebra/Intersection');

            return new Intersection(this, relation);
        },

        /**
         *
         * @param {Relation} relation The relation to compute the join against
         * @returns {Operators.Join} The resulting relation
         *
         * Shortcut to create a Join relation based on this relation and the specified one
         *
         *     var relation1 = new affinity.Relation([
         *              {firstName : {type : affinity.String}}
         *              {lastName : {type : affinity.String}}
         *          ],[
         *              ['John','Doe'],
         *              ['Lucino','Veo'],
         *              ['Mary','Poppins'],
         *          ]);
         *
         *     var relation2 = new affinity.Relation([
         *              {LastName : {type : affinity.String}}
         *              {Title    : {type : affinity.String}}
         *          ],[
         *              ['Doe','Mr'],
         *              ['Poppins','Lady']
         *          ]);
         *
         *     var join = relation1.join(relation2);
         *
         *     // +---------------------+--------------------+-----------------+
         *     // | firstName : TString | lastName : TString | Title : TString |
         *     // +---------------------+--------------------+-----------------+
         *     // | John                | Doe                | Mr              |
         *     // +---------------------+--------------------+-----------------+
         *     // | Mary                | Poppins            | Lady            |
         *     // +---------------------+--------------------+-----------------+
         */
        join: function (relation) {

            debug.relation.trace('#join');

            return new (require('./algebra/Join'))(this, relation);
        },

        /**
         *
         * @param {Relation} relation The relation to compute product against
         * @returns {Operators.Product} The resulting relation
         *
         * Shortcut to create a Product relation based on this relation and the specified one
         *
         *     var relation1 = new affinity.Relation([
         *              {firstName : {type : affinity.String}}
         *              {lastName : {type : affinity.String}}
         *          ],[
         *              ['John','Doe'],
         *              ['Lucino','Veo'],
         *              ['Mary','Poppins'],
         *          ]);
         *
         *     var relation2 = new affinity.Relation([
         *              {title : {type : affinity.String}}
         *          ],[
         *              ['Lady'],
         *              ['Mr']
         *          ]);
         *
         *     var product = relation1.product(relation2);
         *
         *     // +---------------------+--------------------+-----------------+
         *     // | firstName : TString | lastName : TString | Title : TString |
         *     // +---------------------+--------------------+-----------------+
         *     // | John                | Doe                | Lady            |
         *     // +---------------------+--------------------+-----------------+
         *     // | John                | Doe                | Mr              |
         *     // +---------------------+--------------------+-----------------+
         *     // | Lucino              | Veo                | Lady            |
         *     // +---------------------+--------------------+-----------------+
         *     // | Lucino              | Veo                | Mr              |
         *     // +---------------------+--------------------+-----------------+
         *     // | Mary                | Poppins            | Lady            |
         *     // +---------------------+--------------------+-----------------+
         *     // | Mary                | Poppins            | Mr              |
         *     // +---------------------+--------------------+-----------------+
         */
        product: function (relation) {

            debug.relation.trace('#product');

            return new (require('./algebra/Product'))(this, relation);
        },

        /**
         * @param {String[]} attributeNames The relation to compute intersection against
         * @returns {Operators.Projection} The resulting relation
         *
         * Shortcut to create a Project relation based on this relation
         *
         * The attributeNames parameter must be in the format :
         *
         *     relation.project(['argument1', 'argument2']);
         *
         *     var relation1 = new affinity.Relation([
         *              {firstName : {type : affinity.String}}
         *              {lastName : {type : affinity.String}}
         *          ],[
         *              ['John','Doe'],
         *              ['Lucino','Veo'],
         *              ['Mary','Poppins'],
         *          ]);
         *
         *     var intersection = relation1.project(['firstName']);
         *
         *     // +---------------------+
         *     // | firstName : TString |
         *     // +---------------------+
         *     // | John                |
         *     // +---------------------+
         *     // | Lucino              |
         *     // +---------------------+
         *     // | Mary                |
         *     // +---------------------+
         */
        project: function (attributeNames) {

            debug.relation.trace('#project');

            return new (require('./algebra/Projection'))(this, attributeNames);
        },

        /**
         *
         * @param {Object} newNames An object containing the new attribute names.
         * @returns {Operators.Rename} The resulting relation
         *
         * Shortcut to create a Rename relation based on this relation
         *
         *     var relation1 = new affinity.Relation([
         *              {firstName : {type : affinity.String}}
         *              {lastName : {type : affinity.String}}
         *          ],[
         *              ['John','Doe'],
         *              ['Lucino','Veo'],
         *              ['Mary','Poppins'],
         *          ]);
         *
         *     var rename = relation1.rename({lastName : 'Boogie'});
         *
         *     // +---------------------+--------------------+
         *     // | firstName : TString | Boogie : TString   |
         *     // +---------------------+--------------------+
         *     // | John                | Doe                |
         *     // +---------------------+--------------------+
         *     // | Lucino              | Veo                |
         *     // +---------------------+--------------------+
         *     // | Mary                | Poppins            |
         *     // +---------------------+--------------------+
         */
        rename: function (newNames) {

            debug.relation.trace('#rename');

            return new (require('./algebra/Rename'))(this, newNames);
        },

        /**
         *
         * @param {Function} predicate The predicate to test the tuples against
         * @returns {Operators.Restriction} The resulting relation
         *
         * Shortcut to create a Restrict relation based on this relation
         *
         *     var relation = new affinity.Relation([
         *              {firstName : {type : affinity.String}}
         *              {lastName : {type : affinity.String}}
         *          ],[
         *              ['John','Doe'],
         *              ['Lucino','Veo'],
         *              ['Mary','Poppins'],
         *              ['Robert','Robert']
         *          ]);
         *
         *     // Multiple ways to build a predicate:
         *
         *     // Compare with static value
         *     relation.restrict(relation.get('firstName').equal('John'));
         *
         *     // +---------------------+--------------------+
         *     // | firstName : TString | Boogie : TString   |
         *     // +---------------------+--------------------+
         *     // | John                | Doe                |
         *     // +---------------------+--------------------+
         *
         *     // Compare two attributes
         *     relation.restrict(relation.get('firstName').equal(relation.get('lastName'));
         *
         *     // +---------------------+--------------------+
         *     // | firstName : TString | Boogie : TString   |
         *     // +---------------------+--------------------+
         *     // | Robert              | Robert             |
         *     // +---------------------+--------------------+
         *
         *     // Combine with and, or, not
         *     relation.restrict( (relation.get('firstName').not().equal('John')) .and( relation.get('lastName').not().equal('Veo') ) )
         *
         *     // +---------------------+--------------------+
         *     // | firstName : TString | Boogie : TString   |
         *     // +---------------------+--------------------+
         *     // | Mary                | Poppins            |
         *     // +---------------------+--------------------+
         *     // | Robert              | Robert             |
         *     // +---------------------+--------------------+
         */
        restrict: function (predicate) {

            debug.relation.trace('#restrict');

            return new (require('./algebra/Restriction'))(this, predicate);
        },

        /**
         * Shortcut to create a Union relation based on this relation and the specified one
         * @param {Relation} relation The relation to perform Union with
         * @returns {Operators.Union} The resulting relation
         */
        union: function (relation) {

            debug.relation.trace('#union');

            return new (require('./algebra/Union'))(this, relation);
        },

        /**
         * @param {Relation} relation
         * @returns {Operators.Composition} The resulting relation
         */
        compose: function (relation) {

            debug.relation.trace('#compose');

            return new (require('./algebra/Composition'))(this, relation);

        },

        /**
         * @param {String} groupingAttributeName
         * @param {String[]} groupedAttributeNames
         * @return {Operators.Group}
         */
        group: function (groupingAttributeName, groupedAttributeNames) {

            debug.relation.trace('#group');

            return new (require('./algebra/Group'))(this, groupingAttributeName, groupedAttributeNames);

        },

        /**
         * @param {String[]} groupedAttributeNames
         * @returns {Operators.Ungroup}
         */
        ungroup: function (groupedAttributeNames) {

            debug.relation.trace('#ungroup');

            return new (require('./algebra/Ungroup'))(this, groupedAttributeNames);

        },

        /**
         * SemiDifference
         * @returns {Operators.SemiDifference} The resulting relation
         * @param relation
         */
        sdifference: function (relation) {

            debug.relation.trace('#sdifference');

            return new (require('./algebra/Semidifference'))(this, relation);

        },

        /**
         * SemiJoin
         * @returns {Operators.SemiJoin} The Resulting Relation
         * @param relation
         */
        sjoin: function (relation) {

            debug.relation.trace('#sjoin');

            return new (require('./algebra/Semijoin'))(this, relation);

        },

        /**
         * Shortcut to execute a Wrap operation
         * @param wrappingAttributeName The name of the new wrapping attribute
         * @param {String[]} wrappedAttributes The attribute names to be wrapped
         * @returns {Operators.Wrap} The resulting relation
         */
        wrap: function (wrappingAttributeName, wrappedAttributes) {

            debug.relation.trace('#wrap');

            return new (require('./algebra/Wrap'))(this, wrappingAttributeName, wrappedAttributes);

        },

        /**
         * Shortcut to execute an Unwrap operation
         * @param {String[]} wrappedAttributeNames The names of the wrapped attributes to unwrap
         * @returns {Operators.Unwrap} The resulting relation
         */
        unwrap: function (wrappedAttributeNames) {

            debug.relation.trace('#unwrap');

            return new (require('./algebra/Unwrap'))(this, wrappedAttributeNames);

        },

        /**
         * Shortcut to create an Extend operation
         * @param {Object[]} expressions The expressions to evaluate
         * @returns {Operators.Extension} The resulting relation
         */
        extend: function (expressions) {

            debug.relation.trace('#extend');

            return new (require('./algebra/Extension'))(this, expressions);

        },

        /**
         * Shortcut to the Summarize operation
         * @param {String[]|Attribute[]} attributes The attributes to summarize
         * @param {Object} summaries Summary expressions
         */
        summarize : function(attributes, summaries){
            debug.relation.trace('#summarize');

            return new (require('./algebra/Summarize'))(this, attributes, summaries);

        },


        //endregion

        //region Aggregates

        all : function(predicate){

            var All = require('./functions/aggregate/All.js');

            return new All(this, predicate);

        },

        any : function(predicate){

            var Any = require('./functions/aggregate/Any.js');

            return new Any(this, predicate);

        },

        count : function(){

            var Count = require('./functions/aggregate/Count.js');

            return new Count(this);

        }
        //endregion

    }, {

        /**
         * Gets the string representation of the Relation type
         * @returns {string}

         * @static
         */
        toString: function () {
            return 'Relation'
        },

        type: 'Relation',

        /**
         * Tests for equality between two relations
         * @param {Relation} rel1
         * @param {Relation} rel2

         * @static
         * @returns {boolean}
         */
        equal: function (rel1, rel2) {

            debug.relation.trace('Relation.equal');

            if (!rel1.header().equal(rel2.header())) {
                return false;
            }

            rel1.compute();
            rel2.compute();

            return Set.equal(rel1, rel2);

        }

    });


module.exports = Relation;

},{"./ForeignKey":4,"./Header.js":6,"./Key":8,"./Set":10,"./Tuple.js":11,"./Type.js":12,"./algebra/Composition":13,"./algebra/Difference":14,"./algebra/Extension":15,"./algebra/Group":16,"./algebra/Intersection":17,"./algebra/Join":18,"./algebra/Product":19,"./algebra/Projection":20,"./algebra/Rename":21,"./algebra/Restriction":22,"./algebra/Semidifference":23,"./algebra/Semijoin":24,"./algebra/Summarize":25,"./algebra/Ungroup":26,"./algebra/Union":27,"./algebra/Unwrap":28,"./algebra/Wrap":29,"./functions/aggregate/All.js":30,"./functions/aggregate/Any.js":31,"./functions/aggregate/Count.js":33,"./helpers/coerce":80,"./helpers/debug":82,"lodash":103}],10:[function(require,module,exports){
var Type = require('./Type.js');
var _ = require('lodash');
var coerce = require('./helpers/coerce');
var equal = require('./helpers/equal');
var clone = require('./helpers/clone');
var EventEmitter = require('eventemitter3').EventEmitter3;
var debug = require('./helpers/debug.js');


var Set = Type.extend(

    {
        /**
         * @class Set
         * @param {Object} [args] Constructor arguments
         * @param {Type} [args.type] Type of the elements contained in the set
         * @extends Type
         * A Set is an unordered collection of distinct objects (no duplicates).
         */
        constructor: function (args) {

            debug.set.trace('#constructor');

            /**
             * @property {EventEmitter} ee
             * @external
             */
            this.ee = new EventEmitter();

            this.ee.setMaxListeners(0);

            /**
             * @property {Type} _type
             * @private
             */
            this._type = null;

            /**
             * @property {Array} _elements
             * @private
             */
            this._elements = [];

            /**
             * @property {Number} _deletedCount
             * @private
             */
            this._deletedCount = 0;


            // Call bindEvents if is defined

            if (_.isFunction(this.bindEvents)) {
                this.bindEvents();
            }

            if (args) {

                if (args.type) {
                    this.type(args.type);
                }

                if (args.elements) {
                    this.elements(args.elements);
                }

            }



            // Call parent constructor

            Type.apply(this, arguments);

        },

        bindEvents : function(){

        },

        /**
         * @returns {Set}
         *
         * Clones a set
         */
        clone: function () {

            debug.set.trace('#clone');

            var newSet = new this.constructor({type : this.type()});

            this.each(function (element) {
                newSet.add(element, false);
            });

            return newSet;

        },

        /**
         * Destroys the set
         */
        destroy : function(){

            // Deletes the elements
            this.each(function(element, index){

                this.removeAt(index);

            });

            // Deletes the event emitter
            delete this.ee;

        },

        /**
         * Gets or sets the elements of the set
         * @param {Set} [elements] elements of the set
         * @returns {undefined|null|Array}
         * @throws Will throw if the type of the Set has not been set
         */
        elements: function (elements) {

            debug.set.trace('#elements');

            if (this.type() === null) {
                throw new Error('Must define the type of the set first');
            }

            if (elements) {

                if (!_.isArray(elements)) {
                    throw new TypeError('elements must be in array format')
                }

                this.ee.emit('beforeSetElements', elements);

                _.forEach(elements, function (element) {

                    this.add(element);

                }, this);

                this.ee.emit('afterSetElements', elements);

            } else {

                this.ee.emit('beforeGetElements');

                return this._elements;
            }

        },

        /**
         * @param {Type} [type] The type of the Set
         * @returns {null|Type}
         *
         * Getter/Setter for the type parameter. When used without parameter, will return
         * the type of the Set. When used with a parameter, will set the set's type.
         */
        type: function (type) {

            debug.set.trace('#type');

            if (type) {
                this._type = type;
            } else {
                return this._type;
            }

        },

        /**
         * @param {Function} callback The callback function
         * @param {Object} [context] The "this" context for the callback
         *
         * Iterator function. Only an alias for lodash _.forEach
         */
        each: function (callback, context) {

            debug.set.trace('#each');

            _.forEach(this.elements(), function(element, index){

                if(element !== undefined){
                    if(callback.call(context, element, index) === false){
                        return false;
                    }
                }

            });

        },

        /**
         * @param {Function} callback The callback function
         * @param {Object} [context] The "this" context for the callback
         *
         * Iterator function. Only an alias for lodash _.any
         */
        any : function(callback, context){

            debug.set.trace('#any');

            var result = false;

            _.any(this.elements(), function(element, index){

               return (element !== undefined && callback.call(context, element, index));

            });

            return result;

        },

        /**
         * @param {*} element
         * @param {boolean} [checkDuplicate=true] Tests for duplicate elements in the set. Set to false to skip this
         * verification if you are sure the element is not in the set
         * @returns {boolean} True if the element was added, false otherwise
         *
         * Directly add an element to the set.
         */
        add: function (element, checkDuplicate) {

            debug.set.trace('#add');

            if (_.isUndefined(checkDuplicate)) {
                checkDuplicate = true;
            }

            if (element) {

                debug.set.trace('#add coercing element');

                element = coerce(this.type(), element, this);

                if ((checkDuplicate && !this.exists(element)) || !checkDuplicate) {

                    this.ee.emit('beforeAdd', element);

                    var newIndex = this.elements().push(element) - 1;

                    this.ee.emit('afterAdd', element, newIndex);

                    return true;

                }

            }

            return false;

        },


        /**
         * @param {*} element The element to remove
         * @returns {boolean} Returns true if the element was removed, false otherwise
         *
         * Removes an element from the set.
         */
        remove: function (element) {

            debug.set.trace('#remove');

            element = coerce(this.type(), element);

            var index = this.index(element);

            return this.removeAt(index);

        },

        /**
         * @param {number} index The index at which to remove the element
         * @returns {Boolean} True if deleted, false otherwise
         *
         * Removes an element from the set at the specified index.
         */
        removeAt: function (index) {

            debug.set.trace('#removeAt');

            var element = this.atIndex(index);

            if(element === undefined){
                return false;
            }

            this.ee.emit('beforeRemove', element, index);

            this.elements()[index] = undefined;

            this._deletedCount++;

            this.ee.emit('afterRemove', element, index);

            return true;

        },

        /**
         * @returns {null|*} The first element or null.
         *
         * Gets the first element from the set.
         */
        first : function(){

            debug.set.trace('#first');

            var result = _.find(this.elements(), function(element){

                if(!_.isUndefined(element)){
                    return true;
                }

            });

            if(_.isUndefined(result)){
                return null;
            } else {
                return result;
            }

        },

        /**
         * @param {*} object
         * @returns {number|null} Index of object if found, null otherwise
         * @private
         *
         * Find the index of an element with defined type equality methods
         */
        _indexByEquality: function (object) {

            debug.set.trace('#indexByEquality');

            var result = null;

            this.each(function (element, key) {

                if (equal(this.type(), element, object)) {
                    result = key;
                    return false;
                }

            }, this);

            return result;

        },

        /**
         * @param {Object} element The element to search for
         * @returns {null|number} The index of the element if found, null otherwise
         *
         * Gets the index of an element
         */
        index: function (element) {

            debug.set.trace('#index');

            var result = null;

            element = coerce(this.type(), element);

            if(this._index){
                result = this._index(element);
            }

            if (result !== null) return result;

            return this._indexByEquality(element);

        },

        /**
         * Gets the element at the specified index
         * @param {number} index The index of the element
         * @returns {*} The resulting element
         */
        atIndex: function (index) {

            debug.set.trace('#atIndex');

            return this.elements()[index];
        },


        /**
         * @param {*} element The element to find
         * @returns {null|*} the resulting element or null if not found
         *
         * Finds an element
         */
        find: function (element) {

            debug.set.trace('#find');

            var index = this.index(element);

            if (index !== null) {
                return this.atIndex(index);
            } else {
                return null;
            }

        },

        /**
         * @param {*} element The element to check for
         * @returns {boolean} True if the element exists, false if not
         *
         * Checks if an element exists in the set.
         */
        exists: function (element) {

            debug.set.trace('#exists');

            return (this.index(element) !== null);

        },

        /**
         * @returns {number} Number of elements in the set
         */
        length: function () {

            debug.set.trace('#length');

            return this.elements().length-this._deletedCount;

        },

        /**
         * @param {Set} set2 The set to perform union with
         * @returns {Set} The resulting set
         *
         * Union of two sets. Returns a set containing all the elements from A and B.
         *
         *     var set1 = new affinity.Set(affinity.Integer, [1, 2, 3]);
         *
         *     var set2 = new affinity.Set(affinity.Integer, [3, 4, 5]);
         *
         *     var result = set1.setUnion(set2);
         *
         *     // Set has elements [1, 2, 3, 4, 5] (note no duplicates)
         */
        setUnion: function (set2) {

            debug.set.trace('#union');

            var thisType = this.type();
            var otherType = set2.type();

            var type = (thisType === otherType) ? thisType : null;

            var newSet = new this.constructor();

            newSet.type(type);

            _.forEach([this, set2], function (aSet) {

                aSet.each(function (element) {
                    newSet.add(clone(element));
                })

            });

            return newSet;

        },

        /**
         *
         * @param {Set} set2 The set acting as a pastry cutter
         * @returns {Set}
         *
         *     Perform a difference between two sets. Returns a set with the elements of A without
         *     those that A and B have in common.
         *
         *         var set1 = new affinity.Set(affinity.Integer, [1, 2, 3]);
         *
         *         var set2 = new affinity.Set(affinity.Integer, [3, 4, 5]);
         *
         *         var result = set1.setDifference(set2);
         *
         *         // Set has elements [1, 2]
         */
        setDifference: function (set2) {

            debug.set.trace('#difference');

            var newSet = new this.constructor();
            newSet.type(this.type());

            this.each(function (element) {

                if(!set2.exists(element)){
                    newSet.add(clone(element), false);
                }

            });

            return newSet;

        },

        /**
         *
         * @param {Set} set2 The set to perform product with
         * @returns {Set}
         *
         * Performs a product of two sets. Returns a set with all the possible combinations
         * of elements from A combined with those of B. This operation will return a set containing
         * tuples with attributes { 0 : attr1, 1 : attr2}. 0 is the left set element, 1 is the
         * right set element.
         *
         *     var set1 = new affinity.Set(affinity.Integer, [1, 2]);
         *
         *     var set2 = new affinity.Set(affinity.Integer, [3, 4]);
         *
         *     var result = set1.setProduct(set2);
         *
         *     // Set has elements [Tuple(0 : 1, 1 : 3),Tuple(0 : 1, 1 : 4),Tuple(0 : 2, 1 : 2),Tuple(0 : 2, 1 : 4)]
         */
        setProduct: function (set2) {

            debug.set.trace('#product');

            var Tuple = require('./Tuple.js');

            var newSet = new Set({type: Tuple});

            this.each(function (element1) {

                set2.each(function (element2) {

                    var tuple = new Tuple({0: element1, 1: element2});
                    newSet.add(tuple, false);

                });

            });

            return newSet;

        },

        /**
         *
         * @param {Set} set2 The set to be intersected with
         * @returns {Set} The resulting set
         *
         * Performs an intersection with another set. Returns a set with
         * the elements that A and B have in common.
         *
         *     var set1 = new affinity.Set(affinity.Integer, [1, 2, 3]);
         *
         *     var set2 = new affinity.Set(affinity.Integer, [3, 4, 5]);
         *
         *     var result = set1.setIntersection(set2);
         *
         *     // Set has elements [3]
         */
        setIntersection: function (set2) {

            debug.set.trace('#intersection');

            var newSet = new this.constructor();

            newSet.type(this.type());

            this.each(function (element1) {

                if (set2.exists(element1)) {
                    newSet.add(clone(element1), false);
                }

            }, this);

            return newSet;

        },

        /**
         *
         * @param {Set} set2 The set to peform symmetric difference against
         * @returns {Set} The resulting set
         *
         * Performs a symmetric difference. Returns a set with the elements that A
         * and B do not have in common.
         *
         *     var set1 = new affinity.Set(affinity.Integer, [1, 2, 3]);
         *
         *     var set2 = new affinity.Set(affinity.Integer, [3, 4, 5]);
         *
         *     var result = set1.setSymmetricDifference(set2);
         *
         *     // Set has elements [1, 2, 4, 5]
         */
        setSymmetricDifference: function (set2) {

            debug.set.trace('#symmetricDifference');

            var newSet = new (this.constructor)({type: this.type()});

            var set1 = this;

            set1.each(function (element1) {

                if (!set2.exists(element1)) {
                    newSet.add(clone(element1));
                }

            });

            set2.each(function (element2) {

                if (!set1.exists(element2)) {
                    newSet.add(clone(element2));
                }

            });

            return newSet;

        },

        /**
         * @param aSet
         * @returns {boolean}
         *
         * Determine if the set is a subset of another set.
         */
        isSubset : function(aSet){

            debug.set.trace('#isSubset');

            var match = true;

            this.each(function(element){
                if(!aSet.exists(element)){
                    match = false;
                    return false;
                }
            });

            return match;

        },

        /**
         * @param aSet
         * @returns {boolean}
         *
         * Determine if the set is a superset of another set
         */
        isSuperset : function(aSet){

            debug.set.trace('#isSuperset');

            return !aSet.isSubset(this);
        },

        /**
         * @param aSet
         * @returns {boolean}
         *
         * Determines if the set is a proper subset of another set
         */
        isProperSubset : function(aSet){

            debug.set.trace('#isProperSubset');

            if(this.length() >= aSet.length()){
                return false;
            }
            return this.isSubset(aSet);
        },

        /**
         * @param aSet
         * @returns {boolean}
         *
         * Determine if the set is a proper superset of another set
         */
        isProperSuperset : function(aSet){

            debug.set.trace('#isProperSuperset');

            return !aSet.isProperSubset(this);
        },

        /**
         * @param {Set} anotherSet
         * @returns {boolean}
         *
         * Checks if two sets are equal
         */
        equal: function (anotherSet) {

            debug.set.trace('#equal');

            return this.constructor.equal(this, anotherSet);

        }




    }, {

        /**
         *
         * @param {Set} set1 The first set to compare
         * @param {Set} set2 The second set to compare
         * @returns {boolean} True if the sets are equal, false otherwise
         * @static
         *
         * Checks if two sets are equal
         *
         */
        equal: function (set1, set2) {

            debug.set.trace('.equal');

            var setLength1 = set1.length(),
                setLength2 = set2.length(),
                mismatch = false;

            // Check that both sets are of the same type

            if (set1.type() && set2.type() && (set1.type() !== set2.type())) {
                return false;
            }

            // Check that both sets are of the same length
            if (setLength1 !== setLength2) {
                return false;
            }

            // Find each set1 items in set2
            set1.each(function (element1) {

                var index2 = set2.index(element1);

                if (index2 === null) {
                    mismatch = true;
                    return false;
                }

            });

            return !mismatch;

        }

    });

module.exports = Set;
},{"./Tuple.js":11,"./Type.js":12,"./helpers/clone":79,"./helpers/coerce":80,"./helpers/debug.js":82,"./helpers/equal":83,"eventemitter3":102,"lodash":103}],11:[function(require,module,exports){
var Type = require('./Type.js');
var Header = require('./Type.js');
var TString = require('./types/String.js');
var Attribute = require('./Attribute.js');
var _ = require('lodash');
var equal = require('./helpers/equal');
var value = require('./helpers/value');
var Set = require('./Set.js');
var Tuple = Type.extend(
    {

        /**
         * @class Tuple
         * @param attributes
         * @extends Type
         * @constructor
         */
        constructor: function (attributes) {

            this.attributes = {};

            if (attributes) {

                if (!_.isObject(attributes)) {
                    throw new TypeError('Tuple attributes in wrong format')
                }

                var a;

                for (a in attributes) {

                    if (attributes.hasOwnProperty(a)) {
                        this.set(a, attributes[a]);
                    }

                }
            }

            Type.apply(this, arguments);

        },


        /**
         * Iterator function that loops through each of the tuple attributes
         * @param {Function} callback Callback function
         * @param {Object} context Execution context of the callback
         */
        each : function(callback, context){
            _.forIn(this.attributes, callback, context);
        },

        /**
         * Copies attribtues from another tuple
         * @param {Tuple} tuple Tuple to copy attributes from
         * @param {Header|Attribute[]|Set|String[]} [attributesArgument=[]] Attributes to copy
         * @param {boolean} [exclude=false] Do we exclude or include the specified arguments
         */
        copy : function(tuple, attributesArgument, exclude){

            if (exclude !== true && exclude !== false){
                exclude = false;
            }

            if (!_.isUndefined(attributesArgument) && !_.isNull(attributesArgument)) {

                var result = new Set({type: TString});

                // Coerce the attributes argument to Set of string
                if (attributesArgument instanceof Header) {
                    attributesArgument.each(function (attribute) {
                        result.add(attribute.name);
                    })
                } else if (attributesArgument instanceof Set) {
                    attributesArgument.each(function (attributeArgument) {

                        if (attributeArgument instanceof Attribute) {
                            result.add(attributeArgument.name);
                        } else if (_.isString(attributeArgument)) {
                            result.add(attributeArgument);
                        }

                    })
                } else if (_.isArray(attributesArgument)) {
                    _.forEach(attributesArgument, function (attributeArgument) {
                        if (attributeArgument instanceof Attribute) {
                            result.add(attributeArgument.name);
                        } else if (_.isString(attributeArgument)) {
                            result.add(attributeArgument);
                        }
                    })
                } else if (_.isString(attributesArgument)) {
                    result.add(attributesArgument);
                }

                attributesArgument = result;

            }

            if(attributesArgument && exclude === false){

                attributesArgument.each(function(copiedAttribute){

                    this.set(value(copiedAttribute), tuple.get(value(copiedAttribute)));

                }, this)

            } else {

                _.forEach(tuple.attributes, function (tupleAttribute, tupleAttributeKey) {

                    if (attributesArgument && exclude === true){

                        var isExcludedAttribute = false;

                        attributesArgument.each(function(excludedAttribute){

                            if (equal(TString, excludedAttribute, tupleAttributeKey)){
                                isExcludedAttribute = true;
                                return false;
                            }

                        });

                        if(!isExcludedAttribute){
                           this.set(tupleAttributeKey, tupleAttribute);
                        }

                    } else {
                        this.set(tupleAttributeKey, tupleAttribute);
                    }

                }, this)

            }

        },

        /**
         * Test for equality with another tuple
         * @param {Tuple} tuple
         * @returns {boolean}
         */
        equals: function (tuple) {
            return Tuple.equal(this, tuple);
        },

        /**
         * Sets an attribute value
         * @param {String} attributeName Name of the attribute
         * @param {*} value Value of the attribute
         */
        set: function (attributeName, value) {

            if(this.relation){

                var clone = this.clone();

                var oldValue = this.attributes[attributeName];

                var foundIndex = undefined;

                value = this.relation.header().get(attributeName).type.coerce(value);

                clone.attributes[attributeName] = value;

                // Let's check if updating the tuple's attribute
                // will cause a duplicate tuple in the relation

                if((foundIndex = this.relation.index(clone)) !== null && (this.relation.atIndex(foundIndex) !== this)){

                    this.relation.remove(this);

                } else {

                    this.relation.ee.emit('beforeUpdate', this, attributeName, value);

                    this.attributes[attributeName] = value;

                    this.relation.ee.emit('afterUpdate', this, attributeName, value, oldValue);

                }

            } else {

                this.attributes[attributeName] = value;

            }

        },

        /**
         * Gets and attribute value
         * @param {Attribute|String} attributeName Name of the attribute
         * @returns {*}
         */
        get: function (attributeName) {

            return this.attributes[attributeName];

        },

        /**
         * Deletes an attribute from the tuple
         * @param {String} attributeName The attribute name to delete
         */
        delete: function (attributeName) {
            delete this.attributes[attributeName];
        },

        /**
         * Clones a tuple
         * @returns {Tuple}
         */
        clone: function () {

            var attr,
                newTuple = new (this.constructor)();

            _.forEach(this.attributes, function (attribute, key) {

                if (_.isFunction(attribute.clone)) {
                    attr = attribute.clone();
                } else {
                    attr = attribute;
                }

                newTuple.set(key, attr);

            }, this);

            return newTuple;

        },

        /**
         * String representation of the tuple
         * @returns {string}
         */
        toString : function(){

            var count = 0;

            var attrLength = Object.keys(this.attributes).length;
            var attrs = ['Tuple({'];

            this.each(function(attribute, key){

                attrs.push(key.toString()+ ' : ' + attribute.toString());

                if(count !== attrLength-1){
                    attrs.push(', ')
                }

                count++;

            },this);

            attrs.push('})');

            return attrs.join('');

        },

        toObject : function(recursive){

            recursive = typeof(recursive) !== 'undefined' ? recursive : false;

            var result = {};

            this.each(function(attribute, key) {

                if(recursive && !!this.relation && !!this.relation.get(key) && (this.relation.get(key).type === Tuple)) {
                    result[key] = attribute.toObject(true);
                } else {
                    result[key] = attribute;
                }

            }, this);

            return result;

        }


    }, {

        type: 'Tuple',

        toString: function () {
            return 'Tuple'
        },

        /**
         * Test for equality between two tuples
         * @param {Tuple} tuple1
         * @param {Tuple} tuple2
         * @returns {boolean}
         * @static

         */
        equal: function (tuple1, tuple2) {

            var key;

            if (!(tuple1 instanceof Tuple) || !(tuple2 instanceof Tuple)) {
                throw new Error('Provided tuples are of the wrong type');
            }

            var match = true;

            tuple1.each(function(attr, key){

                if(tuple2.get(key) === null){
                    match = false;
                    return false;
                }

                if(!equal(null, attr, tuple2.get(key))){
                    match = false;
                    return false;
                }

            });

            return match;

        },

        /**
         * Check that two tuples match on the given attributes
         * @param {Tuple} tuple1
         * @param {Tuple} tuple2
         * @param {Attribute[]} attributes
         * @returns {boolean}
         * @static

         */
        matchOnAttributes : function(tuple1, tuple2, attributes){

            var match = true;

            attributes.each(function(attribute){

               var attributeName = attribute.name;

                if(!equal(null, tuple1.get(attributeName), tuple2.get(attributeName))){
                    match = false;
                    return false;
                }

            });

            return match;

        },

        /**
         * Coerces an arbitrary object to type Tuple
         * @param {Object|Tuple} tuple
         * @param relation The Relation to which belongs the tuple.
         * @returns {Tuple}
         * @static

         */
        coerce: function (tuple, relation) {


            if(tuple instanceof Tuple){

                // Given tuple is of type Tuple.

                return tuple;

            } else {

                if(!_.isObject(tuple)){

                    // It is not an object. It can't be coerced.

                    throw new TypeError('Wrong parameter type. Expected an object or a Tuple')
                }

                // It is not a Tuple instance. Check if it might be coerced.
                if (_.isArray(tuple)) {

                    if (_.isUndefined(relation) || _.isNull(relation)) {
                        throw new Error('Cannot coerce array-declared tuple if no relation is specified')
                    }

                    if (_.isFunction(relation.header)) {

                        // Collection has header

                        var header = relation.header(),
                            headerCount = header.length();

                        if (headerCount > 0) {

                            // Header has one or more attributes

                            if(!header._orderedDeclaration){
                                throw new Error('Cannot coerce an array declared tuple if the header has not been declared in array format')
                            }

                            if(headerCount !== tuple.length){
                                throw new Error('Cannot coerce Tuple, it does not have the same number of attributes as the header');
                            }

                            var newTuple = new Tuple();

                            // Iterate through each attributes of the header in order

                            header.each(function(attribute, index){

                                // Set the corresponding tuple attribute

                                newTuple.set(attribute.name, tuple[index]);

                            });

                            return newTuple;

                        }

                    }

                }

                tuple = new Tuple(tuple);

                return tuple;

            }

        }

    });

module.exports = Tuple;
},{"./Attribute.js":2,"./Set.js":10,"./Type.js":12,"./helpers/equal":83,"./helpers/value":85,"./types/String.js":99,"lodash":103}],12:[function(require,module,exports){
var Base = require('./Base.js');

var Type = Base.extend(
    {

        /**
         * @class Type
         * @extends Base
         */
        constructor: function (value) {

            //this._value = value;

            Base.apply(this, arguments);

        },

        /**
         * Clones the object
         * @returns {Type}
         */
        clone : function(){

            return new this.constructor(this._value);

        },

        /**
         * Destroys the object
         */
        destroy : function(){

        }

    }, {

        type : 'Type',

        toString: function () {
            return 'Type'
        }

    });

module.exports = Type;
},{"./Base.js":3}],13:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var Tuple = require('./../Tuple.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');

var Composition = Relation.extend(

    {

        /**
         * @class Operators.Composition
         * @extends Relation
         *
         * @param {Relation} relationA The relation A
         * @param {Relation} relationB The relation B
         *
         *
         * The Composition operator will perform a natural join between A and B while removing the common attributes
         *
         *     var relationA = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {firstName: { type: affinity.String}},
         *              {lastName: { type: affinity.String}}
         *          ],[
         *              [1, 'John', 'Doe'],
         *              [2, 'Mary', 'Poppins'],
         *              [3, 'Lucky', 'Luke']
         *          ]);
         *     // +------------------------+---------------------+--------------------+
         *     // | characterId : TInteger | firstName : TString | lastName : TString |
         *     // +========================+=====================+====================+
         *     // | 1                      | John                | Doe                |
         *     // +------------------------+---------------------+--------------------+
         *     // | 2                      | Mary                | Poppins            |
         *     // +------------------------+---------------------+--------------------+
         *     // | 3                      | Lucky               | Luke               |
         *     // +------------------------+---------------------+--------------------+
         *
         *     var relationB = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {fan: { type: affinity.String}}
         *          ],[
         *              [1, 'Mr X'],
         *              [1, 'Miss Dibble'],
         *              [2, 'Nat Bibble']
         *          ]);
         *     // +------------------------+---------------+
         *     // | characterId : TInteger | fan : TString |
         *     // +========================+===============+
         *     // | 1                      | Mr X          |
         *     // +------------------------+---------------+
         *     // | 1                      | Miss Dibble   |
         *     // +------------------------+---------------+
         *     // | 2                      | Nat Bibble    |
         *     // +------------------------+---------------+
         *
         *     var relationC = relationA.compose(relationB);
         *
         *     // or
         *
         *     var relationC = new affinity.Composition(relationA, relationB)
         *
         *     // +---------------------+--------------------+---------------+
         *     // | firstName : TString | lastName : TString | fan : TString |
         *     // +=====================+====================+===============+
         *     // | John                | Doe                | Mr X          |
         *     // +---------------------+--------------------+---------------+
         *     // | John                | Doe                | Miss Dibble   |
         *     // +---------------------+--------------------+---------------+
         *     // | Mary                | Poppins            | Nat Bibble    |
         *     // +---------------------+--------------------+---------------+
         *     //
         */
        constructor: function (relationA, relationB) {

            /**
             * @property {Object} args
             * @property {Relation} args.left
             * @property {Relation} args.right
             */

            debug.compose.trace('#constructor');

            this.args = {};

            this.args.left = relationA;

            this.args.right = relationB;

            Relation.call(this);

            this.commonAttributes = null;

        },

        bindEvents: function () {

            debug.compose.trace('#bindEvents');

            // Calling the parent bindEvents
            Composition.__super__.bindEvents.call(this);

            var that = this;

            var left = that.args.left;
            var right = that.args.right;

            // beforeGetHeader
            this.ee.once('beforeGetHeader', function () {

                var leftHeader = left.header();
                var rightHeader = right.header();

                debug.compose.trace('beforeGetHeader');

                Header.assertSameNameSameType(leftHeader, rightHeader);

                that.commonAttributes = Header.commonAttributes(leftHeader, rightHeader);

                that.leftAttributes = leftHeader.setDifference(that.commonAttributes);

                that.rightAttributes = rightHeader.setDifference(that.commonAttributes);

                that.header().copy(leftHeader.setUnion(rightHeader).setDifference(that.commonAttributes));

            });

            // beforeGetBody
            this.ee.once('beforeGetBody', function () {

                debug.compose.trace('beforeGetBody');

                left.each(function (tuple) { that.doAfterAdd(left, tuple); });

                right.each(function (tuple) { that.doAfterAdd(right, tuple);});

            });

            left.ee.on('afterAdd', function(tuple){

                that.doAfterAdd(left, tuple);

            });

            right.ee.on('afterAdd', function(tuple){

                that.doAfterAdd(right, tuple);

            });

            left.ee.on('afterRemove', function(tuple, index){

                that.doAfterRemove(left, tuple);

            });

            right.ee.on('afterRemove', function(tuple, index){

                that.doAfterRemove(right, tuple);

            });

            left.ee.on('afterUpdate', function(tuple, attributeName, value){

                that.doAfterUpdate(left, tuple, attributeName, value);

            });

            right.ee.on('afterUpdate', function(tuple, attributeName, value){

                that.doAfterUpdate(right, tuple, attributeName, value);

            });

        },

        /**
         * Event handler when tuples are added to the base relations
         * @param {Relation} relation relation in which the tuple was added
         * @param {Tuple} tuple1 the tuple that was added
         */
        doAfterAdd : function(relation, tuple1){

            var that = this;

            var otherRelation = (relation === that.args.left ? that.args.right : that.args.left);

            otherRelation.each(function(tuple2){

                var match = Tuple.matchOnAttributes(tuple1, tuple2, that.commonAttributes);

                if(match){

                    var combinedTuple = _.extend({}, tuple1.attributes, tuple2.attributes);

                    var newTuple = new Tuple();

                    that.header().each(function(composeAttribute){

                        var composeAttributeName = composeAttribute.name;

                        newTuple.set(composeAttributeName, combinedTuple[composeAttributeName])

                    });

                    that.add(newTuple);

                }

            })

        },


        /**
         * Event handler when tuples are removed from the base relations.
         * @param {Relation} relation Relation in which the tuple was removed
         * @param {Tuple} removedTuple The tuple that was removed
         */
        doAfterRemove : function(relation, removedTuple){

            var that = this;

            var nonCommonAttributes = (relation === that.args.left ? that.leftAttributes : that.rightAttributes);

            // Find tuples which match the removed tuple on its attributes

            that.each(function(tuple, index){

                var match = Tuple.matchOnAttributes(tuple, removedTuple, nonCommonAttributes);

                if(match){

                    that.removeAt(index);

                }

            });

        },

        /**
         * Event handler when tuples are updated in the base relations
         * @param {Relation} relation The relation where the tuple was updated
         * @param {Tuple} tuple The tuple that was updated
         * @param {String} attributeName The name of the attribute that was updated
         * @param {*} value The new value of the attribute
         */
        doAfterUpdate : function(relation, tuple, attributeName, value, oldValue){

            var that = this;

            var otherRelation = (relation === that.args.left ? that.args.right : that.args.left);

            var result = this.args.left.compose(this.args.right);

            that.adjustTo(result);

        }

    }, {

        type : 'Composition'

    });

module.exports = Composition;
},{"./../Header.js":6,"./../Relation.js":9,"./../Tuple.js":11,"./../helpers/debug":82,"lodash":103}],14:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');

var Difference = Relation.extend(


    {

        /**
         * @class Operators.Difference
         * @extends Relation
         * @param {Relation} left The relation from which to remove the tuples
         * @param {Relation} right The relation that will be substracted from the other
         *
         * The Difference operation gives the first relation's tuples minus those that are in the second relation.
         *
         *     var left = new affinity.Relation([
         *              {a: { type: affinity.Integer}},
         *              {b: { type: affinity.Integer}},
         *              {c: { type: affinity.Integer}}
         *          ],[
         *              [1, 2, 3],
         *              [4, 5, 6],
         *              [7, 8, 9]
         *          ]);

         *     var right = new affinity.Relation([
         *              {a: { type: affinity.Integer}},
         *              {b: { type: affinity.Integer}},
         *              {c: { type: affinity.Integer}}
         *          ], [
         *              [1, 2, 3]
         *          ]);
         *
         *     var rel3 = left.difference(right);
         *
         *     // or
         *
         *     var rel4 = new affinity.Difference(left, right)
         *
         *     // +--------------+--------------+--------------+
         *     // | a : TInteger | b : TInteger | c : TInteger |
         *     // +==============+==============+==============+
         *     // | 4            | 5            | 6            |
         *     // +--------------+--------------+--------------+
         *     // | 7            | 8            | 9            |
         *     // +--------------+--------------+--------------+
         */
        constructor: function (left, right) {

            debug.difference.trace('#constructor');

            /**
             * @property {Object} args
             */
            this.args = {};

            /**
             * @property {Relation} left
             */
            this.args.left = left;

            /**
             * @property {Relation} right
             */
            this.args.right = right;

            /**
             * @property {Relation[]} relations
             */
            this.args.relations = [left, right];

            /**
             * @property {Boolean} computed
             */
            this.computed = false;

            // Calls the parent constructor
            Relation.call(this);

        },

        /**
         * @private
         */
        bindEvents: function () {

            debug.difference.trace('#bindEvents');

            Difference.__super__.bindEvents.call(this);

            var that = this;

            var left = that.args.left;
            var right = that.args.right;

            // BeforeGetHeader
            this.ee.once('beforeGetHeader', function () {

                var leftHeader = left.header();
                var rightHeader = right.header();

                debug.difference.trace('beforeGetHeader');

                Header.assertUnionCompatible(leftHeader, rightHeader);

                that.header().copy(leftHeader);

            });


            // BeforeGetBody
            this.ee.once('beforeGetBody', function () {

                debug.difference.trace('beforeGetBody');

                left.each(function (tuple1) {

                    if (right.index(tuple1) === null) {

                        that.add(tuple1.clone(), false);

                    }

                });

                that.computed = true;

            });

            left.ee.on('afterAdd', function(tuple, index){
                that.afterLeftAdd(left, tuple);
            });

            right.ee.on('afterAdd', function(tuple, index){
                that.afterRightAdd(left, tuple);
            });

            left.ee.on('afterRemove', function(tuple, index){
                that.afterLeftRemove(right, tuple);
            });

            right.ee.on('afterRemove', function(tuple, index){
                that.afterRightRemove(right, tuple);
            });

            left.ee.on('afterUpdate', function(tuple, attributeName, value, oldValue){
                that.afterLeftUpdate(left, tuple, attributeName, value, oldValue);
            });

            right.ee.on('afterUpdate', function(tuple, attributeName, value, oldValue){
                that.afterRightUpdate(right, tuple, attributeName, value, oldValue);
            });

        },

        /**
         * Event triggered when tuples are removed from the left relation
         * @param {Relation} relation
         * @param {Tuple} removedTuple
         * @private
         */
        afterLeftRemove : function(relation, removedTuple){

            // If the tuple is not present in the right relation,
            // remove it
            if(this.computed && this.args.right.index(removedTuple) === null){
                this.remove(removedTuple);
            }

        },

        /**
         * Event triggered when tuples are removed from the right relation
         * @param {Relation} relation
         * @param {Tuple} removedTuple
         * @private
         */
        afterRightRemove : function(relation, removedTuple){

            // If the tuple is present in the left relation,
            // add it.
            if(this.computed && this.args.left.index(removedTuple) !== null){
                this.add(removedTuple.clone());
            }

        },

        /**
         * Event triggered when tuples are added to the left base relation
         * @param {Relation} relation
         * @param {Tuple} addedTuple
         * @private
         */
        afterLeftAdd : function(relation, addedTuple){

            // If the tuple is not in the right
            // relation, add it.
            if(this.computed && this.args.right.index(addedTuple) === null){

                this.add(addedTuple.clone());

            }

        },

        /**
         * Event triggered when tuples are added to the right base relation
         * @param {Relation} relation
         * @param {Tuple} addedTuple
         * @private
         */
        afterRightAdd : function(relation, addedTuple){

            // If the tuple is present in the left
            // relation, remove it.
            if(this.computed && this.args.left.index(addedTuple) !== null){

                this.remove(addedTuple);

            }

        },

        /**
         * Event triggered when tuples are updated on the left relation
         * @param {Relation}relation
         * @param {Tuple} tuple
         * @param {String} attributeName
         * @param {*} value
         * @param {*} oldValue
         * @private
         */
        afterLeftUpdate : function(relation, tuple, attributeName, value, oldValue){

            if(this.computed){

                var oldRightIndex, rightIndex, oldTuple;

                oldTuple = tuple.clone();

                oldTuple.attributes[attributeName] = oldValue;

                oldRightIndex = this.args.right.index(oldTuple);
                rightIndex = this.args.right.index(tuple);

                if(oldRightIndex === null && rightIndex === null){

                    this.find(oldTuple).set(attributeName, value);

                } else if (oldRightIndex === null && rightIndex !== null){

                    this.remove(oldTuple);

                } else if (oldRightIndex !== null && rightIndex === null){

                    this.add(tuple.clone());

                }

            }


        },

        /**
         * Event triggered when tuples are updated on the right relation
         * @param {Relation}relation
         * @param {Tuple} tuple
         * @param {String} attributeName
         * @param {*} value
         * @param {*} oldValue
         * @private
         */
        afterRightUpdate : function(relation, tuple, attributeName, value, oldValue){

            if(this.computed){

                var oldLeftIndex, leftIndex, oldTuple;

                oldTuple = tuple.clone();

                oldTuple.attributes[attributeName] = oldValue;

                oldLeftIndex = this.args.left.index(oldTuple);
                leftIndex = this.args.left.index(tuple);

                if (oldLeftIndex === null && leftIndex !== null){

                    this.remove(tuple);

                } else if (oldLeftIndex !== null && leftIndex !== null){

                    this.add(oldTuple);

                    this.remove(tuple);

                } else if (oldLeftIndex !== null && leftIndex === null){

                    this.add(oldTuple);

                }
            }
        }

    }, {

        type : 'Difference'

    });

module.exports = Difference;
},{"./../Header.js":6,"./../Relation.js":9,"./../helpers/debug":82,"lodash":103}],15:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var Attribute = require('./../Attribute.js');
var Tuple = require('./../Tuple.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');

var Extend = Relation.extend(
    {

        constructor: function (relation, expressions) {
            /**
             * @class Operators.Extension
             * @extends Relation
             * @param {Relation} relation T{he relation from which to remove the tuples
             * @param {Object[]} expressions The arguments from which to calculate the new attribute value.
             *
             * The Extend operation allows the addition of calculated {@link Header} {@link Attribute}s
             *
             *     var relationA = new affinity.Relation([
             *              {name: { type: affinity.String}},
             *              {born: { type: affinity.Integer}},
             *              {died: { type: affinity.Integer}}
             *          ],[
             *              ['Aristotle', -384, -322],
             *              ['Plato',     -428, -348],
             *              ['Socrates',  -470, -399]
             *          ]);
             *
             *     var born = relationA.get('born');
             *     var died = relationA.get('died');
             *
             *     var relationB = relationA.extend([{ lived : died.minus(born) }]);
             *
             *     //or
             *
             *     // LIVED = DIED - BORN
             *
             *     var relationB = new affinity.Extend(relationA, [{ lived : died.minus(born) }]);
             *
             *     //                                                       <-EXTENDED ATTR-->
             *     // +----------------+-----------------+-----------------+------------------+
             *     // | name : TString | born : TInteger | died : TInteger | lived : TInteger |
             *     // +================+=================+=================+==================+
             *     // | Aristotle      | -384            | -322            | 62               |
             *     // +----------------+-----------------+-----------------+------------------+
             *     // | Plato          | -428            | -348            | 80               |
             *     // +----------------+-----------------+-----------------+------------------+
             *     // | Socrates       | -470            | -399            | 71               |
             *     // +----------------+-----------------+-----------------+------------------+
             *     //
             *
             *     // Possible to add multiple attributes in one call :
             *
             *     // LIVED = DIED - BORN, SINCE = YEAR(NOW())-DIED
             *
             *     var relationB = new affinity.Extend(relationA, [
             *          { lived : died.minus(born) },
             *          { since: affinity.year(affinity.now()).minus(died) }
             *     ]);
             *
             *     //                                                       <-EXTENDED ATTR--> <-EXTENDED ATTR-->
             *     // +----------------+-----------------+-----------------+------------------+------------------+
             *     // | name : TString | born : TInteger | died : TInteger | lived : TInteger | since : TInteger |
             *     // +================+=================+=================+==================+==================+
             *     // | Aristotle      | -384            | -322            | 62               | 2335             |
             *     // +----------------+-----------------+-----------------+------------------+------------------+
             *     // | Plato          | -428            | -348            | 80               | 2362             |
             *     // +----------------+-----------------+-----------------+------------------+------------------+
             *     // | Socrates       | -470            | -399            | 71               | 2413             |
             *     // +----------------+-----------------+-----------------+------------------+------------------+
             *     //
             *
             *     // Possible to have custom defined functions
             *     // Beware though to return the right data type (divisions by zero, tan(/2), ...)
             *
             *     // You may as well use this feature, but since affinity will later be a SQL parser too,
             *     // it will obviously not support the translation of custom defined functions into SQL code.
             *     // If you plan have use of affinity's future SQL parser, beware that these custom functions
             *     // will only run in javascript, because we need the AST so we can convert it to SQL.
             *
             *     // I would have loved javascript to support overloading of operators, but that won't
             *     // happen anytime soon.
             *
             *     var relationB = relation.extend([
             *
             *          {'lived' : {function(tuple){
             *              return tuple.get('died')-tuple.get('born');
             *          }, type : affinity.Integer},
             *
             *          {'died' : {function(tuple){
             *              return 2014 - tuple.get('died')
             *          }, type : affinity.Integer},
             *
             *     ]);
             *
             */

            debug.extend.trace('#constructor');

            /*
            * @property {Object} args
            * @property {Relation} args.relation
            * @property {Array} args.expressions
            */

            this.args = {};

            this.args.relation = relation;

            this.args.expressions = expressions;

            // Coerce the argument to an array if it is not already

            if (!_.isArray(this.args.expressions)) {
                this.args.expressions = [this.args.expressions];
            }

            // Throw an error if the expression array is of length 0
            if (this.args.expressions.length === 0) {
                throw new Error('You must define expressions!');
            }

            Relation.call(this);

        },

        bindEvents: function () {

            debug.extend.trace('#bindEvents');

            // Calling the parent bindEvents
            Extend.__super__.bindEvents.call(this);

            var that = this;

            var expressions = that.args.expressions;

            var relation = that.args.relation;

            /// BeforeGetHeader

            this.ee.once('beforeGetHeader', function () {

                debug.extend.trace('beforeGetHeader');

                // Add the attributes of the base relation

                that.header().copy(relation.header());

                /// Parse extension attributes

                _.forOwn(expressions, function (expression, key) {

                    // Expression must be an object
                    if (!_.isObject(expression)) {
                        throw new TypeError('Wrong expression format')
                    }

                    var keys = Object.keys(expression);

                    // Expression must have only one parameter
                    if (keys.length !== 1) {
                        throw new SyntaxError('Unhandled expression declaration');
                    }

                    // This is the name of the attribute to add
                    var extensionName = keys[0];

                    // This is the expression
                    var extensionParam = expression[extensionName];


                    var type;

                    // Check if the param is only an Attribute
                    if(extensionParam instanceof Attribute){

                        // Return the same type as the attribute
                        type = extensionParam.type;

                        // Convert the attribute to TupleAttribute
                        expressions[key][extensionName] = extensionParam = new (require('./../functions/tuple/Attribute'))(extensionParam.name);


                    } else {

                        // Convert the attributes objects to functions that iterate through tuples
                        extensionParam.convertAttributeToTuple();

                        // Get the return type of the expression
                        type = extensionParam.type();

                    }

                    // Key must not already exist in the current header
                    if (that.header().get(extensionName) !== null) {
                        throw new Error('Relation extension name already exists in the header');
                    }

                    // Create the new header attribute
                    var extensionAttribute = new Attribute({type: type, name: extensionName});

                    // The attribute is a calculated attribute
                    extensionAttribute.calculated(true);

                    // Add the attribute in the header
                    that.header().add(extensionAttribute);

                })

            });


            /// BeforeGetBody

            this.ee.once('beforeGetBody', function () {

                debug.extend.trace('beforeGetBody');

                relation.each(function (tuple) {

                    that.afterAdd(relation, tuple);

                })

            });

            relation.ee.on('afterAdd', function(tuple, index){
                that.afterAdd(that.args.relation, tuple);
            });

            relation.ee.on('afterRemove', function(tuple, index){
                that.afterRemove(that.args.relation, tuple);
            });

            relation.ee.on('afterUpdate', function(tuple, attributeName, value, oldValue){
                that.afterUpdate(that.args.relation, tuple, attributeName, value, oldValue);
            });

        },

        /**
         * Calculates the extend expressions values for a tuple
         * @param {Tuple} tuple The tuple to calculate expressions against
         * @param {Boolean} clone either to return a new instance of the tuple, or the passed instance
         * @returns {Tuple} The built tuple
         */
        buildTuple : function(tuple, clone){

            if (_.isBoolean(clone)){
                // clone = clone;
            } else {
                clone = true;
            }

            var that = this,
                newTuple;

            if (clone){

                // Create the tuple we are going to add
                newTuple = new Tuple();

                // Copy the attributes from the base tuple
                newTuple.copy(tuple);

            } else {

                newTuple = tuple;

            }

            _.forEach(that.args.expressions, function (expression) {

                // This is the new attribute name
                var attributeName = Object.keys(expression)[0];

                // This is the evaluation expression
                var attributeExpression = expression[attributeName];

                attributeExpression.assignTuple(newTuple);

                // This is the new value
                var expressionValue = attributeExpression.value();

                // Let's set the new value in the tuple
                newTuple.set(attributeName, expressionValue);

            });

            return newTuple;
        },

        afterAdd : function(relation, addedTuple){

            var that = this;

            that.add(that.buildTuple(addedTuple));

        },

        afterRemove : function(relation, tuple, index){

            var myTuple = this.buildTuple(tuple);

            this.remove(myTuple);
        },

        afterUpdate : function(relation, tuple, attributeName, value, oldValue){

            var that = this;

            var tupleClone = tuple.clone();

            tupleClone.set(attributeName, oldValue);

            tupleClone = that.buildTuple(tupleClone);

            var myTuple =  that.find(tupleClone);

            myTuple = that.find(myTuple);

            myTuple.set(attributeName, value);

            that.buildTuple(myTuple, false);

        }

    }, {

        type : 'Extension'

    });

module.exports = Extend;
},{"./../Attribute.js":2,"./../Header.js":6,"./../Relation.js":9,"./../Tuple.js":11,"./../functions/tuple/Attribute":78,"./../helpers/debug":82,"lodash":103}],16:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var Tuple = require('./../Tuple.js');
var Attribute = require('./../Attribute.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');




var Group = Relation.extend(

    {

        /**
         * @class Operators.Group
         * @extends Relation
         * @param {Relation} relation The relation to group
         * @param {String} attributeName The new grouped attribute name
         * @param {String[]} attributes The attributes to group
         *
         * The Group operation will group the specified tuple's attributes into one.
         * The resulting tuples will have an {@link Attribute} whose {@link Type} will be a {@link Relation}. See example.
         *
         *     var relationA = new affinity.Relation([
         *              {a: { type: affinity.Integer}},
         *              {b: { type: affinity.Integer}},
         *              {c: { type: affinity.Integer}}
         *          ],[
         *              [1, 2, 3],
         *              [4, 5, 6],
         *              [4, 9, 9],
         *              [7, 8, 9]
         *          ]);
         *
         *     var relationB = relationA.group('groupedAttribute', ['b', 'c'])
         *
         *     //or
         *
         *     var relationB = new affinity.Group(relationA, 'groupedAttribute', ['b','c'])
         *
         *     //                 <----GROUPING ATTRIBUTE---------->
         *     // +--------------+---------------------------------+
         *     // | a : TInteger | groupedAttribute : Relation     |
         *     // +==============+=================================+
         *     // | 1            | +--------------+--------------+ |
         *     // |              | | b : TInteger | c : TInteger | |
         *     // |              | +==============+==============+ |
         *     // |              | | 2            | 3            | |
         *     // |              | +--------------+--------------+ |
         *     // +--------------+---------------------------------+
         *     // | 4            | +--------------+--------------+ |
         *     // |              | | b : TInteger | c : TInteger | |
         *     // |              | +==============+==============+ |
         *     // |              | | 5            | 6            | |
         *     // |              | +--------------+--------------+ |
         *     // |              | | 9            | 9            | |
         *     // |              | +--------------+--------------+ |
         *     // +--------------+---------------------------------+
         *     // | 7            | +--------------+--------------+ |
         *     // |              | | b : TInteger | c : TInteger | |
         *     // |              | +==============+==============+ |
         *     // |              | | 8            | 9            | |
         *     // |              | +--------------+--------------+ |
         *     // +--------------+---------------------------------+
         */
        constructor: function (relation, attributeName, attributes) {

            /**
             * @property {Object} args
             * @property {Relation} args.relation
             * @property {String} args.groupingAttributeName
             * @property {String[]} args.groupedAttributeNames
             * @property {Attribute[]} args.groupedAttributes
             * @property {Attribute} args.groupingAttribute
             */

            debug.group.trace('#constructor');

            this.args = {};

            this.args.relation = relation;

            this.args.groupingAttributeName = attributeName;

            this.args.groupedAttributeNames = attributes;

            this.args.groupedAttributes = [];

            this.args.groupingAttribute = null;

            // Calling the parent constructor
            Relation.call(this);

        },

        bindEvents: function () {

            debug.group.trace('#bindEvents');

            // Calling the parent bindEvents
            Group.__super__.bindEvents.call(this);

            var that = this,
                groupedAttributeNames = this.args.groupedAttributeNames,
                groupingAttributeName = this.args.groupingAttributeName,
                relation = this.args.relation,
                groupedAttributes = that.args.groupedAttributes;

            // BeforeGetHeader
            that.ee.once('beforeGetHeader', function () {

                // We want to have this kind of relation
                //
                // +----------------+----------------+-------------------------------------+
                // | attr3 : <type> | attr4 : <type> | groupedAttr : Relation              |
                // +================+================+=====================================+
                //
                // Where attr3 and attr4 are non grouped attributes
                // and groupedAttr will contain the grouped attributes relations
                //

                var header = relation.header();

                debug.group.trace('beforeGetHeader');

                // Check that the attributes specified in groupedAttributeNames exists in the base header
                _.forEach(groupedAttributeNames, function(groupedAttributeName){
                    if(header.get(groupedAttributeName) === null){
                        throw new Error('Attribute with name "'+groupedAttributeName+'" does not exist in the header')
                    }
                });

                // Loop through each of the relation's header attributes
                header.each(function(attribute){

                    // Check if the attribute is part of the grouped attributes

                    var present = _.any(groupedAttributeNames, function(groupedAttributeName){
                        return groupedAttributeName === attribute.name;
                    });

                    if(!present){
                        // If it is not present, add it to the header.
                        that.header().add(attribute.clone());
                    } else {
                        // If it is present, store it in the groupedAttributeNames array
                        groupedAttributes.push(attribute);
                    }

                });

                // Let's create the groupingAttributeName and add it to the header

                that.args.groupingAttribute = new Attribute({name : groupingAttributeName, type : Relation});

                that.header().add(that.args.groupingAttribute);

            });


            // BeforeGetBody
            that.ee.once('beforeGetBody', function () {

                debug.group.trace('beforeGetBody');


                // Make sure the header is computed

                that.header();


                // Let's loop through each of the relation's tuples

                relation.each(function(tuple){

                    // This variable will store the tuple grouped attribute values
                    var groupedAttributeValues = {};

                    // This variable will store the tuple non-grouped attribute values
                    var nonGroupedAttributeValues = {};

                    // Now, we will build these variables

                    // Let's loop through each of the tuple's attribute values
                    tuple.each(function(value, key){

                        // Check if the current tuple attribute is grouped or not grouped
                        var grouped = _.any(that.args.groupedAttributes, function(groupedAttribute){
                            return key === groupedAttribute.name;
                        });

                        if(grouped){

                            // Tuple attribute is part of the grouped attributes

                            groupedAttributeValues[key] = value;

                        } else {

                            // Tuple attribute is not part of the grouped attributes

                            nonGroupedAttributeValues[key] = value;

                        }

                    });


                    // The groupedAttributeValues and nonGroupedAttributeValues are now built
                    //
                    // We started with a tuple like
                    // { attr1 : value, attr2 : value, attr3: value, attr4 : value}
                    //
                    // We grouped 'attr1' and 'attr2'
                    //
                    // And we simply divided the tuples into two objects, one containing the attribute values
                    // that are supposed to be grouped, and another that is not supposed to be grouped
                    //
                    // They should look somewhat like :
                    // groupedAttributeValues : { attr1 : value, attr2 : value, ... }
                    // nonGroupedAttributeValues : { attr3 : value, attr4 : value, ...}


                    // If two tuples have the same non grouped attribute values, what we will do
                    // is merge their nonGroupedAttributeValues into a "nested relation", meaning
                    // that we will have a relation that will contain relations.


                    // Let's loop through each tuple of the being-built relation
                    // and see if a tuple already exists with the same nonGroupedAttributeValues


                    var matchingTuple = null;

                    that.each(function(tuple){

                        var match = true;

                        _.forOwn(nonGroupedAttributeValues, function(value, key){

                            if(tuple.get(key) !== value){

                                match = false;
                                return false;

                            }

                        });

                        if(match){
                            matchingTuple = tuple;
                            return false;
                        }

                    });


                    if (matchingTuple === null){

                        // A tuple with the same non grouped attribute values has not been found.
                        // We will create it and create the nested relation too.

                        var newTuple = new Tuple(nonGroupedAttributeValues);


                        // This tuple should look like
                        // +----------------+----------------+
                        // | attr3 : <type> | attr4 : <type> |
                        // +================+================+
                        // | value          | value          |
                        // +----------------+----------------+


                        // Creating the relation

                        var newRelation = new Relation();


                        // Adding the grouped attributes to the new nested relation header

                        _.forOwn(groupedAttributes, function(attribute){

                            newRelation.header().add(attribute.clone());

                        });

                        // We will store the relation header in the root relation header attribute
                        // So that we will know what kind of relation this is without having to access
                        // the body

                        that.args.groupingAttribute.relationHeader = newRelation.header().clone();

                        // This relation should look like
                        // +----------------+----------------+
                        // | attr1 : <type> | attr2 : <type> |
                        // +================+================+


                        // Setting the relation in the tuple grouped attribute

                        newTuple.set(groupingAttributeName, newRelation);

                        // The tuple will now be
                        // +----------------+----------------+-------------------------------------+
                        // | attr3 : <type> | attr4 : <type> | groupedAttr : Relation              |
                        // +================+================+=====================================+
                        // | value          | value          | +----------------+----------------+ |
                        // |                |                | | attr1 : <type> | attr2 : <type> | |
                        // |                |                | +================+================+ |
                        // +----------------+----------------+-------------------------------------+



                        // Adding the tuple to the relation

                        that.add(newTuple, false);


                        // A matching tuple now exists because we just created it

                        matchingTuple = newTuple;

                    }

                    // We create the tuple that will be inserted in the nested relation

                    var nestedTuple = new Tuple(groupedAttributeValues);

                    // We add this tuple to the nested relation

                    matchingTuple.get(groupingAttributeName).add(nestedTuple, false);

                    // And voil!

                });


            });

            // Binds the base relation afterAdd event
            that.args.relation.ee.on('afterAdd', function(tuple, index){
                that.afterAdd(relation, tuple);
            });

            // Binds the base relation afterRemove event
            that.args.relation.ee.on('afterRemove', function(tuple, index){
                that.afterRemove(relation, tuple);
            });

            // Binds the base relation afterUpdate event
            that.args.relation.ee.on('afterUpdate', function(tuple, attributeName, value, oldValue){
                that.afterUpdate(relation, tuple, attributeName, value, oldValue);
            });

        },

        /**
         * Event handler when a tuple has been added to the base relation
         * @param {Relation} relation
         * @param {Tuple} tuple
         */
        afterAdd : function(relation, tuple){
            debug.group.trace('Group#afterAdd');
            var result = this.args.relation.group(this.args.groupingAttributeName, this.args.groupedAttributeNames);
            this.adjustTo(result);
        },

        /**
         * Event handler when a tuple has been removed from the base relation
         * @param {Relation} relation
         * @param {Tuple} tuple
         */
        afterRemove : function(relation, tuple){
            debug.group.trace('Group#afterRemove');
            var result = this.args.relation.group(this.args.groupingAttributeName, this.args.groupedAttributeNames);
            this.adjustTo(result);
        },

        /**
         * Event handler when a tuple has been updated from the base relation
         * @param {Relation} relation
         * @param {Tuple} tuple
         * @param {String} attributeName
         * @param {*} value
         * @param {*} oldValue
         */
        afterUpdate : function(relation, tuple, attributeName, value, oldValue){
            debug.group.trace('Group#afterUpdate');
            var result = this.args.relation.group(this.args.groupingAttributeName, this.args.groupedAttributeNames);
            this.adjustTo(result);
        }

    }, {

        type : 'Group'

    });

module.exports = Group;
},{"./../Attribute.js":2,"./../Header.js":6,"./../Relation.js":9,"./../Tuple.js":11,"./../helpers/debug":82,"lodash":103}],17:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');


var Intersection = Relation.extend(

    {

        /**
         * @class Operators.Intersection
         * @param {Relation} relationA
         * @param {Relation} relationB
         * @extends Relation
         *
         * The intersection creates a new relation with tuples common in relationA and relationB
         *
         *     var rel1 = new affinity.Relation([
         *           {a: { type: affinity.Integer}},
         *           {b: { type: affinity.Integer}},
         *           {c: { type: affinity.Integer}}
         *       ], [
         *           [1, 2, 3],
         *           [4, 5, 6],
         *           [7, 8, 9]
         *       ]);
         *
         *     var rel2 = new affinity.Relation([
         *          {a: { type: affinity.Integer}},
         *          {b: { type: affinity.Integer}},
         *          {c: { type: affinity.Integer}}
         *      ], [
         *          [1, 2, 3]
         *      ]);
         *
         *v    ar rel3 = new affinity.Intersection(rel1, rel2);
         *
         *     // +--------------+--------------+--------------+
         *     // | a : TInteger | b : TInteger | c : TInteger |
         *     // +==============+==============+==============+
         *     // | 1            | 2            | 3            |
         *     // +--------------+--------------+--------------+
         */

        constructor: function (relationA, relationB) {

            this.rels = [relationA, relationB];

            Relation.call(this);

        },

        bindEvents: function () {

            debug.intersection.trace('#bindEvents');

            Intersection.__super__.bindEvents.call(this);

            var that = this;

            var rel1 = that.rels[0],
                rel2 = that.rels[1];


            // BeforeGetHeader

            this.ee.once('beforeGetHeader', function () {

                var header1 = rel1.header();
                var header2 = rel2.header();

                debug.intersection.trace('beforeGetHeader');

                Header.assertUnionCompatible(header1, header2);

                that.header().copy(header1);

            });


            // BeforeGetBody

            this.ee.once('beforeGetBody', function () {

                debug.intersection.trace('beforeGetBody');

                rel1.each(function (tuple1) {

                    if (rel2.index(tuple1) !== null) {
                        that.add(tuple1.clone(), false);
                    }

                })

            });

        },

        afterLeftAdd : function(relation, tuple){

        },

        afterLeftRemove : function(relation, tuple){

        },

        afterLeftUpdate : function(relation, tuple, attributeName, value, oldValue){

        },

        afterRightAdd : function(relation, tuple){

        },

        afterRightRemove : function(relation, tuple){

        },

        afterRightUpdate : function(relation, tuple, attributeName, value, oldValue){

        }

    }, {

        type : 'Intersection'

    });

module.exports = Intersection;
},{"./../Header.js":6,"./../Relation.js":9,"./../helpers/debug":82,"lodash":103}],18:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var Tuple = require('./../Tuple.js');
var debug = require('./../helpers/debug');

var _ = require('lodash');



var Join = Relation.extend(

    {

        /**
         * @class Operators.Join
         * @param {Relation} relationA
         * @param {Relation} relationB
         * @extends Relation
         *
         * The Join operation returns all possible combinations of tuples from relationA and relationB where
         * the tuples have the same value for their common attributes.
         *
         *     var relationA = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {firstName: { type: affinity.String}},
         *              {lastName: { type: affinity.String}}
         *          ],[
         *              [1, 'John', 'Doe'],
         *              [2, 'Mary', 'Poppins'],
         *              [3, 'Lucky', 'Luke']
         *          ]);
         *
         *     var relationB = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {fan: { type: affinity.String}}
         *          ],[
         *              [1, 'Mr X'],
         *              [1, 'Miss Dibble'],
         *              [2, 'Nat Bibble']
         *          ]);
         *
         *     var relationC = relationA.join(relationB);
         *
         *     // or
         *
         *     var relationC = new affinity.Join(relationA, relationB)
         *
         *     // <---COMMON ATTRIBUTE---->
         *     // +------------------------+---------------------+--------------------+---------------+
         *     // | characterId : TInteger | firstName : TString | lastName : TString | fan : TString |
         *     // +========================+=====================+====================+===============+
         *     // | 1                      | John                | Doe                | Mr X          |
         *     // +------------------------+---------------------+--------------------+---------------+
         *     // | 2                      | John                | Doe                | Miss Dibble   |
         *     // +------------------------+---------------------+--------------------+---------------+
         *     // | 3                      | Mary                | Poppins            | Nat Bibble    |
         *     // +------------------------+---------------------+--------------------+---------------+
         *     //
         *
         */
        constructor: function (relationA, relationB) {

            this.rels = [relationA, relationB];
            this._commonAttributes = [];

            Relation.call(this);

            var that = this;

        },

        bindEvents: function () {

            debug.join.trace('#bindEvents');

            Join.__super__.bindEvents.call(this);

            var that = this;

            var rel1 = that.rels[0];
            var rel2 = that.rels[1];

            // BeforeGetHeader

            this.ee.once('beforeGetHeader', function () {

                debug.join.trace('beforeGetHeader');

                var header1 = rel1.header();
                var header2 = rel2.header();

                Header.assertSameNameSameType(header1, header2);

                that.commonAttributes = Header.commonAttributes(header1, header2);

                that.header().copy(header1);
                that.header().copy(header2);

            });


            // BeforeGetBody

            this.ee.once('beforeGetBody', function () {

                that.header();

                debug.join.trace('beforeGetBody');

                // Loop through each body of the first relation
                rel1.each(function (tuple1) {

                    // Loop through each tuples of the second relation
                    rel2.each(function (tuple2) {

                        var match = Tuple.matchOnAttributes(tuple1, tuple2, that.commonAttributes);

                        // If a match was detected
                        if (match) {

                            // Clone the first tuple
                            var newTuple = new Tuple();

                            // Copy the joined tuple attributes
                            newTuple.copy(tuple1);
                            newTuple.copy(tuple2);

                            // Then add it to the relation
                            that.add(newTuple, false);
                        }

                    }, that);

                }, that)

            });

            that.rels[0].ee.on('afterAdd', function(tuple, index){
                that.afterLeftAdd(that.rels[0], tuple, index);
            });

            that.rels[1].ee.on('afterAdd', function(tuple, index){
                that.afterRightAdd(that.rels[1], tuple, index);
            });

            that.rels[0].ee.on('afterRemove', function(tuple, index){
                that.afterLeftRemove(that.rels[0], tuple, index);
            });

            that.rels[1].ee.on('afterRemove', function(tuple, index){
                that.afterRightRemove(that.rels[0], tuple, index);
            });

            that.rels[0].ee.on('afterUpdate', function(tuple, attributeName, value, oldValue){
                that.afterLeftUpdate(that.rels[0], tuple, attributeName, value, oldValue);
            });

            that.rels[1].ee.on('afterUpdate', function(tuple, attributeName, value, oldValue){
                that.afterLeftUpdate(that.rels[0], tuple, attributeName, value, oldValue);
            });


        },

        afterLeftAdd : function(relation, tuple){
            debug.group.trace('Join#afterLeftAdd');
            var result = this.rels[0].join(this.rels[1]);
            this.adjustTo(result);
        },

        afterLeftRemove : function(relation, tuple){
            debug.group.trace('Join#afterLeftRemove');
            var result = this.rels[0].join(this.rels[1]);
            this.adjustTo(result);
        },

        afterLeftUpdate : function(relation, tuple, attributeName, value, oldValue){
            debug.group.trace('Join#afterLeftUpdate');
            var result = this.rels[0].join(this.rels[1]);
            this.adjustTo(result);
        },

        afterRightAdd : function(relation, tuple){
            debug.group.trace('Join#afterRightAdd');
            var result = this.rels[0].join(this.rels[1]);
            this.adjustTo(result);
        },

        afterRightRemove : function(relation, tuple){
            debug.group.trace('Join#afterRightRemove');
            var result = this.rels[0].join(this.rels[1]);
            this.adjustTo(result);
        },

        afterRightUpdate : function(relation, tuple, attributeName, value, oldValue){
            debug.group.trace('Join#afterRightUpdate');
            var result = this.rels[0].join(this.rels[1]);
            this.adjustTo(result);
        }

    }, {

        type : 'Join'

    });

module.exports = Join;
},{"./../Header.js":6,"./../Relation.js":9,"./../Tuple.js":11,"./../helpers/debug":82,"lodash":103}],19:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var Tuple = require('./../Tuple.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');



var Product = Relation.extend(

    {

        /**
         * @class Operators.Product
         * @param {Relation} relationA
         * @param {Relation} relationB
         * @extends Relation
         *
         * Example :
         *
         *     var relationA = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {firstName: { type: affinity.String}},
         *              {lastName: { type: affinity.String}}
         *          ],[
         *              [1, 'John', 'Doe'],
         *              [2, 'Mary', 'Poppins'],
         *              [3, 'Lucky', 'Luke']
         *          ]);
         *
         *     var relationB = new affinity.Relation([
         *              {product: { type: affinity.String}}
         *          ],[
         *              ['Doll'],
         *              ['PlayMobile'],
         *          ]);
         *
         *     var relationC = relationA.product(relationB);
         *
         *     // or
         *
         *     var relationC = new affinity.Product(relationA, relationB)
         *
         *     // +------------------------+---------------------+--------------------+-------------------+
         *     // | characterId : TInteger | firstName : TString | lastName : TString | product : TString |
         *     // +========================+=====================+====================+===================+
         *     // | 1                      | John                | Doe                | Doll              |
         *     // +------------------------+---------------------+--------------------+-------------------+
         *     // | 2                      | John                | Doe                | PlayMobile        |
         *     // +------------------------+---------------------+--------------------+-------------------+
         *     // | 1                      | Mary                | Poppins            | Doll              |
         *     // +------------------------+---------------------+--------------------+-------------------+
         *     // | 2                      | Mary                | Poppins            | PlayMobile        |
         *     // +------------------------+---------------------+--------------------+-------------------+
         *     // | 1                      | Lucky               | Luke               | Doll              |
         *     // +------------------------+---------------------+--------------------+-------------------+
         *     // | 2                      | Lucky               | Luke               | PlayMobile        |
         *     // +------------------------+---------------------+--------------------+-------------------+
         *     //
         *
         */
        constructor: function (relationA, relationB) {

            debug.product.trace('#constructor');

            this.rels = [relationA, relationB];

            Relation.call(this);

        },

        bindEvents: function () {

            debug.product.trace('#bindEvents');

            Product.__super__.bindEvents.call(this);

            var that = this;

            var rel1 = this.rels[0];
            var rel2 = this.rels[1];

            // BeforeGetHeader

            that.ee.once('beforeGetHeader', function () {

                debug.product.trace('beforeGetHeader');

                var header1 = rel1.header();
                var header2 = rel2.header();

                // Check that the two relations have disjoint headers
                Header.assertDisjoint(header1, header2);

                that.header().copy(header1.setUnion(header2));

            });


            // BeforeGetBody

            that.ee.once('beforeGetBody', function () {

                debug.product.trace('beforeGetBody');

                var tupleSet = rel1.setProduct(rel2);

                tupleSet.each(function (tuplePair) {

                    var newTuple = new Tuple();

                    newTuple.copy(tuplePair.get('0'));
                    newTuple.copy(tuplePair.get('1'));

                    that.add(newTuple, false);

                }, that);

            });

        },

        afterLeftAdd : function(relation, tuple){

        },

        afterLeftRemove : function(relation, tuple){

        },

        afterLeftUpdate : function(relation, tuple, attributeName, value, oldValue){

        },

        afterRightAdd : function(relation, tuple){

        },

        afterRightRemove : function(relation, tuple){

        },

        afterRightUpdate : function(relation, tuple, attributeName, value, oldValue){

        }

    }, {

        type : 'Product'

    });

module.exports = Product;
},{"./../Header.js":6,"./../Relation.js":9,"./../Tuple.js":11,"./../helpers/debug":82,"lodash":103}],20:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var Tuple = require('./../Tuple.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');



var Projection = Relation.extend(

    {

        /**
         * @class Operators.Projection
         * @param {Relation} relation
         * @param {String[]} args
         * @extends Relation
         *
         * Example :
         *
         *     var relationA = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {firstName: { type: affinity.String}},
         *              {lastName: { type: affinity.String}}
         *          ],[
         *              [1, 'John', 'Doe'],
         *              [2, 'Mary', 'Poppins'],
         *              [3, 'Lucky', 'Luke']
         *          ]);
         *
         *     // +------------------------+---------------------+--------------------+
         *     // | characterId : TInteger | firstName : TString | lastName : TString |
         *     // +========================+=====================+====================+
         *     // | 1                      | John                | Doe                |
         *     // +------------------------+---------------------+--------------------+
         *     // | 2                      | Mary                | Poppins            |
         *     // +------------------------+---------------------+--------------------+
         *     // | 3                      | Lucky               | Luke               |
         *     // +------------------------+---------------------+--------------------+
         *
         *     var relationB = relationA.project(['firstName']);
         *
         *     // or
         *
         *     var relationC = new affinity.Projection(relationA, ['firstName']);
         *
         *     // +---------------------+
         *     // | firstName : TString |
         *     // +=====================+
         *     // | John                |
         *     // +---------------------+
         *     // | Mary                |
         *     // +---------------------+
         *     // | Lucky               |
         *     // +---------------------+
         *
         */
        constructor: function (relation, args) {

            this.rel = relation;
            this.args = args;

            Relation.call(this);

        },

        bindEvents: function () {

            debug.projection.trace('#bindEvents');

            Projection.__super__.bindEvents.call(this);

            var that = this;

            var relation = this.rel;

            that.ee.once('beforeGetBody', function () {

                debug.projection.trace('beforeGetBody');

                relation.each(function (tuple) {

                    var newTuple = new Tuple();

                    newTuple.copy(tuple, that.args);

                    that.add(newTuple);

                }, that)

            });

            that.ee.once('beforeGetHeader', function () {

                debug.projection.trace('beforeGetHeader');

                that.header().copy(relation.header().project(that.args))

            });

            // Binds the base relation afterAdd event
            relation.ee.on('afterAdd', function(tuple, index){
                that.afterAdd(relation, tuple);
            });

            // Binds the base relation afterRemove event
            relation.ee.on('afterRemove', function(tuple, index){
                that.afterRemove(relation, tuple);
            });

            // Binds the base relation afterUpdate event
            relation.ee.on('afterUpdate', function(tuple, attributeName, value, oldValue){
                that.afterUpdate(relation, tuple, attributeName, value, oldValue);
            });

        },

        afterAdd : function(relation, tuple){
            var result = relation.project(this.args);
            debug.group.trace('Projection#afterAdd');
            this.adjustTo(result);
        },

        afterRemove : function(relation, tuple){
            var result = relation.project(this.args);
            debug.group.trace('Projection#afterRemove');
            this.adjustTo(result);
        },

        afterUpdate : function(relation, tuple, attributeName, value, oldValue){
            var result = relation.project(this.args);
            debug.group.trace('Projection#afterUpdate');
            this.adjustTo(result);
        }

    }, {

        type : 'Projection'

    });

module.exports = Projection;
},{"./../Header.js":6,"./../Relation.js":9,"./../Tuple.js":11,"./../helpers/debug":82,"lodash":103}],21:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Tuple = require('./../Tuple.js');
var Set = require('./../Set.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');



var Rename = Relation.extend(

    {

        /**
         * @class Operators.Rename
         * @param {Relation} relation
         * @param {Object} args
         * @extends Relation
         *
         * Example :
         *
         *     var relationA = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {firstName: { type: affinity.String}},
         *              {lastName: { type: affinity.String}}
         *          ],[
         *              [1, 'John', 'Doe'],
         *              [2, 'Mary', 'Poppins'],
         *              [3, 'Lucky', 'Luke']
         *          ]);
         *
         *     var relationB = relationA.rename({'firstName':'familyName'})
         *
         *     // or
         *
         *     var relationC = new affinity.Projection(relationA, {'lastName':'familyName'});
         *
         *     //                                                <--RENAMED ATTRIBUTE--->
         *     // +------------------------+---------------------+----------------------+
         *     // | characterId : TInteger | firstName : TString | familyName : TString |
         *     // +========================+=====================+======================+
         *     // | 1                      | John                | Doe                  |
         *     // +------------------------+---------------------+----------------------+
         *     // | 2                      | Mary                | Poppins              |
         *     // +------------------------+---------------------+----------------------+
         *     // | 3                      | Lucky               | Luke                 |
         *     // +------------------------+---------------------+----------------------+
         */
        constructor: function (relation, args) {

            this.relation = relation;
            this.args = args;

            Relation.call(this);

        },

        bindEvents: function () {

            debug.rename.trace('#bindEvents');

            Rename.__super__.bindEvents.call(this);

            var that = this;

            that.ee.once('beforeGetBody', function () {

                debug.rename.trace('beforeGetBody');

                //var a, b, tupleCount, tuple, tuples, keys, keyCount, key, newName;

                //that._body = new Set({type: Tuple});

                //tuples = that.relation.body();
                //tupleCount = tuples.length;
                //keys = Object.keys(that.args);
                //keyCount = keys.length;

                that.relation.each(function(tuple){

                    var newTuple = tuple.clone();

                    _.forIn(that.args, function(value, key){

                        if(value !== key){
                            newTuple.set(value, newTuple.get(key));
                            delete newTuple.attributes[key];
                        }

                    });

                    that.add(newTuple, false);

                });

            });

            that.ee.once('beforeGetHeader', function () {

                debug.rename.trace('beforeGetHeader');

                that.header().copy(that.relation.header().rename(that.args));

            });

        },

        afterAdd : function(relation, tuple){
            var result = this.relation.rename(this.args);
            this.adjustTo(result);
        },

        afterRemove : function(relation, tuple){
            var result = this.relation.rename(this.args);
            this.adjustTo(result);
        },

        afterUpdate : function(relation, tuple, attributeName, value, oldValue){
            var result = this.relation.rename(this.args);
            this.adjustTo(result);
        }

    }, {



    }, {

        type : 'Rename'

    });

module.exports = Rename;
},{"./../Relation.js":9,"./../Set.js":10,"./../Tuple.js":11,"./../helpers/debug":82,"lodash":103}],22:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');
var Function = require('./../Function.js');



var Restriction = Relation.extend(

    {

        /**
         * @class Operators.Restriction
         * @param {Relation} relation
         * @param {Function} predicate
         * @extends Relation
         *
         * Example :
         *
         *     var relationA = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {firstName: { type: affinity.String}},
         *              {lastName: { type: affinity.String}}
         *          ],[
         *              [1, 'John', 'Doe'],
         *              [2, 'Mary', 'Poppins'],
         *              [3, 'Lucky', 'Luke']
         *          ]);
         *
         *     var characterId = relationA.get('characterId')
         *     var firstName = relationA.get('firstName')
         *     var lastName = relationA.get('lastName')
         *
         *
         *
         *     var relationC = relationA.restrict(characterId.equals(1))
         *
         *     // or
         *
         *     var relationC = new affinity.Projection(relationA, characterId.equals(1));
         *
         *     // +------------------------+---------------------+--------------------+
         *     // | characterId : TInteger | firstName : TString | lastName : TString |
         *     // +========================+=====================+====================+
         *     // | 1                      | John                | Doe                |
         *     // +------------------------+---------------------+--------------------+
         *
         */
        constructor: function (relation, predicate) {

            this.rel = relation;
            this.predicate = predicate;
            Relation.call(this);

        },

        bindEvents: function () {

            debug.restriction.trace('#bindEvents');

            Restriction.__super__.bindEvents.call(this);

            var that = this;


            that.ee.once('beforeGetHeader', function () {

                debug.restriction.trace('beforeGetHeader');

                that.header().copy(that.rel.header());

            });


            that.ee.once('beforeGetBody', function () {

                that.rel.each( function (tuple) { that.afterAdd(tuple); })

            });

            that.rel.ee.on('afterAdd', function(tuple){
                that.afterAdd(tuple);
            })

        },

        afterAdd : function(tuple){

            debug.restriction.trace('afterAdd');

            var that = this;

            that.header();

            if(that.predicate instanceof Function){

                that.predicate.convertAttributeToTuple();

                if (that.predicate.assignTuple(tuple).value() === true) {
                    that.add(tuple.clone(), false);
                }

            } else if (_.isFunction(that.predicate)) {

                if(that.predicate(tuple)){
                    that.add(tuple.clone(), false);
                }

            } else {
                throw new TypeError('Unsupported predicate type')
            }

        },

        afterRemove : function(relation, tuple){
            var result = this.relation.restrict(this.predicate);
            this.adjustTo(result);
        },

        afterUpdate : function(relation, tuple, attributeName, value, oldValue){
            var result = this.relation.restrict(this.predicate);
            this.adjustTo(result);
        }

    }, {

        type : 'Restriction'

    });

module.exports = Restriction;
},{"./../Function.js":5,"./../Header.js":6,"./../Relation.js":9,"./../helpers/debug":82,"lodash":103}],23:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var Tuple = require('./../Tuple.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');
var equal = require('./../helpers/equal');



var SemiDifference = Relation.extend(

    {

        /**
         * @class Operators.SemiDifference
         * @extends Relation
         * @param {Relation} relationA The relation from which to seek tuples with no counterpart
         * @param {Relation} relationB The relation containing the counterparts
         *
         * The SemiDifference will find all tuples in A that do not have a counterpart in B on their common attributes
         *
         *     // Find the characters that do not have fans
         *
         *     var relationA = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {firstName: { type: affinity.String}},
         *              {lastName: { type: affinity.String}}
         *          ],[
         *              [1, 'John', 'Doe'],
         *              [2, 'Mary', 'Poppins'],
         *              [3, 'Lucky', 'Luke']
         *          ]);
         *
         *     var relationB = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {fan: { type: affinity.String}}
         *          ],[
         *              [1, 'Mr X'],
         *              [1, 'Miss Dibble'],
         *              [2, 'Nat Bibble']
         *          ]);
         *
         *     var relationC = relationA.sdifference(relationB);
         *
         *     // or
         *
         *     var relationC = new affinity.SemiDifference(relationA, relationB)
         *
         *     // +------------------------+---------------------+--------------------+
         *     // | characterId : TInteger | firstName : TString | lastName : TString |
         *     // +========================+=====================+====================+
         *     // | 3                      | Lucky               | Luke               |
         *     // +------------------------+---------------------+--------------------+
         *     //
         *     // Lucky Luke is the only character without a fan
         *
         */
        constructor: function (relationA, relationB) {

            debug.semiDifference.trace('#constructor');

            this.rels = [relationA, relationB];

            Relation.call(this);

        },

        bindEvents: function () {

            debug.semiDifference.trace('#bindEvents');

            // Calling the parent bindEvents
            SemiDifference.__super__.bindEvents.call(this);

            var that = this;

            // BeforeGetHeader
            this.ee.once('beforeGetHeader', function () {

                debug.semiDifference.trace('beforeGetHeader');

                Header.assertSameNameSameType(that.rels[0].header(), that.rels[1].header());

                that.commonAttributes = that.rels[0].header().setIntersection(that.rels[1].header());

                that.header().copy(that.rels[0].header());

            });


            // BeforeGetBody
            this.ee.once('beforeGetBody', function () {

                that.header();

                debug.semiDifference.trace('beforeGetBody');

                var rel1 = that.rels[0];
                var rel2 = that.rels[1];

                rel1.each(function(tuple1){

                    var counterpart = false;

                    if(that.commonAttributes.length() > 0){

                        rel2.each(function(tuple2){

                            // Check if tuple1 has same common attributes as tuple2

                            var match = Tuple.matchOnAttributes(tuple1, tuple2, that.commonAttributes);

                            if(match){
                                counterpart = true;
                                return false;
                            }

                        });

                    }

                    if(!counterpart){
                        that.add(tuple1.clone(), false);
                    }

                })

            });

        },

        afterLeftAdd : function(relation, tuple){

        },

        afterLeftRemove : function(relation, tuple){

        },

        afterLeftUpdate : function(relation, tuple, attributeName, value, oldValue){

        },

        afterRightAdd : function(relation, tuple){

        },

        afterRightRemove : function(relation, tuple){

        },

        afterRightUpdate : function(relation, tuple, attributeName, value, oldValue){

        }

    }, {

        type : 'SemiDifference'

    });

module.exports = SemiDifference;
},{"./../Header.js":6,"./../Relation.js":9,"./../Tuple.js":11,"./../helpers/debug":82,"./../helpers/equal":83,"lodash":103}],24:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var Tuple = require('./../Tuple.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');
var equal = require('./../helpers/equal');



var SemiJoin = Relation.extend(

    {

        /**
         * @class Operators.SemiJoin
         * @extends Relation
         * @param {Relation} relationA The relation from which to seek tuples with their counterparts in B
         * @param {Relation} relationB The relation containing the counterparts
         *
         * The SemiJoin will find all tuples in A that have a counterpart in B on their common attributes
         *
         *     // Find the characters that have fans
         *
         *     var relationA = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {firstName: { type: affinity.String}},
         *              {lastName: { type: affinity.String}}
         *          ],[
         *              [1, 'John', 'Doe'],
         *              [2, 'Mary', 'Poppins'],
         *              [3, 'Lucky', 'Luke']
         *          ]);
         *
         *     var relationB = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {fan: { type: affinity.String}}
         *          ],[
         *              [1, 'Mr X'],
         *              [1, 'Miss Dibble'],
         *              [2, 'Nat Bibble']
         *          ]);
         *
         *     var relationC = relationA.sjoin(relationB);
         *
         *     // or
         *
         *     var relationC = new affinity.SemiJoin(relationA, relationB)
         *
         *     // +------------------------+---------------------+--------------------+
         *     // | characterId : TInteger | firstName : TString | lastName : TString |
         *     // +========================+=====================+====================+
         *     // | 1                      | John                | Doe                |
         *     // +------------------------+---------------------+--------------------+
         *     // | 2                      | Mary                | Poppins            |
         *     // +------------------------+---------------------+--------------------+
         *     //
         *     // John Doe and Mary Poppins have fans
         */
        constructor: function (relationA, relationB) {

            debug.semiJoin.trace('#constructor');

            this.rels = [relationA, relationB];

            Relation.call(this);

        },

        bindEvents: function () {

            debug.semiJoin.trace('#bindEvents');

            // Calling the parent bindEvents
            SemiJoin.__super__.bindEvents.call(this);

            var that = this;

            // BeforeGetHeader
            this.ee.once('beforeGetHeader', function () {

                debug.semiJoin.trace('beforeGetHeader');

                Header.assertSameNameSameType(that.rels[0].header(), that.rels[1].header());

                that.commonAttributes = that.rels[0].header().setIntersection(that.rels[1].header());

                that.header().copy(that.rels[0].header());

            });


            // BeforeGetBody
            this.ee.once('beforeGetBody', function () {

                debug.semiJoin.trace('beforeGetBody');

                var relation1 = that.rels[0];
                var relation2 = that.rels[1];

                relation1.each(function(tuple1){

                    var counterpart = false;

                    if (that.commonAttributes.length() > 0){

                        relation2.each(function(tuple2){

                            var match = Tuple.matchOnAttributes(tuple1, tuple2, that.commonAttributes);

                            if(match){
                                counterpart = true;
                                return false;
                            }

                        });

                    }

                    if(counterpart){
                        that.add(tuple1.clone(), false);
                    }

                })

            });

        },

        afterLeftAdd : function(relation, tuple){

        },

        afterLeftRemove : function(relation, tuple){

        },

        afterLeftUpdate : function(relation, tuple, attributeName, value, oldValue){

        },

        afterRightAdd : function(relation, tuple){

        },

        afterRightRemove : function(relation, tuple){

        },

        afterRightUpdate : function(relation, tuple, attributeName, value, oldValue){

        }

    }, {

        type : 'SemiJoin'

    });

module.exports = SemiJoin;
},{"./../Header.js":6,"./../Relation.js":9,"./../Tuple.js":11,"./../helpers/debug":82,"./../helpers/equal":83,"lodash":103}],25:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var Tuple = require('./../Tuple.js');
var Attribute = require('./../Attribute.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');

var Summarize = Relation.extend({

    /**
     * @class Operators.Summarize
     * @extends Relation
     *
     * The Summarize operation will be the projection result of given relation attributes
     * while extending this resulting relation with calculated attributes.
     *
     * Example :
     *
     *     var relation = new affinity.Relation([
     *         { id : {type : affinity.Integer} },
     *         { name : {type : affinity.String} },
     *         { age : {type : affinity.Integer} },
     *     ],[
     *         [1, 'John Doe', 23],
     *         [2, 'John Doe', 35],
     *         [3, 'John Doe', 27],
     *         [4, 'Bo Derek', 12],
     *         [5, 'Bo Derek', 7],
     *         [6, 'Marilyn Monroe', 16],
     *     ]);
     *
     *     var age = relation.get('age');
     *
     *     var summarized = relation.summarize(
     *         ['name'],
     *         [
     *             { "age.avg()" : age.avg()        },
     *             { "age.sum()" : age.sum()        },
     *             { "count()"   : affinity.count() }
     *         ]
     *     );
     *
     *     summarized.print();
     *
     *     // +------------------+----------------------+---------------------+---------------------+
     *     // | name : String    | age.avg() : Float    | age.sum() : Float   | count() : Integer   |
     *     // +==================+======================+=====================+=====================+
     *     // | John Doe         | 28.333333333333332   | 85                  | 3                   |
     *     // +------------------+----------------------+---------------------+---------------------+
     *     // | Bo Derek         | 9.5                  | 19                  | 2                   |
     *     // +------------------+----------------------+---------------------+---------------------+
     *     // | Marilyn Monroe   | 16                   | 16                  | 1                   |
     *     // +------------------+----------------------+---------------------+---------------------+
     */

    /**
     * Create a new Summary relation
     * @param {Relation} relation The relation to summarize
     * @param {Attribute[]|String[]} attributes The attributes to keep
     * @param {Object[]} summaries The summary expressions
     */
    constructor : function(relation, attributes, summaries){

        this.args = {};

        this.args.relation = relation;

        this.args.attributes = attributes;

        this.args.summaries = summaries;

        Relation.call(this);

    },

    bindEvents : function(){

        debug.semiJoin.trace('#bindEvents');

        // Calling the parent bindEvents
        Summarize.__super__.bindEvents.call(this);

        var that = this;

        that.ee.once('beforeGetHeader', function(){

            var relation = that.args.relation;

            var header = relation.header();

            var attributes = that.args.attributes;

            var summaries = that.args.summaries;

            // Check that the given attributes exist in the
            // base header.
            Header.assertAttributesExist(header, attributes);

            // Copy the given attributes from the base header
            that.header().copy(relation.header(), attributes);

            // Add the summaries attributes
            _.forEach(summaries, function(summary){

                var summaryName = Object.keys(summary)[0];

                var summaryExpression = summary[summaryName];

                var summaryType = summaryExpression.type();

                var newAttribute = new Attribute({name : summaryName, type : summaryType});

                that.header().add(newAttribute);

            });

        });

        that.ee.once('beforeGetBody', function(){

            var relation = that.args.relation;

            var header = relation.header();

            var attributes = that.args.attributes;

            var summaries = that.args.summaries;

            var instanceAttributes = new Header();

            instanceAttributes.copy(header, attributes);

            // These are the attributes that will be grouped
            var otherAttributes = header.setDifference(instanceAttributes);

            var otherAttributeNames = [];

            otherAttributes.each(function(otherAttribute){
                otherAttributeNames.push(otherAttribute.name);
            });

            // Create an intermediary group relation
            var grouped = relation.group('___grouped___', otherAttributeNames);

            grouped.each(function(groupedTuple){

                // Create the tuple that will be inserted
                var newTuple = new Tuple();

                // Copy the non-grouped attributes into the new tuple
                newTuple.copy(groupedTuple, attributes);

                // Get the grouped relation
                var groupedRelation = groupedTuple.get('___grouped___');

                _.forEach(summaries, function(summary){

                    var summaryName = Object.keys(summary)[0];

                    var summaryExpression = summary[summaryName];

                    summaryExpression.relation = groupedRelation;

                    var summaryValue = summaryExpression.value();

                    newTuple.set(summaryName, summaryValue);

                });

                that.add(newTuple);

            });

        })

    },

    afterAdd : function(relation, tuple){

    },

    afterRemove : function(relation, tuple){

    },

    afterUpdate : function(relation, tuple, attributeName, value, oldValue){

    }

}, {

    type : 'Summarize'

});


module.exports = Summarize;
},{"./../Attribute.js":2,"./../Header.js":6,"./../Relation.js":9,"./../Tuple.js":11,"./../helpers/debug":82,"lodash":103}],26:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var Tuple = require('./../Tuple.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');



var Ungroup = Relation.extend(
    {

        /**
         * @class Operators.Ungroup
         * @extends Relation
         * @param {Relation} relation The relation to ungroup
         * @param {String[]} groupedAttributes The grouped attribute names to ungroup
         *
         * The Ungroup operation will ungroup the specified grouped attributes.
         *
         *     var relationA = new affinity.Relation([
         *              {a: { type: affinity.Integer}},
         *              {b: { type: affinity.Integer}},
         *              {c: { type: affinity.Integer}}
         *          ],[
         *              [1, 2, 3],
         *              [4, 5, 6],
         *              [4, 9, 9],
         *              [7, 8, 9]
         *          ]);
         *
         *     var relationB = relationA.group('groupedAttribute', ['b', 'c'])
         *
         *     // +--------------+---------------------------------+
         *     // | a : TInteger | groupedAttribute : Relation     |
         *     // +==============+=================================+
         *     // | 1            | +--------------+--------------+ |
         *     // |              | | b : TInteger | c : TInteger | |
         *     // |              | +==============+==============+ |
         *     // |              | | 2            | 3            | |
         *     // |              | +--------------+--------------+ |
         *     // +--------------+---------------------------------+
         *     // | 4            | +--------------+--------------+ |
         *     // |              | | b : TInteger | c : TInteger | |
         *     // |              | +==============+==============+ |
         *     // |              | | 5            | 6            | |
         *     // |              | +--------------+--------------+ |
         *     // |              | | 9            | 9            | |
         *     // |              | +--------------+--------------+ |
         *     // +--------------+---------------------------------+
         *     // | 7            | +--------------+--------------+ |
         *     // |              | | b : TInteger | c : TInteger | |
         *     // |              | +==============+==============+ |
         *     // |              | | 8            | 9            | |
         *     // |              | +--------------+--------------+ |
         *     // +--------------+---------------------------------+
         *
         *     var relationC = relationB.ungroup(['groupedAttribute']);
         *
         *     //                 <----UNGROUPED ATTRIBUTES---->
         *     // +--------------+--------------+--------------+
         *     // | a : TInteger | b : TInteger | c : TInteger |
         *     // +==============+==============+==============+
         *     // | 1            | 2            | 3            |
         *     // +--------------+--------------+--------------+
         *     // | 4            | 5            | 6            |
         *     // +--------------+--------------+--------------+
         *     // | 4            | 9            | 9            |
         *     // +--------------+--------------+--------------+
         *     // | 7            | 8            | 9            |
         *     // +--------------+--------------+--------------+
         *
         *     relationC.equal(relationA) // true
         */
        constructor: function (relation, groupedAttributes) {

            debug.ungroup.trace('#constructor');

            this.relation = relation;
            this.groupedAttributeNames = groupedAttributes;

            Relation.call(this);

        },

        bindEvents: function () {

            debug.ungroup.trace('#bindEvents');

            // Calling the parent bindEvents
            Ungroup.__super__.bindEvents.call(this);

            var that = this;

            // BeforeGetHeader
            this.ee.once('beforeGetHeader', function () {

                debug.ungroup.trace('beforeGetHeader');

                // Let's "flatten" the headers. We will add the nested relation header attributes
                // to this relation

                _.forEach(that.groupedAttributeNames, function(groupedAttributeName){

                    // A RVA (relation-valued attribute) stores a copy of the header of it's nested relations
                    // in the attribute.relationHeader property.
                    var relationHeader = that.relation.header().get(groupedAttributeName).relationHeader;

                    that.header().copy(relationHeader);

                });

                // Let's add all the other non-grouped attributes to the header

                that.relation.header().each(function(attribute){

                    var grouped = _.any(that.groupedAttributeNames, function(groupedAttributeName){

                        return groupedAttributeName === attribute.name;

                    });

                    if(!grouped){

                        that.header().add(attribute.clone());

                    }

                });

            });

            // BeforeGetBody
            this.ee.once('beforeGetBody', function () {

                debug.ungroup.trace('beforeGetBody');

                that.relation.each(function(tuple){

                    _.forEach(that.groupedAttributeNames, function(groupedAttributeName){

                        tuple.get(groupedAttributeName).each(function(nestedTuple){

                            var newTuple = new Tuple();

                            // Copy the non grouped attributes from the root tuple
                            newTuple.copy(tuple, that.groupedAttributeNames, true);

                            // Copy the attributes from the nested tuple

                            newTuple.copy(nestedTuple);

                            that.add(newTuple, false);

                        })

                    })

                })

            });

        },

        afterAdd : function(relation, tuple){
            var result = this.relation.ungroup(this.groupedAttributeNames);
            this.adjustTo(result);
        },

        afterRemove : function(relation, tuple){
            var result = this.relation.ungroup(this.groupedAttributeNames);
            this.adjustTo(result);
        },

        afterUpdate : function(relation, tuple, attributeName, value, oldValue){
            var result = this.relation.ungroup(this.groupedAttributeNames);
            this.adjustTo(result);
        }

    }, {

        type : 'Ungroup'

    });

module.exports = Ungroup;
},{"./../Header.js":6,"./../Relation.js":9,"./../Tuple.js":11,"./../helpers/debug":82,"lodash":103}],27:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');



var Union = Relation.extend(

    {

        /**
         * @class Operators.Union
         * @param {Relation} relationA
         * @param {Relation} relationB
         * @extends Relation
         *
         * Example :
         *
         *     var relationA = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {firstName: { type: affinity.String}},
         *              {lastName: { type: affinity.String}}
         *          ],[
         *              [1, 'John', 'Doe'],
         *              [2, 'Mary', 'Poppins'],
         *              [3, 'Lucky', 'Luke']
         *          ]);
         *
         *
         *     var relationB = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {firstName: { type: affinity.String}},
         *              {lastName: { type: affinity.String}}
         *          ],[
         *              [1, 'Mr', 'X'],
         *              [2, 'Lady', 'Gaga'],
         *              [3, 'Bo', 'Vril']
         *          ]);
         *
         *     var relationC = relationA.union(relationB)
         *
         *     // or
         *
         *     var relationC = new affinity.Union(relationA, relationB);
         *
         *     // +------------------------+---------------------+--------------------+
         *     // | characterId : TInteger | firstName : TString | lastName : TString |
         *     // +========================+=====================+====================+   -
         *     // | 1                      | John                | Doe                |    |
         *     // +------------------------+---------------------+--------------------+    |
         *     // | 2                      | Mary                | Poppins            |    | RelationA
         *     // +------------------------+---------------------+--------------------+    |
         *     // | 3                      | Lucky               | Luke               |    |
         *     // +------------------------+---------------------+--------------------+   -
         *     // | 1                      | Mr                  | X                  |    |
         *     // +------------------------+---------------------+--------------------+    |
         *     // | 2                      | Lady                | Gaga               |    | RelationB
         *     // +------------------------+---------------------+--------------------+    |
         *     // | 3                      | Bo                  | Vril               |    |
         *     // +------------------------+---------------------+--------------------+   -
         *
         */
        constructor: function (relationA, relationB) {
            this.rels = [relationA, relationB];
            Relation.call(this);
        },

        bindEvents: function () {

            debug.union.trace('#bindEvents');

            Union.__super__.bindEvents.call(this);

            var that = this;

            that.ee.once('beforeGetBody', function () {

                debug.union.trace('beforeGetBody');

                _.forEach(that.rels, function (relation) {

                    relation.each(function(tuple){

                        that.add(tuple.clone());

                    });

                }, that)

            });

            that.ee.once('beforeGetHeader', function () {

                debug.union.trace('beforeGetHeader');

                Header.assertUnionCompatible(that.rels[0].header(), that.rels[1].header());

                that.header().copy(that.rels[0].header());

            });

        },

        afterLeftAdd : function(relation, tuple){

        },

        afterLeftRemove : function(relation, tuple){

        },

        afterLeftUpdate : function(relation, tuple, attributeName, value, oldValue){

        },

        afterRightAdd : function(relation, tuple){

        },

        afterRightRemove : function(relation, tuple){

        },

        afterRightUpdate : function(relation, tuple, attributeName, value, oldValue){

        }

    }, {

        type : 'Union'

    });

module.exports = Union;
},{"./../Header.js":6,"./../Relation.js":9,"./../helpers/debug":82,"lodash":103}],28:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var Tuple = require('./../Tuple.js');
var Set = require('./../Set.js');
var Attribute = require('./../Attribute.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');



var Unwrap = Relation.extend(

    {

        /**
         * @class Operators.Unwrap
         * @extends Relation
         * @param {Relation} relation The relation to Unwrap
         * @param {String[]|String|Set|Header} attributeNames The name of the wrapped attributes to unwrap
         *
         * The Unwrap operator will reverse the {@link Operators.Wrap} operation, converting a tuple-valued attribute into
         * the attributes of the tuples.
         *
         *     var relationA = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {firstName: { type: affinity.String}},
         *              {lastName: { type: affinity.String}}
         *          ],[
         *              [1, 'John', 'Doe'],
         *              [2, 'Mary', 'Poppins'],
         *              [3, 'Lucky', 'Luke']
         *          ]);
         *
         *     var relationB = relationA.Unwrap('UnwrappedAttribute', ['firstName','lastName']);
         *
         *
         *     // +-------------------------------------------------------------------------+
         *     // | characterId : TInteger | unwrappedAttribute : Tuple                     |
         *     // +========================+================================================+
         *     // | 1                      | Tuple{firstName : 'John', lastName : 'Doe'}    |
         *     // +-------------------------------------------------------------------------+
         *     // | 2                      | Tuple{firstName : 'Mary', lastName : 'Poppins'}|
         *     // +-------------------------------------------------------------------------+
         *     // | 3                      | Tuple{firstName : 'Lucky', lastName : 'Luke'}  |
         *     // +-------------------------------------------------------------------------+
         *     //
         *
         *     var relationC = relationB.unwrap('unwrappedAttribute');
         *
         *     // or
         *
         *     var relationC = new affinity.Unwrap(relationB, 'unwrappedAttribute');
         *
         *
         *     //                          <-------UNWRAPPED ATTRIBUTES--------------->
         *     // +------------------------+---------------------+--------------------+
         *     // | characterId : TInteger | firstName : TString | lastName : TString |
         *     // +========================+=====================+====================+
         *     // | 1                      | John                | Doe                |
         *     // +------------------------+---------------------+--------------------+
         *     // | 2                      | Mary                | Poppins            |
         *     // +------------------------+---------------------+--------------------+
         *     // | 3                      | Lucky               | Luke               |
         *     // +------------------------+---------------------+--------------------+
         *
         */
        constructor: function (relation, attributeNames) {

            debug.unwrap.trace('#constructor');

            // Check if the relation argument is of good type
            if(!(relation instanceof Relation)){
                throw new TypeError('Specified relation is of wrong type');
            }

            // If the attributeNames is a string, coerce it to an array
            if(_.isString(attributeNames)){
                attributeNames = [attributeNames];
            }

            // If the attributeNames is not an array or set, throw an error
            if(!_.isArray(attributeNames) && !(attributeNames instanceof Set)){
                throw new Error('Unsupported type of specified attributeNames to unwrap');
            }

            if(_.isArray(attributeNames) && attributeNames.length <= 0){
                throw new Error('You must specify attributes to unwrap!');
            }

            if((attributeNames instanceof Set) && attributeNames.length() <= 0){
                throw new Error('You must specify attributes to unwrap!');
            }

            this.attributeNames = attributeNames;
            this.relation = relation;

            Relation.call(this);

        },

        bindEvents: function () {

            debug.unwrap.trace('#bindEvents');

            // Calling the parent bindEvents
            Unwrap.__super__.bindEvents.call(this);

            var relation = this.relation;

            var that = this;

            // BeforeGetHeader
            this.ee.once('beforeGetHeader', function () {

                debug.unwrap.trace('beforeGetHeader');

                // Copy all attributes from the base header that will not be unwrapped
                that.header().copy(relation.header(), that.attributeNames, true);

                // Get all attributes that were wrapped in the base relation
                var alreadyWrappedAttributes = new Header();
                relation.header().each(function(attribute){
                    if(attribute.wrappedAttributes){
                        alreadyWrappedAttributes.add(attribute.clone());
                    }
                });

                // Get the attributes which will be unwrapped
                var unwrappedAttributes = new Header();
                unwrappedAttributes.copy(relation.header(), that.attributeNames);
                that.unwrappedAttributes = unwrappedAttributes;

                // Get the attributes which will not be unwrapped
                var nonUnwrappedAttributes = new Header();
                nonUnwrappedAttributes.copy(relation.header(), that.attributeNames, true);
                that.nonUnwrappedAttributes = nonUnwrappedAttributes;

                // Check that the attributes to be unwrapped are wrapped. We would not want
                // to unwrap non-wrapped attributes!
                if(!unwrappedAttributes.isSubset(alreadyWrappedAttributes)){
                    throw new Error('Specified attributes are not all wrapped attributes. Must specify attributes which are wrapped.');
                }

                // Add all nested unwrapped attributes in the header
                unwrappedAttributes.each(function(unwrappedAttribute){
                    unwrappedAttribute.wrappedAttributes.each(function(wrappedAttribute){
                        that.header().add(wrappedAttribute.clone());
                    })
                })

            });

            // BeforeGetBody
            this.ee.once('beforeGetBody', function () {

                debug.unwrap.trace('beforeGetBody');

                // Loop through each tuple of the relation
                that.relation.each(function(tuple){

                    // Create the tuple to be inserted
                    var newTuple = new Tuple();

                    // Assign the values to the attributes which will not be unwrapped
                    that.nonUnwrappedAttributes.each(function(attribute){
                        newTuple.set(attribute.name, tuple.get(attribute.name));
                    });

                    // Loop through the attributes to be unwrapped
                    that.unwrappedAttributes.each(function(unwrappedAttribute){

                        // Loop through the wrapped attribute header
                        unwrappedAttribute.wrappedAttributes.each(function(wrappedAttribute){

                            // Set the tuple value for this attribute
                            newTuple.set(wrappedAttribute.name, tuple.get(unwrappedAttribute.name).get(wrappedAttribute.name));

                        })

                    });

                    that.add(newTuple);

                })

            });

        },

        afterAdd : function(relation, tuple){
            var result = this.relation.unwrap(this.attributeNames);
            this.adjustTo(result);
        },

        afterRemove : function(relation, tuple){
            var result = this.relation.unwrap(this.attributeNames);
            this.adjustTo(result);
        },

        afterUpdate : function(relation, tuple, attributeName, value, oldValue){
            var result = this.relation.unwrap(this.attributeNames);
            this.adjustTo(result);
        }

    }, {

        type : 'Unwrap'

    });

module.exports = Unwrap;
},{"./../Attribute.js":2,"./../Header.js":6,"./../Relation.js":9,"./../Set.js":10,"./../Tuple.js":11,"./../helpers/debug":82,"lodash":103}],29:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Set = require('./../Set.js');
var Header = require('./../Header.js');
var Attribute = require('./../Attribute.js');
var Tuple = require('./../Tuple.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');



var Wrap = Relation.extend(

    {

        /**
         * @class Operators.Wrap
         * @extends Relation
         * @param {Relation} relationA The relation to wrap
         * @param {String} wrappingAttributeName The name of the wrapping attribute
         * @param {String[]} wrappedAttributes The wrappedAttributes to wrap
         *
         * The Wrap will gather multiple wrappedAttributes into a single one, converting them to a tuple-valued attribute
         *
         *     var relationA = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {firstName: { type: affinity.String}},
         *              {lastName: { type: affinity.String}}
         *          ],[
         *              [1, 'John', 'Doe'],
         *              [2, 'Mary', 'Poppins'],
         *              [3, 'Lucky', 'Luke']
         *          ]);
         *
         *     // +------------------------+---------------------+--------------------+
         *     // | characterId : TInteger | firstName : TString | lastName : TString |
         *     // +========================+=====================+====================+
         *     // | 1                      | John                | Doe                |
         *     // +------------------------+---------------------+--------------------+
         *     // | 2                      | Mary                | Poppins            |
         *     // +------------------------+---------------------+--------------------+
         *     // | 3                      | Lucky               | Luke               |
         *     // +------------------------+---------------------+--------------------+
         *
         *     var relationC = relationA.wrap('wrappedAttribute', ['firstName','lastName']);
         *
         *     // or
         *
         *     var relationC = new affinity.Wrap(relationA, 'wrappedAttribute', ['firstName','lastName']);
         *
         *     //                          <----WRAPPING ATTRIBUTE-------------------------->
         *     // +-------------------------------------------------------------------------+
         *     // | characterId : TInteger | wrappedAttribute : Tuple                       |
         *     // +========================+================================================+
         *     // | 1                      | Tuple{firstName : 'John', lastName : 'Doe'}    |
         *     // +-------------------------------------------------------------------------+
         *     // | 2                      | Tuple{firstName : 'Mary', lastName : 'Poppins'}|
         *     // +-------------------------------------------------------------------------+
         *     // | 3                      | Tuple{firstName : 'Lucky', lastName : 'Luke'}  |
         *     // +-------------------------------------------------------------------------+
         *     //
         *
         */
        constructor: function (relationA, wrappingAttributeName, wrappedAttributes) {

            debug.wrap.trace('#constructor');

            this.relation = relationA;

            Attribute.assertValidName(wrappingAttributeName);

            if(!_.isArray(wrappedAttributes) && !(wrappedAttributes instanceof Set)){
                throw new Error('Wrapped attributes must be an array or set of attributes / attribute names');
            }

            if(_.isArray(wrappedAttributes) && wrappedAttributes.length <= 0){
                throw new Error('There must be at least one attribute to wrap');
            }

            if(wrappedAttributes instanceof Set && wrappedAttributes.length() <= 0){
                throw new Error('There must be at least one attribute to wrap');
            }

            this.wrappedAttributeName = wrappingAttributeName;
            this.wrappedAttributes = wrappedAttributes;

            Relation.call(this);

        },

        bindEvents: function () {

            debug.wrap.trace('#bindEvents');

            // Calling the parent bindEvents
            Wrap.__super__.bindEvents.call(this);

            var that = this;

            // BeforeGetHeader
            this.ee.once('beforeGetHeader', function () {

                debug.wrap.trace('beforeGetHeader');

                // Check that the passed attributes exist in the base header
                Header.assertAttributesExist(that.relation, that.wrappedAttributes);

                // Extract the wrapped attributes, convert them to a Header instance
                var wrappedAttributes = new Header();
                wrappedAttributes.copy(that.relation.header(), that.wrappedAttributes);
                that.wrappedAttributes = wrappedAttributes;

                // Extract the non wrapped attributes in another variable, and
                // copy the attributes in this header
                that.nonWrappedAttributes = new Header();
                that.nonWrappedAttributes.copy(that.relation.header(), that.wrappedAttributes, true);
                that.header().copy(that.nonWrappedAttributes);

                // Create the wrapped attribute
                var newWrappedAttribute = new Attribute({name : that.wrappedAttributeName, type : Tuple})

                // Store the wrapped header in the attribute
                newWrappedAttribute.wrappedAttributes = that.wrappedAttributes;

                // Add it to the header
                that.header().add(newWrappedAttribute);

            });


            // BeforeGetBody
            this.ee.once('beforeGetBody', function () {

                debug.wrap.trace('beforeGetBody');

                that.relation.each(function(tuple){

                    // Create the tuple we will later insert
                    var newTuple = new Tuple();

                    // Copy the value of the non-wrapped attributes
                    newTuple.copy(tuple, that.nonWrappedAttributes);

                    // Create the nested tuple
                    var nestedTuple = new Tuple();

                    // Copy the values of the wrapped attributes in the nested tuple
                    nestedTuple.copy(tuple, that.wrappedAttributes);

                    // Add the nested tuple to the containing tuple
                    newTuple.set(that.wrappedAttributeName, nestedTuple);

                    that.add(newTuple);

                })

            });

        },

        afterAdd : function(relation, tuple){
            var result = this.relation.wrap(this.wrappedAttributeName, this.wrappedAttributes);
            this.adjustTo(result);
        },

        afterRemove : function(relation, tuple){
            var result = this.relation.wrap(this.wrappedAttributeName, this.wrappedAttributes);
            this.adjustTo(result);
        },

        afterUpdate : function(relation, tuple, attributeName, value, oldValue){
            var result = this.relation.wrap(this.wrappedAttributeName, this.wrappedAttributes);
            this.adjustTo(result);
        }

    }, {

        type : 'Wrap'

    });

module.exports = Wrap;
},{"./../Attribute.js":2,"./../Header.js":6,"./../Relation.js":9,"./../Set.js":10,"./../Tuple.js":11,"./../helpers/debug":82,"lodash":103}],30:[function(require,module,exports){
var Function = require('./../../Function');

var Boolean = require('./../../types/Boolean.js');

var _ = require('lodash');

var All = Function.extend({

    /**
     * @class Functions.Aggregate.All
     * @extends Function
     *
     * Functions that checks if all the tuples in a relation match the
     * given boolean predicate.
     *
     * Example :
     *
     *     var relation = new affinity.Relation([
     *         { name : { type : affinity.String } },
     *         { age : { type : affinity.Integer } }
     *     ],[
     *         ['John Doe', 23],
     *         ['Mark Clinton', 36],
     *         ['Super Woman', 56]
     *     ]);
     *
     *     var name = relation.get('name');
     *     var age = relation.get('age')
     *
     *     var all = relation.all(age.gt(20));
     *
     *     console.log(all.value());
     *
     *     // true
     */

    constructor : function(relation, predicate){

        Function.apply(this, Array.prototype.slice.call(arguments,0));

        this.name = 'All';

        this.predicate = predicate;

        this.relation = relation;

        this.type(Boolean);

    },


    value : function(){

        var relation = this.relation;

        var predicate = this.predicate;

        var result = true;

        predicate.convertAttributeToTuple();

        relation.each(function(tuple){

            predicate.assignTuple(tuple);

            if( predicate.value() === false ){

                result = false;
                return false;

            }

        });

        return result;

    }

});

module.exports = All;
},{"./../../Function":5,"./../../types/Boolean.js":93,"lodash":103}],31:[function(require,module,exports){
var Function = require('./../../Function');

var Boolean = require('./../../types/Boolean.js');

var _ = require('lodash');

var Any = Function.extend({

    /**
     * @class Functions.Aggregate.Any
     * @extends Function
     *
     * Functions that checks if any of the tuples in a relation match the
     * given boolean predicate.
     *
     * Example :
     *
     *     var relation = new affinity.Relation([
     *         { name : { type : affinity.String } },
     *         { age : { type : affinity.Integer } }
     *     ],[
     *         ['John Doe', 23],
     *         ['Mark Clinton', 36],
     *         ['Super Woman', 56]
     *     ]);
     *
     *     var name = relation.get('name');
     *     var age = relation.get('age')
     *
     *     var any = relation.any(age.gt(50));
     *
     *     console.log(any.value());
     *
     *     // true
     */

    constructor : function(relation, predicate){

        Function.apply(this, Array.prototype.slice.call(arguments,0));

        this.name = 'Any';

        this.type(Boolean);

        this.relation = relation;

        this.predicate = predicate;

    },

    value : function(){

        var relation = this.relation;

        var predicate = this.predicate;

        var result = false;

        predicate.convertAttributeToTuple();

        relation.each(function(tuple){

            predicate.assignTuple(tuple);

            if( predicate.value() === true ){

                result = true;
                return false;

            }

        });

        return result;

    }
});

module.exports = Any;
},{"./../../Function":5,"./../../types/Boolean.js":93,"lodash":103}],32:[function(require,module,exports){
var Function = require('./../../Function');

var Float = require('./../../types/Float.js');

var _ = require('lodash');

var Average = Function.extend({

    /**
     * @class Functions.Aggregate.Average
     * @extends Function
     *
     * Functions that returns the average for a relation
     * attribute
     *
     * Example :
     *
     *     var relation = new affinity.Relation([
     *         { name : { type : affinity.String } },
     *         { age : { type : affinity.Integer } }
     *     ],[
     *         ['John Doe', 23],
     *         ['Mark Clinton', 36],
     *         ['Super Woman', 56]
     *     ]);
     *
     *     var age = relation.get('age');
     *
     *     var max = relation.avg(age)
     *
     *     console.log(max.value());
     *
     *     // 38.33333333
     */

    constructor : function(attribute){

        Function.apply(this, Array.prototype.slice.call(arguments,0));

        this.name = 'Average';

        this.type(Float);

        this.attribute = attribute;

        this.relation = attribute.header.relation;

    },

    value : function(){

        var attribute = this.attribute;

        var relation = this.relation;

        var result = 0;

        var length = relation.length();

        relation.each(function(tuple){

            result += tuple.get(attribute.name);

        });

        result = result / length;

        return result;

    }
});

module.exports = Average;
},{"./../../Function":5,"./../../types/Float.js":95,"lodash":103}],33:[function(require,module,exports){
var Function = require('./../../Function');

var Integer = require('./../../types/Integer.js');

var _ = require('lodash');

var Count = Function.extend({

    /**
     * @class Functions.Aggregate.Count
     * @extends Function
     *
     * Functions that counts the number of tuples
     *
     * Example :
     *
     *     var relation = new affinity.Relation([
     *         { name : { type : affinity.String } },
     *         { age : { type : affinity.Integer } }
     *     ],[
     *         ['John Doe', 23],
     *         ['Mark Clinton', 36],
     *         ['Super Woman', 56]
     *     ]);
     *
     *     var count = relation.count()
     *
     *     console.log(count.value());
     *
     *     // 3
     */

    constructor : function(relation){

        Function.apply(this, Array.prototype.slice.call(arguments,0));

        this.name = 'Count';

        this.type(Integer);

        this.relation = relation;

    },

    value : function(){

        return this.relation.length();

    }

});

module.exports = Count;
},{"./../../Function":5,"./../../types/Integer.js":96,"lodash":103}],34:[function(require,module,exports){
var Function = require('./../../Function');

var compare = require('./../../helpers/compare.js');

var Integer = require('./../../types/Integer.js');

var Maximum = Function.extend({

    /**
     * @class Functions.Aggregate.Maximum
     * @extends Function
     *
     * Functions that returns the largest value of an attribute in a relation.
     *
     * Example :
     *
     *     var relation = new affinity.Relation([
     *         { name : { type : affinity.String } },
     *         { age : { type : affinity.Integer } }
     *     ],[
     *         ['John Doe', 23],
     *         ['Mark Clinton', 36],
     *         ['Super Woman', 56]
     *     ]);
     *
     *     var age = relation.get('age');
     *
     *     var max = relation.max(age)
     *
     *     console.log(max.value());
     *
     *     // 56
     */

    constructor : function(attribute){

        Function.apply(this, Array.prototype.slice.call(arguments,0));

        this.name = 'Maximum';

        this.type(Integer);

        this.attribute = attribute;

        this.relation = attribute.header.relation;

    },

    value : function(){

        var relation = this.relation;

        var attribute = this.attribute;

        var type = this.attribute.type;

        var max = null;

        relation.each(function(tuple){

            var value = tuple.get(attribute.name);

            if(max === null){
                max = value;
            } else if ( compare(type, value, max) > 0 ){
                max = value;
            }

        });

        return max;

    }
});

module.exports = Maximum;
},{"./../../Function":5,"./../../helpers/compare.js":81,"./../../types/Integer.js":96}],35:[function(require,module,exports){
var Function = require('./../../Function');

var compare = require('./../../helpers/compare.js');

var Integer = require('./../../types/Integer.js');

var Minimum = Function.extend({

    /**
     * @class Functions.Aggregate.Minimum
     * @extends Function
     *
     * Functions that returns the minimum value of an attribute in a relation.
     *
     * Example :
     *
     *     var relation = new affinity.Relation([
     *         { name : { type : affinity.String } },
     *         { age : { type : affinity.Integer } }
     *     ],[
     *         ['John Doe', 23],
     *         ['Mark Clinton', 36],
     *         ['Super Woman', 56]
     *     ]);
     *
     *     var age = relation.get('age');
     *
     *     var min = relation.min(age);
     *
     *     console.log(min.value());
     *
     *     // 23
     */

    constructor : function(attribute){

        Function.apply(this, Array.prototype.slice.call(arguments,0));

        this.name = 'Minimum';

        this.type(Integer);

        this.attribute = attribute;

        this.relation = attribute.header.relation;

    },

    value : function(){

        var relation = this.relation;

        var attribute = this.attribute;

        var type = this.attribute.type;

        var min = null;

        relation.each(function(tuple){

            var value = tuple.get(attribute.name);

            if(min === null){
                min = value;
            } else if ( compare(type, value, min) < 0 ){
                min = value;
            }

        });

        return min;

    }

});

module.exports = Minimum;
},{"./../../Function":5,"./../../helpers/compare.js":81,"./../../types/Integer.js":96}],36:[function(require,module,exports){
var Function = require('./../../Function');

var Float = require('./../../types/Float.js');

var Variance = require('./Variance.js');

var StandardDeviation = Function.extend({

    /**
     * @class Functions.Aggregate.StandardDeviation
     * @extends Function
     *
     * Functions that returns the standard deviation
     * of an attribute in a relation
     *
     * Example :
     *
     *     var relation = new affinity.Relation([
     *         { name : { type : affinity.String } },
     *         { age : { type : affinity.Integer } }
     *     ],[
     *         ['John Doe', 23],
     *         ['Mark Clinton', 36],
     *         ['Super Woman', 56]
     *     ]);
     *
     *     var age = relation.get('age');
     *
     *     var stdev = relation.standardDeviation(age)
     *
     *     console.log(stdev.value());
     *
     *     // 16.6232768531
     */

    constructor : function(attribute){

        Function.apply(this, Array.prototype.slice.call(arguments,0));

        this.name = 'StandardDeviation';

        this.type(Float);

        this.attribute = attribute;

    },

    value : function(){

        var attribute = this.attribute;

        var variance = new Variance(attribute).value();

        return Math.sqrt(variance);

    }
});

module.exports = StandardDeviation;
},{"./../../Function":5,"./../../types/Float.js":95,"./Variance.js":38}],37:[function(require,module,exports){
var Function = require('./../../Function');

var Float = require('./../../types/Float.js');

var Sum = Function.extend({

    /**
     * @class Functions.Aggregate.Count
     * @extends Function
     *
     * Functions that calculates the sum of all values for
     * an attribute in a relation
     *
     * Example :
     *
     *     var relation = new affinity.Relation([
     *         { name : { type : affinity.String } },
     *         { age : { type : affinity.Integer } }
     *     ],[
     *         ['John Doe', 23],
     *         ['Mark Clinton', 36],
     *         ['Super Woman', 56]
     *     ]);
     *
     *     var age = relation.get('age');
     *
     *     var sum = relation.sum(age);
     *
     *     console.log(sum.value());
     *
     *     // 115
     */

    constructor : function(attribute){

        Function.apply(this, Array.prototype.slice.call(arguments,0));

        this.name = 'Sum';

        this.type(Float);

        this.attribute = attribute;

        this.relation = attribute.header.relation;

    },

    value : function(){

        var relation = this.relation;

        var attributeName = this.attribute.name;

        var sum = 0;

        relation.each(function(tuple){

            sum += tuple.get(attributeName);

        });

        return sum;

    }

});

module.exports = Sum;
},{"./../../Function":5,"./../../types/Float.js":95}],38:[function(require,module,exports){
var Function = require('./../../Function');

var Average = require('./Average.js');

var Float = require('./../../types/Float.js');

var Variance = Function.extend({

    /**
     * @class Functions.Aggregate.Variance
     * @extends Function
     *
     * Functions that returns the variance
     * of attribute values in a relation
     *
     * Example :
     *
     *     var relation = new affinity.Relation([
     *         { name : { type : affinity.String } },
     *         { age : { type : affinity.Integer } }
     *     ],[
     *         ['John Doe', 23],
     *         ['Mark Clinton', 36],
     *         ['Super Woman', 56]
     *     ]);
     *
     *     var age = relation.get('age');
     *
     *     var variance = relation.variance(age)
     *
     *     console.log(variance.value());
     *
     *     // 184.22222
     */

    constructor : function(attribute){

        Function.apply(this, Array.prototype.slice.call(arguments,0));

        this.name = 'Sum';

        this.type(Float);

        this.attribute = attribute;

        this.relation = attribute.header.relation

    },

    value : function(){

        var attribute = this.attribute;

        var relation = this.relation;

        var attributeName = this.attribute.name;

        var average = new Average(attribute).value();

        var length = relation.length();

        var totalVariance = 0;

        relation.each(function(tuple){

            var value = tuple.get(attributeName);

            totalVariance += Math.pow((value - average), 2);

        });

        return totalVariance / length;

    }
});

module.exports = Variance;
},{"./../../Function":5,"./../../types/Float.js":95,"./Average.js":32}],39:[function(require,module,exports){
var Function = require('./../../Function.js');
var TBoolean = require('./../../types/Boolean.js');
var _ = require('lodash');
var equal = require('./../../helpers/equal');

var FEqual = Function.extend(

    {

        /**
         * @class Functions.Comparable.Equal
         * @extends Function
         *
         * Function that compares if two values are equal. Only applies
         * to types that implement a static "equal" method or to primitives.
         *
         * When used with an Extension operator :
         *
         *      var philosophers = new affinity.Relation([
         *              {name: { type: affinity.String}},
         *              {born: { type: affinity.Integer}},
         *              {died: { type: affinity.Integer}}
         *          ],[
         *              ['Aristotle', -384, -322],
         *              ['Plato',     -428, -348],
         *              ['Socrates',  -470, -399]
         *          ]);
         *
         *      name = philosophers.get('name');
         *      born = philosophers.get('born');
         *      died = philosophers.get('died');
         *
         *      var extended = philosophers.extend([{ diedIn322BC : died.eq(-322) }]);
         *
         *      // or equivalent :
         *
         *      var extended = philosophers.extend([{ diedIn322BC : new affinity.Equal(died, -322) }]);
         *
         *      extended.print();
         *
         *      // +----------------+-----------------+-----------------+------------------------+
         *      // | name : TString | born : TInteger | died : TInteger | diedIn322BC : TBoolean |
         *      // +================+=================+=================+========================+
         *      // | Aristotle      | -384            | -322            | true                   |
         *      // +----------------+-----------------+-----------------+------------------------+
         *      // | Plato          | -428            | -348            | false                  |
         *      // +----------------+-----------------+-----------------+------------------------+
         *      // | Socrates       | -470            | -399            | false                  |
         *      // +----------------+-----------------+-----------------+------------------------+
         *
         *
         * When used with a Restriction operator :
         *
         *      var restricted = philosophers.restrict(died.eq(-322));
         *
         *      // or equivalent :
         *
         *      var restricted = philosophers.restrict(new affinity.Equal(died, -322));
         *
         *      restricted.print();
         *
         *      // +----------------+-----------------+-----------------+
         *      // | name : TString | born : TInteger | died : TInteger |
         *      // +================+=================+=================+
         *      // | Aristotle      | -384            | -322            |
         *      // +----------------+-----------------+-----------------+
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments,0));

            this.name = 'Equals';

            this.type(TBoolean);

        },

        /**
         * Gets the result of the function
         * @returns {Boolean}
         */
        value: function () {

            return equal(null, this.parameters[0], this.parameters[1]);

        }

});

module.exports = FEqual;
},{"./../../Function.js":5,"./../../helpers/equal":83,"./../../types/Boolean.js":93,"lodash":103}],40:[function(require,module,exports){
var Function = require('./../../Function.js');
var TBoolean = require('./../../types/Boolean.js');
var _ = require('lodash');
var compare = require('./../../helpers/compare');

var GreaterThan = Function.extend(

    {

        /**
         * @class Functions.Comparable.GreaterThan
         * @extends Function
         *
         * Function that checks if a value is greater than another one.
         * Only applies to types that implement the static "compare" method
         * or to primitives.
         *
         * When used with an Extension operator :
         *
         *      var philosophers = new affinity.Relation([
         *              {name: { type: affinity.String}},
         *              {born: { type: affinity.Integer}},
         *              {died: { type: affinity.Integer}}
         *          ],[
         *              ['Aristotle', -384, -322],
         *              ['Plato',     -428, -348],
         *              ['Socrates',  -470, -399]
         *          ]);
         *
         *      name = philosophers.get('name');
         *      born = philosophers.get('born');
         *      died = philosophers.get('died');
         *
         *      var extended = philosophers.extend([{ diedAfter350BC : died.gt(-322) }]);
         *
         *      // or equivalent :
         *
         *      var extended = philosophers.extend([{ diedAfter350BC : new affinity.GreaterThan(died, -322) }]);
         *
         *      extended.print();
         *
         *      // +----------------+-----------------+-----------------+---------------------------+
         *      // | name : TString | born : TInteger | died : TInteger | diedAfter350BC : TBoolean |
         *      // +================+=================+=================+===========================+
         *      // | Aristotle      | -384            | -322            | true                      |
         *      // +----------------+-----------------+-----------------+---------------------------+
         *      // | Plato          | -428            | -348            | true                      |
         *      // +----------------+-----------------+-----------------+---------------------------+
         *      // | Socrates       | -470            | -399            | true                      |
         *      // +----------------+-----------------+-----------------+---------------------------+
         *
         *
         * When used with a Restriction operator :
         *
         *      var restricted = philosophers.restrict(died.gt(-350));
         *
         *      // or equivalent :
         *
         *      var restricted = philosophers.restrict(new affinity.GreaterThan(died, -350));
         *
         *      restricted.print();
         *
         *      // +----------------+-----------------+-----------------+
         *      // | name : TString | born : TInteger | died : TInteger |
         *      // +================+=================+=================+
         *      // | Aristotle      | -384            | -322            |
         *      // +----------------+-----------------+-----------------+
         *      // | Plato          | -428            | -348            |
         *      // +----------------+-----------------+-----------------+
         *
         */
        constructor: function () {

            Function.apply(this, arguments);

            this.name = 'GreaterThan';

            this.type(TBoolean);

        },

        /**
         * Gets the result of the function
         * @returns {boolean}
         */
        value: function () {

            return (compare(null, this.parameters[0], this.parameters[1]) > 0);

        }

    },{

    });

module.exports = GreaterThan;
},{"./../../Function.js":5,"./../../helpers/compare":81,"./../../types/Boolean.js":93,"lodash":103}],41:[function(require,module,exports){
var Function = require('./../../Function.js');
var compare = require('./../../helpers/compare');
var TBoolean = require('./../../types/Boolean.js');
var _ = require('lodash');

var FLargerThanEqual = Function.extend(

    {

        /**
         * @class Functions.Comparable.GreaterThanEqual
         * @extends Function
         *
         * Function that checks if a value is greater than or equal to another one. It only applies
         * to types that implement a static "compare" method or to primitives.
         *
         * When used with an Extension operator :
         *
         *      var philosophers = new affinity.Relation([
         *              {name: { type: affinity.String}},
         *              {born: { type: affinity.Integer}},
         *              {died: { type: affinity.Integer}}
         *          ],[
         *              ['Aristotle', -384, -322],
         *              ['Plato',     -428, -348],
         *              ['Socrates',  -470, -399]
         *          ]);
         *
         *      name = philosophers.get('name');
         *      born = philosophers.get('born');
         *      died = philosophers.get('died');
         *
         *      var extended = philosophers.extend([{ diedSince348BC : died.gte(-348) }]);
         *
         *      // or equivalent :
         *
         *      var extended = philosophers.extend([{ diedSince348BC : new affinity.GreaterThanEqual(died, -348) }]);
         *
         *      extended.print();
         *
         *      // +----------------+-----------------+-----------------+---------------------------+
         *      // | name : TString | born : TInteger | died : TInteger | diedSince348BC : TBoolean |
         *      // +================+=================+=================+===========================+
         *      // | Aristotle      | -384            | -322            | false                     |
         *      // +----------------+-----------------+-----------------+---------------------------+
         *      // | Plato          | -428            | -348            | true                      |
         *      // +----------------+-----------------+-----------------+---------------------------+
         *      // | Socrates       | -470            | -399            | true                      |
         *      // +----------------+-----------------+-----------------+---------------------------+
         *
         *
         * When used with a Restriction operator :
         *
         *      var restricted = philosophers.restrict(died.gte(-348));
         *
         *      // or equivalent :
         *
         *      var restricted = philosophers.restrict(new affinity.GreaterThanEqual(died, -348));
         *
         *      restricted.print();
         *
         *      // +----------------+-----------------+-----------------+
         *      // | name : TString | born : TInteger | died : TInteger |
         *      // +================+=================+=================+
         *      // | Aristotle      | -384            | -322            |
         *      // +----------------+-----------------+-----------------+
         *      // | Plato          | -428            | -348            |
         *      // +----------------+-----------------+-----------------+
         */
        constructor: function () {

            Function.apply(this, arguments);

            this.name = 'GreaterThanEqual';

            this.type(TBoolean);

        },

        /**
         * Gets the result of the function
         * @returns {boolean}
         */
        value: function () {

            return (compare(null, this.parameters[0], this.parameters[1]) >= 0);

        }

    },{



    });

module.exports = FLargerThanEqual;
},{"./../../Function.js":5,"./../../helpers/compare":81,"./../../types/Boolean.js":93,"lodash":103}],42:[function(require,module,exports){
var Function = require('./../../Function.js');
var compare = require('./../../helpers/compare');
var TBoolean = require('./../../types/Boolean.js');
var _ = require('lodash');

var FSmallerThan = Function.extend(

    {

        /**
         * @class Functions.Comparable.SmallerThan
         * @extends Function
         *
         * Function that checks if a value is smaller than another one. It only applies
         * to types that implement a static "compare" method or to primitives.
         *
         * When used with an Extension operator :
         *
         *      var philosophers = new affinity.Relation([
         *              {name: { type: affinity.String}},
         *              {born: { type: affinity.Integer}},
         *              {died: { type: affinity.Integer}}
         *          ],[
         *              ['Aristotle', -384, -322],
         *              ['Plato',     -428, -348],
         *              ['Socrates',  -470, -399]
         *          ]);
         *
         *      name = philosophers.get('name');
         *      born = philosophers.get('born');
         *      died = philosophers.get('died');
         *
         *      var extended = philosophers.extend([{ diedBefore348BC : died.st(-348) }]);
         *
         *      // or equivalent :
         *
         *      var extended = philosophers.extend([{ diedBefore348BC : new affinity.SmallerThan(died, -348) }]);
         *
         *      extended.print();
         *
         *      // +----------------+-----------------+-----------------+----------------------------+
         *      // | name : TString | born : TInteger | died : TInteger | diedBefore348BC : TBoolean |
         *      // +================+=================+=================+============================+
         *      // | Aristotle      | -384            | -322            | true                       |
         *      // +----------------+-----------------+-----------------+----------------------------+
         *      // | Plato          | -428            | -348            | false                      |
         *      // +----------------+-----------------+-----------------+----------------------------+
         *      // | Socrates       | -470            | -399            | false                      |
         *      // +----------------+-----------------+-----------------+----------------------------+
         *
         *
         * When used with a Restriction operator :
         *
         *      var restricted = philosophers.restrict(died.st(-348));
         *
         *      // or equivalent :
         *
         *      var restricted = philosophers.restrict(new affinity.SmallerThan(died, -348));
         *
         *      restricted.print();
         *
         *      // +----------------+-----------------+-----------------+
         *      // | name : TString | born : TInteger | died : TInteger |
         *      // +================+=================+=================+
         *      // | Aristotle      | -384            | -322            |
         *      // +----------------+-----------------+-----------------+
         */
        constructor: function () {

            Function.apply(this, arguments);

            this.name = 'SmallerThan';

            this.type(TBoolean);

        },

        /**
         * Gets the result of the function
         * @returns {boolean}
         */
        value: function () {

            return (compare(null, this.parameters[0], this.parameters[1]) < 0);

        }

    },{



    });

module.exports = FSmallerThan;
},{"./../../Function.js":5,"./../../helpers/compare":81,"./../../types/Boolean.js":93,"lodash":103}],43:[function(require,module,exports){
var Function = require('./../../Function.js');
var compare = require('./../../helpers/compare');
var TBoolean = require('./../../types/Boolean.js');
var _ = require('lodash');

var FSmallerThanEqual = Function.extend(

    {

        /**
         * @class Functions.Comparable.SmallerThanEqual
         * @extends Function
         *
         * Function that checks if a value is smaller than or equal to another one. It only applies
         * to types that implement a static "compare" method or to primitives.
         *
         * When used with an Extension operator :
         *
         *      var philosophers = new affinity.Relation([
         *              {name: { type: affinity.String}},
         *              {born: { type: affinity.Integer}},
         *              {died: { type: affinity.Integer}}
         *          ],[
         *              ['Aristotle', -384, -322],
         *              ['Plato',     -428, -348],
         *              ['Socrates',  -470, -399]
         *          ]);
         *
         *      name = philosophers.get('name');
         *      born = philosophers.get('born');
         *      died = philosophers.get('died');
         *
         *      var extended = philosophers.extend([{ diedUpTo348BC : died.ste(-348) }]);
         *
         *      // or equivalent :
         *
         *      var extended = philosophers.extend([{ diedUpTo348BC : new affinity.SmallerThanEqual(died, -348) }]);
         *
         *      extended.print();
         *
         *      // +----------------+-----------------+-----------------+--------------------------+
         *      // | name : TString | born : TInteger | died : TInteger | diedUpTo348BC : TBoolean |
         *      // +================+=================+=================+==========================+
         *      // | Aristotle      | -384            | -322            | true                     |
         *      // +----------------+-----------------+-----------------+--------------------------+
         *      // | Plato          | -428            | -348            | true                     |
         *      // +----------------+-----------------+-----------------+--------------------------+
         *      // | Socrates       | -470            | -399            | false                    |
         *      // +----------------+-----------------+-----------------+--------------------------+
         *
         *
         * When used with a Restriction operator :
         *
         *      var restricted = philosophers.restrict(died.ste(-348));
         *
         *      // or equivalent :
         *
         *      var restricted = philosophers.restrict(new affinity.SmallerThanEqual(died, -348));
         *
         *      restricted.print();
         *
         *      // +----------------+-----------------+-----------------+
         *      // | name : TString | born : TInteger | died : TInteger |
         *      // +================+=================+=================+
         *      // | Aristotle      | -384            | -322            |
         *      // +----------------+-----------------+-----------------+
         *      // | Plato          | -428            | -348            |
         *      // +----------------+-----------------+-----------------+
         *
         */
        constructor: function () {

            Function.apply(this, arguments);

            this.name = 'SmallerThanEqual';

            this.type(TBoolean);

        },

        /**
         * Gets the result of the function
         * @returns {boolean}
         */
        value: function () {

            return (compare(null, this.parameters[0], this.parameters[1]) <= 0);

        }

    },{



    });

module.exports = FSmallerThanEqual;
},{"./../../Function.js":5,"./../../helpers/compare":81,"./../../types/Boolean.js":93,"lodash":103}],44:[function(require,module,exports){
var Function = require('./../../Function.js');
var TBoolean = require('./../../types/Boolean.js');
var _ = require('lodash');

var And = Function.extend(
    {

        /**
         * @class Functions.Connective.And
         * @extends Function
         *
         * Function that checks if its arguments all return a true boolean.
         *
         * When used with an Extension operator :
         *
         *      var philosophers = new affinity.Relation([
         *              {name: { type: affinity.String}},
         *              {born: { type: affinity.Integer}},
         *              {died: { type: affinity.Integer}}
         *          ],[
         *              ['Aristotle', -384, -322],
         *              ['Plato',     -428, -348],
         *              ['Socrates',  -470, -399]
         *          ]);
         *
         *      name = philosophers.get('name');
         *      born = philosophers.get('born');
         *      died = philosophers.get('died');
         *
         *      var extended = philosophers.extend([{ "322to384BC" : died.eq(-322).and(born.eq(-384)) }]);
         *
         *      // or equivalent :
         *
         *      var extended = philosophers.extend([
         *          { diedIn322BC : new affinity.And(new affinity.Equal(died, -322), new affinity.Equal(born, -384)) }
         *      ]);
         *
         *      extended.print();
         *
         *      // +----------------+-----------------+-----------------+------------------------+
         *      // | name : TString | born : TInteger | died : TInteger | 322to384BC : TBoolean  |
         *      // +================+=================+=================+========================+
         *      // | Aristotle      | -384            | -322            | true                   |
         *      // +----------------+-----------------+-----------------+------------------------+
         *      // | Plato          | -428            | -348            | false                  |
         *      // +----------------+-----------------+-----------------+------------------------+
         *      // | Socrates       | -470            | -399            | false                  |
         *      // +----------------+-----------------+-----------------+------------------------+
         *
         *
         * When used with a Restriction operator :
         *
         *      var restricted = philosophers.restrict(died.eq(-322).and(born.eq(-384)));
         *
         *      // or equivalent :
         *
         *      var restricted = philosophers.restrict(
         *          new affinity.And(new affinity.Equal(died, -322), new affinity.Equal(born, -384))
         *      );
         *
         *      restricted.print();
         *
         *      // +----------------+-----------------+-----------------+
         *      // | name : TString | born : TInteger | died : TInteger |
         *      // +================+=================+=================+
         *      // | Aristotle      | -384            | -322            |
         *      // +----------------+-----------------+-----------------+
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TBoolean);

            this.name = 'And';

        },

        /**
         * Gets the function return value
         * @returns {boolean}
         */
        value: function () {

            return _.every(this.parameters, function(parameter){

                if(!_.isBoolean(parameter)){
                    parameter = parameter.value();
                }
                return parameter;

            });

        }

    },{



    });

module.exports = And;
},{"./../../Function.js":5,"./../../types/Boolean.js":93,"lodash":103}],45:[function(require,module,exports){
var Function = require('./../../Function.js');
var TBoolean = require('./../../types/Boolean.js');
var _ = require('lodash');

var Not = Function.extend(

    {

        /**
         * @class Functions.Connective.Not
         * @extends Function
         *
         * Function that checks if its argument returns false
         *
         * When used with an Extension operator :
         *
         *      var philosophers = new affinity.Relation([
         *              {name: { type: affinity.String}},
         *              {born: { type: affinity.Integer}},
         *              {died: { type: affinity.Integer}}
         *          ],[
         *              ['Aristotle', -384, -322],
         *              ['Plato',     -428, -348],
         *              ['Socrates',  -470, -399]
         *          ]);
         *
         *      name = philosophers.get('name');
         *      born = philosophers.get('born');
         *      died = philosophers.get('died');
         *
         *      var extended = philosophers.extend([{ "notBornIn384BC" : born.not().eq(-384) }]);
         *
         *      // or equivalent :
         *
         *      var extended = philosophers.extend([
         *          { diedIn322BC : new affinity.Not(new affinity.Equal(born, -322)) }
         *      ]);
         *
         *      extended.print();
         *
         *      // +----------------+-----------------+-----------------+----------------------------+
         *      // | name : TString | born : TInteger | died : TInteger | notBornIn384BC : TBoolean  |
         *      // +================+=================+=================+============================+
         *      // | Aristotle      | -384            | -322            | false                      |
         *      // +----------------+-----------------+-----------------+----------------------------+
         *      // | Plato          | -428            | -348            | true                       |
         *      // +----------------+-----------------+-----------------+----------------------------+
         *      // | Socrates       | -470            | -399            | true                       |
         *      // +----------------+-----------------+-----------------+----------------------------+
         *
         *
         * When used with a Restriction operator :
         *
         *      var restricted = philosophers.restrict(born.not().eq(-384));
         *
         *      // or equivalent :
         *
         *      var restricted = philosophers.restrict(
         *          new affinity.Not(new affinity.Equal(born, -322))
         *      );
         *
         *      restricted.print();
         *
         *      // +----------------+-----------------+-----------------+
         *      // | name : TString | born : TInteger | died : TInteger |
         *      // +================+=================+=================+
         *      // | Plato          | -428            | -348            |
         *      // +----------------+-----------------+-----------------+
         *      // | Socrates       | -470            | -399            |
         *      // +----------------+-----------------+-----------------+
         *
         */
        constructor: function () {

            Function.apply(this, arguments);

            this.type(TBoolean);

            this.name = 'Not';

        },

        /**
         * Gets the function return value
         * @returns {boolean}
         */
        value: function () {

            if(!_.isBoolean(this.parameters[0])){
                return !this.parameters[0].value();
            }

            return !this.parameters[0];

        }

    },{



    });

module.exports = Not;
},{"./../../Function.js":5,"./../../types/Boolean.js":93,"lodash":103}],46:[function(require,module,exports){
var Function = require('./../../Function.js');
var TBoolean = require('./../../types/Boolean.js');
var _ = require('lodash');

var Or = Function.extend(
    {

        /**
         * @class Functions.Connective.Or
         * @extends Function
         *
         * Function that checks if one of its arguments return true
         *
         * When used with an Extension operator :
         *
         *      var philosophers = new affinity.Relation([
         *              {name: { type: affinity.String}},
         *              {born: { type: affinity.Integer}},
         *              {died: { type: affinity.Integer}}
         *          ],[
         *              ['Aristotle', -384, -322],
         *              ['Plato',     -428, -348],
         *              ['Socrates',  -470, -399]
         *          ]);
         *
         *      name = philosophers.get('name');
         *      born = philosophers.get('born');
         *      died = philosophers.get('died');
         *
         *      var extended = philosophers.extend([{ "born384or428BC" : born.eq(-384).or(born.eq(-428)) }]);
         *
         *      // or equivalent :
         *
         *      var extended = philosophers.extend([
         *          { diedIn322BC : new affinity.Or(new affinity.Equal(born, -384), new affinity.Equal(born, -428)) }
         *      ]);
         *
         *      extended.print();
         *
         *      // +----------------+-----------------+-----------------+----------------------------+
         *      // | name : TString | born : TInteger | died : TInteger | born384or428BC : TBoolean  |
         *      // +================+=================+=================+============================+
         *      // | Aristotle      | -384            | -322            | true                       |
         *      // +----------------+-----------------+-----------------+----------------------------+
         *      // | Plato          | -428            | -348            | true                       |
         *      // +----------------+-----------------+-----------------+----------------------------+
         *      // | Socrates       | -470            | -399            | false                      |
         *      // +----------------+-----------------+-----------------+----------------------------+
         *
         *
         * When used with a Restriction operator :
         *
         *      var restricted = philosophers.restrict(born.eq(-384).or(born.eq(-428)));
         *
         *      // or equivalent :
         *
         *      var restricted = philosophers.restrict(
         *          new affinity.Or(new affinity.Equal(born, -384), new affinity.Equal(born, -428))
         *      );
         *
         *      restricted.print();
         *
         *      // +----------------+-----------------+-----------------+
         *      // | name : TString | born : TInteger | died : TInteger |
         *      // +================+=================+=================+
         *      // | Aristotle      | -384            | -322            |
         *      // +----------------+-----------------+-----------------+
         *      // | Plato          | -428            | -348            |
         *      // +----------------+-----------------+-----------------+
         *
         */
        constructor: function () {

            Function.apply(this, arguments);

            this.type(TBoolean);

            this.name = 'Or';

        },

        value: function () {


            return _.any(this.parameters, function(parameter){

                if(!_.isBoolean(parameter)){
                    parameter = parameter.value();
                }
                return parameter;

            });

        }

    },{


    });

module.exports = Or;
},{"./../../Function.js":5,"./../../types/Boolean.js":93,"lodash":103}],47:[function(require,module,exports){
var Function = require('./../../Function.js');
var TInteger = require('./../../types/Integer.js');
var value = require('./../../helpers/value');

var FDayOfMonth = Function.extend(
    {

        /**
         * @class Functions.Date.DayOfMonth
         * @extends Function
         *
         * Function that extracts a date's day of the month
         *
         * With extend operation :
         *
         *      var events = new affinity.Relation([
         *          {date : {type : affinity.Date}},
         *          {name : {type : affinity.String}}
         *      ],[
         *          [new Date(2014, 1, 07), 'Sochi'],
         *          [new Date(2014, 0, 02), 'Chocolate rush'],
         *          [new Date(2014, 3, 15), 'Millionth coffee drank']
         *      ])
         *
         *      var date = events.get('date')
         *
         *      var extended = events.extend([ { "date.dayOfMonth()" : date.dayOfMonth() } ]);
         *
         *      // or equivalent
         *
         *      var extended = events.extend([ { "date.dayOfMonth()" : new affinity.DayOfMonth(date) } ]);
         *
         *      extended.print();
         *
         *      +-------------------------------------------+--------------------------+-------------------------------+
         *      | date : Date                               | name : String            | date.dayOfMonth() : Integer   |
         *      +===========================================+==========================+===============================+
         *      | Fri Feb 07 2014 00:00:00 GMT-0500 (EST)   | Sochi                    | 7                             |
         *      +-------------------------------------------+--------------------------+-------------------------------+
         *      | Thu Jan 02 2014 00:00:00 GMT-0500 (EST)   | Chocolate rush           | 2                             |
         *      +-------------------------------------------+--------------------------+-------------------------------+
         *      | Tue Apr 15 2014 00:00:00 GMT-0400 (EDT)   | Millionth coffee drank   | 15                            |
         *      +-------------------------------------------+--------------------------+-------------------------------+
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TInteger);

            this.name = 'DayOfMonth';

        },

        /**
         * Gets the function's return value
         * @returns {number}
         */
        value: function () {

            return value(this.parameters[0]).getDate();

        }

    },{


    });

module.exports = FDayOfMonth;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../types/Integer.js":96}],48:[function(require,module,exports){
var Function = require('./../../Function.js');
var TInteger = require('./../../types/Integer.js');
var value = require('./../../helpers/value');

var FDayOfWeek = Function.extend(
    {

        /**
         * @class Functions.Date.DayOfWeek
         * @extends Function
         *
         * Function that extracts a date's day of the week
         *
         * Sunday is 0, Saturday is 6
         *
         * With extend operation :
         *
         *      var events = new affinity.Relation([
         *          {date : {type : affinity.Date}},
         *          {name : {type : affinity.String}}
         *      ],[
         *          [new Date(2014, 1, 07), 'Sochi'],
         *          [new Date(2014, 0, 02), 'Chocolate rush'],
         *          [new Date(2014, 3, 15), 'Millionth coffee drank']
         *      ])
         *
         *      var date = events.get('date')
         *
         *      var extended = events.extend([ { "date.dayOfWeek()" : date.dayOfWeek() } ]);
         *
         *      // or equivalent
         *
         *      var extended = events.extend([ { "date.dayOfWeek()" : new affinity.DayOfWeek(date) } ]);
         *
         *      extended.print();
         *
         *      // +-------------------------------------------+--------------------------+------------------------------+
         *      // | date : Date                               | name : String            | date.dayOfWeek() : Integer   |
         *      // +===========================================+==========================+==============================+
         *      // | Fri Feb 07 2014 00:00:00 GMT-0500 (EST)   | Sochi                    | 5                            |
         *      // +-------------------------------------------+--------------------------+------------------------------+
         *      // | Thu Jan 02 2014 00:00:00 GMT-0500 (EST)   | Chocolate rush           | 4                            |
         *      // +-------------------------------------------+--------------------------+------------------------------+
         *      // | Tue Apr 15 2014 00:00:00 GMT-0400 (EDT)   | Millionth coffee drank   | 2                            |
         *      // +-------------------------------------------+--------------------------+------------------------------+
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TInteger);

            this.name = 'DayOfWeek';

        },

        /**
         * Gets the function return value
         * @returns {number}
         */
        value: function () {

            return value(this.parameters[0]).getDay();

        }

    },{


    });

module.exports = FDayOfWeek;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../types/Integer.js":96}],49:[function(require,module,exports){
var Function = require('./../../Function.js');
var TInteger = require('./../../types/Integer.js');
var value = require('./../../helpers/value');

var FDayOfYear = Function.extend(
    {

        /**
         * @class Functions.Date.DayOfYear
         * @extends Function
         *
         * Function that extracts a date's day of the year
         *
         * January 1st is 0
         *
         * With extend operation :
         *
         *      var events = new affinity.Relation([
         *          {date : {type : affinity.Date}},
         *          {name : {type : affinity.String}}
         *      ],[
         *          [new Date(2014, 1, 07), 'Sochi'],
         *          [new Date(2014, 0, 02), 'Chocolate rush'],
         *          [new Date(2014, 3, 15), 'Millionth coffee drank']
         *      ])
         *
         *      var date = events.get('date')
         *
         *      var extended = events.extend([ { "date.dayOfYear()" : date.dayOfYear() } ]);
         *
         *      // or equivalent
         *
         *      var extended = events.extend([ { "date.dayOfYear()" : new affinity.DayOfYear(date) } ]);
         *
         *      extended.print();
         *
         *      // +-------------------------------------------+--------------------------+------------------------------+
         *      // | date : Date                               | name : String            | date.dayOfYear() : Integer   |
         *      // +===========================================+==========================+==============================+
         *      // | Fri Feb 07 2014 00:00:00 GMT-0500 (EST)   | Sochi                    | 37                           |
         *      // +-------------------------------------------+--------------------------+------------------------------+
         *      // | Thu Jan 02 2014 00:00:00 GMT-0500 (EST)   | Chocolate rush           | 1                            |
         *      // +-------------------------------------------+--------------------------+------------------------------+
         *      // | Tue Apr 15 2014 00:00:00 GMT-0400 (EDT)   | Millionth coffee drank   | 104                          |
         *      // +-------------------------------------------+--------------------------+------------------------------+
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TInteger);

            this.name = 'DayOfYear';

        },

        value: function () {

            var date = value(this.parameters[0]);

            var begin = new Date(date.getFullYear(),0,1);

            return Math.ceil((date - begin) / 86400000);

        }

    },{


    });

module.exports = FDayOfYear;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../types/Integer.js":96}],50:[function(require,module,exports){
var Function = require('./../../Function.js');
var TInteger = require('./../../types/Integer.js');
var value = require('./../../helpers/value');

var FHours = Function.extend(
    {

        /**
         * @class Functions.Date.Hours
         * @extends Function
         *
         * Function that extracts a date's hours component as an integer
         *
         * Midnight is 0
         *
         * With extend operation :
         *
         *      var wokeUp = new Date();
         *      wokeUp.setHours(8);
         *
         *      var breakfast = new Date();
         *      breakfast.setHours(9)
         *
         *      var dinner = new Date();
         *      dinner.setHours(18);
         *
         *      var events = new affinity.Relation([
         *          {time : {type : affinity.Date}},
         *          {name : {type : affinity.String}}
         *      ],[
         *          [wokeUp, 'Woke Up'],
         *          [breakfast, 'Breakfast'],
         *          [dinner, 'Dinner']
         *      ])
         *
         *      var time = events.get('time')
         *
         *      var extended = events.extend([ { "time.hours()" : time.hours() } ]);
         *
         *      // or equivalent
         *
         *      var extended = events.extend([ { "time.hours()" : new affinity.Hours(time) } ]);
         *
         *      extended.print();
         *
         *      // +-------------------------------------------+-----------------+--------------------------+
         *      // | time : Date                               | name : String   | time.hours() : Integer   |
         *      // +===========================================+=================+==========================+
         *      // | Sun Jun 29 2014 08:43:39 GMT-0400 (EDT)   | Woke Up         | 8                        |
         *      // +-------------------------------------------+-----------------+--------------------------+
         *      // | Sun Jun 29 2014 09:43:39 GMT-0400 (EDT)   | Breakfast       | 9                        |
         *      // +-------------------------------------------+-----------------+--------------------------+
         *      // | Sun Jun 29 2014 18:43:39 GMT-0400 (EDT)   | Dinner          | 18                       |
         *      // +-------------------------------------------+-----------------+--------------------------+
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TInteger);

            this.name = 'Hours';

        },

        /**
         * Gets the function's return value
         * @returns {number}
         */
        value: function () {

            return value(this.parameters[0]).getHours();

        }

    },{


    });

module.exports = FHours;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../types/Integer.js":96}],51:[function(require,module,exports){
var Function = require('./../../Function.js');
var TInteger = require('./../../types/Integer.js');
var value = require('./../../helpers/value');

var FMilliseconds = Function.extend(
    {

        /**
         * @class Functions.Date.Milliseconds
         * @extends Function
         *
         * Function that extracts a date's milliseconds component
         *
         * Midnight is 0
         *
         * With extend operation :
         *
         *      var date1 = new Date();
         *      date1.setMilliseconds(100);
         *
         *
         *      var date2 = new Date();
         *      date2.setMilliseconds(200);
         *
         *      var date3 = new Date();
         *      date3.setMilliseocnds(300);
         *
         *      var events = new affinity.Relation([
         *          {time : {type : affinity.Date}}
         *      ],[
         *         [date1], [date2], [date3]
         *      ])
         *
         *      var time = events.get('time')
         *
         *      var extended = events.extend([ { "time.milliseconds()" : time.milliseconds() } ]);
         *
         *      // or equivalent
         *
         *      var extended = events.extend([ { "time.milliseconds()" : new affinity.Milliseconds(time) } ]);
         *
         *      extended.print();
         *
         *      // +-------------------------------------------+---------------------------------+
         *      // | time : Date                               | time.milliseconds() : Integer   |
         *      // +===========================================+=================================+
         *      // | Sun Jun 29 2014 08:44:17 GMT-0400 (EDT)   | 100                             |
         *      // +-------------------------------------------+---------------------------------+
         *      // | Sun Jun 29 2014 08:44:17 GMT-0400 (EDT)   | 200                             |
         *      // +-------------------------------------------+---------------------------------+
         *      // | Sun Jun 29 2014 08:44:17 GMT-0400 (EDT)   | 557                             |
         *      // +-------------------------------------------+---------------------------------+
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TInteger);

            this.name = 'Milliseconds';

        },

        /**
         * Gets the function return value
         * @returns {number}
         */
        value: function () {

            return value(this.parameters[0]).getMilliseconds();

        }

    },{


    });

module.exports = FMilliseconds;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../types/Integer.js":96}],52:[function(require,module,exports){
var Function = require('./../../Function.js');
var TInteger = require('./../../types/Integer.js');
var value = require('./../../helpers/value');

var FMinutes = Function.extend(
    {

        /**
         * @class Functions.Date.Minutes
         * @extends Function
         *
         * Function that extracts a date's minutes component as an integer
         *
         *
         * With extend operation :
         *
         *      var quarterToFive = new Date();
         *      quarterToFive.setHours(4);
         *      quarterToFive.setMinutes(45);
         *
         *      var five = new Date();
         *      five.setHours(5)
         *      five.setMinutes(0);
         *
         *      var sixThirty = new Date();
         *      sixThirty.setHours(6);
         *      sixThirty.setMinutes(30);
         *
         *
         *      var events = new affinity.Relation([
         *          {time : {type : affinity.Date}},
         *          {name : {type : affinity.String}}
         *      ],[
         *          [quarterToFive, 'Quarter to Five'],
         *          [five, 'Five'],
         *          [sixThirty, 'Six Thirty']
         *      ])
         *
         *      var time = events.get('time')
         *
         *      var extended = events.extend([ { "time.minutes()" : time.minutes() } ]);
         *
         *      // or equivalent
         *
         *      var extended = events.extend([ { "time.minutes()" : new affinity.Minutes(time) } ]);
         *
         *      extended.print();
         *
         *      // +-------------------------------------------+-------------------+----------------------------+
         *      // | time : Date                               | name : String     | time.minutes() : Integer   |
         *      // +===========================================+===================+============================+
         *      // | Sun Jun 29 2014 04:45:49 GMT-0400 (EDT)   | Quarter to Five   | 45                         |
         *      // +-------------------------------------------+-------------------+----------------------------+
         *      // | Sun Jun 29 2014 05:00:49 GMT-0400 (EDT)   | Five              | 0                          |
         *      // +-------------------------------------------+-------------------+----------------------------+
         *      // | Sun Jun 29 2014 06:30:49 GMT-0400 (EDT)   | Six Thirty        | 30                         |
         *      // +-------------------------------------------+-------------------+----------------------------+
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TInteger);

            this.name = 'Minutes';

        },

        value: function () {

            return value(this.parameters[0]).getMinutes();

        }

    },{


    });

module.exports = FMinutes;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../types/Integer.js":96}],53:[function(require,module,exports){
var Function = require('./../../Function.js');
var TInteger = require('./../../types/Integer.js');
var value = require('./../../helpers/value');

var FMonth = Function.extend(
    {

        /**
         * @class Functions.Date.Month
         * @extends Function
         *
         * Function that extracts a date's month number
         *
         * January is 0
         *
         * With extend operation :
         *
         *      var events = new affinity.Relation([
         *          {date : {type : affinity.Date}},
         *          {name : {type : affinity.String}}
         *      ],[
         *          [new Date(2014, 1, 07), 'Sochi'],
         *          [new Date(2014, 0, 02), 'Chocolate rush'],
         *          [new Date(2014, 3, 15), 'Millionth coffee drank']
         *      ])
         *
         *      var date = events.get('date')
         *
         *      var extended = events.extend([ { "date.month()" : date.month() } ]);
         *
         *      // or equivalent
         *
         *      var extended = events.extend([ { "date.month()" : new affinity.Month(date) } ]);
         *
         *      extended.print();
         *
         *      // +-------------------------------------------+--------------------------+--------------------------+
         *      // | date : Date                               | name : String            | date.month() : Integer   |
         *      // +===========================================+==========================+==========================+
         *      // | Fri Feb 07 2014 00:00:00 GMT-0500 (EST)   | Sochi                    | 1                        |
         *      // +-------------------------------------------+--------------------------+--------------------------+
         *      // | Thu Jan 02 2014 00:00:00 GMT-0500 (EST)   | Chocolate rush           | 0                        |
         *      // +-------------------------------------------+--------------------------+--------------------------+
         *      // | Tue Apr 15 2014 00:00:00 GMT-0400 (EDT)   | Millionth coffee drank   | 3                        |
         *      // +-------------------------------------------+--------------------------+--------------------------+
         *      //
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TInteger);

            this.name = 'Month';

        },

        value: function () {

            return value(this.parameters[0]).getMonth();

        }

    },{


    });

module.exports = FMonth;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../types/Integer.js":96}],54:[function(require,module,exports){
var Function = require('./../../Function.js');
var TInteger = require('./../../types/Integer.js');
var value = require('./../../helpers/value');

var Seconds = Function.extend(
    {

        /**
         * @class Functions.Date.Seconds
         * @extends Function
         *
         * Function that extracts a date's second number
         *
         * With extend operation :
         *
         *      var events = new affinity.Relation([
         *          {date : {type : affinity.Date}},
         *          {name : {type : affinity.String}}
         *      ],[
         *          [new Date(), 'Now'],
         *      ])
         *
         *      var date = events.get('date')
         *
         *      var extended = events.extend([ { "date.seconds()" : date.seconds() } ]);
         *
         *      // or equivalent
         *
         *      var extended = events.extend([ { "date.seconds()" : new affinity.Seconds(date) } ]);
         *
         *      extended.print();
         *
         *      // +-------------------------------------------+-----------------+----------------------------+
         *      // | date : Date                               | name : String   | date.seconds() : Integer   |
         *      // +===========================================+=================+============================+
         *      // | Sun Jun 29 2014 08:51:05 GMT-0400 (EDT)   | Now             | 5                          |
         *      // +-------------------------------------------+-----------------+----------------------------+
         *      //
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TInteger);

            this.name = 'Seconds';

        },

        /**
         * Gets the function return value
         * @returns {number}
         */
        value: function () {

            return value(this.parameters[0]).getSeconds();

        }

    },{


    });

module.exports = Seconds;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../types/Integer.js":96}],55:[function(require,module,exports){
var Function = require('./../../Function.js');
var Integer = require('./../../types/Integer.js');
var value = require('./../../helpers/value');

var Timestamp = Function.extend(

    {

        /**
         * @class Functions.Date.Timestamp
         * @extends Function
         *
         * Function that extracts a date's timestamp
         *
         * With extend operation :
         *
         *      var events = new affinity.Relation([
         *          {date : {type : affinity.Date}},
         *          {name : {type : affinity.String}}
         *      ],[
         *          [new Date(), 'Now'],
         *      ])
         *
         *      var date = events.get('date')
         *
         *      var extended = events.extend([ { "date.timestamp()" : date.ts() } ]);
         *
         *      // or equivalent
         *
         *      var extended = events.extend([ { "date.timestamp()" : new affinity.Timestamp(date) } ]);
         *
         *      extended.print();
         *
         *      // +-------------------------------------------+-----------------+------------------------------+
         *      // | date : Date                               | name : String   | date.timestamp() : Integer   |
         *      // +===========================================+=================+==============================+
         *      // | Sun Jun 29 2014 10:02:34 GMT-0400 (EDT)   | Now             | 1404050554805                |
         *      // +-------------------------------------------+-----------------+------------------------------+
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(Integer);

            this.name = 'Timestamp';

        },

        value: function () {

            var param = value(this.parameters[0]);

            return value(this.parameters[0]).getTime();

        }

    },{


    });

module.exports = Timestamp;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../types/Integer.js":96}],56:[function(require,module,exports){
var Function = require('./../../Function.js');
var TInteger = require('./../../types/Integer.js');
var value = require('./../../helpers/value');

var WeekOfYear = Function.extend(
    {

        /**
         * @class Functions.Date.WeekOfYear
         * @extends Function
         *
         * Function that extracts a date's week number (0-51)
         *
         * With extend operation :
         *
         *      var events = new affinity.Relation([
         *          {date : {type : affinity.Date}},
         *          {name : {type : affinity.String}}
         *      ],[
         *          [new Date(2014, 02, 07), 'Sochi'],
         *          [new Date(2014, 01, 02), 'Chocolate rush'],
         *          [new Date(2014, 04, 15), 'Millionth coffee drank']
         *      ])
         *
         *      var date = events.get('date')
         *
         *      var extended = events.extend([ { "date.weekOfYear()" : date.weekOfYear() } ]);
         *
         *      // or equivalent
         *
         *      var extended = events.extend([ { "date.weekOfYear()" : new affinity.weekOfYear(date) } ]);
         *
         *      extended.print();
         *
         *      // +-------------------------------------------+--------------------------+-------------------------------+
         *      // | date : Date                               | name : String            | date.weekOfYear() : Integer   |
         *      // +===========================================+==========================+===============================+
         *      // | Fri Mar 07 2014 00:00:00 GMT-0500 (EST)   | Sochi                    | 10                            |
         *      // +-------------------------------------------+--------------------------+-------------------------------+
         *      // | Sun Feb 02 2014 00:00:00 GMT-0500 (EST)   | Chocolate rush           | 5                             |
         *      // +-------------------------------------------+--------------------------+-------------------------------+
         *      // | Thu May 15 2014 00:00:00 GMT-0400 (EDT)   | Millionth coffee drank   | 20                            |
         *      // +-------------------------------------------+--------------------------+-------------------------------+
         *      //
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TInteger);

            this.name = 'WeekOfYear';

        },

        /**
         * Gets the function return value
         * @returns {number}
         */
        value: function () {

            var d = new Date(+value(this.parameters[0]));
            d.setHours(0,0,0);
            d.setDate(d.getDate()+4-(d.getDay()||7));
            return Math.ceil((((d-new Date(d.getFullYear(),0,1))/8.64e7)+1)/7);

        }

    },{


    });

module.exports = WeekOfYear;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../types/Integer.js":96}],57:[function(require,module,exports){
var Function = require('./../../Function.js');
var TInteger = require('./../../types/Integer.js');
var value = require('./../../helpers/value');

var Year = Function.extend(
    {

        /**
         * @class Functions.Date.Year
         * @extends Function
         *
         *
         * Function that extracts a date's full year number
         *
         * With extend operation :
         *
         *      var events = new affinity.Relation([
         *          {date : {type : affinity.Date}},
         *          {name : {type : affinity.String}}
         *      ],[
         *          [new Date(2013, 01, 02)],
         *          [new Date(2011, 06, 30)],
         *          [new Date(2010, 04, 15)]
         *      ])
         *
         *      var date = events.get('date')
         *
         *      var extended = events.extend([ { "date.year()" : date.year() } ]);
         *
         *      // or equivalent
         *
         *      var extended = events.extend([ { "date.year()" : new affinity.Year(date) } ]);
         *
         *      extended.print();
         *
         *      // +-------------------------------------------+--------------------------+-------------------------+
         *      // | date : Date                               | name : String            | date.year() : Integer   |
         *      // +===========================================+==========================+=========================+
         *      // | Fri Mar 07 2014 00:00:00 GMT-0500 (EST)   | Sochi                    | 2014                    |
         *      // +-------------------------------------------+--------------------------+-------------------------+
         *      // | Sun Feb 02 2014 00:00:00 GMT-0500 (EST)   | Chocolate rush           | 2014                    |
         *      // +-------------------------------------------+--------------------------+-------------------------+
         *      // | Thu May 15 2014 00:00:00 GMT-0400 (EDT)   | Millionth coffee drank   | 2014                    |
         *      // +-------------------------------------------+--------------------------+-------------------------+
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TInteger);

            this.name = 'Year';

        },

        value: function () {

            return value(this.parameters[0]).getFullYear();

        }

    },{


    });

module.exports = Year;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../types/Integer.js":96}],58:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');

var Absolute = Function.extend(
    {

        /**
         * @class Functions.Numeric.Absolute
         * @extends Function
         *
         * Function that extracts the Absolute value of a Number
         *
         * Example with Extend operator :
         *
         *      var relation = new affinity.Relation([
         *          { A :  {type : affinity.Integer} },
         *      ],[
         *          [-10], [-5], [0], [5], [10]]
         *      ])
         *
         *      var A = relation.get('A');
         *
         *
         *      var extended = relation.extend([{ "A.abs()" : A.abs() }]);
         *
         *      // or
         *
         *      var extended = relation.extend([{ "A.abs()" : new affinity.Absolute(A) }]);
         *
         *      extended.print();
         *
         *      //+---------------+---------------------+
         *      //| A : Integer   | A.abs() : Integer   |
         *      //+===============+=====================+
         *      //| -10           | 10                  |
         *      //+---------------+---------------------+
         *      //| -5            | 5                   |
         *      //+---------------+---------------------+
         *      //| 0             | 0                   |
         *      //+---------------+---------------------+
         *      //| 5             | 5                   |
         *      //+---------------+---------------------+
         *      //| 10            | 10                  |
         *      //+---------------+---------------------+
         *
         */

        /**
         * @param {Number|Function|Attribute} param The number to absolucize
         *
         * Create a new Absolute function
         */
        constructor: function (param) {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TNumeric);

            this.name = 'Absolute';

        },

        /**
         * @returns {Number} The result
         *
         * Gets the function result
         */
        value: function () {

            return Math.abs(value(this.parameters[0]));

        }

    });

Absolute.mixin(require('./../../mixins/numeric'));
Absolute.mixin(require('./../../mixins/comparable'));
Absolute.mixin(require('./../../mixins/size-comparable'));

module.exports = Absolute;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../mixins/comparable":86,"./../../mixins/numeric":90,"./../../mixins/size-comparable":91,"./../../types/Numeric.js":97}],59:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');

var FCeil = Function.extend(
    {

        /**
         * @class Functions.Numeric.Ceil
         * @extends Function
         *
         * Function that rounds a number upwards
         *
         * Example with Extend operator :
         *
         *      var relation = new affinity.Relation([
         *          { A :  {type : affinity.Integer} },
         *      ],[
         *          [1.01], [-2.85], [3], [3.12], [10.2]]
         *      ])
         *
         *      var A = relation.get('A');
         *
         *
         *      var extended = relation.extend([{ "A.ceil()" : A.ceil() }]);
         *
         *      // or
         *
         *      var extended = relation.extend([{ "A.ceil()" : new affinity.Ceil(A) }]);
         *
         *      extended.print();
         *
         *      //+---------------+----------------------+
         *      //| A : Integer   | A.ceil() : Integer   |
         *      //+===============+======================+
         *      //| 1.01          | 2                    |
         *      //+---------------+----------------------+
         *      //| -2.85         | -2                   |
         *      //+---------------+----------------------+
         *      //| 3             | 3                    |
         *      //+---------------+----------------------+
         *      //| 3.12          | 4                    |
         *      //+---------------+----------------------+
         *      //| 10.2          | 11                   |
         *      //+---------------+----------------------+
         *
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TNumeric);

            this.name = 'Ceil';

        },

        /**
         * Gets the function return value
         * @returns {number}
         */
        value: function () {

            return Math.ceil(value(this.parameters[0]));

        }

    });

FCeil.mixin(require('./../../mixins/numeric'));
FCeil.mixin(require('./../../mixins/comparable'));
FCeil.mixin(require('./../../mixins/size-comparable'));

module.exports = FCeil;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../mixins/comparable":86,"./../../mixins/numeric":90,"./../../mixins/size-comparable":91,"./../../types/Numeric.js":97}],60:[function(require,module,exports){
var Function = require('./../../Function.js');
var Numeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');

var Cosine = Function.extend(
    {

        /**
         * @class Functions.Numeric.Cosine
         * @extends Function
         *
         * Function that returns the cosine of a number
         *
         * Example with Extend operator :
         *
         *      var relation = new affinity.Relation([
         *          { A :  {type : affinity.Integer} },
         *      ],[
         *          [0], [Math.PI/2], [Math.PI], [3*Math.PI/2], [2*Math.PI]
         *      ])
         *
         *      var A = relation.get('A');
         *
         *
         *      var extended = relation.extend([{ "cos(A)" : A.cos() }]);
         *
         *      // or
         *
         *      var extended = relation.extend([{ "cos(A)" : new affinity.Cosine(A) }]);
         *
         *      extended.print();
         *
         *      // The following result shows a bug, but it's not affinity's fault.
         *      // Due to a bug in V8
         *      // (see this http://stackoverflow.com/questions/24455775/why-does-node-not-evaluate-math-tanmath-pi-2-to-infinity-but-chrome-v8-does)
         *      // Math.tan(Math.PI/2) won't evaluate to Infinity.
         *      // Math.tan(Math.PI) won't evaluate to 0.
         *      // And so on. This is due to Math.cos(Math.PI/2) not evaluating to 0.
         *
         *      // This will be fixed in node v0.11. as I tested the v0.11.14-pre version.
         *
         *      //+---------------+--------------------------+
         *      //| A : Integer   | cos(A) : Numeric         |
         *      //+===============+==========================+
         *      //| 0             | 1                        |
         *      //+---------------+--------------------------+
         *      //| PI/2          | 6.123031769111886e-17    |
         *      //+---------------+--------------------------+
         *      //|              | -1                       |
         *      //+---------------+--------------------------+
         *      //| 3/2          | -1.836909530733566e-16   |
         *      //+---------------+--------------------------+
         *      //| 2            | 1                        |
         *      //+---------------+--------------------------+
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(Numeric);

            this.name = 'Cos';

        },

        /**
         * Gets the function result
         * @returns {Number}
         */
        value: function () {

            return Math.cos(value(this.parameters[0]));

        }

    });

Cosine.mixin(require('./../../mixins/numeric'));
Cosine.mixin(require('./../../mixins/comparable'));
Cosine.mixin(require('./../../mixins/size-comparable'));

module.exports = Cosine;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../mixins/comparable":86,"./../../mixins/numeric":90,"./../../mixins/size-comparable":91,"./../../types/Numeric.js":97}],61:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');

var FDivision = Function.extend(
    {

        /**
         * @class Functions.Numeric.Division
         * @extends Function
         *
         * Function that returns the result of a division between two numbers
         *
         * Example with Extend operator :
         *
         *      var relation = new affinity.Relation([
         *          { A :  {type : affinity.Integer} },
         *      ],[
         *          [-2], [-1], [0], [1], [2]]
         *      ])
         *
         *      var relation2 = relation.extend([{B : relation.get('A')}]);
         *
         *      var product = relation2.project(['A']).product(relation2.get('B'));
         *
         *      var A = product.get('A');
         *      var B = product.get('B');
         *
         *
         *      var extended = product.extend([{"A / B" : A.div(B)}]);
         *
         *      // or equivalent
         *
         *      new affinity.Extend(product, [{ "A / B" : new affinity.Division(A, B) }])
         *
         *
         *      extended.print();
         *
         *
         *      // (Standard behaviour of JavaScript)
         *      // +---------------+---------------+-----------------+
         *      // | A : Integer   | B : Integer   | A / B : Numeric |
         *      // +===============+===============+=================+
         *      // | -2            | -2            | 1               |
         *      // +---------------+---------------+-----------------+
         *      // | -2            | -1            | 2               |
         *      // +---------------+---------------+-----------------+
         *      // | -2            | 0             | -Infinity       |
         *      // +---------------+---------------+-----------------+
         *      // | -2            | 1             | -2              |
         *      // +---------------+---------------+-----------------+
         *      // | -2            | 2             | -1              |
         *      // +---------------+---------------+-----------------+
         *      // | -1            | -2            | 0.5             |
         *      // +---------------+---------------+-----------------+
         *      // | -1            | -1            | 1               |
         *      // +---------------+---------------+-----------------+
         *      // | -1            | 0             | -Infinity       |
         *      // +---------------+---------------+-----------------+
         *      // | -1            | 1             | -1              |
         *      // +---------------+---------------+-----------------+
         *      // | -1            | 2             | -0.5            |
         *      // +---------------+---------------+-----------------+
         *      // | 0             | -2            | 0               |
         *      // +---------------+---------------+-----------------+
         *      // | 0             | -1            | 0               |
         *      // +---------------+---------------+-----------------+
         *      // | 0             | 0             | NaN             |
         *      // +---------------+---------------+-----------------+
         *      // | 0             | 1             | 0               |
         *      // +---------------+---------------+-----------------+
         *      // | 0             | 2             | 0               |
         *      // +---------------+---------------+-----------------+
         *      // | 1             | -2            | -0.5            |
         *      // +---------------+---------------+-----------------+
         *      // | 1             | -1            | -1              |
         *      // +---------------+---------------+-----------------+
         *      // | 1             | 0             | Infinity        |
         *      // +---------------+---------------+-----------------+
         *      // | 1             | 1             | 1               |
         *      // +---------------+---------------+-----------------+
         *      // | 1             | 2             | 0.5             |
         *      // +---------------+---------------+-----------------+
         *      // | 2             | -2            | -1              |
         *      // +---------------+---------------+-----------------+
         *      // | 2             | -1            | -2              |
         *      // +---------------+---------------+-----------------+
         *      // | 2             | 0             | Infinity        |
         *      // +---------------+---------------+-----------------+
         *      // | 2             | 1             | 2               |
         *      // +---------------+---------------+-----------------+
         *      // | 2             | 2             | 1               |
         *      // +---------------+---------------+-----------------+
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TNumeric);

            this.name = 'Division';

        },

        /**
         * Gets the function result
         * @returns {number}
         */
        value: function () {

            return value(this.parameters[0])/value(this.parameters[1]);

        }

    });

FDivision.mixin(require('./../../mixins/numeric'));
FDivision.mixin(require('./../../mixins/comparable'));
FDivision.mixin(require('./../../mixins/size-comparable'));

module.exports = FDivision;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../mixins/comparable":86,"./../../mixins/numeric":90,"./../../mixins/size-comparable":91,"./../../types/Numeric.js":97}],62:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');

var FExp = Function.extend(
    {

        /**
         * @class Functions.Numeric.Exponential
         * @extends Function
         *
         * Returns the exponential of a number (e^x)
         *
         * Example :
         *
         *     var relation = new affinity.Relation([{ A : {type : affinity.Integer} }],[[-2], [-1],[0],[1],[2]]);
         *
         *     var extended = relation.extend([{ "A.exp()" : relation.get('A').exp()}])
         *
         *     or equivalent
         *
         *     var extended = relation.extend([{ "A.exp()" : new affinity.Exp(A)}]);
         *
         *     extended.print();
         *
         *     // +---------------+-----------------------+
         *     // | A : Integer   | A.exp() : Numeric     |
         *     // +===============+=======================+
         *     // | -2            | 0.1353352832366127    |
         *     // +---------------+-----------------------+
         *     // | -1            | 0.36787944117144233   |
         *     // +---------------+-----------------------+
         *     // | 0             | 1                     |
         *     // +---------------+-----------------------+
         *     // | 1             | 2.718281828459045     |
         *     // +---------------+-----------------------+
         *     // | 2             | 7.38905609893065      |
         *     // +---------------+-----------------------+
         *
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TNumeric);

            this.name = 'Exponent';

        },

        /**
         * Gets the function result
         * @returns {number}
         */
        value: function () {

            return Math.exp(value(this.parameters[0]));

        }

    });

FExp.mixin(require('./../../mixins/numeric'));
FExp.mixin(require('./../../mixins/comparable'));
FExp.mixin(require('./../../mixins/size-comparable'));

module.exports = FExp;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../mixins/comparable":86,"./../../mixins/numeric":90,"./../../mixins/size-comparable":91,"./../../types/Numeric.js":97}],63:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');

var Floor = Function.extend(
    {

        /**
         * @class Functions.Numeric.Floor
         * @extends Function
         *
         * Function that rounds a number downwards
         *
         * Example with Extend operator :
         *
         *      var relation = new affinity.Relation([
         *          { A :  {type : affinity.Integer} },
         *      ],[
         *          [1.01], [-2.85], [3], [3.12], [10.2]]
         *      ])
         *
         *      var A = relation.get('A');
         *
         *
         *      var extended = relation.extend([{ "A.floor()" : A.Floor() }]);
         *
         *      // or
         *
         *      var extended = relation.extend([{ "A.floor()" : new affinity.floor(A) }]);
         *
         *      extended.print();
         *
         *      //+---------------+-----------------------+
         *      //| A : Integer   | A.floor() : Integer   |
         *      //+===============+=======================+
         *      //| 1.01          | 1                     |
         *      //+---------------+-----------------------+
         *      //| -2.85         | -3                    |
         *      //+---------------+-----------------------+
         *      //| 3             | 3                     |
         *      //+---------------+-----------------------+
         *      //| 3.12          | 3                     |
         *      //+---------------+-----------------------+
         *      //| 10.2          | 10                    |
         *      //+---------------+-----------------------+
         *
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TNumeric);

            this.name = 'Floor';

        },

        /**
         * Gets the function return value
         * @returns {number}
         */
        value: function () {

            return Math.floor(value(this.parameters[0]));

        }

    });

Floor.mixin(require('./../../mixins/numeric'));
Floor.mixin(require('./../../mixins/comparable'));
Floor.mixin(require('./../../mixins/size-comparable'));

module.exports = Floor;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../mixins/comparable":86,"./../../mixins/numeric":90,"./../../mixins/size-comparable":91,"./../../types/Numeric.js":97}],64:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');
var type = require('./../../helpers/type');

var FMinus = Function.extend(
    {

        /**
         * @class Functions.Numeric.Minus
         * @extends Function
         *
         * Subtracts two numbers
         *
         * Example :
         *
         *     var relation = new affinity.Relation([
         *              {A : {type : affinity.Integer}},
         *              {B : {type : affinity.Integer}}
         *          ],[
         *              [1, 2],
         *              [0, 0],
         *              [10, 1]
         *          ]);
         *
         *     var A = relation.get('A');
         *     var B = relation.get('B');
         *
         *     var extended = relation.extend([{ "A - B" : A.minus(B)}])
         *
         *     // or equivalent
         *
         *     var extended = relation.extend([{"A - B" : new affinity.Minus(A, B)}])
         *
         *     extended.print();
         *
         *     // +---------------+---------------+-------------------+
         *     // | A : Integer   | B : Integer   | A - B : Integer   |
         *     // +===============+===============+===================+
         *     // | 1             | 2             | -1                |
         *     // +---------------+---------------+-------------------+
         *     // | 0             | 0             | 0                 |
         *     // +---------------+---------------+-------------------+
         *     // | 10            | 1             | 9                 |
         *     // +---------------+---------------+-------------------+
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(type(this.parameters[0]));

            this.name = 'Minus';

        },

        /**
         * Gets the function return value
         * @returns {number}
         */
        value: function () {

            return this.type().coerce(value(this.parameters[0])-value(this.parameters[1]));

        }

    });

FMinus.mixin(require('./../../mixins/numeric'));
FMinus.mixin(require('./../../mixins/comparable'));
FMinus.mixin(require('./../../mixins/size-comparable'));

module.exports = FMinus;
},{"./../../Function.js":5,"./../../helpers/type":84,"./../../helpers/value":85,"./../../mixins/comparable":86,"./../../mixins/numeric":90,"./../../mixins/size-comparable":91,"./../../types/Numeric.js":97}],65:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');

var FModulo = Function.extend(
    {

        /**
         * @class Functions.Numeric.Modulo
         * @extends Function
         *
         * Gets the modulo of two numbers
         *
         * Example :
         *
         *     var relation = new affinity.Relation([
         *              {A : {type : affinity.Integer}},
         *              {B : {type : affinity.Integer}}
         *          ],[
         *              [1, 2],
         *              [0, 0],
         *              [10, 1],
         *              [10, 2]
         *          ]);
         *
         *     var A = relation.get('A');
         *     var B = relation.get('B');
         *
         *     var extended = relation.extend([{"A % B" : A.mod(B)}]);
         *
         *     // or equivalent
         *
         *     var extended = relation.extend([{"A % B" : new affinity.Modulo(A, B)}]);
         *
         *     extended.print();
         *
         *     // +---------------+---------------+--------------------+
         *     // | A : Integer   | B : Integer   | A % B : Numeric    |
         *     // +===============+===============+====================+
         *     // | 1             | 2             | 1                  |
         *     // +---------------+---------------+--------------------+
         *     // | 0             | 0             | NaN                |
         *     // +---------------+---------------+--------------------+
         *     // | 10            | 1             | 0                  |
         *     // +---------------+---------------+--------------------+
         *     // | 10            | 2             | 0                  |
         *     // +---------------+---------------+--------------------+
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TNumeric);

            this.name = 'Modulo';

        },

        /**
         * Gets the function return value
         * @returns {number}
         */
        value : function () {

            return value(this.parameters[0])%value(this.parameters[1]);

        }

    });

FModulo.mixin(require('./../../mixins/numeric'));
FModulo.mixin(require('./../../mixins/comparable'));
FModulo.mixin(require('./../../mixins/size-comparable'));

module.exports = FModulo;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../mixins/comparable":86,"./../../mixins/numeric":90,"./../../mixins/size-comparable":91,"./../../types/Numeric.js":97}],66:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');

var FMultiplication = Function.extend(
    {

        /**
         * @class Functions.Numeric.Multiplication
         * @extends Function
         *
         * Multiplies two numbers
         *
         * example :
         *
         *     var relation = new affinity.Relation([
         *          { A : { type : affinity.Integer}},
         *          { B : { type : affinity.Integer}},
         *     ],[
         *          [1, -1],
         *          [-1, 1],
         *          [0, 10],
         *          [1, 10],
         *          [2, -10],
         *     ])
         *
         *     var A = relation.get('A')
         *     var B = relation.get('B')
         *
         *     var extended = relation.extend([{ "A x B" : A.times(B)}])
         *
         *     // or
         *
         *     var extended = relation.extend([{ "A x B" : new affinity.Multiplication(A, B)}])
         *
         *     extended.print()
         *
         *     // +---------------+---------------+-----------------+
         *     // | A : Integer   | B : Integer   | A x B : Numeric |
         *     // +===============+===============+=================+
         *     // | 1             | -1            | -1              |
         *     // +---------------+---------------+-----------------+
         *     // | -1            | 1             | -1              |
         *     // +---------------+---------------+-----------------+
         *     // | 0             | 10            | 0               |
         *     // +---------------+---------------+-----------------+
         *     // | 1             | 10            | 10              |
         *     // +---------------+---------------+-----------------+
         *     // | 2             | -10           | -20             |
         *     // +---------------+---------------+-----------------+
         *
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TNumeric);

            this.name = 'Multiplication';

        },

        value : function () {

            return value(this.parameters[0])*value(this.parameters[1]);

        }

    });

FMultiplication.mixin(require('./../../mixins/numeric'));
FMultiplication.mixin(require('./../../mixins/comparable'));
FMultiplication.mixin(require('./../../mixins/size-comparable'));

module.exports = FMultiplication;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../mixins/comparable":86,"./../../mixins/numeric":90,"./../../mixins/size-comparable":91,"./../../types/Numeric.js":97}],67:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');
var type = require('./../../helpers/type');

var Plus = Function.extend(
    {

        /**
         * @class Functions.Numeric.Plus
         * @extends Function
         *
         * Adds two numbers
         *
         * example :
         *
         *     var relation = new affinity.Relation([
         *          { A : { type : affinity.Integer}},
         *          { B : { type : affinity.Integer}},
         *     ],[
         *          [1, -1],
         *          [-1, 1],
         *          [0, 10],
         *          [1, 10],
         *          [2, -10],
         *     ])
         *
         *     var A = relation.get('A')
         *     var B = relation.get('B')
         *
         *     var extended = relation.extend([{ "A + B" : A.plus(B)}])
         *
         *     // or
         *
         *     var extended = relation.extend([{ "A + B" : new affinity.Plus(A, B)}])
         *
         *     extended.print()
         *
         *     // +---------------+---------------+-----------------+
         *     // | A : Integer   | B : Integer   | A + B : Numeric |
         *     // +===============+===============+=================+
         *     // | 1             | -1            | 0               |
         *     // +---------------+---------------+-----------------+
         *     // | -1            | 1             | 0               |
         *     // +---------------+---------------+-----------------+
         *     // | 0             | 10            | 10              |
         *     // +---------------+---------------+-----------------+
         *     // | 1             | 10            | 11              |
         *     // +---------------+---------------+-----------------+
         *     // | 2             | -10           | -18             |
         *     // +---------------+---------------+-----------------+
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(this.parameters[0]);

            this.name = 'Plus';

        },

        /**
         * Gets the function return value
         * @returns {number}
         */
        value: function () {

            return this.type().coerce(value(this.parameters[0])+value(this.parameters[1]));

        }

    });

Plus.mixin(require('./../../mixins/numeric'));
Plus.mixin(require('./../../mixins/comparable'));
Plus.mixin(require('./../../mixins/size-comparable'));

module.exports = Plus;
},{"./../../Function.js":5,"./../../helpers/type":84,"./../../helpers/value":85,"./../../mixins/comparable":86,"./../../mixins/numeric":90,"./../../mixins/size-comparable":91,"./../../types/Numeric.js":97}],68:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');

var FPow = Function.extend(
    {

        /**
         * @class Functions.Numeric.Power
         * @extends Function
         *
         * Returns a number to the power of another number
         *
         * example :
         *
         *     var relation = new affinity.Relation([
         *          { A : { type : affinity.Integer}},
         *          { B : { type : affinity.Integer}},
         *     ],[
         *          [1, -1],
         *          [-1, 1],
         *          [0, 10],
         *          [1, 10],
         *          [2, -10],
         *     ])
         *
         *     var A = relation.get('A')
         *     var B = relation.get('B')
         *
         *     var extended = relation.extend([{ "A ^ B" : A.pow(B)}])
         *
         *     // or
         *
         *     var extended = relation.extend([{ "A ^ B" : new affinity.Pow(A, B)}])
         *
         *     extended.print()
         *
         *     // +---------------+---------------+-----------------+
         *     // | A : Integer   | B : Integer   | A ^ B : Numeric |
         *     // +===============+===============+=================+
         *     // | 1             | -1            | 1               |
         *     // +---------------+---------------+-----------------+
         *     // | -1            | 1             | -1              |
         *     // +---------------+---------------+-----------------+
         *     // | 0             | 10            | 0               |
         *     // +---------------+---------------+-----------------+
         *     // | 1             | 10            | 1               |
         *     // +---------------+---------------+-----------------+
         *     // | 2             | -10           | 0.0009765625    |
         *     // +---------------+---------------+-----------------+
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TNumeric);

            this.name = 'Power';

        },

        /**
         * Gets the function's return value;
         * @returns {number}
         */
        value: function () {

            return Math.pow(value(this.parameters[0]),value(this.parameters[1]));

        }

    });

FPow.mixin(require('./../../mixins/numeric'));
FPow.mixin(require('./../../mixins/comparable'));
FPow.mixin(require('./../../mixins/size-comparable'));

module.exports = FPow;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../mixins/comparable":86,"./../../mixins/numeric":90,"./../../mixins/size-comparable":91,"./../../types/Numeric.js":97}],69:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');

var Round = Function.extend(
    {

        /**
         * @class Functions.Numeric.Round
         * @extends Function
         *
         * Rounds a number to its closest whole number
         *
         * example :
         *
         *     var relation = new affinity.Relation([
         *          { A : { type : affinity.Integer}}
         *     ],[
         *          [-10],[-5],[-2],[-1],[0],[1],[2],[5],[10]
         *     ]);
         *
         *     var A = relation.get('A');
         *
         *     var extended = relation.extend([{"A.sqrt()" : A.sqrt()}, {"A.sqrt().round()" : A.sqrt().round()}]);
         *
         *     // or
         *
         *     var extended = relation.extend([
         *         {"A.sqrt()"         : new affinity.SquareRoot(A)},
         *         {"A.sqrt().round()" : new affinity.Round(new affinity.SquareRoot(A))}
         *     ]);
         *
         *     extended.print();
         *
         *     // +---------------+----------------------+------------------------------+
         *     // | A : Integer   | A.sqrt() : Numeric   | A.sqrt().round() : Numeric   |
         *     // +===============+======================+==============================+
         *     // | -10           | NaN                  | NaN                          |
         *     // +---------------+----------------------+------------------------------+
         *     // | -5            | NaN                  | NaN                          |
         *     // +---------------+----------------------+------------------------------+
         *     // | -2            | NaN                  | NaN                          |
         *     // +---------------+----------------------+------------------------------+
         *     // | -1            | NaN                  | NaN                          |
         *     // +---------------+----------------------+------------------------------+
         *     // | 0             | 0                    | 0                            |
         *     // +---------------+----------------------+------------------------------+
         *     // | 1             | 1                    | 1                            |
         *     // +---------------+----------------------+------------------------------+
         *     // | 2             | 1.4142135623730951   | 1                            |
         *     // +---------------+----------------------+------------------------------+
         *     // | 5             | 2.23606797749979     | 2                            |
         *     // +---------------+----------------------+------------------------------+
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TNumeric);

            this.name = 'Round';

        },

        /**
         * Gets the function's return value
         * @returns {number}
         */
        value: function () {

            return Math.round(value(this.parameters[0]));

        }

    });

Round.mixin(require('./../../mixins/numeric'));
Round.mixin(require('./../../mixins/comparable'));
Round.mixin(require('./../../mixins/size-comparable'));

module.exports = Round;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../mixins/comparable":86,"./../../mixins/numeric":90,"./../../mixins/size-comparable":91,"./../../types/Numeric.js":97}],70:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');

var Sine = Function.extend(
    {

        /**
         * @class Functions.Numeric.Sine
         * @extends Function
         *
         * Function that returns the sine of a number
         *
         * Example with Extend operator :
         *
         *      var relation = new affinity.Relation([
         *          { A :  {type : affinity.Integer} },
         *      ],[
         *          [0], [Math.PI/2], [Math.PI], [3*Math.PI/2], [2*Math.PI]
         *      ])
         *
         *      var A = relation.get('A');
         *
         *
         *      var extended = relation.extend([{ "sin(A)" : A.sin() }]);
         *
         *      // or
         *
         *      var extended = relation.extend([{ "sin(A)" : new affinity.Sine(A) }]);
         *
         *      extended.print();
         *
         *      //+---------------+------------------+
         *      //| A : Integer   | sin(A) : Numeric |
         *      //+===============+==================+
         *      //| 0             | 0                |
         *      //+---------------+------------------+
         *      //| PI/2          | 1                |
         *      //+---------------+------------------+
         *      //|              | 0                |
         *      //+---------------+------------------+
         *      //| 3/2          | 1                |
         *      //+---------------+------------------+
         *      //| 2            | 0                |
         *      //+---------------+------------------+
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TNumeric);

            this.name = 'Sine';

        },

        /**
         * Gets the function return value
         * @returns {number}
         */
        value: function () {

            return Math.sin(value(this.parameters[0]));

        }

    });

Sine.mixin(require('./../../mixins/numeric'));
Sine.mixin(require('./../../mixins/comparable'));
Sine.mixin(require('./../../mixins/size-comparable'));

module.exports = Sine;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../mixins/comparable":86,"./../../mixins/numeric":90,"./../../mixins/size-comparable":91,"./../../types/Numeric.js":97}],71:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');

var FSquareRoot = Function.extend(
    {

        /**
         * @class Functions.Numeric.SquareRoot
         * @extends Function
         *
         *
         * Returns the square root of a number
         *
         * example :
         *
         *     var relation = new affinity.Relation([
         *          { A : { type : affinity.Integer}}
         *     ],[
         *          [-10],[-5],[-2],[-1],[0],[1],[2],[5],[10]
         *     ])
         *
         *     var A = relation.get('A')
         *
         *     var extended = relation.extend([{"A.sqrt()" : A.sqrt()}]);
         *
         *     // or
         *
         *     var extended = relation.extend([{ "A.sqrt()" : new affinity.Sqrt(A)}])
         *
         *     extended.print();
         *
         *     // +---------------+----------------------+
         *     // | A : Integer   | A.sqrt() : Numeric   |
         *     // +===============+======================+
         *     // | -10           | NaN                  |
         *     // +---------------+----------------------+
         *     // | -5            | NaN                  |
         *     // +---------------+----------------------+
         *     // | -2            | NaN                  |
         *     // +---------------+----------------------+
         *     // | -1            | NaN                  |
         *     // +---------------+----------------------+
         *     // | 0             | 0                    |
         *     // +---------------+----------------------+
         *     // | 1             | 1                    |
         *     // +---------------+----------------------+
         *     // | 2             | 1.4142135623730951   |
         *     // +---------------+----------------------+
         *     // | 5             | 2.23606797749979     |
         *     // +---------------+----------------------+
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TNumeric);

            this.name = 'Square Root';

        },

        /**
         * Gets the function result
         * @returns {number}
         */
        value: function () {

            return Math.sqrt(value(this.parameters[0]));

        }

    });

FSquareRoot.mixin(require('./../../mixins/numeric'));
FSquareRoot.mixin(require('./../../mixins/comparable'));
FSquareRoot.mixin(require('./../../mixins/size-comparable'));

module.exports = FSquareRoot;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../mixins/comparable":86,"./../../mixins/numeric":90,"./../../mixins/size-comparable":91,"./../../types/Numeric.js":97}],72:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');

var Tangent = Function.extend(
    {

        /**
         * @class Functions.Numeric.Tangent
         * @extends Function
         *
         * Function that returns the Tangent of a number
         *
         * Example with Extend operator :
         *
         *      var relation = new affinity.Relation([
         *          { A :  {type : affinity.Integer} },
         *      ],[
         *          [0], [Math.PI/2], [Math.PI], [3*Math.PI/2], [2*Math.PI]
         *      ]);
         *
         *      var A = relation.get('A');
         *
         *
         *      var extended = relation.extend([{ "tan(A)" : A.tan() }]);
         *
         *      // or
         *
         *      var extended = relation.extend([{ "tan(A)" : new affinity.Tangent(A) }]);
         *
         *      extended.print();
         *
         *      // The following result shows a bug, but it's not affinity's fault.
         *      // Due to a bug in V8
         *      // (see this http://stackoverflow.com/questions/24455775/why-does-node-not-evaluate-math-tanmath-pi-2-to-infinity-but-chrome-v8-does)
         *      // Math.tan(Math.PI/2) won't evaluate to Infinity.
         *      // Math.tan(Math.PI) won't evaluate to 0.
         *      // And so on. This is due to Math.cos(Math.PI/2) not evaluating to 0.
         *
         *      // This will be fixed in node v0.11. as I tested the v0.11.14-pre version.
         *
         *      //+---------------+---------------------------+
         *      //| A : Integer   | tan(A) : Numeric          |
         *      //+===============+===========================+
         *      //| 0             | 0                         |
         *      //+---------------+---------------------------+
         *      //| PI/2          | 16331778728383844         |
         *      //+---------------+---------------------------+
         *      //|              | -1.2246063538223773e-16   |
         *      //+---------------+---------------------------+
         *      //| 3/2          | 5443926242794615          |
         *      //+---------------+---------------------------+
         *      //| 2            | -2.4492127076447545e-16   |
         *      //+---------------+---------------------------+
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TNumeric);

            this.name = 'Tangent';

        },

        /**
         * Gets the function return value
         * @returns {number}
         */
        value: function () {

            return Math.tan(value(this.parameters[0]));

        }

    });

Tangent.mixin(require('./../../mixins/numeric'));
Tangent.mixin(require('./../../mixins/comparable'));
Tangent.mixin(require('./../../mixins/size-comparable'));

module.exports = Tangent;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../mixins/comparable":86,"./../../mixins/numeric":90,"./../../mixins/size-comparable":91,"./../../types/Numeric.js":97}],73:[function(require,module,exports){
var Function = require('./../../Function.js');
var TInteger = require('./../../types/Integer.js');
var value = require('./../../helpers/value');

var Length = Function.extend({

    /**
     * @class Functions.String.Length
     *
     * Returns the length of a string
     *
     * Example with Extension operator :
     *
     *     var affinity = require('./index.js');
     *
     *     var relation = new affinity.Relation([
     *          { name : { type : affinity.String}}
     *     ],[
     *          ['John Doe'], ['Mark Clinton'], ['Bo Vril']
     *     ]);
     *
     *     var name = relation.get('name');
     *
     *     var extended = relation.extend([{"name.length()" : name.length()}]);
     *
     *     // or
     *
     *     var extended = relation.extend([
     *         {"name.length()" : new affinity.Length(name)}
     *     ]);
     *
     *     extended.print();
     *
     *     // +-----------------+-------------------------+
     *     // | name : String   | name.length() : Integer |
     *     // +=================+=========================+
     *     // | John Doe        | 8                       |
     *     // +-----------------+-------------------------+
     *     // | Mark Clinton    | 12                      |
     *     // +-----------------+-------------------------+
     *     // | Bo Vril         | 7                       |
     *     // +-----------------+-------------------------+
     *
     */
    constructor: function () {

        Function.apply(this, Array.prototype.slice.call(arguments, 0));

        this.type(TInteger);

        this.name = 'Length';

    },

    /**
     * Gets the function return value
     * @returns {number}
     */
    value: function () {

        return value(this.parameters[0]).length;

    }

});

module.exports = Length;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../types/Integer.js":96}],74:[function(require,module,exports){
var Function = require('./../../Function.js');
var TString = require('./../../types/String.js');
var value = require('./../../helpers/value');

var Length = Function.extend({

    /**
     * @class Functions.String.Lowercase
     *
     * Returns the lowercase version of a string
     *
     * Example with Extension operator :
     *
     *     var affinity = require('./index.js');
     *
     *     var relation = new affinity.Relation([
     *          { name : { type : affinity.String}}
     *     ],[
     *          ['John Doe'], ['Mark Clinton'], ['Bo Vril']
     *     ]);
     *
     *     var name = relation.get('name');
     *
     *     var extended = relation.extend([{"name.lowercase()" : name.lowercase()}]);
     *
     *     // or
     *
     *     var extended = relation.extend([
     *         { "name.lowercase()" : new affinity.Lowercase(name) }
     *     ])
     *
     *     extended.print();
     *
     *     // +-----------------+---------------------------+
     *     // | name : String   | name.lowercase() : String |
     *     // +=================+===========================+
     *     // | John Doe        | john doe                  |
     *     // +-----------------+---------------------------+
     *     // | Mark Clinton    | mark clinton              |
     *     // +-----------------+---------------------------+
     *     // | Bo Vril         | bo vril                   |
     *     // +-----------------+---------------------------+
     */
    constructor: function () {

        Function.apply(this, Array.prototype.slice.call(arguments, 0));

        this.type(TString);

        this.name = 'Lowercase';

    },

    value: function () {

        return value(this.parameters[0]).toLowerCase();

    }

});

module.exports = Length;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../types/String.js":99}],75:[function(require,module,exports){
var Function = require('./../../Function.js');
var TString = require('./../../types/String.js');
var value = require('./../../helpers/value');

var Uppercase = Function.extend({

    /**
     * @class Functions.String.Substring
     *
     * Returns a substring from a string
     *
     * Example with Extension operator :
     *
     *     var affinity = require('./index.js');
     *
     *     var relation = new affinity.Relation([
     *          { name : { type : affinity.String}}
     *     ],[
     *          ['John Doe'], ['Mark Clinton'], ['Bo Vril']
     *     ]);
     *
     *     var name = relation.get('name');
     *
     *     var extended = relation.extend([{"name.substr(0,5)" : name.substr(0, 5)}]);
     *
     *     //or
     *
     *     var extended = relation.extend([
     *         { "name.substr(0,5)" : new affinity.Substring(name, 0, 5) }
     *     ]);
     *
     *     extended.print();
     *
     *     // +-----------------+---------------------------+
     *     // | name : String   | name.substr(0,5) : String |
     *     // +=================+===========================+
     *     // | John Doe        | John                      |
     *     // +-----------------+---------------------------+
     *     // | Mark Clinton    | Mark                      |
     *     // +-----------------+---------------------------+
     *     // | Bo Vril         | Bo Vr                     |
     *     // +-----------------+---------------------------+
     */
    constructor: function () {

        Function.apply(this, Array.prototype.slice.call(arguments, 0));

        this.type(TString);

        this.name = 'Substring';

    },

    value: function () {

        var start = value(this.parameters[1]);
        var length = value(this.parameters[2]);
        return value(this.parameters[0]).substr(start, length);

    }

});

module.exports = Uppercase;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../types/String.js":99}],76:[function(require,module,exports){
var Function = require('./../../Function.js');
var TString = require('./../../types/String.js');
var value = require('./../../helpers/value');

var Test = Function.extend({

    /**
     * @class Functions.String.Test
     *
     * Tests a regex on a string.
     *
     * Example with Extension operator :
     *
     *     var affinity = require('./index.js');
     *
     *     var relation = new affinity.Relation([
     *          { name : { type : affinity.String}}
     *     ],[
     *          ['John Doe'], ['Mark Clinton'], ['Bo Vril']
     *     ]);
     *
     *     var name = relation.get('name');
     *
     *     var extended = relation.extend([{ "name.test(/Doe/)" : name.test(/Doe/)}]);
     *
     *     // or
     *
     *     var extended = relation.extend([
     *         { "name.test(/Doe/)" : new affinity.Test(name, /Doe/) }
     *     ])
     *
     *     extended.print();
     *
     *     // +-----------------+----------------------------+
     *     // | name : String   | name.test(/Doe/) : Boolean |
     *     // +=================+============================+
     *     // | John Doe        | true                       |
     *     // +-----------------+----------------------------+
     *     // | Mark Clinton    | false                      |
     *     // +-----------------+----------------------------+
     *     // | Bo Vril         | false                      |
     *     // +-----------------+----------------------------+
     */
    constructor: function () {

        Function.apply(this, Array.prototype.slice.call(arguments, 0));

        this.type(TString);

        this.name = 'Test';

    },

    /**
     * Gets the function return value
     * @returns {boolean}
     */
    value: function () {

        var regex = value(this.parameters[1]);
        return regex.test(value(this.parameters[0]));

    }

});

module.exports = Test;
},{"./../../Function.js":5,"./../../helpers/value":85,"./../../types/String.js":99}],77:[function(require,module,exports){
var Function = require('./../../Function.js');
var TString = require('./../../types/String.js');
var value = require('./../../helpers/value');

var Uppercase = Function.extend({

    /**
     * @class Functions.String.Uppercase
     *
     * Returns the uppercase version of a string
     *
     * Example with Extension operator :
     *
     *     var affinity = require('./index.js');
     *
     *     var relation = new affinity.Relation([
     *          { upcs : { type : affinity.String}}
     *     ],[
     *          ['John Doe'], ['Mark Clinton'], ['Bo Vril']
     *     ]);
     *
     *     var extended = relation.extend([{"name.uppercase()" : relation.get('name').uppercase()}]);
     *
     *     // or
     *
     *     var extended = relation.extend([
     *         { "name.uppercase()" : new affinity.Uppercase(name) }
     *     ])
     *
     *     extended.print();
     *
     *     // +-----------------+---------------------------+
     *     // | name : String   | name.uppercase() : String |
     *     // +=================+===========================+
     *     // | John Doe        | JOHN DOE                  |
     *     // +-----------------+---------------------------+
     *     // | Mark Clinton    | MARK CLINTON              |
     *     // +-----------------+---------------------------+
     *     // | Bo Vril         | BO VRIL                   |
     *     // +-----------------+---------------------------+
     */
    constructor: function () {

        Function.apply(this, Array.prototype.slice.call(arguments, 0));

        this.type(TString);

        this.name = 'Uppercase';

    },

    /**
     * Gets the function return value
     * @returns {string}
     */
    value: function () {

        return value(this.parameters[0]).toUpperCase();

    }

});

module.exports = Uppercase;



},{"./../../Function.js":5,"./../../helpers/value":85,"./../../types/String.js":99}],78:[function(require,module,exports){
var Function = require('./../../Function.js');
var Type = require('./../../Type.js');
var TBoolean = require('./../../types/Boolean.js');

var TupleAttribute = Function.extend({

    /**
     * @class Functions.Tuple.AttributeValue
     * @extends Function
     *
     * When building a predicate, you pass the Header Attributes directly like this :
     *
     *     var extended = relation.extend(relation.get('attribute1').plus(relation.get('attribute2')));
     *
     * In the documentation for Relation#get, it is specified that it returns an Attribute.
     *
     * Though, when building predicates for restriction or extension operators, we convert the passed Attributes
     * into a function TupleAttribute. So this is the same as the above :
     *
     *     var extended = relation.extend(new affinity.TupleAttribute('attribute1').plus(new affinity.TupleAttribute('attribute2')));
     *
     * Directly passing the Header Attribute is just some nice sugar.
     *
     */
    constructor: function (attributeName) {

        Function.apply(this, arguments);

        this.attributeName = attributeName;

        this.name = 'TupleAttribute';

    },

    /**
     * Gets the function return value
     * @returns {*}
     */
    value: function () {

        var tuple = this.parameters[0];

        var attributeName = this.attributeName;

        if(!tuple.attributes.hasOwnProperty(attributeName)){
            throw new Error('Attribute "'+attributeName+'" does not exist in Tuple');
        }

        return tuple.get(attributeName);

    },

    /**
     * Assigns a tuple to the function
     * @param tuple
     */
    assignTuple : function(tuple){

        this.parameters[0] = tuple;

    }

},{


});

module.exports = TupleAttribute;
},{"./../../Function.js":5,"./../../Type.js":12,"./../../types/Boolean.js":93}],79:[function(require,module,exports){
var _ = require('lodash');
var debug = require('./debug');

var clone = function (element) {

    debug.clone.trace('#clone');

    if (element.clone && _.isFunction(element.clone)) {

        return element.clone();

    } else {

        return _.cloneDeep(element);

    }

};

module.exports = clone;
},{"./debug":82,"lodash":103}],80:[function(require,module,exports){
var _ = require('lodash');
var debug = require('./debug');
var coerce = function (type, value) {
    debug.coerce.trace('#coerce');
    if(value instanceof type){
        return value;
    } else if (type && _.isFunction(type.coerce)) {
        return type.coerce.apply(this, Array.prototype.slice.call(arguments, 1));
    } else {
        if (type && value instanceof type) {
            return value;
        }
        if (type) {
            var result = new (type.prototype.constructor.bind.apply(type, (Array.prototype.slice.call(arguments, 0))));
        } else {
            result = value;
        }
        return result;
    }
};
module.exports = coerce;
},{"./debug":82,"lodash":103}],81:[function(require,module,exports){
var value = require('./value');
var _ = require('lodash');
var Function = require('./../Function');
var Type = require('./../Type');
var debug = require('./debug');

var compare = function (type, value1, value2) {

    debug.compare.trace('#compare');

    // Get the function return values if applicable

    value1 = value(value1);
    value2 = value(value2);


    // Access the type's equal function

    if(value1 instanceof Type){
        return value1.constructor.compare(value1, value2);
    }

    if(value2 instanceof Type){
        return value2.constructor.compare(value1, value2);
    }

    if(value1 instanceof Date){
        value1 = value1.getTime();
    }

    if(value2 instanceof Date){
        value2 = value2.getTime();
    }


    if(value1 === value2){
        return 0;
    } else if (value1 > value2){
        return 1;
    } else if (value2 > value1){
        return -1;
    }


};

module.exports = compare;
},{"./../Function":5,"./../Type":12,"./debug":82,"./value":85,"lodash":103}],82:[function(require,module,exports){

var log4js;

try {
    log4js = require("log4js");

    log4js.configure({
        appenders: [
            { type: 'console' }
        ],
        replaceConsole: false
    });

    log4js.setGlobalLogLevel(log4js.levels.WARN);

} catch(e) {
    log4js = {};

    var logger = function(){
        this.trace = this.warn = this.debug = function(){
            return;
        }
    };

    log4js.getLogger = function(){
        return new logger();
    };
}

var Set = module.exports.set = log4js.getLogger('Set');
var Relation = module.exports.relation = log4js.getLogger('Relation');
var Header = module.exports.header = log4js.getLogger('Header');

var Compose = module.exports.compose = log4js.getLogger('Compose');
var Difference = module.exports.difference = log4js.getLogger('Difference');
var Extend = module.exports.extend = log4js.getLogger('Extend');
var Group = module.exports.group = log4js.getLogger('Group');
var Intersection = module.exports.intersection = log4js.getLogger('Intersection');
var Join = module.exports.join = log4js.getLogger('Join');
var Product = module.exports.product = log4js.getLogger('Product');
var Projection = module.exports.projection = log4js.getLogger('Projection');
var Rename = module.exports.rename = log4js.getLogger('Rename');
var Restriction = module.exports.restriction = log4js.getLogger('Restriction');
var SemiJoin = module.exports.semiJoin = log4js.getLogger('SemiJoin');
var SemiDifference = module.exports.semiDifference = log4js.getLogger('SemiDifference');
var Ungroup = module.exports.ungroup = log4js.getLogger('Ungroup');
var Union = module.exports.union = log4js.getLogger('Union');
var Unwrap = module.exports.unwrap = log4js.getLogger('Unwrap');
var Wrap = module.exports.wrap = log4js.getLogger('Wrap');
var TableDump = module.exports.reldump = log4js.getLogger('TableDump');
var Test = module.exports.test = log4js.getLogger('Test');

var Index = module.exports.index = log4js.getLogger('Index');
var Key = module.exports.key = log4js.getLogger('Key');
var ForeignKey = module.exports.foreignKey = log4js.getLogger('ForeignKey');


var Clone = module.exports.clone = log4js.getLogger('Clone');
var Type = module.exports.type = log4js.getLogger('Type');
var Coerce = module.exports.coerce = log4js.getLogger('Coerce');
var Compare = module.exports.compare = log4js.getLogger('Compare');
var Value = module.exports.value = log4js.getLogger('Value');
var Equal = module.exports.equal = log4js.getLogger('Equal');



},{"log4js":undefined}],83:[function(require,module,exports){
var value = require('./value');
var _ = require('lodash');
var Function = require('./../Function');
var Type = require('./../Type');
var debug = require('./debug');

var equal = function (type, value1, value2) {

    debug.equal.trace('#equal');

    // Get the function return values if applicable

    value1 = value(value1);
    value2 = value(value2);

    if(_.isUndefined(value1) && _.isUndefined(value2)){
        return true;
    } else if (_.isUndefined(value1) || _.isUndefined(value2)){
        return false;
    } else if (_.isNull(value1) && _.isNull(value2)){
        return true;
    } else if (_.isNull(value1) || _.isNull(value2)){
        return false;
    }


    // Access the type's equal function

    if(value1.constructor && value1.constructor.equal){
        return value1.constructor.equal(value1, value2);
    }

    if(value2.constructor && value2.constructor.equal){
        return value2.constructor.equal(value1, value2);
    }


    // Fallback on good'ol lodash

    return _.isEqual(value1, value2);


};

module.exports = equal;
},{"./../Function":5,"./../Type":12,"./debug":82,"./value":85,"lodash":103}],84:[function(require,module,exports){
var value = require('./value');
var _ = require('lodash');
var Function = require('./../Function');
var Attribute = require('./../Attribute');
var Type = require('./../Type');
var debug = require('./debug');

var TBoolean = require('./../types/Boolean');
var TString = require('./../types/String');
var TDate = require('./../types/Date');
var TInteger = require('./../types/Integer');
var TNumeric = require('./../types/Numeric');
var TFloat = require('./../types/Float');


var type = function(thang){

    debug.type.trace('#type');

    if(thang instanceof Attribute){
        return thang.type;
    }

    if(thang instanceof Type){
        return thang.constructor;
    }

    if(thang instanceof Function){
        return thang.type();
    }

    if(_.isBoolean(thang)){
        return TBoolean;
    }

    if(_.isNumber(thang)){
        return TNumeric;
    }

    if(_.isDate(thang)){
        return TDate;
    }

};

module.exports = type;


},{"./../Attribute":2,"./../Function":5,"./../Type":12,"./../types/Boolean":93,"./../types/Date":94,"./../types/Float":95,"./../types/Integer":96,"./../types/Numeric":97,"./../types/String":99,"./debug":82,"./value":85,"lodash":103}],85:[function(require,module,exports){

var debug = require('./debug');
var Function = require('./../Function');

var value = function (value) {

    debug.value.trace('#value');

    if(value instanceof Function){

        value = value.value();

    }

    return value;

};

module.exports = value;
},{"./../Function":5,"./debug":82}],86:[function(require,module,exports){
/**
 * @class Mixins.Comparable
 */


/**
 * @member Mixins.Comparable
 */
module.exports.equals = function (attr) {

    var Equal = require('./../functions/comparable/Equal.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Equal(this, attr));
    }

    return new Equal(this, attr);

};

/**
 * @member Mixins.Comparable
 */
module.exports.eq = function(attr){
    return module.exports.equals.call(this, attr);
};
},{"./../functions/comparable/Equal.js":39}],87:[function(require,module,exports){
/**
 * @class Mixins.Chainable
 */

/**
 * @member Mixins.Chainable
 */
module.exports.and = function (param) {

    var And = require('./../functions/connective/And.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new And(this, param));
    }

    return new And(this, param);

};

/**
 * @member Mixins.Chainable
 */
module.exports.or = function () {

    var Or = require('./../functions/connective/Or.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Or(this));
    }

    return new Or(this);

};
},{"./../functions/connective/And.js":44,"./../functions/connective/Or.js":46}],88:[function(require,module,exports){
module.exports.dayOfMonth = function () {

    var DayOfMonth = require('./../functions/date/DayOfMonth.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new DayOfMonth(this));
    }

    return new DayOfMonth(this);

};

module.exports.dayOfWeek = function () {

    var DayOfWeek = require('./../functions/date/DayOfWeek.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new DayOfWeek(this));
    }

    return new DayOfWeek(this);

};

module.exports.dayOfYear = function () {

    var DayOfYear = require('./../functions/date/DayOfYear.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new DayOfYear(this));
    }

    return new DayOfYear(this);

};


module.exports.month = function () {

    var Month = require('./../functions/date/Month.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Month(this));
    }

    return new Month(this);

};

module.exports.ts = function () {

    var Timestamp = require('./../functions/date/Timestamp.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Timestamp(this));
    }

    return new Timestamp(this);

};

module.exports.weekOfYear = function () {

    var WeekOfYear = require('./../functions/date/WeekOfYear.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new WeekOfYear(this));
    }

    return new WeekOfYear(this);

};

module.exports.year = function () {

    var Year = require('./../functions/date/Year.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Year(this));
    }

    return new Year(this);

};

module.exports.hours = function () {

    var Hours = require('./../functions/date/Hours.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Hours(this));
    }

    return new Hours(this);

};

module.exports.minutes = function () {

    var Minutes = require('./../functions/date/Minutes.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Minutes(this));
    }

    return new Minutes(this);

};

module.exports.seconds = function () {

    var Seconds = require('./../functions/date/Seconds.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Seconds(this));
    }

    return new Seconds(this);

};

module.exports.milliseconds = function () {

    var Milliseconds = require('./../functions/date/Milliseconds.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Milliseconds(this));
    }

    return new Milliseconds(this);

};
},{"./../functions/date/DayOfMonth.js":47,"./../functions/date/DayOfWeek.js":48,"./../functions/date/DayOfYear.js":49,"./../functions/date/Hours.js":50,"./../functions/date/Milliseconds.js":51,"./../functions/date/Minutes.js":52,"./../functions/date/Month.js":53,"./../functions/date/Seconds.js":54,"./../functions/date/Timestamp.js":55,"./../functions/date/WeekOfYear.js":56,"./../functions/date/Year.js":57}],89:[function(require,module,exports){
/**
 * @class Mixins.Negatable
 */

/**
 * @member Mixins.Negatable
 */
module.exports.not = function (attr) {

    this._negated = true;
    return this;

};
},{}],90:[function(require,module,exports){
module.exports.abs = function () {
    var Absolute = require('./../functions/numeric/Absolute.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Absolute(this));
    }
    return new Absolute(this);
};

module.exports.ceil = function (attr) {
    var Ceil = require('./../functions/numeric/Ceil.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Ceil(this));
    }
    return new Ceil(this);
};

module.exports.floor = function (attr) {
    var Floor = require('./../functions/numeric/Floor.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Ceil(this));
    }
    return new Floor(this);
};

module.exports.cos = function (attr) {
    var Cos = require('./../functions/numeric/Cosine.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Cos(this));
    }
    return new Cos(this);
};

module.exports.div = function (attr) {
    var Division = require('./../functions/numeric/Division.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Division(this, attr));
    }
    return new Division(this, attr);
};


module.exports.exp = function () {
    var Exp = require('./../functions/numeric/Exponential.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Exp(this));
    }
    return new Exp(this);
};


module.exports.minus = function (attr) {
    var Minus = require('./../functions/numeric/Minus.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Minus(this, attr));
    }
    return new Minus(this, attr);
};


module.exports.mod = function (attr) {
    var Modulo = require('./../functions/numeric/Modulo.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Modulo(this, attr));
    }
    return new Modulo(this, attr);
};


module.exports.times = function (attr) {
    var Multiplication = require('./../functions/numeric/Multiplication.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Multiplication(this, attr));
    }
    return new Multiplication(this, attr);
};


module.exports.plus = function (attr) {
    var Plus = require('./../functions/numeric/Plus.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Plus(this, attr));
    }
    return new Plus(this, attr);
};


module.exports.pow = function (attr) {
    var Pow = require('./../functions/numeric/Power.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Pow(this, attr));
    }
    return new Pow(this, attr);
};


module.exports.round = function () {
    var Round = require('./../functions/numeric/Round.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Round(this));
    }
    return new Round(this);
};


module.exports.sin = function () {
    var Sin = require('./../functions/numeric/Sine.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Sin(this));
    }
    return new Sin(this);
};


module.exports.sqrt = function () {
    var Sqrt = require('./../functions/numeric/SquareRoot.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Sqrt(this));
    }
    return new Sqrt(this);
};


module.exports.tan = function () {
    var Tan = require('./../functions/numeric/Tangent.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Tan(this));
    }
    return new Tan(this);
};

module.exports.avg = function(){

    var Average = require('./../functions/aggregate/Average.js');
    return new Average(this);

};

module.exports.standardDeviation = function(){

    var StandardDeviation = require('./../functions/aggregate/StandardDeviation.js');
    return new StandardDeviation(this);

};

module.exports.sum = function(){

    var Sum = require('./../functions/aggregate/Sum.js');
    return new Sum(this);

};

module.exports.variance = function(){

    var Variance = require('./../functions/aggregate/Variance.js');
    return new Variance(this);

};


},{"./../functions/aggregate/Average.js":32,"./../functions/aggregate/StandardDeviation.js":36,"./../functions/aggregate/Sum.js":37,"./../functions/aggregate/Variance.js":38,"./../functions/numeric/Absolute.js":58,"./../functions/numeric/Ceil.js":59,"./../functions/numeric/Cosine.js":60,"./../functions/numeric/Division.js":61,"./../functions/numeric/Exponential.js":62,"./../functions/numeric/Floor.js":63,"./../functions/numeric/Minus.js":64,"./../functions/numeric/Modulo.js":65,"./../functions/numeric/Multiplication.js":66,"./../functions/numeric/Plus.js":67,"./../functions/numeric/Power.js":68,"./../functions/numeric/Round.js":69,"./../functions/numeric/Sine.js":70,"./../functions/numeric/SquareRoot.js":71,"./../functions/numeric/Tangent.js":72}],91:[function(require,module,exports){
/**
 * @class Mixins.SizeComparable
 */

/**
 * @member Mixins.SizeComparable
 */
module.exports.gt = function (attr) {
    var GreaterThan = require('./../functions/comparable/GreaterThan.js');
    return new GreaterThan(this, attr);
};

/**
 * @member Mixins.SizeComparable
 */
module.exports.gte = function (attr) {
    var GreaterThanEqual = require('./../functions/comparable/GreaterThanEqual.js');
    return new GreaterThanEqual(this, attr);
};

/**
 * @member Mixins.SizeComparable
 */
module.exports.st = function (attr) {
    var SmallerThan = require('./../functions/comparable/SmallerThan.js');
    return new SmallerThan(this, attr);
};

/**
 * @member Mixins.SizeComparable
 */
module.exports.ste = function (attr) {
    var SmallerThanEqual = require('./../functions/comparable/SmallerThanEqual.js');
    return new SmallerThanEqual(this, attr);
};

module.exports.max = function(){
    var Maximum = require('./../functions/aggregate/Maximum');

    return new Maximum(this);
};

module.exports.min = function(){
    var Minimum = require('./../functions/aggregate/Minimum');

    return new Minimum(this);
};
},{"./../functions/aggregate/Maximum":34,"./../functions/aggregate/Minimum":35,"./../functions/comparable/GreaterThan.js":40,"./../functions/comparable/GreaterThanEqual.js":41,"./../functions/comparable/SmallerThan.js":42,"./../functions/comparable/SmallerThanEqual.js":43}],92:[function(require,module,exports){


module.exports.length = function () {
    var Length = require('./../functions/string/Length.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Length(this));
    }
    return new Length(this);
};

module.exports.lowercase = function () {
    var Lowercase = require('./../functions/string/Lowercase.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Lowercase(this));
    }
    return new Lowercase(this);
};

module.exports.test = function (regex) {
    var Test = require('./../functions/string/Test.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Test(this, regex));
    }
    return new Test(this, regex);
};

module.exports.substr = function (index, len) {
    var Substring = require('./../functions/string/Substring.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Substring(this, index, len));
    }
    return new Substring(this, index, len);
};

module.exports.uppercase = function () {
    var Uppercase = require('./../functions/string/Uppercase.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Uppercase(this));
    }
    return new Uppercase(this);
};
},{"./../functions/string/Length.js":73,"./../functions/string/Lowercase.js":74,"./../functions/string/Substring.js":75,"./../functions/string/Test.js":76,"./../functions/string/Uppercase.js":77}],93:[function(require,module,exports){
var Type = require('./../Type');
var _ = require('lodash');

var TBoolean = Type.extend(/**
 * @class Types.Boolean
 * @extends Type
 *
 * Represents a Boolean Type
 *
 * This class should not be instantiated. It is only used to define
 * relation header attribute types or function return types.
 *
 */{



}, {

    /**
     * @param {boolean|Types.Boolean} boolean1
     * @param {boolean|Types.Boolean} boolean2
     * @static
     * @returns {boolean}
     *
     * Method to check if two boolean object are equal
     *
     */
    equal: function (boolean1, boolean2) {

        return boolean1 === boolean2;

    },

    /**
     * @param {*} value The variable to coerce to Boolean type
     * @static
     * @returns {boolean}
     */
    coerce : function(value){

        var lowerCaseValue;

        if(_.isBoolean(value)){
            return value;
        } else if (value === 0){
            return false;
        } else if (value === 1){
            return true;
        } else if (_.isString(value)){

            lowerCaseValue = value.toLowerCase();

            if(lowerCaseValue === 'true' || lowerCaseValue === 't'){
                return true;
            } else if(lowerCaseValue === 'false' || lowerCaseValue === 'f'){
                return false;
            }

        }

    },

    /**
     * @static
     * @returns {string}
     *
     * String representation of the Boolean type
     */
    toString: function () {
        return 'Boolean'
    },

    /**
     * @param {boolean} boolean
     * @static
     * @returns {boolean}
     *
     * Returns the value of a boolean
     */
    value : function(boolean){

        return boolean;

    },

    /**
     * Mixins for Booleans
     * @static
     */
    payload : [
        require('./../mixins/comparable'),
        require('./../mixins/connectable'),
        require('./../mixins/not')
    ],

    type : 'Boolean'

});

module.exports = TBoolean;


},{"./../Type":12,"./../mixins/comparable":86,"./../mixins/connectable":87,"./../mixins/not":89,"lodash":103}],94:[function(require,module,exports){
var Object = require('./Object');
var _ = require('lodash');

var Date = Object.extend({

    /**
     * @class Types.Date
     * @extends Type
     *
     * Represents a Date type.
     *
     * Should not be instantiated. Only used to represent
     * relation header attribute types or function return types.
     */

}, {

    /**
     * Serialize method for Dates.
     * @param {Date|Types.Date} date
     * @static
     * @returns {number}
     */
    serialize : function(date){

        return date.getTime();

    },

    /**
     * Coerces an arbitrary object into a date
     * @param {string|number|Date|Types.Date} value
     * @static
     * @returns {Date}
     */
    coerce : function(value){

        if(_.isString(value)){
            return new Date(value);
        } else if (_.isNumber(value)){
            var result = new Date();
            result.setTime(value);
            return result;
        } else if(_.isDate(value)){
            return value;
        }

    },

    /**
     * Check if two dates are equal
     * @param {Date|Types.Date} date1
     * @param {Date|Types.Date} date2
     * @static
     * @returns {boolean}
     */
    equal: function (date1, date2) {

        return date1 === date2;

    },

    /**
     * String representation of the Date type
     * @static
     * @returns {string}
     */
    toString: function () {
        return 'Date'
    },

    /**
     * Gets the value of a date
     * @static
     * @param date
     * @returns {Date}
     */
    value : function(date){

        return date;

    },

    /**
     * Mixins for dates
     */
    payload : [
        require('./../mixins/comparable'),
        require('./../mixins/size-comparable'),
        require('./../mixins/not'),
        require('./../mixins/date')
    ],

    type : 'Date'

});

module.exports = Date;


},{"./../mixins/comparable":86,"./../mixins/date":88,"./../mixins/not":89,"./../mixins/size-comparable":91,"./Object":98,"lodash":103}],95:[function(require,module,exports){
var Numeric = require('./Numeric.js');
var _ = require('lodash');

var Float = Numeric.extend({

    /**
     * @class Types.Float
     * @extends Types.Numeric
     *
     * Represents a Float type.
     *
     * This class should not be instantiated. It is only used
     * to represent relation header attribute types or function return types.
     */

}, {

    /**
     * String representation of the Float type
     * @static
     * @returns {string}
     */
    toString: function () {
        return 'Float'
    },


    /**
     * Coerces an arbitrary value to Float type
     * @param value
     * @returns {number}
     */
    coerce : function(value){

        if (_.isNumber(value) || _.isString(value)){
            return parseFloat(value);
        }

    },

    primitive : true,

    type : 'Float'

});

module.exports = Float;


},{"./Numeric.js":97,"lodash":103}],96:[function(require,module,exports){
var TNumeric = require('./Numeric.js');
var _ = require('lodash');

var Integer = TNumeric.extend({

    /**
     * @class Types.Integer
     * @extends Types.Numeric
     *
     * Represents an Integer type.
     *
     * This class should not be instantiated. It is only used
     * to represent relation header attribute types or function return types.
     */

}, {

    /**
     * Coerces an arbitrary value to Integer type
     * @param value
     * @returns {number}
     */
    coerce : function(value){

        if (_.isNumber(value) || _.isString(value)){
            return parseInt(value);
        }

    },

    /**
     * String representation of the Integer Type
     * @returns {string}
     */
    toString: function () {
        return 'Integer'
    },

    primitive : true,

    type : 'Integer'

});

module.exports = Integer;


},{"./Numeric.js":97,"lodash":103}],97:[function(require,module,exports){
var Type = require('./../Type');
var _ = require('lodash');

var Numeric = Type.extend({

    /**
     * @class Types.Numeric
     *
     * Represents a Numeric type.
     *
     * This class should not be instantiated. It is only used
     * to represent relation header attribute types or function return types.
     */

}, {

    /**
     * @param {*} value
     * @returns {number}
     *
     * Coerces an arbitrary value to type float
     *
     */
    coerce : function(value){

        if(_.isNumber(value)){
            return value;
        } else if (_.isString(value)){
            return parseFloat(value);
        }

    },

    /**
     * Mixins for Numeric types
     */
    payload : [
        require('./../mixins/comparable'),
        require('./../mixins/size-comparable'),
        require('./../mixins/numeric'),
        require('./../mixins/connectable'),
        require('./../mixins/not')
    ],

    /**
     * Returns the value of the Numeric object
     * @param numeric
     * @returns {*}
     */
    value : function(numeric){

        return numeric;

    },

    equal: function (numeric1, numeric2) {

        return (numeric1 === numeric2);

    },

    toString: function () {
        return 'Numeric'
    },

    primitive : true,

    type : 'Numeric'

});


module.exports = Numeric;


},{"./../Type":12,"./../mixins/comparable":86,"./../mixins/connectable":87,"./../mixins/not":89,"./../mixins/numeric":90,"./../mixins/size-comparable":91,"lodash":103}],98:[function(require,module,exports){
var Type = require('./../Type');
var _ = require('lodash');

var TObject = Type.extend({

    /**
     * @class Types.Object
     * @extends Type
     *
     * Represents an Object Type.
     */

    /**
     * Creates new Object instances
     * @param value
     */
    constructor: function (value) {

        Type.apply(this, Array.prototype.slice.call(arguments, 0));

        if(_.isObject(value)){
            _.extend(this, value);
        }

        this.name = 'Object';
    },

    /**
     * String representation of an Object value
     * @returns {string}
     */
    toString: function () {

        return 'Object';

    }

}, {

    /**
     * Method to coerce an arbitrary value into an Object instance
     * @param value
     * @returns {Object}
     */
    coerce : function(value){

        return value;

    },

    /**
     * Mixins for Object type
     */
    payload : [
        require('./../mixins/comparable'),
        require('./../mixins/connectable'),
        require('./../mixins/not')
    ],

    /**
     * Returns the value of the object
     * @param object
     * @returns {*}
     */
    value : function(object){

        return object;

    },

    /**
     * Tests for equality between two objects
     * @static
     * @param object1
     * @param object2
     * @returns {boolean}
     */
    equal: function (object1, object2) {

        return _.isEqual(object1, object2);

    },

    /**
     * String representation of an object
     * @static
     * @returns {string}
     */
    toString: function () {

        return 'Object'

    },

    /**
     * Object is not a primitive type
     */
    primitive : false,

    type : 'Object'

});


module.exports = TObject;


},{"./../Type":12,"./../mixins/comparable":86,"./../mixins/connectable":87,"./../mixins/not":89,"lodash":103}],99:[function(require,module,exports){
var Type = require('./../Type');
var TBoolean = require('./Boolean');
var _ = require('lodash');

var String = Type.extend({

    /**
     * @class Types.String
     * @extends Type
     *
     * Represents a String Attribute Type.
     *
     * Should not be instantiated. It is only
     * used to represent relation header attribute types or function return types.
     *
     */

}, {

    coerce : function(value){

        return value;

    },

    /**
     * Mixins for String types
     */
    payload : [
        require('./../mixins/comparable'),
        require('./../mixins/size-comparable'),
        require('./../mixins/connectable'),
        require('./../mixins/not'),
        require('./../mixins/string'),
    ],

    /**
     * Checks for equality between two strings
     * @param str1
     * @param str2
     * @returns {boolean}
     */
    equal: function (str1, str2) {

        return str2 === str1;

    },

    /**
     * String representation of a String Type
     * @returns {string}
     */
    toString: function () {
        return 'String'
    },

    /**
     * String is a primitive
     */
    primitive : true,

    type : 'TString'

});

module.exports = String;


},{"./../Type":12,"./../mixins/comparable":86,"./../mixins/connectable":87,"./../mixins/not":89,"./../mixins/size-comparable":91,"./../mixins/string":92,"./Boolean":93,"lodash":103}],100:[function(require,module,exports){
var Type = require('./../Type');
var TBoolean = require('./Boolean');

var TType = Type.extend({

    /**
     * @class Types.Type
     * @extends Type
     *
     * Represents a Type Attribute type.
     *
     * Should not be instantiated. It is only
     * used to represent relation header attribute types or function return types.
     *
     */

}, {

    /**
     * Check if two Types are equal
     * @param {Function} type1
     * @param {Function} type2
     * @returns {boolean}
     */
    equal: function (type1, type2) {

        return (type1 === type2);

    },

    toString: function () {
        return 'Type'
    },

    type : 'Type'

});

module.exports = TType;


},{"./../Type":12,"./Boolean":93}],101:[function(require,module,exports){
/**
 * @class Affinity
 * @type {Object} 
 * @member Affinity
 */
var affinity = {};

//region Types

/**
 * @member Affinity
 * @type {Index}
 */
affinity.Index = require('./affinity/Index.js');

/**
 * @type {Types.Type}  
 * @member Affinity
 */
affinity.Type = require('./affinity/types/Type.js');

/**
 * @type {Set} 
 * @member Affinity
 */
affinity.Set = require('./affinity/Set.js');

/**
 * @type {Relation} 
 * @member Affinity
 */
affinity.Relation = require('./affinity/Relation.js');

/**
 * @type {Tuple} 
 * @member Affinity
 */
affinity.Tuple = require('./affinity/Tuple.js');

/**
 * @type {Header} 
 * @member Affinity
 */
affinity.Header = require('./affinity/Header.js');

/**
 * @type {Attribute} 
 * @member Affinity
 */
affinity.Attribute = require('./affinity/Attribute.js');

/**
 * @type {Types.Object} 
 * @member Affinity
 */
affinity.Object = require('./affinity/types/Object');

/**
 * @type {Types.Integer} 
 * @member Affinity
 */
affinity.Integer = require('./affinity/types/Integer');

/**
 * @type {Types.Float} 
 * @member Affinity
 */
affinity.Float = require('./affinity/types/Float');

/**
 * @type {Types.String} 
 * @member Affinity
 */
affinity.String = require('./affinity/types/String');

/**
 * @type {Types.Boolean} 
 * @member Affinity
 */
affinity.Boolean = require('./affinity/types/Boolean');

/**
 * @type {Types.Date} 
 * @member Affinity
 */
affinity.Date = require('./affinity/types/Date');
//endregion

/**
 * @type {Function} 
 * @member Affinity
 */
affinity.Function = require('./affinity/Function.js');

//region Connective Functions

/**
 * @type {Functions.Connective.And} 
 * @member Affinity
 */
affinity.And = require('./affinity/functions/connective/And.js');

/**
 * @type {Functions.Connective.Or} 
 * @member Affinity
 */
affinity.Or = require('./affinity/functions/connective/Or.js');

/**
 * @type {Functions.Connective.Not} 
 * @member Affinity
 */
affinity.Not = require('./affinity/functions/connective/Not.js');
//endregion

//region Comparative Functions

/**
 * @type {Functions.Comparable.Equal} 
 * @member Affinity
 */
affinity.Equal = require('./affinity/functions/comparable/Equal.js');

/**
 * @type {Functions.Comparable.Equal} 
 * @member Affinity
 */
affinity.eq = function(attr1, attr2){
    return new affinity.Equal(attr1, attr2);
};


/**
 * @type {Functions.Comparable.GreaterThan} 
 * @member Affinity
 */
affinity.GreaterThan = require('./affinity/functions/comparable/GreaterThan.js');

/**
 * @type {Functions.Comparable.GreaterThan} 
 * @member Affinity
 */
affinity.gt = function(attr1, attr2){
    return new affinity.GreaterThan(attr1, attr2);
};


/**
 * @type {Functions.Comparable.GreaterThanEqual} 
 * @member Affinity
 */
affinity.GreaterThanEqual = require('./affinity/functions/comparable/GreaterThanEqual.js');

/**
 * @type {Functions.Comparable.GreaterThanEqual} 
 * @member Affinity
 */
affinity.gte = function(attr1, attr2){
    return new affinity.GreaterThanEqual(attr1, attr2);
};


/**
 * @type {Functions.Comparable.SmallerThan} 
 * @member Affinity
 */
affinity.SmallerThan = require('./affinity/functions/comparable/SmallerThan.js');

/**
 * @type {Functions.Comparable.SmallerThan} 
 * @member Affinity
 */
affinity.st = function(attr1, attr2){
    return new affinity.SmallerThan(attr1, attr2);
};


/**
 * @type {Functions.Comparable.SmallerThanEqual} 
 * @member Affinity
 */
affinity.SmallerThanEqual = require('./affinity/functions/comparable/SmallerThanEqual.js');

/**
 * @type {Functions.Comparable.SmallerThanEqual} 
 * @member Affinity
 */
affinity.ste = function(attr1, attr2){
    return new affinity.SmallerThanEqual(attr1, attr2);
};

//endregion

//region Numeric Functions

/**
 * @type {Functions.Numeric.Absolute} 
 * @member Affinity
 */
affinity.Absolute = require('./affinity/functions/numeric/Absolute.js');

/**
 * @type {Functions.Numeric.Ceil} 
 * @member Affinity
 */
affinity.Ceil = require('./affinity/functions/numeric/Ceil.js');
/**
 * @type {Functions.Numeric.Cosine} 
 * @member Affinity
 */
affinity.Cosine = require('./affinity/functions/numeric/Cosine.js');

/**
 * @type {Functions.Numeric.Division} 
 * @member Affinity
 */
affinity.Division = require('./affinity/functions/numeric/Division.js');

/**
 * @type {Functions.Numeric.Exponential} 
 * @member Affinity
 */
affinity.Exponential = require('./affinity/functions/numeric/Exponential.js');

/**
 * @type {Functions.Numeric.Floor} 
 * @member Affinity
 */
affinity.Floor = require('./affinity/functions/numeric/Floor.js');

/**
 * @type {Functions.Numeric.Minus} 
 * @member Affinity
 */
affinity.Minus = require('./affinity/functions/numeric/Minus.js');

/**
 * @type {Functions.Numeric.Modulo} 
 * @member Affinity
 */
affinity.Modulo = require('./affinity/functions/numeric/Modulo.js');

/**
 * @type {Functions.Numeric.Multiplication} 
 * @member Affinity
 */
affinity.Multiplication = require('./affinity/functions/numeric/Multiplication.js');

/**
 * @type {Functions.Numeric.Plus} 
 * @member Affinity
 */
affinity.Plus = require('./affinity/functions/numeric/Plus.js');

/**
 * @type {Functions.Numeric.Power} 
 * @member Affinity
 */
affinity.Power = require('./affinity/functions/numeric/Power.js');

/**
 * @type {Functions.Numeric.Round} 
 * @member Affinity
 */
affinity.Round = require('./affinity/functions/numeric/Round.js');

/**
 * @type {Functions.Numeric.Sine} 
 * @member Affinity
 */
affinity.Sine = require('./affinity/functions/numeric/Sine.js');

/**
 * @type {Functions.Numeric.SquareRoot} 
 * @member Affinity
 */
affinity.SquareRoot = require('./affinity/functions/numeric/SquareRoot.js');

/**
 * @type {Functions.Numeric.Tangent} 
 * @member Affinity
 */
affinity.Tangent = require('./affinity/functions/numeric/Tangent.js');

/**
 * @param attr
 * @returns {Functions.Numeric.Absolute}
 */
affinity.abs = function(attr){
    return new affinity.Absolute(attr);
};

/**
 * @param attr
 * @returns {Functions.Numeric.Ceil}
 */
affinity.ceil = function(attr){
    return new affinity.Ceil(attr);
};

/**
 * @param attr
 * @returns {Functions.Numeric.Floor}
 */
affinity.floor = function(attr){
    return new affinity.Floor(attr);
};

/**
 * @param attr
 * @returns {Functions.Numeric.Cosine}
 */
affinity.cos = function(attr){
    return new affinity.Cosine(attr);
};

/**
 * @param attr1
 * @param attr2
 * @returns {Functions.Numeric.Division}
 */
affinity.div = function(attr1, attr2){
    return new affinity.Division(attr1, attr2);
};

/**
 * @param attr
 * @returns {Functions.Numeric.Exponential}
 */
affinity.exp = function(attr){
    return new affinity.Exponential(attr);
};

/**
 * @param attr1
 * @param attr2
 * @returns {Functions.Numeric.Minus}
 */
affinity.minus = function(attr1, attr2){
    return new affinity.Minus(attr1, attr2);
};

/**
 * @param attr1
 * @param attr2
 * @returns {Functions.Numeric.Modulo}
 */
affinity.mod = function(attr1, attr2){
    return new affinity.Modulo(attr1, attr2);
};

/**
 * @param attr1
 * @param attr2
 * @returns {Functions.Numeric.Multiplication}
 */
affinity.times = function(attr1, attr2){
    return new affinity.Multiplication(attr1, attr2);
};

/**
 * @param attr1
 * @param attr2
 * @returns {Functions.Numeric.Plus}
 */
affinity.plus = function(attr1, attr2){
    return new affinity.Plus(attr1, attr2);
};

/**
 * @param attr1
 * @param attr2
 * @returns {Functions.Numeric.Power}
 */
affinity.pow = function(attr1, attr2){
    return new affinity.Power(attr1, attr2);
};

/**
 * @param attr
 * @returns {Functions.Numeric.Round}
 */
affinity.round = function(attr){
    return new affinity.Round(attr);
};

/**
 * @param attr
 * @returns {Functions.Numeric.Sine}
 */
affinity.sin = function(attr){
    return new affinity.Sine(attr);
};

/**
 * @param attr
 * @returns {Functions.Numeric.SquareRoot}
 */
affinity.sqrt = function(attr){
    return new affinity.SquareRoot(attr);
};

/**
 * @param attr
 * @returns {Functions.Numeric.Tangent}
 */
affinity.tan = function(attr){
    return new affinity.Tangent(attr);
};
//endregion

//region String Functions

/**
 * @type {Functions.String.Length} 
 * @member Affinity
 */
affinity.Length = require('./affinity/functions/string/Length.js');

/**
 * @type {Functions.String.Lowercase} 
 * @member Affinity
 */
affinity.Lowercase = require('./affinity/functions/string/Lowercase.js');

/**
 * @type {Functions.String.Test} 
 * @member Affinity
 */
affinity.Test = require('./affinity/functions/string/Test.js');

/**
 * @type {Functions.String.Substring} 
 * @member Affinity
 */
affinity.Substring = require('./affinity/functions/string/Substring.js');

/**
 * @type {Functions.String.Uppercase} 
 * @member Affinity
 */
affinity.Uppercase = require('./affinity/functions/string/Uppercase.js');

/**
 * @param attr
 * @returns {Functions.String.Length}
 */
affinity.length = function(attr){
    return new affinity.Length(attr);
};

/**
 * @param attr
 * @returns {Functions.String.Lowercase}
 */
affinity.lowercase = function(attr){
    return new affinity.Lowercase(attr);
};

/**
 * @param attr
 * @param regex
 * @returns {Functions.String.Test}
 */
affinity.test = function(attr, regex){
    return new affinity.Test(attr, regex);
};

/**
 * @param attr
 * @param start
 * @param length
 * @returns {Functions.String.Substring}
 */
affinity.substr = function(attr, start, length){
    return new affinity.Length(attr, start, length);
};

/**
 * @param attr
 * @returns {Functions.String.Uppercase}
 */
affinity.uppercase = function(attr){
    return new affinity.Length(attr);
};
//endregion

//region Tuple Functions

/**
 * @type {Functions.Tuple.AttributeValue} 
 * @member Affinity
 */
affinity.TupleValue = require('./affinity/functions/tuple/Attribute.js');

/**
 * @param relation
 * @param attributeName
 * @returns {Functions.Tuple.AttributeValue}
 */
affinity.value = function(relation, attributeName){
    var result = new affinity.TupleValue(attributeName);
    result.type(relation.header().get(attributeName));
    return result;
};
//endregion

//region Date Functions

affinity.DayOfMonth = require('./affinity/functions/date/DayOfMonth.js');
affinity.DayOfMonth = require('./affinity/functions/date/DayOfMonth.js');
affinity.DayOfWeek = require('./affinity/functions/date/DayOfWeek.js');
affinity.DayOfYear = require('./affinity/functions/date/DayOfYear.js');
affinity.Hours = require('./affinity/functions/date/Hours.js');
affinity.Milliseconds = require('./affinity/functions/date/Milliseconds.js');
affinity.Minutes = require('./affinity/functions/date/Minutes.js');
affinity.Month = require('./affinity/functions/date/Month.js');
affinity.Seconds = require('./affinity/functions/date/Seconds.js');
affinity.Timestamp = require('./affinity/functions/date/Timestamp.js');
affinity.WeekOfYear = require('./affinity/functions/date/WeekOfYear.js');
affinity.Year = require('./affinity/functions/date/Year.js');
//endregion

affinity.count = function(){
    return new (require('./affinity/functions/aggregate/Count.js'));
};

//region Relational Operators

/**
 * @type {Operators.Composition} 
 * @member Affinity
 */
affinity.Composition = require('./affinity/algebra/Composition.js');

/**
 * @type {Operators.Difference} 
 * @member Affinity
 */
affinity.Difference = require('./affinity/algebra/Difference.js');

/**
 * @type {Operators.Extension} 
 * @member Affinity
 */
affinity.Extension = require('./affinity/algebra/Extension.js');

/**
 * @type {Operators.Group} 
 * @member Affinity
 */
affinity.Group = require('./affinity/algebra/Group.js');

/**
 * @type {Operators.Intersection} 
 * @member Affinity
 */
affinity.Intersection = require('./affinity/algebra/Intersection.js');

/**
 * @type {Operators.Join} 
 * @member Affinity
 */
affinity.Join = require('./affinity/algebra/Join.js');

/**
 * @type {Operators.Product} 
 * @member Affinity
 */
affinity.Product = require('./affinity/algebra/Product.js');

/**
 * @type {Operators.Projection} 
 * @member Affinity
 */
affinity.Projection = require('./affinity/algebra/Projection.js');

/**
 * @type {Operators.Rename} 
 * @member Affinity
 */
affinity.Rename = require('./affinity/algebra/Rename.js');

/**
 * @type {Operators.Restriction} 
 * @member Affinity
 */
affinity.Restriction = require('./affinity/algebra/Restriction.js');

/**
 * @type {Operators.SemiDifference} 
 * @member Affinity
 */
affinity.SemiDifference = require('./affinity/algebra/Semidifference.js');

/**
 * @type {Operators.SemiJoin} 
 * @member Affinity
 */
affinity.SemiJoin = require('./affinity/algebra/Semijoin.js');

/**
 * @type {Operators.Ungroup} 
 * @member Affinity
 */
affinity.Ungroup = require('./affinity/algebra/Ungroup.js');

/**
 * @type {Operators.Union} 
 * @member Affinity
 */
affinity.Union = require('./affinity/algebra/Union.js');

/**
 * @type {Operators.Unwrap} 
 * @member Affinity
 */
affinity.Unwrap = require('./affinity/algebra/Unwrap.js');

/**
 * @type {Operators.Wrap} 
 * @member Affinity
 */
affinity.Wrap = require('./affinity/algebra/Wrap.js');
//endregion

//region Constants

/**
 * @type {Relation} 
 * @member Affinity
 */
affinity.TABLE_DUM = new affinity.Relation([]);

/**
 * @type {Relation} 
 * @member Affinity
 */
affinity.TABLE_DEE = new affinity.Relation([], [
    []
]);
//endregion

module.exports = affinity;

},{"./affinity/Attribute.js":2,"./affinity/Function.js":5,"./affinity/Header.js":6,"./affinity/Index.js":7,"./affinity/Relation.js":9,"./affinity/Set.js":10,"./affinity/Tuple.js":11,"./affinity/algebra/Composition.js":13,"./affinity/algebra/Difference.js":14,"./affinity/algebra/Extension.js":15,"./affinity/algebra/Group.js":16,"./affinity/algebra/Intersection.js":17,"./affinity/algebra/Join.js":18,"./affinity/algebra/Product.js":19,"./affinity/algebra/Projection.js":20,"./affinity/algebra/Rename.js":21,"./affinity/algebra/Restriction.js":22,"./affinity/algebra/Semidifference.js":23,"./affinity/algebra/Semijoin.js":24,"./affinity/algebra/Ungroup.js":26,"./affinity/algebra/Union.js":27,"./affinity/algebra/Unwrap.js":28,"./affinity/algebra/Wrap.js":29,"./affinity/functions/aggregate/Count.js":33,"./affinity/functions/comparable/Equal.js":39,"./affinity/functions/comparable/GreaterThan.js":40,"./affinity/functions/comparable/GreaterThanEqual.js":41,"./affinity/functions/comparable/SmallerThan.js":42,"./affinity/functions/comparable/SmallerThanEqual.js":43,"./affinity/functions/connective/And.js":44,"./affinity/functions/connective/Not.js":45,"./affinity/functions/connective/Or.js":46,"./affinity/functions/date/DayOfMonth.js":47,"./affinity/functions/date/DayOfWeek.js":48,"./affinity/functions/date/DayOfYear.js":49,"./affinity/functions/date/Hours.js":50,"./affinity/functions/date/Milliseconds.js":51,"./affinity/functions/date/Minutes.js":52,"./affinity/functions/date/Month.js":53,"./affinity/functions/date/Seconds.js":54,"./affinity/functions/date/Timestamp.js":55,"./affinity/functions/date/WeekOfYear.js":56,"./affinity/functions/date/Year.js":57,"./affinity/functions/numeric/Absolute.js":58,"./affinity/functions/numeric/Ceil.js":59,"./affinity/functions/numeric/Cosine.js":60,"./affinity/functions/numeric/Division.js":61,"./affinity/functions/numeric/Exponential.js":62,"./affinity/functions/numeric/Floor.js":63,"./affinity/functions/numeric/Minus.js":64,"./affinity/functions/numeric/Modulo.js":65,"./affinity/functions/numeric/Multiplication.js":66,"./affinity/functions/numeric/Plus.js":67,"./affinity/functions/numeric/Power.js":68,"./affinity/functions/numeric/Round.js":69,"./affinity/functions/numeric/Sine.js":70,"./affinity/functions/numeric/SquareRoot.js":71,"./affinity/functions/numeric/Tangent.js":72,"./affinity/functions/string/Length.js":73,"./affinity/functions/string/Lowercase.js":74,"./affinity/functions/string/Substring.js":75,"./affinity/functions/string/Test.js":76,"./affinity/functions/string/Uppercase.js":77,"./affinity/functions/tuple/Attribute.js":78,"./affinity/types/Boolean":93,"./affinity/types/Date":94,"./affinity/types/Float":95,"./affinity/types/Integer":96,"./affinity/types/Object":98,"./affinity/types/String":99,"./affinity/types/Type.js":100}],102:[function(require,module,exports){
'use strict';

/**
 * Representation of a single EventEmitter function.
 *
 * @param {Function} fn Event handler to be called.
 * @param {Mixed} context Context for function execution.
 * @param {Boolean} once Only emit once
 * @api private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Minimal EventEmitter interface that is molded against the Node.js
 * EventEmitter interface.
 *
 * @constructor
 * @api public
 */
function EventEmitter() { /* Nothing to set */ }

/**
 * Holds the assigned EventEmitters by name.
 *
 * @type {Object}
 * @private
 */
EventEmitter.prototype._events = undefined;

/**
 * Return a list of assigned event listeners.
 *
 * @param {String} event The events that should be listed.
 * @returns {Array}
 * @api public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  if (!this._events || !this._events[event]) return [];
  if (this._events[event].fn) return [this._events[event].fn];

  for (var i = 0, l = this._events[event].length, ee = new Array(l); i < l; i++) {
    ee[i] = this._events[event][i].fn;
  }

  return ee;
};

/**
 * Emit an event to all registered event listeners.
 *
 * @param {String} event The name of the event.
 * @returns {Boolean} Indication if we've emitted an event.
 * @api public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  if (!this._events || !this._events[event]) return false;

  var listeners = this._events[event]
    , len = arguments.length
    , args
    , i;

  if ('function' === typeof listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Register a new EventListener for the given event.
 *
 * @param {String} event Name of the event.
 * @param {Functon} fn Callback function.
 * @param {Mixed} context The context of the function.
 * @api public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  var listener = new EE(fn, context || this);

  if (!this._events) this._events = {};
  if (!this._events[event]) this._events[event] = listener;
  else {
    if (!this._events[event].fn) this._events[event].push(listener);
    else this._events[event] = [
      this._events[event], listener
    ];
  }

  return this;
};

/**
 * Add an EventListener that's only called once.
 *
 * @param {String} event Name of the event.
 * @param {Function} fn Callback function.
 * @param {Mixed} context The context of the function.
 * @api public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  var listener = new EE(fn, context || this, true);

  if (!this._events) this._events = {};
  if (!this._events[event]) this._events[event] = listener;
  else {
    if (!this._events[event].fn) this._events[event].push(listener);
    else this._events[event] = [
      this._events[event], listener
    ];
  }

  return this;
};

/**
 * Remove event listeners.
 *
 * @param {String} event The event we want to remove.
 * @param {Function} fn The listener that we need to find.
 * @param {Boolean} once Only remove once listeners.
 * @api public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, once) {
  if (!this._events || !this._events[event]) return this;

  var listeners = this._events[event]
    , events = [];

  if (fn) {
    if (listeners.fn && (listeners.fn !== fn || (once && !listeners.once))) {
      events.push(listeners);
    }
    if (!listeners.fn) for (var i = 0, length = listeners.length; i < length; i++) {
      if (listeners[i].fn !== fn || (once && !listeners[i].once)) {
        events.push(listeners[i]);
      }
    }
  }

  //
  // Reset the array, or remove it completely if we have no more listeners.
  //
  if (events.length) {
    this._events[event] = events.length === 1 ? events[0] : events;
  } else {
    delete this._events[event];
  }

  return this;
};

/**
 * Remove all listeners or only the listeners for the specified event.
 *
 * @param {String} event The event want to remove all listeners for.
 * @api public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  if (!this._events) return this;

  if (event) delete this._events[event];
  else this._events = {};

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// This function doesn't apply anymore.
//
EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
  return this;
};

//
// Expose the module.
//
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.EventEmitter2 = EventEmitter;
EventEmitter.EventEmitter3 = EventEmitter;

//
// Expose the module.
//
module.exports = EventEmitter;

},{}],103:[function(require,module,exports){
(function (global){
/**
 * @license
 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
 * Build: `lodash modern -o ./dist/lodash.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to pool arrays and objects used internally */
  var arrayPool = [],
      objectPool = [];

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date + '';

  /** Used as the size when optimizations are enabled for large arrays */
  var largeArraySize = 75;

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to detect and test whitespace */
  var whitespace = (
    // whitespace
    ' \t\x0B\f\xA0\ufeff' +

    // line terminators
    '\n\r\u2028\u2029' +

    // unicode category "Zs" space separators
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to match empty string literals in compiled template source */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to detected named functions */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match leading whitespace and zeros to be removed */
  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to detect functions containing a `this` reference */
  var reThis = /\bthis\b/;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** Used to assign default `context` object properties */
  var contextProps = [
    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
    'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify */
  var templateCounter = 0;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used as an internal `_.debounce` options object */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used as the property descriptor for `__bindData__` */
  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object'
      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
      : (cache ? 0 : -1);
  }

  /**
   * Adds a given value to the corresponding cache object.
   *
   * @private
   * @param {*} value The value to add to the cache.
   */
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }

  /**
   * Used by `_.max` and `_.min` as the default callback when a given
   * collection is a string value.
   *
   * @private
   * @param {string} value The character to inspect.
   * @returns {number} Returns the code unit of given character.
   */
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }

  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index < length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value > other || typeof value == 'undefined') {
          return 1;
        }
        if (value < other || typeof other == 'undefined') {
          return -1;
        }
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to return the same value for
    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
    //
    // This also ensures a stable sort in V8 and other engines.
    // See http://code.google.com/p/v8/issues/detail?id=90
    return a.index - b.index;
  }

  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
   */
  function createCache(array) {
    var index = -1,
        length = array.length,
        first = array[0],
        mid = array[(length / 2) | 0],
        last = array[length - 1];

    if (first && typeof first == 'object' &&
        mid && typeof mid == 'object' && last && typeof last == 'object') {
      return false;
    }
    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return result;
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'true': false,
      'undefined': false,
      'value': null
    };
  }

  /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Releases the given object back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new `lodash` function using the given context object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns the `lodash` function.
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See http://es5.github.io/#x11.1.5.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references */
    var Array = context.Array,
        Boolean = context.Boolean,
        Date = context.Date,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];

    /** Used for native method references */
    var objectProto = Object.prototype;

    /** Used to restore the original `_` reference in `noConflict` */
    var oldDash = context._;

    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;

    /** Used to detect if a method is native */
    var reNative = RegExp('^' +
      String(toString)
        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        .replace(/toString| for [^\]]+/g, '.*?') + '$'
    );

    /** Native method shortcuts */
    var ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        fnToString = Function.prototype.toString,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        push = arrayRef.push,
        setTimeout = context.setTimeout,
        splice = arrayRef.splice,
        unshift = arrayRef.unshift;

    /** Used to set meta data on functions */
    var defineProperty = (function() {
      // IE 8 only accepts DOM elements
      try {
        var o = {},
            func = isNative(func = Object.defineProperty) && func,
            result = func(o, o, o) && func;
      } catch(e) { }
      return result;
    }());

    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used to lookup a built-in constructor by [[Class]] */
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps the given value to enable intuitive
     * method chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
     * and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
     * `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * provided, otherwise they return unwrapped values.
     *
     * Explicit chaining can be enabled by using the `_.chain` method.
     *
     * @name _
     * @constructor
     * @category Chaining
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
       ? value
       : new lodashWrapper(value);
    }

    /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap in a `lodash` instance.
     * @param {boolean} chainAll A flag to enable chaining for all methods
     * @returns {Object} Returns a `lodash` instance.
     */
    function lodashWrapper(value, chainAll) {
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    }
    // ensure `new lodashWrapper` is an instance of `lodash`
    lodashWrapper.prototype = lodash.prototype;

    /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';

    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': /<%-([\s\S]+?)%>/g,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': /<%([\s\S]+?)%>/g,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*--------------------------------------------------------------------------*/

    /**
     * The base implementation of `_.bind` that creates the bound function and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new bound function.
     */
    function baseBind(bindData) {
      var func = bindData[0],
          partialArgs = bindData[2],
          thisArg = bindData[4];

      function bound() {
        // `Function#bind` spec
        // http://es5.github.io/#x15.3.4.5
        if (partialArgs) {
          // avoid `arguments` object deoptimizations by using `slice` instead
          // of `Array.prototype.slice.call` and not assigning `arguments` to a
          // variable as a ternary expression
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        // mimic the constructor's `return` behavior
        // http://es5.github.io/#x13.2.2
        if (this instanceof bound) {
          // ensure `new bound` is an instance of `func`
          var thisBinding = baseCreate(func.prototype),
              result = func.apply(thisBinding, args || arguments);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisArg, args || arguments);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.clone` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, callback, stackA, stackB) {
      if (callback) {
        var result = callback(value);
        if (typeof result != 'undefined') {
          return result;
        }
      }
      // inspect [[Class]]
      var isObj = isObject(value);
      if (isObj) {
        var className = toString.call(value);
        if (!cloneableClasses[className]) {
          return value;
        }
        var ctor = ctorByClass[className];
        switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+value);

          case numberClass:
          case stringClass:
            return new ctor(value);

          case regexpClass:
            result = ctor(value.source, reFlags.exec(value));
            result.lastIndex = value.lastIndex;
            return result;
        }
      } else {
        return value;
      }
      var isArr = isArray(value);
      if (isDeep) {
        // check for circular references and return corresponding clone
        var initedStack = !stackA;
        stackA || (stackA = getArray());
        stackB || (stackB = getArray());

        var length = stackA.length;
        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }
        result = isArr ? ctor(value.length) : {};
      }
      else {
        result = isArr ? slice(value) : assign({}, value);
      }
      // add array properties assigned by `RegExp#exec`
      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      }
      // exit for shallow clone
      if (!isDeep) {
        return result;
      }
      // add the source value to the stack of traversed objects
      // and associate it with its clone
      stackA.push(value);
      stackB.push(result);

      // recursively populate clone (susceptible to call stack limits)
      (isArr ? forEach : forOwn)(value, function(objValue, key) {
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(prototype, properties) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }
    // fallback for browsers without `Object.create`
    if (!nativeCreate) {
      baseCreate = (function() {
        function Object() {}
        return function(prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object;
            Object.prototype = null;
          }
          return result || context.Object();
        };
      }());
    }

    /**
     * The base implementation of `_.createCallback` without support for creating
     * "_.pluck" or "_.where" style callbacks.
     *
     * @private
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     */
    function baseCreateCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      // exit early for no `thisArg` or already bound by `Function#bind`
      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
        return func;
      }
      var bindData = func.__bindData__;
      if (typeof bindData == 'undefined') {
        if (support.funcNames) {
          bindData = !func.name;
        }
        bindData = bindData || !support.funcDecomp;
        if (!bindData) {
          var source = fnToString.call(func);
          if (!support.funcNames) {
            bindData = !reFuncName.test(source);
          }
          if (!bindData) {
            // checks if `func` references the `this` keyword and stores the result
            bindData = reThis.test(source);
            setBindData(func, bindData);
          }
        }
      }
      // exit early if there are no `this` references or `func` is bound
      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 2: return function(a, b) {
          return func.call(thisArg, a, b);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return bind(func, thisArg);
    }

    /**
     * The base implementation of `createWrapper` that creates the wrapper and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new function.
     */
    function baseCreateWrapper(bindData) {
      var func = bindData[0],
          bitmask = bindData[1],
          partialArgs = bindData[2],
          partialRightArgs = bindData[3],
          thisArg = bindData[4],
          arity = bindData[5];

      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          key = func;

      function bound() {
        var thisBinding = isBind ? thisArg : this;
        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        if (partialRightArgs || isCurry) {
          args || (args = slice(arguments));
          if (partialRightArgs) {
            push.apply(args, partialRightArgs);
          }
          if (isCurry && args.length < arity) {
            bitmask |= 16 & ~32;
            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
          }
        }
        args || (args = arguments);
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (this instanceof bound) {
          thisBinding = baseCreate(func.prototype);
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.difference` that accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {Array} [values] The array of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     */
    function baseDifference(array, values) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
          result = [];

      if (isLarge) {
        var cache = createCache(values);
        if (cache) {
          indexOf = cacheIndexOf;
          values = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(values);
      }
      return result;
    }

    /**
     * The base implementation of `_.flatten` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns a new flattened array.
     */
    function baseFlatten(array, isShallow, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (value && typeof value == 'object' && typeof value.length == 'number'
            && (isArray(value) || isArguments(value))) {
          // recursively flatten arrays (susceptible to call stack limits)
          if (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }
          var valIndex = -1,
              valLength = value.length,
              resIndex = result.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[resIndex++] = value[valIndex];
          }
        } else if (!isStrict) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
     * that allows partial "_.where" style comparisons.
     *
     * @private
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      if (callback) {
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;

      // exit early for unlike primitive values
      if (a === a &&
          !(a && objectTypes[type]) &&
          !(b && objectTypes[otherType])) {
        return false;
      }
      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
      // http://es5.github.io/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return (a != +a)
            ? b != +b
            // but treat `+0` vs. `-0` as not equal
            : (a == 0 ? (1 / a == 1 / b) : a == +b);

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');

        if (aWrapped || bWrapped) {
          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        }
        // exit for functions and DOM nodes
        if (className != objectClass) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = a.constructor,
            ctorB = b.constructor;

        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB &&
              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
              ('constructor' in a && 'constructor' in b)
            ) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;

      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);

      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        // compare lengths to determine if a deep comparison is necessary
        length = a.length;
        size = b.length;
        result = size == length;

        if (result || isWhere) {
          // deep compare the contents, ignoring non-numeric properties
          while (size--) {
            var index = length,
                value = b[size];

            if (isWhere) {
              while (index--) {
                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      }
      else {
        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
        // which, in this case, is more costly
        forIn(b, function(value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            // count the number of properties.
            size++;
            // deep compare each property value.
            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
          }
        });

        if (result && !isWhere) {
          // ensure both objects have the same number of properties
          forIn(a, function(value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              // `size` will be `-1` if `a` has more properties than `b`
              return (result = --size > -1);
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.merge` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     */
    function baseMerge(object, source, callback, stackA, stackB) {
      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
        var found,
            isArr,
            result = source,
            value = object[key];

        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          // avoid merging previously merged cyclic sources
          var stackLength = stackA.length;
          while (stackLength--) {
            if ((found = stackA[stackLength] == source)) {
              value = stackB[stackLength];
              break;
            }
          }
          if (!found) {
            var isShallow;
            if (callback) {
              result = callback(value, source);
              if ((isShallow = typeof result != 'undefined')) {
                value = result;
              }
            }
            if (!isShallow) {
              value = isArr
                ? (isArray(value) ? value : [])
                : (isPlainObject(value) ? value : {});
            }
            // add `source` and associated `value` to the stack of traversed objects
            stackA.push(source);
            stackB.push(value);

            // recursively merge objects and arrays (susceptible to call stack limits)
            if (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        }
        else {
          if (callback) {
            result = callback(value, source);
            if (typeof result == 'undefined') {
              result = source;
            }
          }
          if (typeof result != 'undefined') {
            value = result;
          }
        }
        object[key] = value;
      });
    }

    /**
     * The base implementation of `_.random` without argument juggling or support
     * for returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns a random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function} [callback] The function called per iteration.
     * @returns {Array} Returns a duplicate-value-free array.
     */
    function baseUniq(array, isSorted, callback) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [];

      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
          seen = (callback || isLarge) ? getArray() : result;

      if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
      }
      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;

        if (isSorted
              ? !index || seen[seen.length - 1] !== computed
              : indexOf(seen, computed) < 0
            ) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an object composed
     * of keys generated from the results of running each element of the collection
     * through a callback. The given `setter` function sets the keys and values
     * of the composed object.
     *
     * @private
     * @param {Function} setter The setter function.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter) {
      return function(collection, callback, thisArg) {
        var result = {};
        callback = lodash.createCallback(callback, thisArg, 3);

        var index = -1,
            length = collection ? collection.length : 0;

        if (typeof length == 'number') {
          while (++index < length) {
            var value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } else {
          forOwn(collection, function(value, key, collection) {
            setter(result, value, callback(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that, when called, either curries or invokes `func`
     * with an optional `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of method flags to compose.
     *  The bitmask may be composed of the following flags:
     *  1 - `_.bind`
     *  2 - `_.bindKey`
     *  4 - `_.curry`
     *  8 - `_.curry` (bound)
     *  16 - `_.partial`
     *  32 - `_.partialRight`
     * @param {Array} [partialArgs] An array of arguments to prepend to those
     *  provided to the new function.
     * @param {Array} [partialRightArgs] An array of arguments to append to those
     *  provided to the new function.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new function.
     */
    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;

      if (!isBindKey && !isFunction(func)) {
        throw new TypeError;
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        // clone `bindData`
        bindData = slice(bindData);
        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }
        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        }
        // set `thisBinding` is not previously bound
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        // set if previously bound but not currently (subsequent curried functions)
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        // set curried arity if not yet set
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        // append partial left arguments
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        // append partial right arguments
        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        // merge flags
        bindData[1] |= bitmask;
        return createWrapper.apply(null, bindData);
      }
      // fast path for `_.bind`
      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }

    /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} match The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized, this method returns the custom method, otherwise it returns
     * the `baseIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */
    function getIndexOf() {
      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
      return result;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
     */
    function isNative(value) {
      return typeof value == 'function' && reNative.test(value);
    }

    /**
     * Sets `this` binding data on a given function.
     *
     * @private
     * @param {Function} func The function to set data on.
     * @param {Array} value The data array to set.
     */
    var setBindData = !defineProperty ? noop : function(func, value) {
      descriptor.value = value;
      defineProperty(func, '__bindData__', descriptor);
    };

    /**
     * A fallback implementation of `isPlainObject` which checks if a given value
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var ctor,
          result;

      // avoid non Object objects, `arguments` objects, and DOM elements
      if (!(value && toString.call(value) == objectClass) ||
          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
        return false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function(value, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} match The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == argsClass || false;
    }

    /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */
    var isArray = nativeIsArray || function(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == arrayClass || false;
    };

    /**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     */
    var shimKeys = function(object) {
      var index, iterable = object, result = [];
      if (!iterable) return result;
      if (!(objectTypes[typeof object])) return result;
        for (index in iterable) {
          if (hasOwnProperty.call(iterable, index)) {
            result.push(index);
          }
        }
      return result
    };

    /**
     * Creates an array composed of the own enumerable property names of an object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (!isObject(object)) {
        return [];
      }
      return nativeKeys(object);
    };

    /**
     * Used to convert characters to HTML entities:
     *
     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
     * don't require escaping in HTML and have no special meaning unless they're part
     * of a tag or an unquoted attribute value.
     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
     */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    /** Used to convert HTML entities to characters */
    var htmlUnescapes = invert(htmlEscapes);

    /** Used to match HTML entities and HTML characters */
    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

    /*--------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a callback is provided it will be executed to produce the
     * assigned values. The callback is bound to `thisArg` and invoked with two
     * arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @type Function
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
     * // => { 'name': 'fred', 'employer': 'slate' }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * var object = { 'name': 'barney' };
     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var assign = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
        callback = args[--argsLength];
      }
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
        }
        }
      }
      return result
    };

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a callback
     * is provided it will be executed to produce the cloned values. If the
     * callback returns `undefined` cloning will be handled by the method instead.
     * The callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var shallow = _.clone(characters);
     * shallow[0] === characters[0];
     * // => true
     *
     * var deep = _.clone(characters, true);
     * deep[0] === characters[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, callback, thisArg) {
      // allows working with "Collections" methods without using their `index`
      // and `collection` arguments for `isDeep` and `callback`
      if (typeof isDeep != 'boolean' && isDeep != null) {
        thisArg = callback;
        callback = isDeep;
        isDeep = false;
      }
      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates a deep clone of `value`. If a callback is provided it will be
     * executed to produce the cloned values. If the callback returns `undefined`
     * cloning will be handled by the method instead. The callback is bound to
     * `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var deep = _.cloneDeep(characters);
     * deep[0] === characters[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */
    function cloneDeep(value, callback, thisArg) {
      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? assign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param- {Object} [guard] Allows working with `_.reduce` without using its
     *  `key` and `object` arguments as sources.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var object = { 'name': 'barney' };
     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var defaults = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (typeof result[index] == 'undefined') result[index] = iterable[index];
        }
        }
      }
      return result
    };

    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': false },
     *   'fred': {    'age': 40, 'blocked': true },
     *   'pebbles': { 'age': 1,  'blocked': false }
     * };
     *
     * _.findKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (property order is not guaranteed across environments)
     *
     * // using "_.where" callback shorthand
     * _.findKey(characters, { 'age': 1 });
     * // => 'pebbles'
     *
     * // using "_.pluck" callback shorthand
     * _.findKey(characters, 'blocked');
     * // => 'fred'
     */
    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': true },
     *   'fred': {    'age': 40, 'blocked': false },
     *   'pebbles': { 'age': 1,  'blocked': true }
     * };
     *
     * _.findLastKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
     *
     * // using "_.where" callback shorthand
     * _.findLastKey(characters, { 'age': 40 });
     * // => 'fred'
     *
     * // using "_.pluck" callback shorthand
     * _.findLastKey(characters, 'blocked');
     * // => 'pebbles'
     */
    function findLastKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwnRight(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over own and inherited enumerable properties of an object,
     * executing the callback for each property. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forIn(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
     */
    var forIn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        for (index in iterable) {
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forIn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forInRight(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
     */
    function forInRight(object, callback, thisArg) {
      var pairs = [];

      forIn(object, function(value, key) {
        pairs.push(key, value);
      });

      var length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(pairs[length--], pairs[length], object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Iterates over own enumerable properties of an object, executing the callback
     * for each property. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
     */
    var forOwn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forOwn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */
    function forOwnRight(object, callback, thisArg) {
      var props = keys(object),
          length = props.length;

      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        var key = props[length];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Creates a sorted array of property names of all enumerable properties,
     * own and inherited, of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */
    function functions(object) {
      var result = [];
      forIn(object, function(value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }

    /**
     * Checks if the specified property name exists as a direct property of `object`,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to check.
     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of the given object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     * _.invert({ 'first': 'fred', 'second': 'barney' });
     * // => { 'fred': 'first', 'barney': 'second' }
     */
    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }

    /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        value && typeof value == 'object' && toString.call(value) == boolClass || false;
    }

    /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */
    function isDate(value) {
      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */
    function isElement(value) {
      return value && value.nodeType === 1 || false;
    }

    /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value),
          length = value.length;

      if ((className == arrayClass || className == stringClass || className == argsClass ) ||
          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
        return !length;
      }
      forOwn(value, function() {
        return (result = false);
      });
      return result;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If a callback is provided it will be executed
     * to compare values. If the callback returns `undefined` comparisons will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var copy = { 'name': 'fred' };
     *
     * object == copy;
     * // => false
     *
     * _.isEqual(object, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */
    function isEqual(a, b, callback, thisArg) {
      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
    }

    /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite` which will return true for
     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }

    /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */
    function isFunction(value) {
      return typeof value == 'function';
    }

    /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // check if the value is the ECMAScript language type of Object
      // http://es5.github.io/#x8
      // and avoid a V8 bug
      // http://code.google.com/p/v8/issues/detail?id=2291
      return !!(value && objectTypes[typeof value]);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN` which will return `true` for
     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // `NaN` as a primitive is the only value that is not equal to itself
      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is a number.
     *
     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        value && typeof value == 'object' && toString.call(value) == numberClass || false;
    }

    /**
     * Checks if `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * _.isPlainObject(new Shape);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && toString.call(value) == objectClass)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/fred/);
     * // => true
     */
    function isRegExp(value) {
      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
    }

    /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('fred');
     * // => true
     */
    function isString(value) {
      return typeof value == 'string' ||
        value && typeof value == 'object' && toString.call(value) == stringClass || false;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     *
     * var characters = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // using "_.pluck" callback shorthand
     * _.mapValues(characters, 'age');
     * // => { 'fred': 40, 'pebbles': 1 }
     */
    function mapValues(object, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg, 3);

      forOwn(object, function(value, key, object) {
        result[key] = callback(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a callback is
     * provided it will be executed to produce the merged values of the destination
     * and source properties. If the callback returns `undefined` merging will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'characters': [
     *     { 'name': 'barney' },
     *     { 'name': 'fred' }
     *   ]
     * };
     *
     * var ages = {
     *   'characters': [
     *     { 'age': 36 },
     *     { 'age': 40 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */
    function merge(object) {
      var args = arguments,
          length = 2;

      if (!isObject(object)) {
        return object;
      }
      // allows working with `_.reduce` and `_.reduceRight` without using
      // their `index` and `collection` arguments
      if (typeof args[2] != 'number') {
        length = args.length;
      }
      if (length > 3 && typeof args[length - 2] == 'function') {
        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
      } else if (length > 2 && typeof args[length - 1] == 'function') {
        callback = args[--length];
      }
      var sources = slice(arguments, 1, length),
          index = -1,
          stackA = getArray(),
          stackB = getArray();

      while (++index < length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }
      releaseArray(stackA);
      releaseArray(stackB);
      return object;
    }

    /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` omitting the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The properties to omit or the
     *  function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
     * // => { 'name': 'fred' }
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'fred' }
     */
    function omit(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var props = [];
        forIn(object, function(value, key) {
          props.push(key);
        });
        props = baseDifference(props, baseFlatten(arguments, true, false, 1));

        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          result[key] = object[key];
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (!callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * Creates a two dimensional array of an object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` picking the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The function called per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
     * // => { 'name': 'fred' }
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'fred' }
     */
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var index = -1,
            props = baseFlatten(arguments, true, false, 1),
            length = isObject(object) ? props.length : 0;

        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * An alternative to `_.reduce` this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable properties through a callback, with each callback execution
     * potentially mutating the `accumulator` object. The callback is bound to
     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
     * Callbacks may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;

          accumulator = baseCreate(proto);
        }
      }
      if (callback) {
        callback = lodash.createCallback(callback, thisArg, 4);
        (isArr ? forEach : forOwn)(object, function(value, index, object) {
          return callback(accumulator, value, index, object);
        });
      }
      return accumulator;
    }

    /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (property order is not guaranteed across environments)
     */
    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
     *   to retrieve, specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var args = arguments,
          index = -1,
          props = baseFlatten(args, true, false, 1),
          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
          result = Array(length);

      while(++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }

    /**
     * Checks if a given value is present in a collection using strict equality
     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
     * offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {*} target The value to check for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.contains('pebbles', 'eb');
     * // => true
     */
    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = getIndexOf(),
          length = collection ? collection.length : 0,
          result = false;

      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (isArray(collection)) {
        result = indexOf(collection, target, fromIndex) > -1;
      } else if (typeof length == 'number') {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        forOwn(collection, function(value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through the callback. The corresponding value
     * of each key is the number of times the key was returned by the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
    });

    /**
     * Checks if the given callback returns truey value for **all** elements of
     * a collection. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if all elements passed the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes']);
     * // => false
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(characters, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(characters, { 'age': 36 });
     * // => false
     */
    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return (result = !!callback(value, index, collection));
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning an array of all elements
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(characters, 'blocked');
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     *
     * // using "_.where" callback shorthand
     * _.filter(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     */
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning the first element that
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.find(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
     *
     * // using "_.where" callback shorthand
     * _.find(characters, { 'age': 1 });
     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
     *
     * // using "_.pluck" callback shorthand
     * _.find(characters, 'blocked');
     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
     */
    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }

    /**
     * This method is like `_.find` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(num) {
     *   return num % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forEachRight(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over elements of a collection, executing the callback for each
     * element. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * Note: As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
     * // => logs each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
     * // => logs each number and returns the object (property order is not guaranteed across environments)
     */
    function forEach(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        forOwn(collection, callback);
      }
      return collection;
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
     * // => logs each number from right to left and returns '3,2,1'
     */
    function forEachRight(collection, callback, thisArg) {
      var length = collection ? collection.length : 0;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (length--) {
          if (callback(collection[length], length, collection) === false) {
            break;
          }
        }
      } else {
        var props = keys(collection);
        length = props.length;
        forOwn(collection, function(value, key, collection) {
          key = props ? props[--length] : --length;
          return callback(collection[key], key, collection);
        });
      }
      return collection;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of a collection through the callback. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of the collection through the given callback. The corresponding
     * value of each key is the last element responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keys = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keys, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in the `collection`
     * returning an array of the results of each invoked method. Additional arguments
     * will be provided to each invoked method. If `methodName` is a function it
     * will be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [arg] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      var args = slice(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in the collection
     * through the callback. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (property order is not guaranteed across environments)
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(characters, 'name');
     * // => ['barney', 'fred']
     */
    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        result = [];
        forOwn(collection, function(value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }

    /**
     * Retrieves the maximum value of a collection. If the collection is empty or
     * falsey `-Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.max(characters, function(chr) { return chr.age; });
     * // => { 'name': 'fred', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(characters, 'age');
     * // => { 'name': 'fred', 'age': 40 };
     */
    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the minimum value of a collection. If the collection is empty or
     * falsey `Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.min(characters, function(chr) { return chr.age; });
     * // => { 'name': 'barney', 'age': 36 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(characters, 'age');
     * // => { 'name': 'barney', 'age': 36 };
     */
    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the value of a specified property from all elements in the collection.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} property The name of the property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(characters, 'name');
     * // => ['barney', 'fred']
     */
    var pluck = map;

    /**
     * Reduces a collection to a value which is the accumulated result of running
     * each element in the collection through the callback, where each successive
     * callback execution consumes the return value of the previous execution. If
     * `accumulator` is not provided the first element of the collection will be
     * used as the initial `accumulator` value. The callback is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function reduce(collection, callback, accumulator, thisArg) {
      if (!collection) return accumulator;
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);

      var index = -1,
          length = collection.length;

      if (typeof length == 'number') {
        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          accumulator = noaccum
            ? (noaccum = false, value)
            : callback(accumulator, value, index, collection)
        });
      }
      return accumulator;
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      forEachRight(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The opposite of `_.filter` this method returns the elements of a
     * collection that the callback does **not** return truey for.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that failed the callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(characters, 'blocked');
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     *
     * // using "_.where" callback shorthand
     * _.reject(characters, { 'age': 36 });
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     */
    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      return filter(collection, function(value, index, collection) {
        return !callback(value, index, collection);
      });
    }

    /**
     * Retrieves a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Allows working with functions like `_.map`
     *  without using their `index` arguments as `n`.
     * @returns {Array} Returns the random sample(s) of `collection`.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (collection && typeof collection.length != 'number') {
        collection = values(collection);
      }
      if (n == null || guard) {
        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(nativeMax(0, n), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */
    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        var rand = baseRandom(0, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }

    /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }

    /**
     * Checks if the callback returns a truey value for **any** element of a
     * collection. The function returns as soon as it finds a passing value and
     * does not iterate over the entire collection. The callback is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if any element passed the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(characters, 'blocked');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(characters, { 'age': 1 });
     * // => false
     */
    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if ((result = callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through the callback. This method
     * performs a stable sort, that is, it will preserve the original sort order
     * of equal elements. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an array of property names is provided for `callback` the collection
     * will be sorted by each property value.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'barney',  'age': 26 },
     *   { 'name': 'fred',    'age': 30 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(_.sortBy(characters, 'age'), _.values);
     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
     *
     * // sorting by multiple properties
     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortBy(collection, callback, thisArg) {
      var index = -1,
          isArr = isArray(callback),
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      if (!isArr) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      forEach(collection, function(value, key, collection) {
        var object = result[++index] = getObject();
        if (isArr) {
          object.criteria = map(callback, function(key) { return value[key]; });
        } else {
          (object.criteria = getArray())[0] = callback(value, key, collection);
        }
        object.index = index;
        object.value = value;
      });

      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        if (!isArr) {
          releaseArray(object.criteria);
        }
        releaseObject(object);
      }
      return result;
    }

    /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */
    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return slice(collection);
      }
      return values(collection);
    }

    /**
     * Performs a deep comparison of each element in a `collection` to the given
     * `properties` object, returning an array of all elements that have equivalent
     * property values.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Object} props The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given properties.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.where(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
     *
     * _.where(characters, { 'pets': ['dino'] });
     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
     */
    var where = filter;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using strict
     * equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */
    function difference(array) {
      return baseDifference(array, baseFlatten(arguments, true, true, 1));
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.findIndex(characters, function(chr) {
     *   return chr.age < 20;
     * });
     * // => 2
     *
     * // using "_.where" callback shorthand
     * _.findIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findIndex(characters, 'blocked');
     * // => 1
     */
    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': true },
     *   { 'name': 'fred',    'age': 40, 'blocked': false },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
     * ];
     *
     * _.findLastIndex(characters, function(chr) {
     *   return chr.age > 30;
     * });
     * // => 1
     *
     * // using "_.where" callback shorthand
     * _.findLastIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findLastIndex(characters, 'blocked');
     * // => 2
     */
    function findLastIndex(array, callback, thisArg) {
      var length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Gets the first element or first `n` elements of an array. If a callback
     * is provided elements at the beginning of the array are returned as long
     * as the callback returns truey. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(characters, 'blocked');
     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
     * // => ['barney', 'fred']
     */
    function first(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = -1;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[0] : undefined;
        }
      }
      return slice(array, 0, nativeMin(nativeMax(0, n), length));
    }

    /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truey, the array will only be flattened a single level. If a callback
     * is provided each element of the array is passed through the callback before
     * flattening. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(characters, 'pets');
     * // => ['hoppy', 'baby puss', 'dino']
     */
    function flatten(array, isShallow, callback, thisArg) {
      // juggle arguments
      if (typeof isShallow != 'boolean' && isShallow != null) {
        thisArg = callback;
        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
        isShallow = false;
      }
      if (callback != null) {
        array = map(array, callback, thisArg);
      }
      return baseFlatten(array, isShallow);
    }

    /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the array is already sorted
     * providing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element or last `n` elements of an array. If a
     * callback is provided elements at the end of the array are excluded from
     * the result as long as the callback returns truey. The callback is bound
     * to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(characters, 'blocked');
     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
     * // => ['barney', 'fred']
     */
    function initial(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }

    /**
     * Creates an array of unique values present in all provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of shared values.
     * @example
     *
     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = getArray(),
          indexOf = getIndexOf(),
          trustIndexOf = indexOf === baseIndexOf,
          seen = getArray();

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(trustIndexOf && value.length >= largeArraySize &&
            createCache(argsIndex ? args[argsIndex] : seen));
        }
      }
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [];

      outer:
      while (++index < length) {
        var cache = caches[0];
        value = array[index];

        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }

    /**
     * Gets the last element or last `n` elements of an array. If a callback is
     * provided elements at the end of the array are returned as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.last(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.last(characters, { 'employer': 'na' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function last(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[length - 1] : undefined;
        }
      }
      return slice(array, nativeMax(0, length - n));
    }

    /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from the given array using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {...*} [value] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull(array) {
      var args = arguments,
          argsIndex = 0,
          argsLength = args.length,
          length = array ? array.length : 0;

      while (++argsIndex < argsLength) {
        var index = -1,
            value = args[argsIndex];
        while (++index < length) {
          if (array[index] === value) {
            splice.call(array, index--, 1);
            length--;
          }
        }
      }
      return array;
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`. If `start` is less than `stop` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      start = +start || 0;
      step = typeof step == 'number' ? step : (+step || 1);

      if (end == null) {
        end = start;
        start = 0;
      }
      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
      var index = -1,
          length = nativeMax(0, ceil((end - start) / (step || 1))),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Removes all elements from an array that the callback returns truey for
     * and returns an array of removed elements. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4, 5, 6];
     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
     *
     * console.log(array);
     * // => [1, 3, 5]
     *
     * console.log(evens);
     * // => [2, 4, 6]
     */
    function remove(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (callback(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * The opposite of `_.initial` this method gets all but the first element or
     * first `n` elements of an array. If a callback function is provided elements
     * at the beginning of the array are excluded from the result as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.rest(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.rest(characters, { 'employer': 'slate' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;

        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }

    /**
     * Uses a binary search to determine the smallest index at which a value
     * should be inserted into a given sorted array in order to maintain the sort
     * order of the array. If a callback is provided it will be executed for
     * `value` and each element of `array` to compute their sort ranking. The
     * callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low;

      // explicitly reference `identity` for better inlining in Firefox
      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);

      while (low < high) {
        var mid = (low + high) >>> 1;
        (callback(array[mid]) < value)
          ? low = mid + 1
          : high = mid;
      }
      return low;
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of combined values.
     * @example
     *
     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2, 3, 5, 4]
     */
    function union() {
      return baseUniq(baseFlatten(arguments, true, true));
    }

    /**
     * Creates a duplicate-value-free version of an array using strict equality
     * for comparisons, i.e. `===`. If the array is sorted, providing
     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
     * each element of `array` is passed through the callback before uniqueness
     * is computed. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, callback, thisArg) {
      // juggle arguments
      if (typeof isSorted != 'boolean' && isSorted != null) {
        thisArg = callback;
        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
        isSorted = false;
      }
      if (callback != null) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      return baseUniq(array, isSorted, callback);
    }

    /**
     * Creates an array excluding all provided values using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {...*} [value] The values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
    function without(array) {
      return baseDifference(array, slice(arguments, 1));
    }

    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See http://en.wikipedia.org/wiki/Symmetric_difference.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of values.
     * @example
     *
     * _.xor([1, 2, 3], [5, 2, 1, 4]);
     * // => [3, 5, 4]
     *
     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
     * // => [1, 4, 5]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
            : array;
        }
      }
      return result || [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second
     * elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @alias unzip
     * @category Arrays
     * @param {...Array} [array] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var array = arguments.length > 1 ? arguments : arguments[0],
          index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);

      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }

    /**
     * Creates an object composed from arrays of `keys` and `values`. Provide
     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};

      if (!values && length && !isArray(keys[0])) {
        values = [];
      }
      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that executes `func`, with  the `this` binding and
     * arguments of the created function, only after being called `n` times.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {number} n The number of times the function must be called before
     *  `func` is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('Done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'Done saving!', after all saves have completed
     */
    function after(n, func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * provided to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'fred' }, 'hi');
     * func();
     * // => 'hi fred'
     */
    function bind(func, thisArg) {
      return arguments.length > 2
        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
        : createWrapper(func, 1, null, null, thisArg);
    }

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all the function properties
     * of `object` will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...string} [methodName] The object method names to
     *  bind, specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs', when the button is clicked
     */
    function bindAll(object) {
      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
          index = -1,
          length = funcs.length;

      while (++index < length) {
        var key = funcs[index];
        object[key] = createWrapper(object[key], 1, null, null, object);
      }
      return object;
    }

    /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those provided to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'fred',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi fred'
     *
     * object.greet = function(greeting) {
     *   return greeting + 'ya ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      return arguments.length > 2
        ? createWrapper(key, 19, slice(arguments, 2), null, object)
        : createWrapper(key, 3, null, null, object);
    }

    /**
     * Creates a function that is the composition of the provided functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {...Function} [func] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var realNameMap = {
     *   'pebbles': 'penelope'
     * };
     *
     * var format = function(name) {
     *   name = realNameMap[name.toLowerCase()] || name;
     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
     * };
     *
     * var greet = function(formatted) {
     *   return 'Hiya ' + formatted + '!';
     * };
     *
     * var welcome = _.compose(greet, format);
     * welcome('pebbles');
     * // => 'Hiya Penelope!'
     */
    function compose() {
      var funcs = arguments,
          length = funcs.length;

      while (length--) {
        if (!isFunction(funcs[length])) {
          throw new TypeError;
        }
      }
      return function() {
        var args = arguments,
            length = funcs.length;

        while (length--) {
          args = [funcs[length].apply(this, args)];
        }
        return args[0];
      };
    }

    /**
     * Creates a function which accepts one or more arguments of `func` that when
     * invoked either executes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` can be specified
     * if `func.length` is not sufficient.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var curried = _.curry(function(a, b, c) {
     *   console.log(a + b + c);
     * });
     *
     * curried(1)(2)(3);
     * // => 6
     *
     * curried(1, 2)(3);
     * // => 6
     *
     * curried(1, 2, 3);
     * // => 6
     */
    function curry(func, arity) {
      arity = typeof arity == 'number' ? arity : (+arity || func.length);
      return createWrapper(func, 4, null, null, null, arity);
    }

    /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked.
     * Provide an options object to indicate that `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
     * to the debounced function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * var lazyLayout = _.debounce(calculateLayout, 150);
     * jQuery(window).on('resize', lazyLayout);
     *
     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * });
     *
     * // ensure `batchLog` is executed once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * source.addEventListener('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }, false);
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      wait = nativeMax(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    }

    /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) { console.log(text); }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    function defer(func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 1);
      return setTimeout(function() { func.apply(undefined, args); }, 1);
    }

    /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay execution.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) { console.log(text); }, 1000, 'later');
     * // => logs 'later' after one second
     */
    function delay(func, wait) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 2);
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it will be used to determine the cache key for storing the result
     * based on the arguments provided to the memoized function. By default, the
     * first argument provided to the memoized function is used as the cache key.
     * The `func` is executed with the `this` binding of the memoized function.
     * The result cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     *
     * fibonacci(9)
     * // => 34
     *
     * var data = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // modifying the result cache
     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
     * get('pebbles');
     * // => { 'name': 'pebbles', 'age': 1 }
     *
     * get.cache.pebbles.name = 'penelope';
     * get('pebbles');
     * // => { 'name': 'penelope', 'age': 1 }
     */
    function memoize(func, resolver) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

        return hasOwnProperty.call(cache, key)
          ? cache[key]
          : (cache[key] = func.apply(this, arguments));
      }
      memoized.cache = {};
      return memoized;
    }

    /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */
    function once(func) {
      var ran,
          result;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);

        // clear the `func` variable so the function may be garbage collected
        func = null;
        return result;
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those provided to the new function. This
     * method is similar to `_.bind` except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('fred');
     * // => 'hi fred'
     */
    function partial(func) {
      return createWrapper(func, 16, slice(arguments, 1));
    }

    /**
     * This method is like `_.partial` except that `partial` arguments are
     * appended to those provided to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */
    function partialRight(func) {
      return createWrapper(func, 32, null, slice(arguments, 1));
    }

    /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Provide an options object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle executions to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = wait;
      debounceOptions.trailing = trailing;

      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Additional arguments provided to the function are appended
     * to those provided to the wrapper function. The wrapper is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('Fred, Wilma, & Pebbles');
     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
     */
    function wrap(value, wrapper) {
      return createWrapper(wrapper, 16, [value]);
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var getter = _.constant(object);
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name the created callback will return the property value for a given element.
     * If `func` is an object the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(characters, 'age__gt38');
     * // => [{ 'name': 'fred', 'age': 40 }]
     */
    function createCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (func == null || type == 'function') {
        return baseCreateCallback(func, thisArg, argCount);
      }
      // handle "_.pluck" style callback shorthands
      if (type != 'object') {
        return property(func);
      }
      var props = keys(func),
          key = props[0],
          a = func[key];

      // handle "_.where" style callback shorthands
      if (props.length == 1 && a === a && !isObject(a)) {
        // fast path the common case of providing an object with a single
        // property containing a primitive value
        return function(object) {
          var b = object[key];
          return a === b && (a !== 0 || (1 / a == 1 / b));
        };
      }
      return function(object) {
        var length = props.length,
            result = false;

        while (length--) {
          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
            break;
          }
        }
        return result;
      };
    }

    /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('Fred, Wilma, & Pebbles');
     * // => 'Fred, Wilma, &amp; Pebbles'
     */
    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Adds function properties of a source object to the destination object.
     * If `object` is a function methods will be added to its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Function|Object} [object=lodash] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
     * @example
     *
     * function capitalize(string) {
     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     * }
     *
     * _.mixin({ 'capitalize': capitalize });
     * _.capitalize('fred');
     * // => 'Fred'
     *
     * _('fred').capitalize().value();
     * // => 'Fred'
     *
     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
     * _('fred').capitalize();
     * // => 'Fred'
     */
    function mixin(object, source, options) {
      var chain = true,
          methodNames = source && functions(source);

      if (!source || (!options && !methodNames.length)) {
        if (options == null) {
          options = source;
        }
        ctor = lodashWrapper;
        source = object;
        object = lodash;
        methodNames = functions(source);
      }
      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      var ctor = object,
          isFunc = isFunction(ctor);

      forEach(methodNames, function(methodName) {
        var func = object[methodName] = source[methodName];
        if (isFunc) {
          ctor.prototype[methodName] = function() {
            var chainAll = this.__chain__,
                value = this.__wrapped__,
                args = [value];

            push.apply(args, arguments);
            var result = func.apply(object, args);
            if (chain || chainAll) {
              if (value === result && isObject(result)) {
                return this;
              }
              result = new ctor(result);
              result.__chain__ = chainAll;
            }
            return result;
          };
        }
      });
    }

    /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // no operation performed
    }

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var stamp = _.now();
     * _.defer(function() { console.log(_.now() - stamp); });
     * // => logs the number of milliseconds it took for the deferred function to be called
     */
    var now = isNative(now = Date.now) && now || function() {
      return new Date().getTime();
    };

    /**
     * Converts the given value into an integer of the specified radix.
     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.io/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} value The value to parse.
     * @param {number} [radix] The radix used to interpret the value to parse.
     * @returns {number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */
    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };

    /**
     * Creates a "_.pluck" style function, which returns the `key` value of a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} key The name of the property to retrieve.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var characters = [
     *   { 'name': 'fred',   'age': 40 },
     *   { 'name': 'barney', 'age': 36 }
     * ];
     *
     * var getName = _.property('name');
     *
     * _.map(characters, getName);
     * // => ['barney', 'fred']
     *
     * _.sortBy(characters, getName);
     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
     */
    function property(key) {
      return function(object) {
        return object[key];
      };
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number will be
     * returned. If `floating` is truey or either `min` or `max` are floats a
     * floating-point number will be returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating=false] Specify returning a floating-point number.
     * @returns {number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (typeof min == 'boolean' && noMax) {
          floating = min;
          min = 1;
        }
        else if (!noMax && typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /**
     * Resolves the value of property `key` on `object`. If `key` is a function
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to resolve.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */
    function result(object, key) {
      if (object) {
        var value = object[key];
        return isFunction(value) ? object[key]() : value;
      }
    }

    /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * http://lodash.com/custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as local variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [variable] The data object variable name.
     * @returns {Function|string} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'fred' });
     * // => 'hello fred'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to generate HTML
     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'pebbles' });
     * // => 'hello pebbles'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
     * // => 'hello barney!'
     *
     * // using a custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{([\s\S]+?)}}/g
     * };
     *
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `imports` option to import jQuery
     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(text, data, options) {
      // based on John Resig's `tmpl` implementation
      // http://ejohn.org/blog/javascript-micro-templating/
      // and Laura Doktorova's doT.js
      // https://github.com/olado/doT
      var settings = lodash.templateSettings;
      text = String(text || '');

      // avoid missing dependencies when `iteratorTemplate` is not defined
      options = defaults({}, options, settings);

      var imports = defaults({}, options.imports, settings.imports),
          importsKeys = keys(imports),
          importsValues = values(imports);

      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // compile the regexp to match each delimiter
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // escape characters that cannot be included in string literals
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // replace delimiters with snippets
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // the JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value
        return match;
      });

      source += "';\n";

      // if `variable` is not specified, wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain
      var variable = options.variable,
          hasVariable = variable;

      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      // cleanup code by stripping empty strings
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // frame code as the function body
      source = 'function(' + variable + ') {\n' +
        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
        "var __t, __p = '', __e = _.escape" +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      // Use a sourceURL for easier debugging.
      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

      try {
        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
      } catch(e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      // provide the compiled function's source by its `toString` method, in
      // supported environments, or the `source` property as a convenience for
      // inlining compiled templates during the build process
      result.source = source;
      return result;
    }

    /**
     * Executes the callback `n` times, returning an array of the results
     * of each callback execution. The callback is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns an array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);

      callback = baseCreateCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }

    /**
     * The inverse of `_.escape` this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('Fred, Barney &amp; Pebbles');
     * // => 'Fred, Barney & Pebbles'
     */
    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps the given value with explicit
     * method chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(characters)
     *     .sortBy('age')
     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
     *     .first()
     *     .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      value = new lodashWrapper(value);
      value.__chain__ = true;
      return value;
    }

    /**
     * Invokes `interceptor` with the `value` as the first argument and then
     * returns `value`. The purpose of this method is to "tap into" a method
     * chain in order to perform operations on intermediate results within
     * the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .tap(function(array) { array.pop(); })
     *  .reverse()
     *  .value();
     * // => [3, 2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chaining
     * @returns {*} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(characters).first();
     * // => { 'name': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(characters).chain()
     *   .first()
     *   .pick('age')
     *   .value();
     * // => { 'age': 36 }
     */
    function wrapperChain() {
      this.__chain__ = true;
      return this;
    }

    /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {string} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return String(this.__wrapped__);
    }

    /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {*} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */
    function wrapperValueOf() {
      return this.__wrapped__;
    }

    /*--------------------------------------------------------------------------*/

    // add functions that return wrapped values when chaining
    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.chain = chain;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.createCallback = createCallback;
    lodash.curry = curry;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.pull = pull;
    lodash.range = range;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // add aliases
    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;
    lodash.unzip = zip;

    // add functions to `lodash.prototype`
    mixin(lodash);

    /*--------------------------------------------------------------------------*/

    // add functions that return unwrapped values when chaining
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;

    // add aliases
    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;

    mixin(function() {
      var source = {}
      forOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }(), false);

    /*--------------------------------------------------------------------------*/

    // add functions capable of returning wrapped and unwrapped values when chaining
    lodash.first = first;
    lodash.last = last;
    lodash.sample = sample;

    // add aliases
    lodash.take = first;
    lodash.head = first;

    forOwn(lodash, function(func, methodName) {
      var callbackable = methodName !== 'sample';
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName]= function(n, guard) {
          var chainAll = this.__chain__,
              result = func(this.__wrapped__, n, guard);

          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
            ? result
            : new lodashWrapper(result, chainAll);
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = '2.4.1';

    // add "Chaining" functions to the wrapper
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;

    // add `Array` functions that return unwrapped values
    forEach(['join', 'pop', 'shift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var chainAll = this.__chain__,
            result = func.apply(this.__wrapped__, arguments);

        return chainAll
          ? new lodashWrapper(result, chainAll)
          : result;
      };
    });

    // add `Array` functions that return the existing wrapped value
    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });

    // add `Array` functions that return new wrapped values
    forEach(['concat', 'slice', 'splice'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
      };
    });

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // expose Lo-Dash
  var _ = runInContext();

  // some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash is loaded with a RequireJS shim config.
    // See http://requirejs.org/docs/api.html#config-shim
    root._ = _;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define(function() {
      return _;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
    // in Node.js or RingoJS
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // in Narwhal or Rhino -require
    else {
      freeExports._ = _;
    }
  }
  else {
    // in a browser or Rhino
    root._ = _;
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])(1)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImluZGV4LmpzIiwibGliL2FmZmluaXR5L0F0dHJpYnV0ZS5qcyIsImxpYi9hZmZpbml0eS9CYXNlLmpzIiwibGliL2FmZmluaXR5L0ZvcmVpZ25LZXkuanMiLCJsaWIvYWZmaW5pdHkvRnVuY3Rpb24uanMiLCJsaWIvYWZmaW5pdHkvSGVhZGVyLmpzIiwibGliL2FmZmluaXR5L0luZGV4LmpzIiwibGliL2FmZmluaXR5L0tleS5qcyIsImxpYi9hZmZpbml0eS9SZWxhdGlvbi5qcyIsImxpYi9hZmZpbml0eS9TZXQuanMiLCJsaWIvYWZmaW5pdHkvVHVwbGUuanMiLCJsaWIvYWZmaW5pdHkvVHlwZS5qcyIsImxpYi9hZmZpbml0eS9hbGdlYnJhL0NvbXBvc2l0aW9uLmpzIiwibGliL2FmZmluaXR5L2FsZ2VicmEvRGlmZmVyZW5jZS5qcyIsImxpYi9hZmZpbml0eS9hbGdlYnJhL0V4dGVuc2lvbi5qcyIsImxpYi9hZmZpbml0eS9hbGdlYnJhL0dyb3VwLmpzIiwibGliL2FmZmluaXR5L2FsZ2VicmEvSW50ZXJzZWN0aW9uLmpzIiwibGliL2FmZmluaXR5L2FsZ2VicmEvSm9pbi5qcyIsImxpYi9hZmZpbml0eS9hbGdlYnJhL1Byb2R1Y3QuanMiLCJsaWIvYWZmaW5pdHkvYWxnZWJyYS9Qcm9qZWN0aW9uLmpzIiwibGliL2FmZmluaXR5L2FsZ2VicmEvUmVuYW1lLmpzIiwibGliL2FmZmluaXR5L2FsZ2VicmEvUmVzdHJpY3Rpb24uanMiLCJsaWIvYWZmaW5pdHkvYWxnZWJyYS9TZW1pZGlmZmVyZW5jZS5qcyIsImxpYi9hZmZpbml0eS9hbGdlYnJhL1NlbWlqb2luLmpzIiwibGliL2FmZmluaXR5L2FsZ2VicmEvU3VtbWFyaXplLmpzIiwibGliL2FmZmluaXR5L2FsZ2VicmEvVW5ncm91cC5qcyIsImxpYi9hZmZpbml0eS9hbGdlYnJhL1VuaW9uLmpzIiwibGliL2FmZmluaXR5L2FsZ2VicmEvVW53cmFwLmpzIiwibGliL2FmZmluaXR5L2FsZ2VicmEvV3JhcC5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvYWdncmVnYXRlL0FsbC5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvYWdncmVnYXRlL0FueS5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvYWdncmVnYXRlL0F2ZXJhZ2UuanMiLCJsaWIvYWZmaW5pdHkvZnVuY3Rpb25zL2FnZ3JlZ2F0ZS9Db3VudC5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvYWdncmVnYXRlL01heGltdW0uanMiLCJsaWIvYWZmaW5pdHkvZnVuY3Rpb25zL2FnZ3JlZ2F0ZS9NaW5pbXVtLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9hZ2dyZWdhdGUvU3RhbmRhcmREZXZpYXRpb24uanMiLCJsaWIvYWZmaW5pdHkvZnVuY3Rpb25zL2FnZ3JlZ2F0ZS9TdW0uanMiLCJsaWIvYWZmaW5pdHkvZnVuY3Rpb25zL2FnZ3JlZ2F0ZS9WYXJpYW5jZS5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvY29tcGFyYWJsZS9FcXVhbC5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvY29tcGFyYWJsZS9HcmVhdGVyVGhhbi5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvY29tcGFyYWJsZS9HcmVhdGVyVGhhbkVxdWFsLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9jb21wYXJhYmxlL1NtYWxsZXJUaGFuLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9jb21wYXJhYmxlL1NtYWxsZXJUaGFuRXF1YWwuanMiLCJsaWIvYWZmaW5pdHkvZnVuY3Rpb25zL2Nvbm5lY3RpdmUvQW5kLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9jb25uZWN0aXZlL05vdC5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvY29ubmVjdGl2ZS9Pci5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvZGF0ZS9EYXlPZk1vbnRoLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9kYXRlL0RheU9mV2Vlay5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvZGF0ZS9EYXlPZlllYXIuanMiLCJsaWIvYWZmaW5pdHkvZnVuY3Rpb25zL2RhdGUvSG91cnMuanMiLCJsaWIvYWZmaW5pdHkvZnVuY3Rpb25zL2RhdGUvTWlsbGlzZWNvbmRzLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9kYXRlL01pbnV0ZXMuanMiLCJsaWIvYWZmaW5pdHkvZnVuY3Rpb25zL2RhdGUvTW9udGguanMiLCJsaWIvYWZmaW5pdHkvZnVuY3Rpb25zL2RhdGUvU2Vjb25kcy5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvZGF0ZS9UaW1lc3RhbXAuanMiLCJsaWIvYWZmaW5pdHkvZnVuY3Rpb25zL2RhdGUvV2Vla09mWWVhci5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvZGF0ZS9ZZWFyLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL0Fic29sdXRlLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL0NlaWwuanMiLCJsaWIvYWZmaW5pdHkvZnVuY3Rpb25zL251bWVyaWMvQ29zaW5lLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL0RpdmlzaW9uLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL0V4cG9uZW50aWFsLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL0Zsb29yLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL01pbnVzLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL01vZHVsby5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvbnVtZXJpYy9NdWx0aXBsaWNhdGlvbi5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvbnVtZXJpYy9QbHVzLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL1Bvd2VyLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL1JvdW5kLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL1NpbmUuanMiLCJsaWIvYWZmaW5pdHkvZnVuY3Rpb25zL251bWVyaWMvU3F1YXJlUm9vdC5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvbnVtZXJpYy9UYW5nZW50LmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9zdHJpbmcvTGVuZ3RoLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9zdHJpbmcvTG93ZXJjYXNlLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9zdHJpbmcvU3Vic3RyaW5nLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9zdHJpbmcvVGVzdC5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvc3RyaW5nL1VwcGVyY2FzZS5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvdHVwbGUvQXR0cmlidXRlLmpzIiwibGliL2FmZmluaXR5L2hlbHBlcnMvY2xvbmUuanMiLCJsaWIvYWZmaW5pdHkvaGVscGVycy9jb2VyY2UuanMiLCJsaWIvYWZmaW5pdHkvaGVscGVycy9jb21wYXJlLmpzIiwibGliL2FmZmluaXR5L2hlbHBlcnMvZGVidWcuanMiLCJsaWIvYWZmaW5pdHkvaGVscGVycy9lcXVhbC5qcyIsImxpYi9hZmZpbml0eS9oZWxwZXJzL3R5cGUuanMiLCJsaWIvYWZmaW5pdHkvaGVscGVycy92YWx1ZS5qcyIsImxpYi9hZmZpbml0eS9taXhpbnMvY29tcGFyYWJsZS5qcyIsImxpYi9hZmZpbml0eS9taXhpbnMvY29ubmVjdGFibGUuanMiLCJsaWIvYWZmaW5pdHkvbWl4aW5zL2RhdGUuanMiLCJsaWIvYWZmaW5pdHkvbWl4aW5zL25vdC5qcyIsImxpYi9hZmZpbml0eS9taXhpbnMvbnVtZXJpYy5qcyIsImxpYi9hZmZpbml0eS9taXhpbnMvc2l6ZS1jb21wYXJhYmxlLmpzIiwibGliL2FmZmluaXR5L21peGlucy9zdHJpbmcuanMiLCJsaWIvYWZmaW5pdHkvdHlwZXMvQm9vbGVhbi5qcyIsImxpYi9hZmZpbml0eS90eXBlcy9EYXRlLmpzIiwibGliL2FmZmluaXR5L3R5cGVzL0Zsb2F0LmpzIiwibGliL2FmZmluaXR5L3R5cGVzL0ludGVnZXIuanMiLCJsaWIvYWZmaW5pdHkvdHlwZXMvTnVtZXJpYy5qcyIsImxpYi9hZmZpbml0eS90eXBlcy9PYmplY3QuanMiLCJsaWIvYWZmaW5pdHkvdHlwZXMvU3RyaW5nLmpzIiwibGliL2FmZmluaXR5L3R5cGVzL1R5cGUuanMiLCJsaWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvZGlzdC9sb2Rhc2guanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3oyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1dkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYicpOyIsInZhciBCYXNlID0gcmVxdWlyZSgnLi9CYXNlLmpzJyk7XG52YXIgVHlwZSA9IHJlcXVpcmUoJy4vVHlwZS5qcycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxudmFyIEF0dHJpYnV0ZSA9IEJhc2UuZXh0ZW5kKFxuXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgQXR0cmlidXRlXG4gICAgICAgICAqIEBleHRlbmRzIEJhc2VcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gW2FyZ3MubmFtZV0gVGhlIG5hbWUgb2YgdGhlIHtAbGluayBBdHRyaWJ1dGV9XG4gICAgICAgICAqIEBwYXJhbSB7VHlwZXxudWxsfSBbYXJncy50eXBlXSBUaGUge0BsaW5rIFR5cGV9IG9mIHRoZSB7QGxpbmsgQXR0cmlidXRlfVxuICAgICAgICAgKiBAcGFyYW0geyp9IFthcmdzLmRlZmF1bHRdIFRoZSBkZWZhdWx0IHZhbHVlIG9mIHRoZSBBdHRyaWJ1dGVcbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogQSB7QGxpbmsgUmVsYXRpb259J3Mge0BsaW5rIEhlYWRlcn0gaXMgY29tcG9zZWQgb2YgQXR0cmlidXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQW4ge0BsaW5rIEF0dHJpYnV0ZX0gaXMgc2ltcGx5IGFuIG9yZGVyZWQge0BsaW5rIFNldH0ge25hbWUgOiBTdHJpbmcsIHR5cGUgOiB7QGxpbmsgVHlwZX19XG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSB7QGxpbmsgVHlwZX0gb2YgYW4ge0BsaW5rIEF0dHJpYnV0ZX0gaXMgYSBjbGFzcyB0aGF0IGlzIG1haW5seSB1c2VkIHRvIGNvbXBhcmUgdGhlIHZhbHVlcyBvZiB0aGVcbiAgICAgICAgICogUmVsYXRpb24ncyB0dXBsZXMgZm9yIHRoaXMgYXR0aWJ1dGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBleGFtcGxlLFxuICAgICAgICAgKiB3aGVuIHJ1bm5pbmcgYW4ge0BsaW5rIE9wZXJhdG9ycy5Vbmlvbn0gb24gYSB7QGxpbmsgUmVsYXRpb259LCB0aGUge0BsaW5rIFR1cGxlfXMgd2lsbCBiZSB0ZXN0ZWQgZm9yIGVxdWFsaXR5IHNvIHRoYXQgdGhlXG4gICAgICAgICAqIHtAbGluayBSZWxhdGlvbn0gZG9lcyBub3QgaW5jbHVkZSBkdXBsaWNhdGVzIChhcyB0aGUgbWF0aGVtYXRpY2FsIGRlZmluaXRpb24gb2YgYSB7QGxpbmsgU2V0fSB0ZWxscyB1cykuXG4gICAgICAgICAqIFRvIGRvIHRoaXMsIHdlIGNvbXBhcmUgdHdvIHtAbGluayBUdXBsZX0gYnkgY29tcGFyaW5nIHRoZSB2YWx1ZSBvZiB0aGVpciB7QGxpbmsgQXR0cmlidXRlfXMuIElmIGZvciB0aGVzZSB0d29cbiAgICAgICAgICoge0BsaW5rIFR1cGxlfXMsIGFsbCB0aGVpciB7QGxpbmsgQXR0cmlidXRlfSB2YWx1ZXMgYXJlIGVxdWFsLCB0aGUgdHdvIHtAbGluayBUdXBsZX1zIGFyZSBzYWlkIHRvIGJlIGVxdWFsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUbyB0ZXN0IHRoZSBlcXVhbGl0eSBvZiBwcmltaXRpdmUge0BsaW5rIEF0dHJpYnV0ZX1zIChTdHJpbmcsIEJvb2xlYW4sIEludGVnZXIuLi4pLCB0aGlzIGlzIGVhc3kuXG4gICAgICAgICAqIFdlIHRlc3QgdGhlIGVxdWFsaXR5IG9mIHR3byB7QGxpbmsgQXR0cmlidXRlfXMgd2l0aCB0aGUgZXF1YWxpdHkgb3BlcmF0b3IgXCI9PVwiLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaG91Z2gsIHdoZW4gaXQgY29tZXMgdG8gT2JqZWN0IHtAbGluayBBdHRyaWJ1dGV9cywgaXQgaXMgbm90IHBvc3NpYmxlIHRvIHRlc3QgdGhlIGVxdWFsaXR5IHdpdGggdGhlIGVxdWFsaXR5IG9wZXJhdG9yXG4gICAgICAgICAqIFwiPT1cIi4gV2UgbmVlZCBhIGZ1bmN0aW9uIHRoYXQgd2lsbCB0ZXN0IHRoZSB0d28gb2JqZWN0cyBmb3IgZXF1YWxpdHkgYW5kIHRoYXQgd2lsbCByZXR1cm4gdHJ1ZS9mYWxzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVG8gcmVzdW1lLCB0aGUge0BsaW5rIFR5cGV9IG9mIGFuIHtAbGluayBBdHRyaWJ1dGV9IG11c3QgaW1wbGVtZW50IHRoZSBtZXRob2RzIHVzZWQgdG8gY29tcGFyZSB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAgICAgKiB7QGxpbmsgVHVwbGV9IHtAbGluayBBdHRyaWJ1dGV9IHZhbHVlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIHtAbGluayBUeXBlcy5OdW1lcmljfSB7QGxpbmsgVHlwZX1zLCB0aGUge0BsaW5rIFR5cGV9IHdpbGwgYWxzbyBpbXBsZW1lbnQgb3RoZXIgY29tcGFyaXNvbiBvcGVyYXRvcnMgc3VjaCBhcyBMYXJnZXJUaGFuICgubHQoKSkgLi4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciB7QGxpbmsgVHlwZXMuRGF0ZX0ge0BsaW5rIFR5cGV9cywgdGhlIHtAbGluayBUeXBlfSB3aWxsIGFsc28gaW1wbGVtZW50IG90aGVyIG9wZXJhdG9ycyBzdWNoIGFzIERheU9mV2VlaywgLi4uXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgZm4gPSBuZXcgYWZmaW5pdHkuQXR0cmlidXRlKHtuYW1lIDogJ0ZpcnN0TmFtZScsIHR5cGUgOiAnYWZmaW5pdHkuU3RyaW5nJ30pXG4gICAgICAgICAqICAgICB2YXIgbG4gPSBuZXcgYWZmaW5pdHkuQXR0cmlidXRlKHtuYW1lIDogJ0xhc3ROYW1lJywgdHlwZSA6ICdhZmZpbml0eS5TdHJpbmcnfSlcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoYXJncykge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRlbGxzIGlmIHRoZSBhdHRyaWJ1dGUgd2FzIF9uZWdhdGVkIGluIGFuIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fbmVnYXRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlZmF1bHQgdmFsdWUgZm9yIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAqIEB0eXBlIHt1bmRlZmluZWR9XG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9kZWZhdWx0ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRlbGxzIGlmIHRoZSBhdHRyaWJ1dGUgaXMgYW4gYXV0byBpbmNyZW1lbnRpbmcgYXR0cmlidXRlXG4gICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2F1dG9JbmNyZW1lbnQgPSBmYWxzZTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUZWxscyBpZiB0aGUgYXR0cmlidXRlIGlzIGEgY2FsY3VsYXRlZCBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFR5cGUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICogQHR5cGUge1R5cGV9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGFyZ3MgYXJlIGdpdmVuXG4gICAgICAgICAgICBpZiAoYXJncykge1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG5hbWUgYXJnIGlzIGdpdmVuXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubmFtZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBuYW1lIGFyZyBpcyBvZiBnb29kIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfLmlzU3RyaW5nKGFyZ3MubmFtZSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5hbWUgaXMgbm90IGEgc3RyaW5nLCB0aHJvd1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTmFtZSBpcyBvZiB3cm9uZyB0eXBlJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmFtZSBhcmcgc2VlbXMgdG8gYmUgbGVnaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IGFyZ3MubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5hbWUgYXJnIGlzIG5vdCBnaXZlbiwgc2V0IGl0IHRvIG51bGxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgdHlwZSBhcmcgaXMgZ2l2ZW5cbiAgICAgICAgICAgICAgICBpZiAoYXJncy50eXBlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHR5cGUgYXJnIGlzIG9mIGdvb2QgdHlwZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIShhcmdzLnR5cGUucHJvdG90eXBlIGluc3RhbmNlb2YgVHlwZSkgJiYgIShhcmdzLnR5cGUuX19wcm90b19fIGluc3RhbmNlb2YgVHlwZSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHR5cGUgYXJnIGlzIG5vdCBvZiB0eXBlIFR5cGUsIHRocm93XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUeXBlIGlzIG9mIHdyb25nIHR5cGUnKVxuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUeXBlIGFyZyBzZWVtcyB0byBiZSBsZWdpdFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gYXJncy50eXBlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmZvckluKGFyZ3MudHlwZS5wYXlsb2FkLCBmdW5jdGlvbihtaXgpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5mb3JJbihtaXgsIGZ1bmN0aW9uIChtaXhpbiwga2V5KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldID0gbWl4aW47XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LHRoaXMpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sdGhpcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHR5cGUgYXJnIGlzIG5vdCBnaXZlbiwgc2V0IGl0IHRvIG51bGxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJncy5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdCcpKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVmYXVsdCA9IGFyZ3MuZGVmYXVsdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJncy5oYXNPd25Qcm9wZXJ0eSgnYXV0b0luY3JlbWVudCcpKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXV0b0luY3JlbWVudCA9IGFyZ3MuYXV0b0luY3JlbWVudDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjdWx0ZWQgUHJvcGVydHkgZ2V0dGVyIHNldHRlclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQ2FsY3VsYXRlZFxuICAgICAgICAgKiBAcmV0dXJuIHt1bmRlZmluZWR8Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNhbGN1bGF0ZWQgOiBmdW5jdGlvbihpc0NhbGN1bGF0ZWQpe1xuXG4gICAgICAgICAgICBpZihfLmlzQm9vbGVhbihpc0NhbGN1bGF0ZWQpKXtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVkID0gaXNDYWxjdWxhdGVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbG9uZXMgdGhlIEF0dHJpYnV0ZSBvYmplY3RcbiAgICAgICAgICogQHJldHVybiB7QXR0cmlidXRlfSBjbG9uZWQgYXR0cmlidXRlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgZm4gPSBuZXcgYWZmaW5pdHkuQXR0cmlidXRlKHtuYW1lIDogJ0ZpcnN0TmFtZScsYWZmaW5pdHkuU3RyaW5nfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgbG4gPSBhdHRyaWJ1dGUuY2xvbmUoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGxuLmVxdWFsKGZuKSAvLyB0cnVlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBsbi5uYW1lID0gJ0xhc3ROYW1lJztcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGxuLmVxdWFsKGZuKSAvLyBmYWxzZVxuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgdmFyIGF0dHIgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih7dHlwZTogdGhpcy50eXBlLCBuYW1lOiB0aGlzLm5hbWV9KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMucmVsYXRpb25IZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBhdHRyLnJlbGF0aW9uSGVhZGVyID0gdGhpcy5yZWxhdGlvbkhlYWRlcjtcbjsgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMud3JhcHBlZEF0dHJpYnV0ZXMpe1xuICAgICAgICAgICAgICAgIGF0dHIud3JhcHBlZEF0dHJpYnV0ZXMgPSB0aGlzLndyYXBwZWRBdHRyaWJ1dGVzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhdHRyLmNhbGN1bGF0ZWQodGhpcy5jYWxjdWxhdGVkKCkpO1xuXG4gICAgICAgICAgICByZXR1cm4gYXR0cjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBhdHRyaWJ1dGUgaXMgYmVpbmcgX25lZ2F0ZWQgaW4gYSBwcmVkaWNhdGVcbiAgICAgICAgICogQHBhcmFtIGV4cHJlc3Npb25cbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfY2hlY2tOZWdhdGVkQXR0cmlidXRlOiBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fbmVnYXRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZ2F0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IChyZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb25uZWN0aXZlL05vdC5qcycpKShleHByZXNzaW9uKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYXR0cmlidXRlLiBVc2VkIHRvIHByaW50IGEgUmVsYXRpb24gaW50byBjb25zb2xlXG4gICAgICAgICAqIGFzIGEgVW5pY29kZSBUYWJsZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArICcgOiAnICsgdGhpcy50eXBlLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHR3byBhdHRyaWJ1dGVzIGFyZSBlcXVhbFxuICAgICAgICAgKiBAcGFyYW0gYXR0cmlidXRlXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgZXF1YWwgOiBmdW5jdGlvbihhdHRyaWJ1dGUpe1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5lcXVhbCh0aGlzLCBhdHRyaWJ1dGUpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVmYXVsdCA6IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuX2F1dG9JbmNyZW1lbnQpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhlYWRlci5yZWxhdGlvbi5sZW5ndGgoKSArIHRoaXMuaGVhZGVyLnJlbGF0aW9uLl9kZWxldGVkQ291bnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0O1xuICAgICAgICB9XG5cbiAgICB9LCB7XG5cbiAgICAgICAgdHlwZSA6ICdBdHRyaWJ1dGUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBc3NlcnRzIHRoYXQgYSBnaXZlbiBuYW1lIGlzIHZhbGlkIGZvciBhbiBhdHRyaWJ1dGVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIG5hbWVcbiAgICAgICAgICovXG4gICAgICAgIGFzc2VydFZhbGlkTmFtZSA6IGZ1bmN0aW9uKG5hbWUpe1xuXG4gICAgICAgICAgICBpZighXy5pc1N0cmluZyhuYW1lKSl7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYW1lIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihuYW1lID09PSAnJyl7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRyaWJ1dGUgbmFtZSBjYW5ub3QgYmUgZW1wdHkgc3RyaW5nJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdHMgZm9yIGVxdWFsaXR5IGJldHdlZW4gdHdvIGF0dHJpYnV0ZXNcbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIEJvb2xlYW4uIEl0IGNhbm5vdCBiZSBwYXJ0IG9mIGEgcHJlZGljYXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0F0dHJpYnV0ZX0gYXR0cmlidXRlMVxuICAgICAgICAgKiBAcGFyYW0ge0F0dHJpYnV0ZX0gYXR0cmlidXRlMlxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICogQHN0YXRpY1xuXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbDogZnVuY3Rpb24gKGF0dHJpYnV0ZTEsIGF0dHJpYnV0ZTIpIHtcblxuICAgICAgICAgICAgcmV0dXJuICgoYXR0cmlidXRlMS5uYW1lID09PSBhdHRyaWJ1dGUyLm5hbWUpICYmIChhdHRyaWJ1dGUxLnR5cGUgPT09IGF0dHJpYnV0ZTIudHlwZSkpXG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29lcmNlcyBhbiBhcmJpdHJhcnkgb2JqZWN0IHRvIHR5cGUgQXR0cmlidXRlXG4gICAgICAgICAqIEBwYXJhbSB7QXR0cmlidXRlfE9iamVjdH0gYXR0cmlidXRlXG4gICAgICAgICAqIEByZXR1cm5zIHtBdHRyaWJ1dGV9XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBmbjEgPSBuZXcgYWZmaW5pdHkuQXR0cmlidXRlKHtuYW1lIDogJ0ZpcnN0TmFtZScsIHR5cGUgOiBhZmZpbml0eS5TdHJpbmd9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBmbjIgPSB7bmFtZSA6ICdGaXJzdE5hbWUnICwgdHlwZSA6IGFmZmluaXR5LlN0cmluZ31cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGFmZmluaXR5LkF0dHJpYnV0ZS5jb2VyY2UoZm4xKSA9PT0gZm4xIC8vIHRydWUsIHRoZSBvYmplY3Qgd2FzIGFscmVhZHkgYW4gQXR0cmlidXRlLlxuICAgICAgICAgKiAgICAgYWZmaW5pdHkuQXR0cmlidXRlLmNvZXJjZShmbjIpID09PSBmbjIgLy8gZmFsc2UsIHRoZSBvYmplY3QgaGFkIHRvIGJlIGNvZXJjZWRcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGFmZmluaXR5LkF0dHJpYnV0ZS5jb2VyY2UoZm4yKS5lcXVhbChmbjEpIC8vIHRydWVcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNvZXJjZTogZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuXG5cbiAgICAgICAgICAgIHZhciBuYW1lO1xuICAgICAgICAgICAgdmFyIHR5cGU7XG4gICAgICAgICAgICB2YXIgYXR0cjtcbiAgICAgICAgICAgIHZhciBrZXlzO1xuICAgICAgICAgICAgdmFyIGF1dG9JbmNyZW1lbnQ7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdFZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlIGluc3RhbmNlb2YgQXR0cmlidXRlKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYXR0cmlidXRlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKF8uaXNPYmplY3QoYXR0cmlidXRlKSl7XG5cbiAgICAgICAgICAgICAgICAvLyBBdHRyaWJ1dGUgaXMgb2YgdGhlIHR5cGUge25hbWUgOiA8bmFtZT4sIHR5cGUgOiA8dHlwZT59XG4gICAgICAgICAgICAgICAgaWYoYXR0cmlidXRlLnR5cGUgJiYgYXR0cmlidXRlLm5hbWUpe1xuXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBhdHRyaWJ1dGUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IGF0dHJpYnV0ZS50eXBlO1xuICAgICAgICAgICAgICAgICAgICBhdXRvSW5jcmVtZW50ID0gYXR0cmlidXRlLmF1dG9JbmNyZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IGF0dHJpYnV0ZS5kZWZhdWx0O1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBdHRyaWJ1dGUgaXMgZWl0aGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHsgPG5hbWU+IDogeyB0eXBlIDogPHR5cGU+IH0gfVxuICAgICAgICAgICAgICAgICAgICAvLyB7IDxuYW1lPiA6IDxBdHRyaWJ1dGU+IH1cblxuICAgICAgICAgICAgICAgICAgICBrZXlzID0gXy5rZXlzKGF0dHJpYnV0ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoICE9PSAxKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgQXR0cmlidXRlIGRlY2xhcmF0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBOYW1lIG9mIHRoZSBBdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGtleXNbMF07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0cmlidXRlIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICBhdHRyID0gYXR0cmlidXRlW25hbWVdO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgaWYoYXR0ciBpbnN0YW5jZW9mIEF0dHJpYnV0ZSl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF0dHJpYnV0ZSBpcyB7IDxuYW1lPiA6IDxBdHRyaWJ1dGU+fVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyLm5hbWUgPSBuYW1lO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0cjtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoYXR0ci50eXBlKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXR0cmlidXRlIGlzIHsgPG5hbWU+IDogeyB0eXBlIDogPHR5cGU+IH0gfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gYXR0cmlidXRlW25hbWVdLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvSW5jcmVtZW50ID0gYXR0cmlidXRlW25hbWVdLmF1dG9JbmNyZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBhdHRyaWJ1dGVbbmFtZV0uZGVmYXVsdDtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGUoe25hbWUgOiBuYW1lLCB0eXBlIDogdHlwZSwgYXV0b0luY3JlbWVudCA6IGF1dG9JbmNyZW1lbnQsIGRlZmF1bHQgOiBkZWZhdWx0VmFsdWV9KTtcblxuICAgICAgICB9XG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdHRyaWJ1dGU7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvcnJlY3RseSBzZXQgdXAgdGhlIHByb3RvdHlwZSBjaGFpbiwgZm9yIHN1YmNsYXNzZXMuXG4vLyBTaW1pbGFyIHRvIGBnb29nLmluaGVyaXRzYCwgYnV0IHVzZXMgYSBoYXNoIG9mIHByb3RvdHlwZSBwcm9wZXJ0aWVzIGFuZFxuLy8gY2xhc3MgcHJvcGVydGllcyB0byBiZSBleHRlbmRlZC5cbnZhciBleHRlbmQgPSBmdW5jdGlvbiAocHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcblxuICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgIHZhciBjaGlsZDtcblxuICAgIC8vIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIG5ldyBzdWJjbGFzcyBpcyBlaXRoZXIgZGVmaW5lZCBieSB5b3VcbiAgICAvLyAodGhlIFwiY29uc3RydWN0b3JcIiBwcm9wZXJ0eSBpbiB5b3VyIGBleHRlbmRgIGRlZmluaXRpb24pLCBvciBkZWZhdWx0ZWRcbiAgICAvLyBieSB1cyB0byBzaW1wbHkgY2FsbCB0aGUgcGFyZW50J3MgY29uc3RydWN0b3IuXG4gICAgaWYgKHByb3RvUHJvcHMgJiYgXy5oYXMocHJvdG9Qcm9wcywgJ2NvbnN0cnVjdG9yJykpIHtcbiAgICAgICAgY2hpbGQgPSBwcm90b1Byb3BzLmNvbnN0cnVjdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEFkZCBzdGF0aWMgcHJvcGVydGllcyB0byB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24sIGlmIHN1cHBsaWVkLlxuICAgIF8uZXh0ZW5kKGNoaWxkLCBwYXJlbnQsIHN0YXRpY1Byb3BzKTtcblxuICAgIC8vIFNldCB0aGUgcHJvdG90eXBlIGNoYWluIHRvIGluaGVyaXQgZnJvbSBgcGFyZW50YCwgd2l0aG91dCBjYWxsaW5nXG4gICAgLy8gYHBhcmVudGAncyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICB2YXIgU3Vycm9nYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gICAgfTtcbiAgICBTdXJyb2dhdGUucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgU3Vycm9nYXRlO1xuXG4gICAgLy8gQWRkIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChpbnN0YW5jZSBwcm9wZXJ0aWVzKSB0byB0aGUgc3ViY2xhc3MsXG4gICAgLy8gaWYgc3VwcGxpZWQuXG4gICAgaWYgKHByb3RvUHJvcHMpIF8uZXh0ZW5kKGNoaWxkLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG5cbiAgICAvLyBTZXQgYSBjb252ZW5pZW5jZSBwcm9wZXJ0eSBpbiBjYXNlIHRoZSBwYXJlbnQncyBwcm90b3R5cGUgaXMgbmVlZGVkXG4gICAgLy8gbGF0ZXIuXG4gICAgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTtcblxuICAgIHJldHVybiBjaGlsZDtcblxufTtcblxuLyoqXG4gKiBAY2xhc3MgQmFzZVxuICovXG52YXIgQmFzZSA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLyoqXG4gKiBAbWVtYmVyIEJhc2VcbiAqIEBtZXRob2QgZXh0ZW5kXG4gKi9cbkJhc2UuZXh0ZW5kID0gZXh0ZW5kO1xuXG4vKipcbiAqIEBtZW1iZXIgQmFzZVxuICovXG5CYXNlLm1peGluID0gZnVuY3Rpb24obWl4aW4pe1xuICAgIF8uZXh0ZW5kKHRoaXMucHJvdG90eXBlLCBtaXhpbik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2U7IiwidmFyIEJhc2UgPSByZXF1aXJlKCcuL0Jhc2UnKSxcbiAgICBJbmRleCA9IHJlcXVpcmUoJy4vSW5kZXgnKSxcbiAgICBIZWFkZXIgPSByZXF1aXJlKCcuL0hlYWRlcicpLFxuICAgIF8gPSByZXF1aXJlKCdsb2Rhc2gnKSxcbiAgICBBdHRyaWJ1dGUgPSByZXF1aXJlKCcuL0F0dHJpYnV0ZScpLFxuICAgIFR1cGxlID0gcmVxdWlyZSgnLi9UdXBsZScpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi9oZWxwZXJzL2RlYnVnJyksXG4gICAgZXF1YWwgPSByZXF1aXJlKCcuL2hlbHBlcnMvZXF1YWwnKTtcblxudmFyIEZvcmVpZ25LZXkgPSBCYXNlLmV4dGVuZCh7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgRm9yZWlnbktleVxuICAgICAqIEBleHRlbmRzIEJhc2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtSZWxhdGlvbn0gcGFyYW1zLnJlbGF0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW118SGVhZGVyfSBwYXJhbXMuY29sdW1uTmFtZXNcbiAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSBwYXJhbXMucmVmZXJlbmNlZFJlbGF0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW118SGVhZGVyfSBwYXJhbXMucmVmZXJlbmNlZENvbHVtbk5hbWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5vblVwZGF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMub25EZWxldGVcbiAgICAgKlxuICAgICAqIFRoZSBGb3JlaWduS2V5IGNsYXNzIHJlcHJlc2VudHMgZm9yZWlnbiBrZXlzIHRvIGEgcmVsYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGUgZm9yZWlnbiBrZXkgZW5mb3JjZXMgdGhlIHJlbGF0aW9uYWwgaW50ZWdyaXR5IG9mIGRpZmZlcmVudCByZWxhdGlvbnMuXG4gICAgICpcbiAgICAgKlxuICAgICAqICAgICB2YXIgZG9ncyA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICogICAgICAgICAge2lkIDoge3R5cGUgOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICogICAgICAgICAge293bmVySWQgOiB7dHlwZSA6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgKiAgICAgICAgICB7bmFtZSA6IHt0eXBlIDogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAqICAgICAgXSxbXG4gICAgICogICAgICAgICAgWzAsIDAsICdGaWRvJ10sXG4gICAgICogICAgICAgICAgWzEsIDAsICdCb2JieSddLFxuICAgICAqICAgICAgICAgIFsyLCAxLCAnU3RhY2V5J10sXG4gICAgICogICAgICAgICAgWzMsIDIsICdDZWFzYXInXSxcbiAgICAgKiAgICAgIF0se1xuICAgICAqICAgICAgICAgIHBrIDogWydpZCddLFxuICAgICAqICAgICAgICAgIGZrIDogW1xuICAgICAqICAgICAgICAgICAgICB7XG4gICAgICogICAgICAgICAgICAgICAgICBjb2x1bW5OYW1lcyAgICAgICAgICAgOiBbJ293bmVySWQnXSxcbiAgICAgKiAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZWRSZWxhdGlvbiAgICA6IHBlb3BsZSxcbiAgICAgKiAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZWRDb2x1bW5OYW1lcyA6IFsnaWQnXSxcbiAgICAgKiAgICAgICAgICAgICAgICAgIG9uVXBkYXRlICAgICAgICAgICAgICA6ICdjYXNjYWRlJyxcbiAgICAgKiAgICAgICAgICAgICAgICAgIG9uRGVsZXRlICAgICAgICAgICAgICA6ICdyZXN0cmljdCdcbiAqICAgICAgICAgICAgICAgICAgfSxcbiAgICAgKiAgICAgICAgICAgICAgLi4uXG4gICAgICogICAgICAgICAgXVxuICAgICAqICAgICAgfSk7XG4gICAgICovXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIChwYXJhbXMpIHtcblxuICAgICAgICBkZWJ1Zy5mb3JlaWduS2V5LnRyYWNlKCcjY29uc3RydWN0b3InKTtcblxuICAgICAgICAvLyByZWxhdGlvbiwgY29sdW1uTmFtZXMsIHJlZmVyZW5jZWRSZWxhdGlvbiwgcmVmZXJlbmNlZENvbHVtbk5hbWVzLCBvblVwZGF0ZSwgb25EZWxldGVcblxuICAgICAgICAvKiogQHByb3BlcnR5IHtIZWFkZXJ9IGNvbHVtbnMgKi9cbiAgICAgICAgdGhpcy5jb2x1bW5zID0gbnVsbDtcblxuICAgICAgICAvKiogQHByb3BlcnR5IHtIZWFkZXJ9IHJlZmVyZW5jZWRDb2x1bW5zICovXG4gICAgICAgIHRoaXMucmVmZXJlbmNlZENvbHVtbnMgPSBudWxsO1xuXG4gICAgICAgIC8qKiBAcHJvcGVydHkge1JlbGF0aW9ufSByZWxhdGlvbiAqL1xuICAgICAgICB0aGlzLnJlbGF0aW9uID0gcGFyYW1zLnJlbGF0aW9uO1xuXG4gICAgICAgIC8qKiBAcHJvcGVydHkge1JlbGF0aW9ufSByZWZlcmVuY2VkUmVsYXRpb24gKi9cbiAgICAgICAgdGhpcy5yZWZlcmVuY2VkUmVsYXRpb24gPSBwYXJhbXMuc2VsZlJlZmVyZW5jaW5nID8gdGhpcy5yZWxhdGlvbiA6IHBhcmFtcy5yZWZlcmVuY2VkUmVsYXRpb247XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgY29sdW1uTmFtZXMgcGFyYW1ldGVyXG5cbiAgICAgICAgaWYgKHBhcmFtcy5jb2x1bW5OYW1lcyBpbnN0YW5jZW9mIEhlYWRlcikge1xuXG4gICAgICAgICAgICAvLyBjb2x1bW5OYW1lcyBpcyBhbHJlYWR5IGEgaGVhZGVyXG4gICAgICAgICAgICBpZiAoIXBhcmFtcy5jb2x1bW5OYW1lcy5pc1N1YnNldChyZWxhdGlvbi5oZWFkZXIoKSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXIgY29sdW1uTmFtZXMgcGFzc2VkIGFzIGludmFsaWQgSGVhZGVyLiAnKTtcblxuICAgICAgICAgICAgdGhpcy5jb2x1bW5zID0gcGFyYW1zLmNvbHVtbk5hbWVzO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmKCFfLmlzQXJyYXkocGFyYW1zLmNvbHVtbk5hbWVzKSl7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmNvbHVtbk5hbWVzID0gW3BhcmFtcy5jb2x1bW5OYW1lc107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY29sdW1ucyA9ICB0aGlzLnJlbGF0aW9uLmhlYWRlcigpLmNsb25lKCkucHJvamVjdChwYXJhbXMuY29sdW1uTmFtZXMpO1xuXG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIFZhbGlkYXRlIHJlZmVyZW5jZWRDb2x1bW5OYW1lcyBwYXJhbWV0ZXJcblxuICAgICAgICBpZiAocGFyYW1zLnJlZmVyZW5jZWRDb2x1bW5OYW1lcyBpbnN0YW5jZW9mIEhlYWRlcikge1xuXG4gICAgICAgICAgICAvLyByZWZlcmVuY2VkQ29sdW1uTmFtZXMgaXMgYWxyZWFkeSBhIGhlYWRlclxuICAgICAgICAgICAgaWYgKCFwYXJhbXMucmVmZXJlbmNlZENvbHVtbk5hbWVzLmlzU3Vic2V0KHBhcmFtcy5yZWZlcmVuY2VkUmVsYXRpb24uaGVhZGVyKCkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyYW1ldGVyIHJlZmVyZW5jZWRDb2x1bW5OYW1lcyBwYXNzZWQgYXMgaW52YWxpZCBIZWFkZXIuICcpO1xuXG4gICAgICAgICAgICB0aGlzLnJlZmVyZW5jZWRDb2x1bW5zID0gcGFyYW1zLnJlZmVyZW5jZWRDb2x1bW5OYW1lcztcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBpZighXy5pc0FycmF5KHBhcmFtcy5yZWZlcmVuY2VkQ29sdW1uTmFtZXMpKXtcbiAgICAgICAgICAgICAgICBwYXJhbXMucmVmZXJlbmNlZENvbHVtbk5hbWVzID0gW3BhcmFtcy5yZWZlcmVuY2VkQ29sdW1uTmFtZXNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWZlcmVuY2VkQ29sdW1ucyA9IHRoaXMucmVmZXJlbmNlZFJlbGF0aW9uLmhlYWRlcigpLmNsb25lKCkucHJvamVjdChwYXJhbXMucmVmZXJlbmNlZENvbHVtbk5hbWVzKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy90b2RvIDogVmVyaWZ5IG9uVXBkYXRlXG4gICAgICAgIC8vdG9kbyA6IFZlcmlmeSBvbkRlbGV0ZVxuXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuXG4gICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIGFkZGVkIHR1cGxlIHJlc3BlY3RzIHRoZSBmb3JlaWduIGtleSBjb25zdHJhaW50IGJlZm9yZSBhZGRpbmcgdGhlIHR1cGxlXG5cbiAgICAgICAgdGhpcy5yZWxhdGlvbi5lZS5vbignYWZ0ZXJBZGQnLCBmdW5jdGlvbih0dXBsZSwgdHVwbGVJbmRleCl7XG5cbiAgICAgICAgICAgIGRlYnVnLmZvcmVpZ25LZXkudHJhY2UoJyNiZWZvcmVBZGQnKTtcblxuICAgICAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgICAgIHRoYXQuY2hlY2tGb3JlaWduS2V5Q29uc3RyYWludCh0dXBsZSk7XG5cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXG4gICAgICAgICAgICAgICAgdGhhdC5yZWxhdGlvbi5yZW1vdmVBdCh0dXBsZUluZGV4KTtcblxuICAgICAgICAgICAgICAgIHRocm93KGVycik7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZW1vdmUgdGhlbiBhZGQgdGhlIHR1cGxlIGZyb20gaW5kZXggYmVmb3JlIHRoZSB0dXBsZSB1cGRhdGVcblxuICAgICAgICB0aGlzLnJlbGF0aW9uLmVlLm9uKCdiZWZvcmVVcGRhdGUnLCBmdW5jdGlvbih0dXBsZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpe1xuXG4gICAgICAgICAgICBkZWJ1Zy5mb3JlaWduS2V5LnRyYWNlKCcjYmVmb3JlVXBkYXRlJyk7XG5cbiAgICAgICAgICAgIHZhciBwcm9qZWN0ZWRUdXBsZSA9IHR1cGxlLmNsb25lKCk7XG5cbiAgICAgICAgICAgIHByb2plY3RlZFR1cGxlLnNldChhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSk7XG5cbiAgICAgICAgICAgIHRoYXQuY2hlY2tGb3JlaWduS2V5Q29uc3RyYWludChwcm9qZWN0ZWRUdXBsZSk7XG5cbiAgICAgICAgfSk7XG5cbiAgICB9LFxuXG4gICAgY2hlY2tGb3JlaWduS2V5Q29uc3RyYWludCA6IGZ1bmN0aW9uKHR1cGxlKXtcblxuICAgICAgICBkZWJ1Zy5mb3JlaWduS2V5LnRyYWNlKCcjY2hlY2tGb3JlaWduS2V5Q29uc3RyYWludCcpO1xuXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgIGtleVR1cGxlLFxuICAgICAgICAgICAgdGVtcG9yYXJ5UmVsYXRpb24sXG4gICAgICAgICAgICBSZWxhdGlvbixcbiAgICAgICAgICAgIHByb2plY3RlZFJlZmVyZW5jZWRSZWxhdGlvbixcbiAgICAgICAgICAgIGludGVyc2VjdGVkUmVsYXRpb247XG5cblxuICAgICAgICAvLy8gQnVpbGQgYSB0dXBsZSBjb250YWluaW5nIHRoZSByZXF1aXJlZCB2YWx1ZXMgZm9yIHRoZSBnaXZlbiByZWZlcmVuY2VkIGNvbHVtbnNcblxuICAgICAgICBrZXlUdXBsZSA9IG5ldyBUdXBsZSgpO1xuXG4gICAgICAgIHRoYXQucmVmZXJlbmNlZENvbHVtbnMuZWFjaChmdW5jdGlvbihyZWZlcmVuY2VkQXR0cmlidXRlLCBhdHRyaWJ1dGVJbmRleCl7XG5cbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSB0aGF0LmNvbHVtbnMuYXRJbmRleChhdHRyaWJ1dGVJbmRleCk7XG5cbiAgICAgICAgICAgIGtleVR1cGxlLnNldChyZWZlcmVuY2VkQXR0cmlidXRlLm5hbWUsIHR1cGxlLmdldChhdHRyaWJ1dGUubmFtZSkpO1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoYXQucmVmZXJlbmNlZFJlbGF0aW9uLmVhY2goZnVuY3Rpb24odHVwbGUsIGluZGV4KXtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG5cbiAgICAgICAgICAgIGtleVR1cGxlLmVhY2goZnVuY3Rpb24oYXR0cmlidXRlKXtcblxuICAgICAgICAgICAgICAgIGlmICghZXF1YWwobnVsbCwga2V5VHVwbGUuZ2V0KGF0dHJpYnV0ZSksIHR1cGxlLmdldChhdHRyaWJ1dGUpKSl7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBmYWxzZSl7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JlaWduIGtleSBjb25zdHJhaW50IGNoZWNrIGZhaWwnKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG59LHtcblxuICAgIGNhc2NhZGVWYWx1ZXMgOiBbJ2Nhc2NhZGUnLCAncHJldmVudCddXG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZvcmVpZ25LZXk7IiwidmFyIEJhc2UgPSByZXF1aXJlKCcuL0Jhc2UuanMnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgQXR0cmlidXRlID0gcmVxdWlyZSgnLi9BdHRyaWJ1dGUnKTtcblxudmFyIEZ1bmN0aW9uID0gQmFzZS5leHRlbmQoXG5cbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBGdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1ldGVyc1xuICAgICAgICAgKiBAcHJvcGVydHkgW0FycmF5XSBwYXJhbWV0ZXJzXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHBhcmFtZXRlcnMpIHtcblxuICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0gW107XG5cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtZXRlcnMucHVzaChhcmd1bWVudHNbaV0pO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBmdW5jdGlvbidzIHBhcmFtZXRlclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW0gVGhlIHBhcmFtZXRlciBvZiB0aGUgZnVuY3Rpb24gdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGlzIHRvIGNoYWluIGNhbGxcbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHBhcmFtKSB7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGEgaW4gcGFyYW0pIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0uaGFzT3duUHJvcGVydHkoYSkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbYV0gPSBwYXJhbVthXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgXy5mb3JFYWNoKHRoaXMuYXJncywgZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBhcmcuc2V0KHBhcmFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGVscGVyIGZ1bmN0aW9uIHVzZWQgdG8gY29udmVydCBhdHRyaWJ1dGVzIG9iamVjdHMgaW50byBmdW5jdGlvbnMgdGhhdCB3aWxsIGdldCB0aGUgdHVwbGVcbiAgICAgICAgICogdmFsdWUgZm9yIHRoYXQgYXR0cmlidXRlXG4gICAgICAgICAqL1xuICAgICAgICBjb252ZXJ0QXR0cmlidXRlVG9UdXBsZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBfLmZvckVhY2godGhpcy5wYXJhbWV0ZXJzLCBmdW5jdGlvbiAocGFyYW1ldGVyLCBpbmRleCkge1xuXG4gICAgICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihwYXJhbWV0ZXIuY29udmVydEF0dHJpYnV0ZVRvVHVwbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlci5jb252ZXJ0QXR0cmlidXRlVG9UdXBsZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXJhbWV0ZXIgaW5zdGFuY2VvZiBBdHRyaWJ1dGUpIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3RnVuYyA9IG5ldyAocmVxdWlyZSgnLi9mdW5jdGlvbnMvdHVwbGUvQXR0cmlidXRlJykpKHBhcmFtZXRlci5uYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICBuZXdGdW5jLnR5cGUgPSBwYXJhbWV0ZXIudHlwZTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmFtZXRlcnNbaW5kZXhdID0gbmV3RnVuYztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYXNzaWduVHVwbGUgOiBmdW5jdGlvbih0dXBsZSl7XG5cbiAgICAgICAgICAgIF8uZm9yRWFjaCh0aGlzLnBhcmFtZXRlcnMsIGZ1bmN0aW9uIChwYXJhbWV0ZXIsIGluZGV4KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyYW1ldGVyIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblxuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXIuYXNzaWduVHVwbGUodHVwbGUpO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfSxcblxuXG4gICAgICAgIHR5cGUgOiBmdW5jdGlvbih0eXBlKXtcblxuICAgICAgICAgICAgaWYodHlwZSl7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl90eXBlID0gdHlwZTtcblxuICAgICAgICAgICAgICAgIF8uZm9ySW4odHlwZS5wYXlsb2FkLCBmdW5jdGlvbiAobWl4KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgXy5mb3JJbihtaXgsIGZ1bmN0aW9uKG1peGluLCBrZXkpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBtaXhpbjtcblxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKVxuXG4gICAgICAgICAgICAgICAgfSwgdGhpcylcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbjsiLCJ2YXIgQXR0cmlidXRlID0gcmVxdWlyZSgnLi9BdHRyaWJ1dGUuanMnKTtcbnZhciBTZXQgPSByZXF1aXJlKCcuL1NldC5qcycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBUU3RyaW5nID0gcmVxdWlyZSgnLi90eXBlcy9TdHJpbmcnKTtcbnZhciBUVHlwZSA9IHJlcXVpcmUoJy4vdHlwZXMvVHlwZScpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnLi9oZWxwZXJzL2RlYnVnLmpzJyk7XG5cbnZhciBIZWFkZXIgPSBTZXQuZXh0ZW5kKFxuXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIZWFkZXIgb2JqZWN0IGNvbnN0cnVjdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAY2xhc3MgSGVhZGVyXG4gICAgICAgICAqIEBleHRlbmRzIFNldFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdXG4gICAgICAgICAqIEB0aHJvd3MgVGhlIGF0dHJpYnV0ZXMgYXJlIG5vdCBwYXNzZWQgaW4gQXJyYXkgZm9ybWF0XG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqIEEge0BsaW5rIEhlYWRlcn0gaXMgb25lIG9mIHRoZSB0d28gbWFpbiBwYXJ0cyBvZiBhXG4gICAgICAgICAqIHtAbGluayBSZWxhdGlvbn0sIGFsb25nIHdpdGggdGhlIEJvZHkgKHdoaWNoIGlzIGEge0BsaW5rIFNldH0pLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJdCBpcyBhIHtAbGluayBTZXR9IG9mIHtAbGluayBBdHRyaWJ1dGV9cy4gSXQgZGVmaW5lcyB0aGUgc3RydWN0dXJlIG9mIHRoZVxuICAgICAgICAgKiB7QGxpbmsgVHVwbGV9cyB0aGF0IHdpbGwgYmUgcGFydCBvZiB0aGUgYm9keSBvZiB0aGVcbiAgICAgICAgICoge0BsaW5rIFJlbGF0aW9ufS4gRWFjaCB7QGxpbmsgVHVwbGV9IGluIGFcbiAgICAgICAgICoge0BsaW5rIFJlbGF0aW9ufSBtdXN0IG1hdGNoIGl0cyB7QGxpbmsgSGVhZGVyfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGhlYWRlciA9IG5ldyBhZmZpbml0eS5oZWFkZXIoW1xuICAgICAgICAgKiAgICAgICAgICB7Zmlyc3RuYW1lIDogYWZmaW5pdHkuc3RyaW5nfSxcbiAgICAgICAgICogICAgICAgICAge2xhc3RuYW1lIDogYWZmaW5pdHkuc3RyaW5nfVxuICAgICAgICAgKiAgICAgXSlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5yZWxhdGlvbigpOyAvLyBjcmVhdGUgYW4gZW1wdHkgcmVsYXRpb24gd2l0aG91dCBhIGhlYWRlciBhbmQgd2l0aG91dCBib2R5XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICByZWxhdGlvbi5oZWFkZXIoaGVhZGVyKTsgLy8gc2V0cyB0aGUgcmVsYXRpb24ncyBoZWFkZXJcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHJlbGF0aW9uLmFkZCh7Zmlyc3ROYW1lIDogJ0pvaG4nLCBsYXN0TmFtZSA6ICdEb2UnfSk7IC8vIEFkZCBhIHR1cGxlIGluIHRoZSBSZWxhdGlvbiB0aGF0IG1hdGNoZXMgdGhlIGhlYWRlclxuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIChhdHRyaWJ1dGVzKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLmhlYWRlci50cmFjZSgnI2NvbnN0cnVjdG9yJyk7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBdHRyaWJ1dGVzIG9mIHRoZSByZWxhdGlvblxuICAgICAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2F0dHJpYnV0ZXMgPSB7fTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUZWxscyBpZiB0aGUgcmVsYXRpb24gd2FzIGRlY2xhcmVkIGluIGFuIG9yZGVyZWQgd2F5IG9yIG5vdFxuICAgICAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9vcmRlcmVkRGVjbGFyYXRpb24gPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcblxuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBhdHRyaWJ1dGVzIGluIHRoZSBhcmd1bWVudHNcblxuICAgICAgICAgICAgICAgIGlmKF8uaXNPYmplY3QoYXR0cmlidXRlcykpe1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEF0dHJpYnV0ZXMgaXMgZWl0aGVyIGFuIGFycmF5IG9yIGFuIG9iamVjdFxuXG4gICAgICAgICAgICAgICAgICAgIGlmKCFfLmlzQXJyYXkoYXR0cmlidXRlcykpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdHRyaWJ1dGVzIGlzIGFuIE9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8geyA8bmFtZT4gOiB7dHlwZSA6IDx0eXBlPn0sIDxuYW1lPiA6IHt0eXBlIDogPHR5cGU+fSwgLi4uIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHsgPG5hbWU+IDogPGF0dHJpYnV0ZT4sIDxuYW1lPiA6IDxhdHRyaWJ1dGU+LCA8bmFtZT4gOiA8YXR0cmlidXRlPiwgLi4uIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgXy5mb3JPd24oYXR0cmlidXRlcywgZnVuY3Rpb24oYXR0cmlidXRlLCBrZXkpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHIgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyW2tleV0gPSBhdHRyaWJ1dGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYXR0cik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF0dHJpYnV0ZXMgaXMgYW4gQXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFsgeyA8bmFtZT4gOiB7dHlwZSA6IDx0eXBlPn0gfSwgeyA8bmFtZT4gOiB7dHlwZSA6IDx0eXBlPn0gfSwgLi4uIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFt7IDxuYW1lPiA6IDxhdHRyaWJ1dGU+fSwgezxuYW1lPiA6IDxhdHRyaWJ1dGU+fSwgezxuYW1lPiA6IDxhdHRyaWJ1dGU+fSwgLi4uIF1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3JkZXJlZERlY2xhcmF0aW9uID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKGF0dHJpYnV0ZXMsIGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGtleSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYXR0cmlidXRlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSx0aGlzKVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vuc3VwcG9ydGVkIGF0dHJpYnV0ZSBkZWNsYXJhdGlvbiBmb3JtYXQnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFNldC5jYWxsKHRoaXMsIHt0eXBlOiBBdHRyaWJ1dGUsIGVsZW1lbnRzOiByZXN1bHR9KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5kcyB0aGUgZXZlbnRzIGZvciB0aGUgb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLmhlYWRlci50cmFjZSgnI2JpbmRFdmVudHMnKTtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGlzLmVlLm9uKCdiZWZvcmVBZGQnLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoYXQuX2F0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoZWxlbWVudC5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSB3aXRoIG5hbWUgJyArIGVsZW1lbnQubmFtZSArICcgYWxyZWFkeSBleGlzdHMgaW4gaGVhZGVyJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5lZS5vbignYWZ0ZXJBZGQnLCBmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgpIHtcblxuICAgICAgICAgICAgICAgIHRoYXQuX2F0dHJpYnV0ZXNbZWxlbWVudC5uYW1lXSA9IGluZGV4O1xuXG4gICAgICAgICAgICAgICAgZWxlbWVudC5oZWFkZXIgPSB0aGF0O1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5lZS5vbignYWZ0ZXJSZW1vdmUnLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9hdHRyaWJ1dGVzW2VsZW1lbnQubmFtZV07XG4gICAgICAgICAgICAgICAgdGhhdC5yZWZyZXNoQXR0cmlidXRlcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZnJlc2hlcyB0aGUgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gICAgICAgICAqL1xuICAgICAgICByZWZyZXNoQXR0cmlidXRlczogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5oZWFkZXIudHJhY2UoJyNyZWZyZXNoQXR0cmlidXRlcycpO1xuXG4gICAgICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzID0ge307XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgpIHtcblxuICAgICAgICAgICAgICAgIGlmKCFfLmlzVW5kZWZpbmVkKGVsZW1lbnQpKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXR0cmlidXRlc1tlbGVtZW50Lm5hbWVdID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LCB0aGlzKVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgb25lIG9mIHRoZSBoZWFkZXIgYXR0cmlidXRlc1xuICAgICAgICAgKiBAcGFyYW0ge0F0dHJpYnV0ZXxTdHJpbmd9IGtleVxuICAgICAgICAgKiBAcmV0dXJucyB7QXR0cmlidXRlfG51bGx9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcblxuICAgICAgICAgICAgZGVidWcuaGVhZGVyLnRyYWNlKCcjZ2V0Jyk7XG5cbiAgICAgICAgICAgIGlmKGtleSBpbnN0YW5jZW9mIEF0dHJpYnV0ZSl7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2F0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoa2V5Lm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBhdHRyID0gdGhpcy5nZXQoa2V5Lm5hbWUpO1xuXG4gICAgICAgICAgICAgICAgaWYoIWF0dHIuZXF1YWxzKGtleSkpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0cjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc1N0cmluZyhrZXkpKXtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzKClbdGhpcy5fYXR0cmlidXRlc1trZXldXTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGluZGV4IG9mIGFuIGF0dHJpYnV0ZSBpbiB0aGUgaGVhZGVyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICAgICAqIEByZXR1cm5zIHtudWxsfEF0dHJpYnV0ZX1cbiAgICAgICAgICovXG4gICAgICAgIGdldEluZGV4OiBmdW5jdGlvbiAobmFtZSkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5oZWFkZXIudHJhY2UoJyNnZXRJbmRleCcpO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2F0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBhbiBhdHRyaWJ1dGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxuICAgICAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgICAgICogQHJldHVybnMge0F0dHJpYnV0ZXxudWxsfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXQgOiBmdW5jdGlvbihpbmRleCl7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuX2VsZW1lbnRzW2luZGV4XSAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudHNbaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBoZWFkZXIgYXR0cmlidXRlcyBsaXN0XG4gICAgICAgICAqIEBwYXJhbSB7KltdfSBhdHRyaWJ1dGVzXG4gICAgICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8bnVsbHxBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIGF0dHJpYnV0ZXM6IGZ1bmN0aW9uIChhdHRyaWJ1dGVzKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLmhlYWRlci50cmFjZSgnI2F0dHJpYnV0ZXMnKTtcblxuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzKGF0dHJpYnV0ZXMpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb25lcyBhIGhlYWRlciBhbmQgaXRzIGF0dHJpYnV0ZXNcbiAgICAgICAgICogQHJldHVybnMge0hlYWRlcn1cbiAgICAgICAgICovXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLmhlYWRlci50cmFjZSgnI2Nsb25lJyk7XG5cbiAgICAgICAgICAgIHZhciBuZXdIZWFkZXIgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXG4gICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcblxuICAgICAgICAgICAgICAgIGlmKCFfLmlzVW5kZWZpbmVkKGVsZW1lbnQpKXtcbiAgICAgICAgICAgICAgICAgICAgbmV3SGVhZGVyLmFkZChlbGVtZW50LmNsb25lKCksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3SGVhZGVyO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2plY3Qgb3BlcmF0aW9uIG9uIEhlYWRlciBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXXxBdHRyaWJ1dGVbXX0gcHJvamVjdGVkQXR0cmlidXRlc1xuICAgICAgICAgKiBAcmV0dXJucyB7SGVhZGVyfVxuICAgICAgICAgKi9cbiAgICAgICAgcHJvamVjdDogZnVuY3Rpb24gKHByb2plY3RlZEF0dHJpYnV0ZXMpIHtcblxuICAgICAgICAgICAgZGVidWcuaGVhZGVyLnRyYWNlKCcjcHJvamVjdCcpO1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0QXR0cmlidXRlcyA9IHt9LFxuICAgICAgICAgICAgICAgIGE7XG5cbiAgICAgICAgICAgIGEgPSBwcm9qZWN0ZWRBdHRyaWJ1dGVzLmxlbmd0aDtcblxuICAgICAgICAgICAgd2hpbGUgKGEtLSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHByb2plY3RlZEF0dHJpYnV0ZSA9IHByb2plY3RlZEF0dHJpYnV0ZXNbYV07XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBzdHJpbmcgZ2l2ZW4sIGZpbmQgdGhlIGF0dHJpYnV0ZSB3aXRoIHRoaXMgbmFtZVxuICAgICAgICAgICAgICAgIGlmIChfLmlzU3RyaW5nKHByb2plY3RlZEF0dHJpYnV0ZSkpIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb2plY3RlZEF0dHJpYnV0ZTtcblxuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0ZWRBdHRyaWJ1dGUgPSB0aGlzLmdldChhdHRyaWJ1dGVOYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvamVjdGVkQXR0cmlidXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ0F0dHJpYnV0ZSB3aXRoIG5hbWUgJyArIGF0dHJpYnV0ZU5hbWUgKyAnIG5vdCBmb3VuZCBpbiBoZWFkZXInKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9qZWN0ZWRBdHRyaWJ1dGUgaW5zdGFuY2VvZiBBdHRyaWJ1dGUpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIGF0dHJpYnV0ZSBpbiB0aGUgaGVhZGVyXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kID0gXy5maW5kKHRoaXMuZWxlbWVudHMoKSwgZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZSA9PT0gcHJvamVjdGVkQXR0cmlidXRlO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ0F0dHJpYnV0ZSBub3QgZm91bmQgaW4gdGhlIGhlYWRlcicpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXcm9uZyBmb3JtYXQgZ2l2ZW4gZm9yIGF0dHJpYnV0ZXMgaW4gSGVhZGVyIHByb2plY3Qgb3BlcmF0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdWx0QXR0cmlidXRlc1twcm9qZWN0ZWRBdHRyaWJ1dGUubmFtZV0gPSBwcm9qZWN0ZWRBdHRyaWJ1dGUuY2xvbmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBIZWFkZXIocmVzdWx0QXR0cmlidXRlcyk7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybSBhIHJlbW92YWwgb3BlcmF0aW9uIG9uIHRoZSBoZWFkZXJcbiAgICAgICAgICogQHBhcmFtIHtBdHRyaWJ1dGVbXXxTdHJpbmdbXXxBdHRyaWJ1dGV8U3RyaW5nfSBhdHRyaWJ1dGVzVG9SZW1vdmUgYXR0cmlidXRlcyB0byByZW1vdmUgZnJvbSB0aGUgaGVhZGVyXG4gICAgICAgICAqIEByZXR1cm4ge0hlYWRlcn0gdGhlIHJlc3VsdGluZyBoZWFkZXJcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGF0dHJpYnV0ZXNUb1JlbW92ZSkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5oZWFkZXIudHJhY2UoJyNyZW1vdmUnKTtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdEhlYWRlciA9IHRoaXMuY2xvbmUoKSxcbiAgICAgICAgICAgICAgICBhLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lO1xuXG4gICAgICAgICAgICAvLyBDb2VyY2UgdGhlIGFyZ3VtZW50cyB0byBhbiBhcnJheVxuICAgICAgICAgICAgaWYgKF8uaXNTdHJpbmcoYXR0cmlidXRlc1RvUmVtb3ZlKSB8fCBhdHRyaWJ1dGVzVG9SZW1vdmUgaW5zdGFuY2VvZiBBdHRyaWJ1dGUpIHtcblxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNUb1JlbW92ZSA9IFthdHRyaWJ1dGVzVG9SZW1vdmVdO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFfLmlzQXJyYXkoYXR0cmlidXRlc1RvUmVtb3ZlKSkge1xuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignV3JvbmcgYXJndW1lbnQgdHlwZSBmb3IgcmVtb3ZhbCBvcGVyYXRpb24nKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhID0gYXR0cmlidXRlc1RvUmVtb3ZlLmxlbmd0aDtcblxuICAgICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGVhY2ggZ2l2ZW4gYXR0cmlidXRlcyB0byByZW1vdmVcblxuICAgICAgICAgICAgd2hpbGUgKGEtLSkge1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCBnaXZlbiBhdHRyaWJ1dGVzVG9SZW1vdmUgYXJlIGluIHRoZSBoZWFkZXJcblxuICAgICAgICAgICAgICAgIGlmIChfLmlzU3RyaW5nKGF0dHJpYnV0ZXNUb1JlbW92ZVthXSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBQYXNzZWQgYXR0cmlidXRlIGlzIGEgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSB3aWxsIGNoZWNrIGlmIHRoZSBhdHRyaWJ1dGUgbmFtZSBleGlzdHMuXG5cbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZXNUb1JlbW92ZVthXTtcblxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzVG9SZW1vdmVbYV0gPSB0aGlzLmdldChhdHRyaWJ1dGVOYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ0F0dHJpYnV0ZSB3aXRoIG5hbWUgJyArIGF0dHJpYnV0ZU5hbWUgKyAnIG5vdCBmb3VuZCBpbiBoZWFkZXInKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBQYXNzZWQgYXR0cmlidXRlIGlzIGFuIEF0dHJpYnV0ZSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugd2lsbCBjaGVjayBpZiBpdCBleGlzdHMgaW4gdGhlIGhlYWRlclxuXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNUb1JlbW92ZVthXTtcblxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlLm5hbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBhdHRyaWJ1dGUgbmFtZSBkb2Vzbid0IGV4aXN0IGluIHRoZSBoZWFkZXJcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdBdHRyaWJ1dGUgd2l0aCBuYW1lICcgKyBhdHRyaWJ1dGVOYW1lICsgJyBub3QgZm91bmQgaW4gaGVhZGVyJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmdldChhdHRyaWJ1dGVOYW1lKS5lcXVhbChhdHRyaWJ1dGUpID09PSBmYWxzZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYXR0cmlidXRlIGlzIGZvdW5kIGJ1dCBkb2Vzbid0IGhhdmUgdGhlIHNhbWUgdHlwZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ0F0dHJpYnV0ZSBvYmplY3QgZm91bmQgaW4gdGhlIGhlYWRlciBidXQgbm90IG9mIHNhbWUgdHlwZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBEZWxldGUgdGhlIGZvdW5kIGF0dHJpYnV0ZXMgZnJvbSB0aGUgcmVzdWx0aW5nIGhlYWRlclxuXG4gICAgICAgICAgICAgICAgcmVzdWx0SGVhZGVyLnJlbW92ZUF0KHJlc3VsdEhlYWRlci5nZXRJbmRleChhdHRyaWJ1dGVOYW1lKSk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdEhlYWRlcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVuYW1lIG9wZXJhdGlvbiBvbiB0aGUgaGVhZGVyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gICAgICAgICAqIEByZXR1cm5zIHtIZWFkZXJ9IFRoZSBuZXcgc2V0XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgbmV3SGVhZGVyID0gSGVhZGVyLnJlbmFtZSggeyBvbGROYW1lIDogJ25ld05hbWUnIH0gKTtcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHJlbmFtZTogZnVuY3Rpb24gKGF0dHJpYnV0ZXMpIHtcblxuICAgICAgICAgICAgZGVidWcuaGVhZGVyLnRyYWNlKCcjcmVuYW1lJyk7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHRIZWFkZXIgPSB0aGlzLmNsb25lKCksXG4gICAgICAgICAgICAgICAga2V5O1xuXG4gICAgICAgICAgICBpZiAoXy5pc09iamVjdChhdHRyaWJ1dGVzKSkge1xuXG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gYXR0cmlidXRlcykge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld05hbWUgPSBhdHRyaWJ1dGVzW2tleV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBzcGVjaWZpZWQgbmFtZSBpcyBhIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfLmlzU3RyaW5nKG5ld05hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTmV3IG5hbWUgZm9yIGF0dHJpYnV0ZSAnICsga2V5ICsgJyBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRBdHRyaWJ1dGUgPSB0aGlzLmdldChrZXkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUga2V5IGV4aXN0cyBpbiB0aGUgY3VycmVudCBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRBdHRyaWJ1dGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ0F0dHJpYnV0ZSB3aXRoIG5hbWUgJyArIGtleSArICcgZG9lc25cXCd0IGV4aXN0IGluIGhlYWRlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgcmVuYW1lZCBvcGVyYXRpb24gZG9lcyBub3Qgb3ZlcndyaXRlIGFuIGV4aXN0aW5nIGtleSBpbiB0aGUgaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShuZXdOYW1lKSAmJiBuZXdOYW1lICE9PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ05ldyBhdHRyaWJ1dGUgbmFtZSAnICsgbmV3TmFtZSArICcgYWxyZWFkeSBleGlzdHMgaW4gdGhlIGhlYWRlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgbmV3IG5hbWUgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBvbGQgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld05hbWUgPT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnLmhlYWRlci53YXJuKCdVc2VsZXNzIHJlbmFtaW5nIG9wZXJhdGlvbnMgOiAnICsga2V5ICsgJyAtPiAnICsgbmV3TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHR3byByZW5hbWVkIGF0dHJpYnV0ZXMgZG9uJ3QgaGF2ZSB0aGUgc2FtZSB0YXJnZXQgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoYSkgJiYgYSAhPT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdOYW1lID09PSBhdHRyaWJ1dGVzW2FdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ1R3byByZW5hbWVkIGF0dHJpYnV0ZXMgaGF2ZSB0aGUgc2FtZSB0YXJnZXQgbmFtZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRIZWFkZXIuX2F0dHJpYnV0ZXNbbmV3TmFtZV0gPSByZXN1bHRIZWFkZXIuX2F0dHJpYnV0ZXNba2V5XTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gbmV3TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRIZWFkZXIuX2F0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0SGVhZGVyLmdldChuZXdOYW1lKS5uYW1lID0gbmV3TmFtZTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignV3JvbmcgYXJndW1lbnQgdHlwZSBmb3IgcmVuYW1lIG9wZXJhdGlvbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0SGVhZGVyO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtSZWxhdGlvbn0gVGhlIHJlbGF0aW9uIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBoZWFkZXJcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBoZWFkZXIgPSBuZXcgYWZmaW5pdHkuSGVhZGVyKHsgYSA6IGFmZmluaXR5LlN0cmluZywgYiA6IGFmZmluaXR5LlN0cmluZyB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBoZWFkZXJSZWxhdGlvbiA9IGhlYWRlci50b1JlbGF0aW9uKCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBoZWFkZXJSZWxhdGlvbi5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBuYW1lIDogU3RyaW5nIHwgdHlwZSA6IFR5cGUgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBhICAgICAgICAgICAgIHwgU3RyaW5nICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBiICAgICAgICAgICAgIHwgU3RyaW5nICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdG9SZWxhdGlvbjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5oZWFkZXIudHJhY2UoJyN0b1JlbGF0aW9uJyk7XG5cbiAgICAgICAgICAgIHZhciByZWwgPSBuZXcgKHJlcXVpcmUoJy4vUmVsYXRpb24uanMnKSkoW1xuICAgICAgICAgICAgICAgIHtuYW1lOiB7dHlwZTogVFN0cmluZ319LFxuICAgICAgICAgICAgICAgIHt0eXBlOiB7dHlwZTogVFR5cGV9fVxuICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgcmVsLmFkZCh7bmFtZTogYXR0cmlidXRlLm5hbWUsIHR5cGU6IGF0dHJpYnV0ZS50eXBlfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlbDtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG5hbWVzIG9mIHRoZSBhdHRyaWJ1dGVzXG4gICAgICAgICAqL1xuICAgICAgICB0b05hbWVBcnJheSA6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihhdHRyaWJ1dGUpe1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGF0dHJpYnV0ZS5uYW1lKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIENvbnZlcnRzIGEgcmVsYXRpb24gdG8gYSBoZWFkZXIuIFRoZSByZWxhdGlvbiBtdXN0IGhhdmUgYSBuYW1lIDogc3RyaW5nIGFuZCB0eXBlIDogdHlwZSBzdHJ1Y3R1cmUuXG4gICAgICAgICAqIEludmVyc2Ugb2Yge0BsaW5rIEhlYWRlciN0b1JlbGF0aW9ufVxuICAgICAgICAgKiBAcGFyYW0gcmVsYXRpb25cbiAgICAgICAgICogQHJldHVybnMge0hlYWRlcn1cbiAgICAgICAgICovXG4gICAgICAgIGZyb21SZWxhdGlvbiA6IGZ1bmN0aW9uKHJlbGF0aW9uKXtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgcmVsYXRpb24gaGFzIHRoZSByaWdodCBoZWFkZXJcbiAgICAgICAgICAgIGlmKCFyZWxhdGlvbi5oZWFkZXIoKS5leGlzdHMoe25hbWUgOiAnbmFtZScsIHR5cGUgOiBUU3RyaW5nfSkgfHwgIXJlbGF0aW9uLmhlYWRlcigpLmV4aXN0cyh7IG5hbWUgOiAndHlwZScsIHR5cGUgOiBUVHlwZX0pIHx8ICEocmVsYXRpb24uaGVhZGVyKCkubGVuZ3RoKCk9PTIpKXtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHJlbGF0aW9uIHRvIGhlYWRlcicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZWxhdGlvbi5lYWNoKGZ1bmN0aW9uKHR1cGxlKXtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZCh7bmFtZSA6IHR1cGxlLmdldCgnbmFtZScpLCB0eXBlIDogdHVwbGUuZ2V0KCd0eXBlJyl9LCBmYWxzZSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29waWVzIGF0dHJpYnV0ZXMgZnJvbSBhIHJlbGF0aW9uIHRvIGFub3RoZXJcbiAgICAgICAgICogQHBhcmFtIHtIZWFkZXJ9IGhlYWRlclxuICAgICAgICAgKiBAcGFyYW0ge0hlYWRlcnxzdHJpbmdbXXxTZXR9IFthdHRyaWJ1dGVzQXJndW1lbnQ9W11dXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2V4Y2x1ZGU9ZmFsc2VdXG4gICAgICAgICAqIEByZXR1cm5zIHtIZWFkZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBjb3B5IDogZnVuY3Rpb24oaGVhZGVyLCBhdHRyaWJ1dGVzQXJndW1lbnQsIGV4Y2x1ZGUpe1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmKGV4Y2x1ZGUgIT09IHRydWUgJiYgZXhjbHVkZSAhPT0gZmFsc2Upe1xuICAgICAgICAgICAgICAgIGV4Y2x1ZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXNBcmd1bWVudCl7XG5cbiAgICAgICAgICAgICAgICAvLyBDb2VyY2UgdGhlIGF0dHJpYnV0ZXNBcmd1bWVudCBhcmd1bWVudHMgdG8gYSBoZWFkZXIgYXJndW1lbnRcblxuICAgICAgICAgICAgICAgIGlmKCEoYXR0cmlidXRlc0FyZ3VtZW50IGluc3RhbmNlb2YgSGVhZGVyKSl7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBIZWFkZXIgPSBuZXcgSGVhZGVyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoYXR0cmlidXRlc0FyZ3VtZW50IGluc3RhbmNlb2YgU2V0KXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc0FyZ3VtZW50LmVhY2goZnVuY3Rpb24oYXR0cmlidXRlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihfLmlzU3RyaW5nKGF0dHJpYnV0ZSkpe1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHIgPSBoZWFkZXIuZ2V0KGF0dHJpYnV0ZSk7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihhdHRyID09PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0cmlidXRlIHdpdGggbmFtZSBcIicgKyBhdHRyaWJ1dGUgKyAnXCIgbm90IGZvdW5kIGluIHRoZSBoZWFkZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBIZWFkZXIuYWRkKGhlYWRlci5nZXQoYXR0cmlidXRlKS5jbG9uZSgpKTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKGF0dHJpYnV0ZSBpbnN0YW5jZW9mIEF0dHJpYnV0ZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGhlYWRlci5nZXQoYXR0cmlidXRlLm5hbWUpID09PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0cmlidXRlIHdpdGggbmFtZSBcIicgKyBhdHRyaWJ1dGUubmFtZSArICdcIiBub3QgZm91bmQgaW4gdGhlIGhlYWRlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcEhlYWRlci5hZGQoYXR0cmlidXRlLmNsb25lKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF8uaXNBcnJheShhdHRyaWJ1dGVzQXJndW1lbnQpKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKGF0dHJpYnV0ZXNBcmd1bWVudCwgZnVuY3Rpb24oYXR0cmlidXRlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihfLmlzU3RyaW5nKGF0dHJpYnV0ZSkpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRyID0gaGVhZGVyLmdldChhdHRyaWJ1dGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGF0dHIgPT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRyaWJ1dGUgd2l0aCBuYW1lIFwiJyArIGF0dHJpYnV0ZSArICdcIiBub3QgZm91bmQgaW4gdGhlIGhlYWRlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcEhlYWRlci5hZGQoYXR0ci5jbG9uZSgpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihhdHRyaWJ1dGUgaW5zdGFuY2VvZiBBdHRyaWJ1dGUpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihoZWFkZXIuZ2V0KGF0dHJpYnV0ZS5uYW1lKSA9PT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSB3aXRoIG5hbWUgXCInICsgYXR0cmlidXRlLm5hbWUgKyAnXCIgbm90IGZvdW5kIGluIHRoZSBoZWFkZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBIZWFkZXIuYWRkKGF0dHJpYnV0ZS5jbG9uZSgpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKGF0dHJpYnV0ZXNBcmd1bWVudCkpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IGhlYWRlci5nZXQoYXR0cmlidXRlc0FyZ3VtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYXR0ciA9PT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRyaWJ1dGUgd2l0aCBuYW1lICcgKyBhdHRyaWJ1dGVzQXJndW1lbnQgKyAnIG5vdCBmb3VuZCBpbiB0aGUgaGVhZGVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBIZWFkZXIuYWRkKGF0dHIpO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzQXJndW1lbnQgPSB0ZW1wSGVhZGVyO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzQXJndW1lbnQuZWFjaChmdW5jdGlvbihhdHRyaWJ1dGUpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihoZWFkZXIuZ2V0KGF0dHJpYnV0ZS5uYW1lKSA9PT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRyaWJ1dGUgd2l0aCBuYW1lICcgKyBhdHRyaWJ1dGUubmFtZSArICcgbm90IGZvdW5kIGluIHRoZSBoZWFkZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleGNsdWRlICYmIGF0dHJpYnV0ZXNBcmd1bWVudCl7XG5cbiAgICAgICAgICAgICAgICBoZWFkZXIuZWFjaChmdW5jdGlvbihhdHRyaWJ1dGUpe1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0V4Y2x1ZGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc0FyZ3VtZW50LmVhY2goZnVuY3Rpb24oZXhjbHVkZWRBdHRyaWJ1dGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYXR0cmlidXRlLmVxdWFsKGV4Y2x1ZGVkQXR0cmlidXRlKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNFeGNsdWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKCFpc0V4Y2x1ZGVkKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKGF0dHJpYnV0ZS5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSwgdGhpcylcblxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFleGNsdWRlICYmIGF0dHJpYnV0ZXNBcmd1bWVudCl7XG5cbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzQXJndW1lbnQuZWFjaChmdW5jdGlvbihpbmNsdWRlZEF0dHJpYnV0ZSl7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQoaGVhZGVyLmdldChpbmNsdWRlZEF0dHJpYnV0ZS5uYW1lKS5jbG9uZSgpKTtcblxuICAgICAgICAgICAgICAgIH0sIHRoaXMpXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBoZWFkZXIuZWFjaChmdW5jdGlvbihhdHRyaWJ1dGUpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZChhdHRyaWJ1dGUuY2xvbmUoKSk7XG4gICAgICAgICAgICAgICAgfSx0aGlzKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9XG5cblxuICAgIH0sIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge0hlYWRlcn0gaGVhZGVyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nW118QXR0cmlidXRlW119IGF0dHJpYnV0ZXNcbiAgICAgICAgICovXG4gICAgICAgIGFzc2VydEF0dHJpYnV0ZXNFeGlzdCA6IGZ1bmN0aW9uKGhlYWRlciwgYXR0cmlidXRlcyl7XG5cbiAgICAgICAgICAgIHZhciBtaXNtYXRjaCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBfLmZvckVhY2goYXR0cmlidXRlcywgZnVuY3Rpb24oYXR0cmlidXRlKXtcblxuICAgICAgICAgICAgICAgIGlmKF8uaXNTdHJpbmcoYXR0cmlidXRlKSl7XG4gICAgICAgICAgICAgICAgICAgIGlmKGhlYWRlci5nZXQoYXR0cmlidXRlKSA9PT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSB3aXRoIG5hbWUgJyArIGF0dHJpYnV0ZSArICcgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGhlYWRlcicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhdHRyaWJ1dGUgaW5zdGFuY2VvZiBBdHRyaWJ1dGUpe1xuICAgICAgICAgICAgICAgICAgICBpZighaGVhZGVyLmV4aXN0cyhhdHRyaWJ1dGUpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0cmlidXRlIHdpdGggbmFtZSAnICsgYXR0cmlidXRlLm5hbWUgKyAnIGRvZXMgbm90IGV4aXN0IGluIHRoZSBoZWFkZXInKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0cmlidXRlIGlzIG9mIHdyb25nIHR5cGUnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtIZWFkZXJ9IGhlYWRlcjFcbiAgICAgICAgICogQHBhcmFtIHtIZWFkZXJ9IGhlYWRlcjJcbiAgICAgICAgICovXG4gICAgICAgIGFzc2VydFNhbWVOYW1lU2FtZVR5cGUgOiBmdW5jdGlvbihoZWFkZXIxLCBoZWFkZXIyKXtcblxuICAgICAgICAgICAgaGVhZGVyMS5lYWNoKGZ1bmN0aW9uKGF0dHJpYnV0ZTEpe1xuXG4gICAgICAgICAgICAgICAgaGVhZGVyMi5lYWNoKGZ1bmN0aW9uKGF0dHJpYnV0ZTIpe1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKGF0dHJpYnV0ZTEubmFtZSA9PT0gYXR0cmlidXRlMi5uYW1lICYmIGF0dHJpYnV0ZTEudHlwZSAhPT0gYXR0cmlidXRlMi50eXBlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSGVhZGVycyBtdXN0IGhhdmUgc2FtZSB0eXBlIG9uIGF0dHJpYnV0ZXMgb2Ygc2FtZSBuYWVtJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge0hlYWRlcn0gaGVhZGVyMVxuICAgICAgICAgKiBAcGFyYW0ge0hlYWRlcn0gaGVhZGVyMlxuICAgICAgICAgKi9cbiAgICAgICAgYXNzZXJ0VW5pb25Db21wYXRpYmxlIDogZnVuY3Rpb24oaGVhZGVyMSwgaGVhZGVyMil7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5lcXVhbChoZWFkZXIxLCBoZWFkZXIyKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVsYXRpb25zIGFyZSBub3QgdW5pb24gY29tcGF0aWJsZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtIZWFkZXJ9IGhlYWRlcjFcbiAgICAgICAgICogQHBhcmFtIHtIZWFkZXJ9IGhlYWRlcjJcbiAgICAgICAgICovXG4gICAgICAgIGFzc2VydERpc2pvaW50IDogZnVuY3Rpb24oaGVhZGVyMSwgaGVhZGVyMil7XG5cbiAgICAgICAgICAgIGlmKCF0aGlzLmRpc2pvaW50KGhlYWRlcjEsIGhlYWRlcjIpKXtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hlYWRlcnMgbXVzdCBiZSBkaXNqb2ludCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtIZWFkZXJ9IGhlYWRlcjFcbiAgICAgICAgICogQHBhcmFtIHtIZWFkZXJ9IGhlYWRlcjJcbiAgICAgICAgICogQHJldHVybnMge1NldHwqfVxuICAgICAgICAgKi9cbiAgICAgICAgY29tbW9uQXR0cmlidXRlcyA6IGZ1bmN0aW9uKGhlYWRlcjEsIGhlYWRlcjIpe1xuXG4gICAgICAgICAgICByZXR1cm4gaGVhZGVyMS5zZXRJbnRlcnNlY3Rpb24oaGVhZGVyMik7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgYSByZWxhdGlvbiBpbnRvIGEgaGVhZGVyLlxuICAgICAgICAgKiBUaGUgcmVsYXRpb24gbXVzdCBoYXZlIHRoZSBoZWFkZXIgb25seSB3aXRoIGF0dHJpYnV0ZXMgbmFtZSA6IFRTdHJpbmcgYW5kIHR5cGUgOiBUVHlwZS5cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0gcmVsYXRpb25cbiAgICAgICAgICogQHJldHVybnMge0hlYWRlcn1cbiAgICAgICAgICovXG4gICAgICAgIGZyb21SZWxhdGlvbiA6IGZ1bmN0aW9uKHJlbGF0aW9uKXtcblxuICAgICAgICAgICAgdmFyIGhlYWRlciA9IG5ldyBIZWFkZXIoKTtcblxuICAgICAgICAgICAgcmV0dXJuIGhlYWRlci5mcm9tUmVsYXRpb24ocmVsYXRpb24pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtIZWFkZXJ9IGhlYWRlcjFcbiAgICAgICAgICogQHBhcmFtIHtIZWFkZXJ9IGhlYWRlcjJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbDogZnVuY3Rpb24gKGhlYWRlcjEsIGhlYWRlcjIpIHtcblxuICAgICAgICAgICAgZGVidWcuaGVhZGVyLnRyYWNlKCdIZWFkZXIuZXF1YWwnKTtcblxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGhlYWRlcjEuX2F0dHJpYnV0ZXMpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoaGVhZGVyMi5fYXR0cmlidXRlcykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbWlzbWF0Y2ggPSBmYWxzZTtcblxuICAgICAgICAgICAgaGVhZGVyMS5lYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUxKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlMU5hbWUgPSBhdHRyaWJ1dGUxLm5hbWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWhlYWRlcjIuX2F0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlMU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghQXR0cmlidXRlLmVxdWFsKGF0dHJpYnV0ZTEsIGhlYWRlcjIuZ2V0KGF0dHJpYnV0ZTEubmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuICFtaXNtYXRjaDtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7SGVhZGVyfSBoZWFkZXIxXG4gICAgICAgICAqIEBwYXJhbSB7SGVhZGVyfSBoZWFkZXIyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzam9pbnQ6IGZ1bmN0aW9uIChoZWFkZXIxLCBoZWFkZXIyKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLmhlYWRlci50cmFjZSgnSGVhZGVyLmRpc2pvaW50Jyk7XG5cbiAgICAgICAgICAgIHZhciBoZWFkZXJzID0gaGVhZGVyMS5sZW5ndGgoKSA+IGhlYWRlcjIubGVuZ3RoKCkgPyBbaGVhZGVyMSxoZWFkZXIyXSA6IFtoZWFkZXIyLGhlYWRlcjFdO1xuXG4gICAgICAgICAgICB2YXIgZGlmZmVyZW50ID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCBoZWFkZXIgaGF2ZSBubyBjb21tb24gYXR0cmlidXRlIG5hbWVzXG4gICAgICAgICAgICBoZWFkZXJzWzBdLmVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZTEpIHtcblxuICAgICAgICAgICAgICAgIGlmIChoZWFkZXJzWzFdLmdldChhdHRyaWJ1dGUxLm5hbWUpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZmZlcmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGRpZmZlcmVudDtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7SGVhZGVyfCp9IGhlYWRlclxuICAgICAgICAgKiBAcmV0dXJucyB7SGVhZGVyfVxuICAgICAgICAgKi9cbiAgICAgICAgY29lcmNlIDogZnVuY3Rpb24oaGVhZGVyKXtcblxuICAgICAgICAgICAgaWYoaGVhZGVyIGluc3RhbmNlb2YgdGhpcyl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlYWRlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIZWFkZXIoaGVhZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSGVhZGVyOyIsInZhciBCYXNlID0gcmVxdWlyZSgnLi9CYXNlJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCcuL2hlbHBlcnMvZGVidWcnKTtcblxudmFyIEluZGV4ID0gQmFzZS5leHRlbmQoXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSW5kZXggY2xhc3MgaXMgYSBzaW1wbGUgdXRpbGl0eSBjbGFzcyBhbGxvd2luZyB0dXBsZXMgdG8gYmUgaW5kZXhlZC5cbiAgICAgICAgICogSXQgc3BlZWRzIHVwIG9wZXJhdGlvbnMgb24gcmVsYXRpb25zIGFzIGl0ZXJhdGlvbnMgYXJlIHJlZHVjZWQuXG4gICAgICAgICAqIEBjbGFzcyBJbmRleFxuICAgICAgICAgKiBAZXh0ZW5kcyBCYXNlXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKGhlYWRlcikge1xuXG4gICAgICAgICAgICBkZWJ1Zy5pbmRleC50cmFjZSgnI2NvbnN0cnVjdG9yJyk7XG5cbiAgICAgICAgICAgIC8qKiBAcHJvcGVydHkge0hlYWRlcn0gaGVhZGVyICovXG4gICAgICAgICAgICB0aGlzLmhlYWRlciA9IGhlYWRlcjtcblxuICAgICAgICAgICAgLyoqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZXZlbHMgKi9cbiAgICAgICAgICAgIHRoaXMubGV2ZWxzID0gaGVhZGVyLmxlbmd0aCgpO1xuXG4gICAgICAgICAgICAvKiogQHByb3BlcnR5IHtPYmplY3R9IGVsZW1lbnRzICovXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzID0ge307XG5cbiAgICAgICAgICAgIC8qKiBAcHJvcGVydHkge0FycmF5fSBoZWFkZXJMZXZlbHMgKi9cbiAgICAgICAgICAgIHRoaXMuaGVhZGVyTGV2ZWxzID0gW107XG5cbiAgICAgICAgICAgIC8qIFJlY3Vyc2l2ZWx5IGl0ZXJhdGluZyB0aHJvdWdoIHRoZSBoZWFkZXIgYW5kIHBvcHVsYXRpbmcgdGhlIGhlYWRlckxldmVscyBhcnJheSovXG5cbiAgICAgICAgICAgIHZhciB0YXJnZXRIZWFkZXIgPSB0aGlzLmhlYWRlci5jbG9uZSgpO1xuXG4gICAgICAgICAgICBmb3IodmFyIGsgPSAwOyBrIDwgdGhpcy5sZXZlbHM7IGsrKyl7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlckxldmVsc1trXSA9IHRhcmdldEhlYWRlcjtcbiAgICAgICAgICAgICAgICB0YXJnZXRIZWFkZXIgPSB0YXJnZXRIZWFkZXIucmVtb3ZlKHRhcmdldEhlYWRlci5maXJzdCgpKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSB0dXBsZSB0byB0aGUgaW5kZXhcbiAgICAgICAgICogQHBhcmFtIHtUdXBsZX0gdHVwbGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICAgICAqL1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uICh0dXBsZSwgaW5kZXgpIHtcblxuICAgICAgICAgICAgZGVidWcuaW5kZXgudHJhY2UoJyNhZGQnKTtcblxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgaGVhZGVyQ291bnQgPSB0aGlzLmhlYWRlci5sZW5ndGgoKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPD0gaGVhZGVyQ291bnQgLSAxOyBhKyspIHtcblxuICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBjb250ZXh0LmhlYWRlci5maXJzdCgpO1xuICAgICAgICAgICAgICAgIHZhciB0dXBsZUF0dHJpYnV0ZVZhbHVlO1xuXG4gICAgICAgICAgICAgICAgaWYoIWF0dHJpYnV0ZS50eXBlLnByaW1pdGl2ZSl7XG4gICAgICAgICAgICAgICAgICAgIHR1cGxlQXR0cmlidXRlVmFsdWUgPSBhdHRyaWJ1dGUudHlwZS5zZXJpYWxpemUodHVwbGUuZ2V0KGF0dHJpYnV0ZS5uYW1lKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHVwbGVBdHRyaWJ1dGVWYWx1ZSA9IHR1cGxlLmdldChhdHRyaWJ1dGUubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGEgPT09IGhlYWRlckNvdW50IC0gMSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZWxlbWVudHNbdHVwbGVBdHRyaWJ1dGVWYWx1ZV0gPSBpbmRleFxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQuZWxlbWVudHMuaGFzT3duUHJvcGVydHkodHVwbGVBdHRyaWJ1dGVWYWx1ZSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0luZGV4ID0gbmV3IEluZGV4KHRoaXMuaGVhZGVyTGV2ZWxzW2ErMV0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmVsZW1lbnRzW3R1cGxlQXR0cmlidXRlVmFsdWVdID0gbmV3SW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSBuZXdJbmRleDtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dC5lbGVtZW50c1t0dXBsZUF0dHJpYnV0ZVZhbHVlXTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGluZGV4IGZvciBhIHR1cGxlXG4gICAgICAgICAqIEBwYXJhbSB7VHVwbGV9IHR1cGxlXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ8bnVsbH1cbiAgICAgICAgICovXG4gICAgICAgIGdldEluZGV4OiBmdW5jdGlvbiAodHVwbGUpIHtcblxuICAgICAgICAgICAgZGVidWcuaW5kZXgudHJhY2UoJyNnZXRJbmRleCcpO1xuXG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBoZWFkZXJDb3VudCA9IHRoaXMuaGVhZGVyLmxlbmd0aCgpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8PSBoZWFkZXJDb3VudCAtIDE7IGErKykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGNvbnRleHQuaGVhZGVyLmZpcnN0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHR1cGxlQXR0cmlidXRlVmFsdWU7XG5cbiAgICAgICAgICAgICAgICBpZighYXR0cmlidXRlLnR5cGUucHJpbWl0aXZlKXtcbiAgICAgICAgICAgICAgICAgICAgdHVwbGVBdHRyaWJ1dGVWYWx1ZSA9IGF0dHJpYnV0ZS50eXBlLnNlcmlhbGl6ZSh0dXBsZS5nZXQoYXR0cmlidXRlLm5hbWUpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0dXBsZUF0dHJpYnV0ZVZhbHVlID0gdHVwbGUuZ2V0KGF0dHJpYnV0ZS5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYSA9PT0gaGVhZGVyQ291bnQgLSAxKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0LmVsZW1lbnRzLmhhc093blByb3BlcnR5KHR1cGxlQXR0cmlidXRlVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVsZW1lbnRzW3R1cGxlQXR0cmlidXRlVmFsdWVdO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQuZWxlbWVudHMuaGFzT3duUHJvcGVydHkodHVwbGVBdHRyaWJ1dGVWYWx1ZSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LmVsZW1lbnRzW3R1cGxlQXR0cmlidXRlVmFsdWVdO1xuXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGEgdHVwbGUgZnJvbSB0aGUgaW5kZXhcbiAgICAgICAgICogQHBhcmFtIHtUdXBsZX0gdHVwbGVcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgcmVtb3ZlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICh0dXBsZSkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5pbmRleC50cmFjZSgnI3JlbW92ZScpO1xuXG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBoZWFkZXJDb3VudCA9IHRoaXMuaGVhZGVyLmxlbmd0aCgpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8PSBoZWFkZXJDb3VudCAtIDE7IGErKykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGNvbnRleHQuaGVhZGVyLmZpcnN0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHR1cGxlQXR0cmlidXRlVmFsdWU7XG5cbiAgICAgICAgICAgICAgICBpZighYXR0cmlidXRlLnR5cGUucHJpbWl0aXZlKXtcbiAgICAgICAgICAgICAgICAgICAgdHVwbGVBdHRyaWJ1dGVWYWx1ZSA9IGF0dHJpYnV0ZS50eXBlLnNlcmlhbGl6ZSh0dXBsZS5nZXQoYXR0cmlidXRlLm5hbWUpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0dXBsZUF0dHJpYnV0ZVZhbHVlID0gdHVwbGUuZ2V0KGF0dHJpYnV0ZS5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYSA9PT0gaGVhZGVyQ291bnQgLSAxKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0LmVsZW1lbnRzLmhhc093blByb3BlcnR5KHR1cGxlQXR0cmlidXRlVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29udGV4dC5lbGVtZW50c1t0dXBsZUF0dHJpYnV0ZVZhbHVlXTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0LmVsZW1lbnRzLmhhc093blByb3BlcnR5KHR1cGxlQXR0cmlidXRlVmFsdWUpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQuZWxlbWVudHNbdHVwbGVBdHRyaWJ1dGVWYWx1ZV07XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmRleDsiLCJ2YXIgVHlwZSA9IHJlcXVpcmUoJy4vVHlwZScpLFxuICAgIEluZGV4ID0gcmVxdWlyZSgnLi9JbmRleCcpLFxuICAgIEhlYWRlciA9IHJlcXVpcmUoJy4vSGVhZGVyJyksXG4gICAgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi9oZWxwZXJzL2RlYnVnJyk7XG5cbnZhciBLZXkgPSBUeXBlLmV4dGVuZCh7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBLZXlcbiAgICAgICAgICogQGV4dGVuZHMgQmFzZVxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgS2V5IGNsYXNzIHJlcHJlc2VudHMga2V5cyB0byBhIHJlbGF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIGtleXMgYXJlIG5vdCBkZWZpbmVkIG9uIGEgcmVsYXRpb24sIGEga2V5IGlzIGFzc3VtZWQgb24gYWxsIGF0dHJpYnV0ZXMgb2YgdGhlIHJlbGF0aW9uLlxuICAgICAgICAgKiBUaG91Z2gsIHdoZW4gYSBrZXkgaXMgZGVmaW5lZCBvbiBhIHN1YnNldCBvZiBhIHJlbGF0aW9uJ3MgYXR0cmlidXRlcywgdGhlIHVuaXF1ZW5lc3NcbiAgICAgICAgICogb2YgdGhlIHR1cGxlcyB3aWxsIGJlIGNhbGN1bGF0ZWQgb25seSBvbiB0aG9zZSBhdHRyaWJ1dGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBbHNvLCBhIEtleSB3aWxsIGluZGV4IHRoZSB0dXBsZXMgZm9yIGl0cyBhdHRyaWJ1dGVzLCBtYWtpbmcgb3BlcmF0aW9ucyBhIGxvdCBmYXN0ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb24gPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICB7YXR0cmlidXRlMSA6IHt0eXBlIDogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICB7YXR0cmlidXRlMiA6IHt0eXBlIDogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICB7YXR0cmlidXRlMyA6IHt0eXBlIDogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICBbMSwgMiwgM10sXG4gICAgICAgICAqICAgICAgICAgIFs0LCAyLCAzXSwgLy8gLT4gV2lsbCBmYWlsIHRvIGJlIGFkZGVkLCBhcyBpdCBkb2VzIG5vdCByZXNwZWN0cyB0aGUgdW5pcXVlIGtleSBjb25zdHJhaW50XG4gICAgICAgICAqICAgICAgICAgIFsxLCA4LCA5XSwgLy8gLT4gV2lsbCBmYWlsIHRvIGJlIGFkZGVkLCBhcyBpdCBkb2VzIG5vdCByZXNwZWN0ZWQgdGhlIHBrIGNvbnN0cmFpbnRcbiAgICAgICAgICogICAgICAgICAgWzEwLCAxMSwgMTJdLFxuICAgICAgICAgKiAgICAgIF0se1xuICAgICAgICAgKiAgICAgICAgICBwayA6IFsnYXR0cmlidXRlMSddLFxuICAgICAgICAgKiAgICAgICAgICB1bmlxdWUgOiBbWydhdHRyaWJ1dGUyJywgJ2F0dHJpYnV0ZTMnXV1cbiAgICAgICAgICogICAgICB9KTtcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAocmVsYXRpb24sIGF0dHJpYnV0ZXMpIHtcblxuICAgICAgICAgICAgZGVidWcua2V5LnRyYWNlKCcjY29uc3RydWN0b3InKTtcblxuICAgICAgICAgICAgaWYoIV8uaXNBcnJheShhdHRyaWJ1dGVzKSl7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcyA9IFthdHRyaWJ1dGVzXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0hlYWRlcn0gaGVhZGVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBoZWFkZXIgPSB0aGlzLmhlYWRlciA9IG5ldyBIZWFkZXIoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaGVhZGVyLnJlbGF0aW9uID0gcmVsYXRpb247XG5cbiAgICAgICAgICAgIGhlYWRlci5jb3B5KHJlbGF0aW9uLmhlYWRlcigpLGF0dHJpYnV0ZXMpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SW5kZXh9IGluZGV4XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXggPSBuZXcgSW5kZXgodGhpcy5oZWFkZXIpO1xuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIHR1cGxlIHRvIHRoZSBpbmRleCBhZnRlciBpdCBpcyBhZGRlZCBpbiB0aGUgcmVsYXRpb25cbiAgICAgICAgICAgIHJlbGF0aW9uLmVlLm9uKCdhZnRlckFkZCcsIGZ1bmN0aW9uKHR1cGxlLCB0dXBsZUluZGV4KXtcblxuICAgICAgICAgICAgICAgIGRlYnVnLmtleS50cmFjZSgnI2FmdGVyQWRkJyk7XG5cbiAgICAgICAgICAgICAgICBpbmRleC5hZGQodHVwbGUsIHR1cGxlSW5kZXgpO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0dXBsZSBmcm9tIHRoZSBiZWZvcmUgaXQgaXMgZGVsZXRlZFxuICAgICAgICAgICAgcmVsYXRpb24uZWUub24oJ2JlZm9yZURlbGV0ZScsIGZ1bmN0aW9uKHR1cGxlLCB0dXBsZUluZGV4KXtcblxuICAgICAgICAgICAgICAgIGRlYnVnLmtleS50cmFjZSgnI2JlZm9yZURlbGV0ZScpO1xuXG4gICAgICAgICAgICAgICAgaW5kZXgucmVtb3ZlKHR1cGxlLCB0dXBsZUluZGV4KTtcblxuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZW4gYWRkIHRoZSB0dXBsZSBmcm9tIGluZGV4IGJlZm9yZSB0aGUgdHVwbGUgdXBkYXRlXG5cbiAgICAgICAgICAgIHJlbGF0aW9uLmVlLm9uKCdiZWZvcmVVcGRhdGUnLCBmdW5jdGlvbih0dXBsZSwgYXR0cmlidXRlTmFtZSl7XG5cbiAgICAgICAgICAgICAgICBkZWJ1Zy5rZXkudHJhY2UoJyNiZWZvcmVVcGRhdGUnKTtcblxuICAgICAgICAgICAgICAgIGlmKGhlYWRlci5nZXQoYXR0cmlidXRlTmFtZSkgIT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHVwbGVJbmRleCA9IGluZGV4LmdldEluZGV4KHR1cGxlKTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgucmVtb3ZlKHR1cGxlLCB0dXBsZUluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZWxhdGlvbi5lZS5vbignYWZ0ZXJVcGRhdGUnLCBmdW5jdGlvbih0dXBsZSwgYXR0cmlidXRlTmFtZSl7XG5cbiAgICAgICAgICAgICAgICBkZWJ1Zy5rZXkudHJhY2UoJyNhZnRlclVwZGF0ZScpO1xuXG4gICAgICAgICAgICAgICAgaWYoaGVhZGVyLmdldChhdHRyaWJ1dGVOYW1lKSAhPT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0dXBsZUluZGV4ID0gaW5kZXguZ2V0SW5kZXgodHVwbGUpO1xuICAgICAgICAgICAgICAgICAgICBpbmRleC5hZGQodHVwbGUsIHR1cGxlSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5OyIsInZhciBIZWFkZXIgPSByZXF1aXJlKCcuL0hlYWRlci5qcycpO1xudmFyIFR1cGxlID0gcmVxdWlyZSgnLi9UdXBsZS5qcycpO1xudmFyIFR5cGUgPSByZXF1aXJlKCcuL1R5cGUuanMnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgU2V0ID0gcmVxdWlyZSgnLi9TZXQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4vaGVscGVycy9kZWJ1ZycpO1xudmFyIGNvZXJjZSA9IHJlcXVpcmUoJy4vaGVscGVycy9jb2VyY2UnKTtcbnZhciBLZXkgPSByZXF1aXJlKCcuL0tleScpO1xudmFyIEZvcmVpZ25LZXkgPSByZXF1aXJlKCcuL0ZvcmVpZ25LZXknKTtcblxudmFyIFJlbGF0aW9uID0gU2V0LmV4dGVuZChcbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBjbGFzcyBSZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0hlYWRlcnxPYmplY3RbXXxBdHRyaWJ1dGVbXX0gaGVhZGVyIEhlYWRlciBvZiB0aGUgUmVsYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtUdXBsZVtdfE9iamVjdFtdfSBib2R5IEJvZHkgb2YgdGhlIFJlbGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25zdHJhaW50cyBDb25zdHJhaW50cyBmb3IgdGhlIHJlbGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGNvbnN0cmFpbnRzLnBrIEZpZWxkcyB0aGF0IHdpbGwgY29uc3RpdHV0ZSBwcmltYXJ5IGtleVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdW119IGNvbnN0cmFpbnRzLnVuaXF1ZSBVbmlxdWUgZmllbGQgZGVmaW5pdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBjb25zdHJhaW50cy5mayBGb3JlaWduIGtleSBkZWZpbml0aW9uc1xuICAgICAgICAgKiBAZXh0ZW5kcyBTZXRcbiAgICAgICAgICpcbiAgICAgICAgICogUmVsYXRpb24gY29uc3RydWN0b3JcbiAgICAgICAgICpcbiAgICAgICAgICogQSBSZWxhdGlvbiBpcyBiYXNpY2FsbHkgYSB7QGxpbmsgU2V0fSwgaW1wbGVtZW50aW5nIHRoZSBiYXNpYyBzZXQgb3BlcmF0b3JzIChVbmlvbiwgRGlmZmVyZW5jZSwgSW50ZXJzZWN0aW9uLCBQcm9kdWN0KVxuICAgICAgICAgKiBhbmQgYWRkaW5nIG1vcmUgb3BlcmF0b3JzLiBJdCBhbHNvIGhhcyBhIHtAbGluayBIZWFkZXJ9LCBhbmQgYWRkcyBjb25zdHJhaW50cyB0byB0aGUgYmFzaWMge0BsaW5rIFNldH0gYmVoYXZpb3IuXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb24gPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICB7aWQgOiB7dHlwZSA6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgICAgICAge25hbWUgOiB7dHlwZSA6IGFmZmluaXR5LlN0cmluZ319LFxuICAgICAgICAgKiAgICAgICAgICB7Ym9ybiA6IHt0eXBlIDogYWZmaW5pdHkuRGF0ZX19LFxuICAgICAgICAgKiAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgIFsxLCAnSm9obiBEb2UnLCBuZXcgRGF0ZSgxOTM0LCAxMCwgMjApXSxcbiAgICAgICAgICogICAgICAgICAgWzIsICdKb2huIFdpbHNvbicsIG5ldyBEYXRlKDE5MjIsIDcsIDUpXSxcbiAgICAgICAgICogICAgIF0pO1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIChoZWFkZXIsIGJvZHksIGNvbnN0cmFpbnRzKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnJlbGF0aW9uLnRyYWNlKCcjY29uc3RydWN0b3InKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge3twazogU3RyaW5nLCB1bmlxdWU6IFN0cmluZ1tdW10sIGZrOiBPYmplY3RbXX19IF9jb25zdHJhaW50QXJndW1lbnRzXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9jb25zdHJhaW50QXJndW1lbnRzID0gY29uc3RyYWludHM7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtLZXl9IF9wayBUaGUgUHJpbWFyeSBLZXkgZm9yIHRoZSBSZWxhdGlvblxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fcGsgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtTZXR9IF91a3MgVGhlIFByaW1hcnkgS2V5cyBmb3IgdGhlIFJlbGF0aW9uXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl91a3MgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtTZXR9IF9ma3MgVGhlIEZvcmVpZ24gS2V5cyBmb3IgdGhlIFJlbGF0aW9uXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9ma3MgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtIZWFkZXJ9IF9oZWFkZXIgVGhlIHJlbGF0aW9uIGhlYWRlclxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5oZWFkZXIoSGVhZGVyLmNvZXJjZShoZWFkZXIpKTtcblxuICAgICAgICAgICAgU2V0LmNhbGwodGhpcywge3R5cGU6IFR1cGxlLCBlbGVtZW50czogYm9keX0pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYmluZEV2ZW50czogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5yZWxhdGlvbi50cmFjZSgnI2JpbmRFdmVudHMnKTtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGlzLmVlLm9uKCdiZWZvcmVHZXRFbGVtZW50cycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmVlLmVtaXQoJ2JlZm9yZUdldEJvZHknKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmVlLm9uKCdiZWZvcmVBZGQnLCBmdW5jdGlvbiAodHVwbGUpIHtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCBkZWZhdWx0IHZhbHVlc1xuICAgICAgICAgICAgICAgIHRoYXQuaGVhZGVyKCkuZWFjaChmdW5jdGlvbihhdHRyaWJ1dGUpe1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0dXBsZUF0dHJpYnV0ZVZhbHVlID0gdHVwbGUuZ2V0KGF0dHJpYnV0ZS5uYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICBpZih0dXBsZUF0dHJpYnV0ZVZhbHVlID09PSBudWxsIHx8IHR1cGxlQXR0cmlidXRlVmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0dXBsZUF0dHJpYnV0ZVZhbHVlID09PSAnJyl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHR1cGxlLnNldChhdHRyaWJ1dGUubmFtZSwgYXR0cmlidXRlLmRlZmF1bHQoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBDb2VyY2UgdHVwbGUgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIHRoYXQuaGVhZGVyKCkuZWFjaChmdW5jdGlvbihhdHRyaWJ1dGUpe1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVWYWx1ZSwgYXR0cmlidXRlVHlwZTtcblxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9IHR1cGxlLmdldChhdHRyaWJ1dGUubmFtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlVHlwZSA9IGF0dHJpYnV0ZS50eXBlO1xuXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZVZhbHVlID0gY29lcmNlKGF0dHJpYnV0ZVR5cGUsIGF0dHJpYnV0ZVZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICB0dXBsZS5zZXQoYXR0cmlidXRlLm5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgdHVwbGUgaXMgdW5pb24tY29tcGF0aWJsZSB3aXRoIHRoZSByZWxhdGlvblxuICAgICAgICAgICAgICAgIGlmICghdGhhdC5pc0NvbXBhdGlibGUodHVwbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHVwbGUgaXMgbm90IHVuaW9uIGNvbXBhdGlibGUnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0dXBsZS5yZWxhdGlvbiA9IHRoYXQ7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmVlLm9uY2UoJ2JlZm9yZUdldEVsZW1lbnRzJywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnRBcmd1bWVudHMgPSB0aGF0Ll9jb25zdHJhaW50QXJndW1lbnRzO1xuXG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgY29uc3RyYWludCBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICBpZiAoY29uc3RyYWludEFyZ3VtZW50cykge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHByaW1hcnkga2V5IGFyZ3VtZW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25zdHJhaW50QXJndW1lbnRzLnBrKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQucGsoY29uc3RyYWludEFyZ3VtZW50cy5wayk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHVuaXF1ZSBrZXkgYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25zdHJhaW50QXJndW1lbnRzLnVuaXF1ZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2goY29uc3RyYWludEFyZ3VtZW50cy51bmlxdWUsIGZ1bmN0aW9uICh1bmlxdWUpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQudWtzKCkuYWRkKG5ldyBLZXkodGhhdCwgdW5pcXVlKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoYXQpO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSBmb3JlaWduIGtleSBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnRBcmd1bWVudHMuZmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaChjb25zdHJhaW50QXJndW1lbnRzLmZrLCBmdW5jdGlvbiAoZmtBcmdzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBma0FyZ3MucmVsYXRpb24gPSB0aGF0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZrID0gbmV3IEZvcmVpZ25LZXkoZmtBcmdzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuZmtzKCkuYWRkKG5ldyBGb3JlaWduS2V5KGZrQXJncykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG5cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMudWtzKCkuZWUub24oJ2JlZm9yZUFkZCcsIGZ1bmN0aW9uKGNvbnN0cmFpbnQpe1xuXG4gICAgICAgICAgICAgICAgLy8gSW5zdXJlIGNvcnJlc3BvbmRpbmcga2V5IHR5cGVzIGhhcyBzZXJpYWxpemUgbWV0aG9kXG4gICAgICAgICAgICAgICAgdGhhdC5fYXNzZXJ0S2V5U2VyaWFsaXplKGNvbnN0cmFpbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUga2V5cyBhcmUgdW5pcXVlXG4gICAgICAgICAgICAgICAgdGhhdC5fYXNzZXJ0S2V5c1VuaXF1ZShjb25zdHJhaW50KTtcblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIGtleXMgYXJlIGlycmVkdWNpYmxlXG4gICAgICAgICAgICAgICAgdGhhdC5fYXNzZXJ0S2V5c0lycmVkdWNpYmxlKGNvbnN0cmFpbnQpO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5lZS5vbignYWZ0ZXJBZGQnLCBmdW5jdGlvbih0dXBsZSwgaW5kZXgpe1xuICAgICAgICAgICAgICAgIHR1cGxlLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgdHVwbGUucmVsYXRpb24gPSB0aGF0O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBfYXNzZXJ0S2V5U2VyaWFsaXplIDogZnVuY3Rpb24obmV3S2V5KXtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCBpZiB0aGUgY29uc3RyYWludCBhcHBsaWVzIG9uIGFuIG9iamVjdCwgdGhhdFxuICAgICAgICAgICAgLy8gaXRzIHR5cGUgaGFzIHRoZSBzZXJpYWxpemUgbWV0aG9kXG5cbiAgICAgICAgICAgIG5ld0tleS5oZWFkZXIuZWFjaChcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhdHRyaWJ1dGUudHlwZS5wcmltaXRpdmUgJiYgIV8uaXNGdW5jdGlvbihhdHRyaWJ1dGUudHlwZS5zZXJpYWxpemUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Nhbm5vdCBpbmRleCBhdHRyaWJ1dGUgXCInICsgYXR0cmlidXRlLm5hbWUgKyAnXCIuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdJdHMgdHlwZSBcIicgKyBhdHRyaWJ1dGUudHlwZS50eXBlICsgJ1wiIG11c3QnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaGF2ZSBhIFwic2VyaWFsaXplXCIgbWV0aG9kIGZvciBpdCB0byBiZSBpbmRleGFibGUuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIF9hc3NlcnRLZXlzVW5pcXVlIDogZnVuY3Rpb24obmV3S2V5KXtcblxuICAgICAgICAgICAgdmFyIGV4aXN0aW5nS2V5cyA9IHRoaXMudWtzKCk7XG5cbiAgICAgICAgICAgIGV4aXN0aW5nS2V5cy5lYWNoKGZ1bmN0aW9uKGtleSl7XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5LmhlYWRlci5lcXVhbChuZXdLZXkuaGVhZGVyKSl7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29uc3RyYWludHMgbXVzdCBiZSB1bmlxdWUnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgX2Fzc2VydEtleXNJcnJlZHVjaWJsZSA6IGZ1bmN0aW9uKG5ld0tleSl7XG5cbiAgICAgICAgICAgIHZhciBleGlzdGluZ0tleXMgPSB0aGlzLnVrcygpO1xuXG4gICAgICAgICAgICBleGlzdGluZ0tleXMuZWFjaChmdW5jdGlvbihrZXkpe1xuXG4gICAgICAgICAgICAgICAgaWYgKG5ld0tleS5oZWFkZXIuc2V0SW50ZXJzZWN0aW9uKGtleS5oZWFkZXIpLmxlbmd0aCgpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29uc3RyYWludCBtdXN0IGJlIGlycmVkdWNpYmxlJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxldGUgb3IgYWRkIHR1cGxlcyB0byBtYXRjaCBhIGdpdmVuIHJlbGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBhZGp1c3RUbzogZnVuY3Rpb24ocmVsYXRpb24pe1xuXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGUoKTtcblxuICAgICAgICAgICAgcmVsYXRpb24uY29tcHV0ZSgpO1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIDEuIERlbGV0ZSB0dXBsZXMgdGhhdCBkbyBub3QgZXhpc3QgaW4gdGhlIGdpdmVuIHJlbGF0aW9uXG5cbiAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIHR1cGxlXG4gICAgICAgICAgICB0aGF0LmVhY2goZnVuY3Rpb24odHVwbGUsIGluZGV4KXtcblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSB0dXBsZSBleGlzdHMgaW4gdGhlIGdpdmVuIHJlbGF0aW9uXG4gICAgICAgICAgICAgICAgaWYgKCFyZWxhdGlvbi5leGlzdHModHVwbGUpKXtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5yZW1vdmVBdChpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gMi4gQWRkIHR1cGxlcyB0aGF0IGRvIG5vdCBleGlzdCBpbiB0aGUgcmVsYXRpb25cblxuICAgICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGVhY2ggdHVwbGUgb2YgdGhlIGdpdmVuIHJlbGF0aW9uXG4gICAgICAgICAgICByZWxhdGlvbi5lYWNoKGZ1bmN0aW9uKHR1cGxlKXtcblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSB0dXBsZSBpcyBwcmVzZW50IGluIHRoaXMgcmVsYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoIXRoYXQuZXhpc3RzKHR1cGxlKSl7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhhdC5hZGQodHVwbGUuY2xvbmUoKSk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgX2luZGV4OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuXG4gICAgICAgICAgICAvLyBMb29rIGZvciB0aGUgdHVwbGUgaW4gdGhlIFBLIGlmIGl0IGV4aXN0c1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fcGspIHtcblxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX3BrLmluZGV4LmdldEluZGV4KGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG5cbiAgICAgICAgICAgIHRoaXMudWtzKCkuYW55KGZ1bmN0aW9uICh1bmlxdWVDb25zdHJhaW50KSB7XG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSB1bmlxdWVDb25zdHJhaW50LmluZGV4LmdldEluZGV4KGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdmb3VuZCBieSB1aycpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHNwZWNpZmllZCBhdHRyaWJ1dGUgb2JqZWN0IGJ5IG5hbWVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZSBBdHRyaWJ1dGUgbmFtZVxuICAgICAgICAgKiBAcmV0dXJucyB7QXR0cmlidXRlfG51bGx9IFRoZSBhdHRyaWJ1dGUgb3IgbnVsbCBpZiBub3QgZm91bmRcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBmbiA9IG5ldyBhZmZpbml0eS5BdHRyaWJ1dGUoe25hbWUgOiAnZmlyc3ROYW1lJywgdHlwZSA6IGFmZmluaXR5LlN0cmluZ30pXG4gICAgICAgICAqICAgICB2YXIgbG4gPSBuZXcgYWZmaW5pdHkuQXR0cmlidXRlKHtuYW1lIDogJ2xhc3ROYW1lJywgdHlwZSA6IGFmZmluaXR5LlN0cmluZ30pXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb24gPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAgZm4sXG4gICAgICAgICAqICAgICAgICAgICAgICBsblxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsnSm9obicsJ0RvZSddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydIZWxsbycsJ1dvcmxkJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ1N1cGVyJywnRHVwZXInXSxcbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICByZWxhdGlvbi5nZXQoJ2ZpcnN0TmFtZScpID09PSBmbiAvLyB0cnVlXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcblxuICAgICAgICAgICAgZGVidWcucmVsYXRpb24udHJhY2UoJyNnZXQnKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyKCkuZ2V0KGF0dHJpYnV0ZSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSB0dXBsZSBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdHVwbGVcbiAgICAgICAgICogQHJldHVybnMgeyp8bnVsbH1cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7ICdmaXJzdE5hbWUnIDoge3R5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICAgICAgeyAnTGFzdE5hbWUnICA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ0pvaG4nLCdEb2UnXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsnSGVsbG8nLCdXb3JsZCddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydTdXBlcicsJ0R1cGVyJ10sXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgcmVsYXRpb24uZWFjaChmdW5jdGlvbih0dXBsZSwgaW5kZXgpe1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgICBjb25zb2xlLmxvZyhyZWxhdGlvbi5hdEluZGV4KGluZGV4KSA9PT0gdHVwbGUpIC8vIHRydWVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIH0pXG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKHJlbGF0aW9uLmF0SW5kZXgoMCkuZ2V0KCdmaXJzdE5hbWUnKSkgLy8gSm9oblxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYXRJbmRleDogZnVuY3Rpb24gKGluZGV4KSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnJlbGF0aW9uLnRyYWNlKCcjYXRJbmRleCcpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50cygpW2luZGV4XTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge1NldH0gW3R1cGxlc10gVGhlIG5ldyBzZXQgb2YgYm9keVxuICAgICAgICAgKiBAcmV0dXJucyB7U2V0fFJlbGF0aW9ufSBUaGUgYm9keS9udWxsIGlmIGdldHRlciwgdGhpcyBpZiBzZXR0ZXJcbiAgICAgICAgICpcbiAgICAgICAgICogR2V0dGVyL1NldHRlciBmb3IgdGhlIGJvZHkgcHJvcGVydHlcbiAgICAgICAgICpcbiAgICAgICAgICogWW91IHdpbGwgbW9yZSBsaWtlbHkgYWx3YXlzIHVzZSB0aGUgZ2V0dGVyIChSZWxhdGlvbi5ib2R5KCkpIHRoYW4gdGhlIHNldHRlclxuICAgICAgICAgKiAoUmVsYXRpb24uYm9keShib2R5KSkgcGFydCBmb3IgdGhpcyBtZXRob2QuXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb24gPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAgeyAnZmlyc3ROYW1lJyA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgICAgIHsgJ0xhc3ROYW1lJyAgOiB7dHlwZSA6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHNldCA9IG5ldyBhZmZpbml0eS5TZXQoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHNldC5hZGQobmV3IGFmZmluaXR5LlR1cGxlKHtmaXJzdE5hbWUgOiAnSm9obicsIGxhc3ROYW1lIDogJ0RvZSd9KSlcbiAgICAgICAgICogICAgIHNldC5hZGQobmV3IGFmZmluaXR5LlR1cGxlKHtmaXJzdE5hbWUgOiAnSGVsbG8nLCBsYXN0TmFtZSA6ICdXb3JsZCd9KSlcbiAgICAgICAgICogICAgIHNldC5hZGQobmV3IGFmZmluaXR5LlR1cGxlKHtmaXJzdE5hbWUgOiAnSm9obicsIGxhc3ROYW1lIDogJ0NhZ2UnfSkpXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICByZWxhdGlvbi5ib2R5KHNldCk7IC8vIFNldHMgdGhlIHJlbGF0aW9uJ3MgYm9keVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgcmVsYXRpb24uYm9keSgpIC8vIEdldHMgdGhlIHJlbGF0aW9uJ3MgYm9keVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgY29uc29sZS5sb2cocmVsYXRpb24uYm9keSgpID09PSBzZXQpIC8vIHRydWVcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGJvZHk6IGZ1bmN0aW9uICh0dXBsZXMpIHtcblxuICAgICAgICAgICAgZGVidWcucmVsYXRpb24udHJhY2UoJyNib2R5Jyk7XG5cbiAgICAgICAgICAgIGlmICh0dXBsZXMpIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHModHVwbGVzKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmVlLmVtaXQoJ2JlZm9yZUdldEJvZHknKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtSZWxhdGlvbn0gUmV0dXJucyB0aGlzIGZvciBjaGFpbmluZ1xuICAgICAgICAgKlxuICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSByZWxhdGlvbi4gQmVjYXVzZSB0aGUgcmVsYXRpb25zIGFyZSBvbmx5IGNhbGN1bGF0ZWQgd2hlbiB0aGVpciBoZWFkZXIgb3IgdGhlaXIgYm9keVxuICAgICAgICAgKiBhcmUgcmVxdWVzdGVkLCB5b3UgbXVzdCBleHBsaWNpdGx5IGNhbGwgY29tcHV0ZSgpIGlmIHlvdSB3YW50IHRvIGNhbGN1bGF0ZSBhIHJlbGF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBZb3Ugc2hvdWxkIG5vdCBuZWVkIHRvIHVzZSB0aGlzIGZ1bmN0aW9uLiBDYWxsaW5nIGJvZHkoKSBvciBoZWFkZXIoKSBjYWxjdWxhdGVzIHRoZSByZWxhdGlvblxuICAgICAgICAgKiBhdXRvbWF0aWNhbGx5XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcHJvZHVjdCA9IHJlbGF0aW9uMS5wcm9kdWN0KHJlbGF0aW9uMik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBBdCB0aGlzIHBvaW50LCBub3RoaW5nIGhhcyBiZWVuIGNhbGN1bGF0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBwcm9kdWN0LmhlYWRlcigpIC8vIEJlY2F1c2Ugd2UgcmVxdWVzdGVkIHRoZSBoZWFkZXIsIGl0IGlzIGNhbGN1bGF0ZWRcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHByb2R1Y3QuYm9keSgpIC8vIEJlY2F1c2Ugd2UgcmVxdWVzdGVkIHRoZSBib2R5LCBpdCBpcyBjYWxjdWxhdGVkXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcHJvZHVjdDIgPSByZWxhdGlvbjEucHJvZHVjdChyZWxhdGlvbjIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgcHJvZHVjdDIuY29tcHV0ZSgpOyAvLyBDYWxjdWxhdGVzIHRoZSBoZWFkZXIgYW5kIHRoZSBib2R5O1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29tcHV0ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5yZWxhdGlvbi50cmFjZSgnI2NvbXB1dGUnKTtcblxuICAgICAgICAgICAgdGhpcy5oZWFkZXIoKTtcbiAgICAgICAgICAgIHRoaXMuYm9keSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0hlYWRlcn0gW2hlYWRlcl1cbiAgICAgICAgICogQHJldHVybnMge251bGx8e0hlYWRlcn19XG4gICAgICAgICAqXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgcmVsYXRpb24ncyBoZWFkZXJcbiAgICAgICAgICovXG4gICAgICAgIGhlYWRlcjogZnVuY3Rpb24gKGhlYWRlcikge1xuXG4gICAgICAgICAgICBpZiAoaGVhZGVyKSB7XG5cbiAgICAgICAgICAgICAgICBkZWJ1Zy5yZWxhdGlvbi50cmFjZSgnI2hlYWRlciAoc2V0KScpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5faGVhZGVyID0gaGVhZGVyO1xuXG4gICAgICAgICAgICAgICAgaGVhZGVyLnJlbGF0aW9uID0gdGhpcztcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGRlYnVnLnJlbGF0aW9uLnRyYWNlKCcjaGVhZGVyIChnZXQpJyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmVlLmVtaXQoJ2JlZm9yZUdldEhlYWRlcicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlcjtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgLyBTZXRzIHRoZSByZWxhdGlvbidzIHByaW1hcnkga2V5XG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcHJpbWFyeUtleU5hbWVdXG4gICAgICAgICAqL1xuICAgICAgICBwayA6IGZ1bmN0aW9uKHByaW1hcnlLZXlOYW1lKXtcblxuICAgICAgICAgICAgaWYgKHByaW1hcnlLZXlOYW1lKXtcblxuICAgICAgICAgICAgICAgIGlmKHRoaXMuX3BrICE9PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVrcygpLnJlbW92ZSh0aGlzLl9wayk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fcGsgPSBuZXcgS2V5KHRoaXMsIHByaW1hcnlLZXlOYW1lKTtcblxuICAgICAgICAgICAgICAgIHRoaXMudWtzKCkuYWRkKHRoaXMuX3BrKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9waztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGZvcmVpZ24ga2V5cyBzZXRcbiAgICAgICAgICogQHJldHVybnMge1NldH1cbiAgICAgICAgICovXG4gICAgICAgIGZrcyA6IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9ma3MgPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmtzID0gbmV3IFNldCh7IHR5cGUgOiBGb3JlaWduS2V5fSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ma3M7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHVuaXF1ZSBrZXlzIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7U2V0fVxuICAgICAgICAgKi9cbiAgICAgICAgdWtzIDogZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3VrcyA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgICAgICB0aGlzLl91a3MgPSBuZXcgU2V0KHsgdHlwZSA6IEtleX0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdWtzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge1R1cGxlfE9iamVjdH0gdHVwbGVcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqXG4gICAgICAgICAqIENoZWNrIGlmIGEgdHVwbGUgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSByZWxhdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgaXNDb21wYXRpYmxlOiBmdW5jdGlvbiAodHVwbGUpIHtcblxuICAgICAgICAgICAgZGVidWcucmVsYXRpb24udHJhY2UoJyNpc0NvbXBhdGlibGUnKTtcblxuICAgICAgICAgICAgdHVwbGUgPSBUdXBsZS5jb2VyY2UodHVwbGUpO1xuXG4gICAgICAgICAgICB2YXIgdHVwbGVLZXlzID0gT2JqZWN0LmtleXModHVwbGUuYXR0cmlidXRlcyk7XG4gICAgICAgICAgICB2YXIgdHVwbGVLZXlDb3VudCA9IHR1cGxlS2V5cy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaGVhZGVyS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuaGVhZGVyKCkuX2F0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgdmFyIGhlYWRlcktleUNvdW50ID0gaGVhZGVyS2V5cy5sZW5ndGg7XG5cblxuICAgICAgICAgICAgLy8vIENoZWNrIGlmIHRoZSBnaXZlbiB0dXBsZSBoYXMgdGhlIHNhbWUgaGVhZGVyIGFzIHRoZSByZWxhdGlvblxuXG4gICAgICAgICAgICAvLyBIZWFkZXIgYW5kIFR1cGxlIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgYXR0cmlidXRlc1xuICAgICAgICAgICAgaWYgKHR1cGxlS2V5Q291bnQgIT09IGhlYWRlcktleUNvdW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIZWFkZXIgYW5kIFR1cGxlIG11c3QgaGF2ZSB0aGUgc2FtZSBhdHRyaWJ1dGUgbmFtZXNcbiAgICAgICAgICAgIHJldHVybiAhXy5zb21lKGhlYWRlcktleXMsIGZ1bmN0aW9uIChoZWFkZXJBdHRyaWJ1dGUpIHtcblxuICAgICAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIGF0dHJpYnV0ZXMgb2YgdGhlIHR1cGxlXG4gICAgICAgICAgICAgICAgcmV0dXJuICFfLnNvbWUodHVwbGVLZXlzLCBmdW5jdGlvbiAodHVwbGVBdHRyaWJ1dGUpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGb3VuZCBhIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodHVwbGVBdHRyaWJ1dGUgPT09IGhlYWRlckF0dHJpYnV0ZSAmJiAodHVwbGUuZ2V0KHR1cGxlQXR0cmlidXRlKSAhPT0gdW5kZWZpbmVkKSAmJiAodHVwbGUuZ2V0KHR1cGxlQXR0cmlidXRlKSAhPT0gbnVsbCkpO1xuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uIFRoZSByZWxhdGlvbiB0byBjb21wYXJlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBJZiB0aGUgcmVsYXRpb25zIGFyZSBlcXVhbCBvciBub3RcbiAgICAgICAgICpcbiAgICAgICAgICogVGVzdHMgaWYgdGhlIHJlbGF0aW9uIGlzIGVxdWFsIHRvIGFub3RoZXIgb25lXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbDogZnVuY3Rpb24gKHJlbGF0aW9uKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnJlbGF0aW9uLnRyYWNlKCcjZXF1YWwnKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuZXF1YWwodGhpcywgcmVsYXRpb24pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbG9uZXMgYSByZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt3aXRoVHVwbGVzPXRydWVdIENvcGllcyB0aGUgdHVwbGVzXG4gICAgICAgICAqIEByZXR1cm5zIHtSZWxhdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIGNsb25lIDogZnVuY3Rpb24od2l0aFR1cGxlcyl7XG5cbiAgICAgICAgICAgIHdpdGhUdXBsZXMgPSAhISh3aXRoVHVwbGVzID09PSB1bmRlZmluZWQgfHwgd2l0aFR1cGxlcyA9PT0gbnVsbCk7XG5cbiAgICAgICAgICAgIHZhciBuZXdIZWFkZXIgPSB0aGlzLmhlYWRlcigpLmNsb25lKCk7XG5cbiAgICAgICAgICAgIHZhciBuZXdSZWxhdGlvbiA9IG5ldyBSZWxhdGlvbihuZXdIZWFkZXIpO1xuXG4gICAgICAgICAgICAvLyBDbG9uZSB0aGUgcGtcblxuICAgICAgICAgICAgLy90b2RvIFBLIENsb25lXG5cbiAgICAgICAgICAgIC8vIENsb25lIHRoZSB1a3NcblxuICAgICAgICAgICAgLy90b2RvIFVLUyBjbG9uZVxuXG4gICAgICAgICAgICAvLyBDbG9uZSB0aGUgZmtzXG5cbiAgICAgICAgICAgIC8vdG9kbyBGS1MgY2xvbmVcblxuICAgICAgICAgICAgaWYgKHdpdGhUdXBsZXMpe1xuICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbih0dXBsZSl7XG4gICAgICAgICAgICAgICAgICAgIG5ld1JlbGF0aW9uLmFkZCh0dXBsZS5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ld1JlbGF0aW9uO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByaW50cyB0aGUgcHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBSZWxhdGlvbiB0byBjb25zb2xlXG4gICAgICAgICAqL1xuICAgICAgICBwcmludDogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5yZWxhdGlvbi50cmFjZSgnI3ByaW50Jyk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcmVsYXRpb25cbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHN0cmluZyBwcmludCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcmVsYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHZhciBoc3BhY2luZyA9IDEsXG4gICAgICAgICAgICAgICAgdnNwYWNpbmcgPSAxLFxuICAgICAgICAgICAgICAgIGFyciA9IHRoaXMuYXJyID0gW10sXG4gICAgICAgICAgICAgICAgaGVhZGVyUm93ID0gW10sXG4gICAgICAgICAgICAgICAgbWF4V2lkdGhzID0gW10sXG4gICAgICAgICAgICAgICAgbWF4SGVpZ2h0cyA9IFtdO1xuXG4gICAgICAgICAgICBkZWJ1Zy5yZWxhdGlvbi50cmFjZSgnI2dldFByaW50U3RyaW5nJyk7XG5cbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZSgpO1xuXG4gICAgICAgICAgICB0aGlzLmhlYWRlcigpLmVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuXG4gICAgICAgICAgICAgICAgaGVhZGVyUm93LnB1c2goeyB3aWR0aDogbnVsbCwgaGVpZ2h0OiBudWxsLCBsaW5lczogbnVsbCwgYXR0cmlidXRlOiBhdHRyaWJ1dGUsIHN0cmluZzogYXR0cmlidXRlLnRvU3RyaW5nKCl9KVxuXG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgLy8gWyB7d2lkdGgsIGhlaWdodCwgbGluZXMsIHN0cmluZ30se3dpZHRoLCBoZWlnaHQsIGxpbmVzLCBzdHJpbmd9LC4uLiBdIF1cblxuICAgICAgICAgICAgYXJyLnB1c2goaGVhZGVyUm93KTtcblxuICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICh0dXBsZSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHR1cGxlUm93ID0gW107XG5cbiAgICAgICAgICAgICAgICBfLmZvckVhY2goaGVhZGVyUm93LCBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0dXBsZVJvdy5wdXNoKHsgd2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCwgbGluZXM6IG51bGwsIHN0cmluZzogdHVwbGUuZ2V0KGF0dHIuYXR0cmlidXRlLm5hbWUpLnRvU3RyaW5nKCl9KVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgYXJyLnB1c2godHVwbGVSb3cpO1xuXG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gZmluZEhlaWdodChzdHJpbmcpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmcuc3BsaXQoXCJcXG5cIikubGVuZ3RoO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRXaWR0aChzdHJpbmcpIHtcblxuICAgICAgICAgICAgICAgIHZhciBsaW5lcyA9IHN0cmluZy5zcGxpdCgnXFxuJyksXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IDA7XG5cbiAgICAgICAgICAgICAgICBfLmZvckVhY2gobGluZXMsIGZ1bmN0aW9uIChsaW5lKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVMZW5ndGggPSBsaW5lLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobGluZUxlbmd0aCA+IG1heClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IGxpbmVMZW5ndGg7XG5cbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBtYXg7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZmluZE1heFdpZHRoKGFycikge1xuXG4gICAgICAgICAgICAgICAgdmFyIG1heCA9IDA7XG5cbiAgICAgICAgICAgICAgICBfLmZvckVhY2goYXJyLCBmdW5jdGlvbiAob2JqKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IG9iai53aWR0aDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobGluZVdpZHRoID4gbWF4KVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gbGluZVdpZHRoO1xuXG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBmaW5kTWF4SGVpZ2h0KGFycikge1xuXG4gICAgICAgICAgICAgICAgdmFyIG1heCA9IDA7XG5cbiAgICAgICAgICAgICAgICBfLmZvckVhY2goYXJyLCBmdW5jdGlvbiAob2JqKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSBvYmouaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lSGVpZ2h0ID4gbWF4KVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gbGluZUhlaWdodDtcblxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1heDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZUxpbmVzKHN0cmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmcuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFtcbiAgICAgICAgICAgIC8vICAgW3t3aWR0aCwgaGVpZ2h0LCBsaW5lcywgc3RyaW5nfSx7d2lkdGgsIGhlaWdodCwgbGluZXMsIHN0cmluZ30sLi4uIF0sXG4gICAgICAgICAgICAvLyAgIFt7d2lkdGgsIGhlaWdodCwgbGluZXMsIHN0cmluZ30se3dpZHRoLCBoZWlnaHQsIGxpbmVzLCBzdHJpbmd9LC4uLiBdLFxuICAgICAgICAgICAgLy8gICBbe3dpZHRoLCBoZWlnaHQsIGxpbmVzLCBzdHJpbmd9LHt3aWR0aCwgaGVpZ2h0LCBsaW5lcywgc3RyaW5nfSwuLi4gXSxcbiAgICAgICAgICAgIC8vICAgLi4uXG4gICAgICAgICAgICAvLyBdXG5cblxuICAgICAgICAgICAgXy5mb3JFYWNoKGFyciwgZnVuY3Rpb24gKHJvdywgcm93SW5kZXgpIHtcblxuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChyb3csIGZ1bmN0aW9uIChjb2wsIGNvbEluZGV4KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29sLndpZHRoID0gZmluZFdpZHRoKGNvbC5zdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICBjb2wuaGVpZ2h0ID0gZmluZEhlaWdodChjb2wuc3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgY29sLmxpbmVzID0gcGFyc2VMaW5lcyhjb2wuc3RyaW5nKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1heFdpZHRoc1tjb2xJbmRleF0gfHwgbWF4V2lkdGhzW2NvbEluZGV4XSA8IGNvbC53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGhzW2NvbEluZGV4XSA9IGNvbC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF4SGVpZ2h0c1tyb3dJbmRleF0gfHwgbWF4SGVpZ2h0c1tyb3dJbmRleF0gPCBjb2wuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHRzW3Jvd0luZGV4XSA9IGNvbC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICdcXG4nO1xuXG5cbiAgICAgICAgICAgIC8vIFByaW50aW5nIHRoZSB0b3AgYm9yZGVyXG5cbiAgICAgICAgICAgIHJlc3VsdCArPSAnKyc7XG5cbiAgICAgICAgICAgIF8uZm9yRWFjaChtYXhXaWR0aHMsIGZ1bmN0aW9uIChtYXhXaWR0aCwgaW5kZXgpIHtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgbWF4V2lkdGhzW2luZGV4XSArIGhzcGFjaW5nICogMiArIDI7IGErKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJy0nXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcrJ1xuXG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuXG4gICAgICAgICAgICAvLyBQcmludGluZyB0aGUgYXR0cmlidXRlc1xuXG4gICAgICAgICAgICBfLmZvckVhY2goYXJyLCBmdW5jdGlvbiAocm93LCByb3dJbmRleCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIG1heEhlaWdodCA9IG1heEhlaWdodHNbcm93SW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCBtYXhIZWlnaHQ7IGErKykge1xuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnfCc7XG5cbiAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKHJvdywgZnVuY3Rpb24gKGNvbCwgY29sSW5kZXgpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1heFdpZHRoID0gbWF4V2lkdGhzW2NvbEluZGV4XTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBjb2wubGluZXNbYV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGluZSkgbGluZSA9ICcnO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhzcGFjaW5nOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGluZUxlbmd0aCA9IGxpbmUubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gbGluZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBoc3BhY2luZzsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcgJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBtYXhXaWR0aCAtIGxpbmVMZW5ndGggKyAyICogaHNwYWNpbmc7IGIrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnICc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnfCc7XG5cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcrJztcblxuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChtYXhXaWR0aHMsIGZ1bmN0aW9uIChtYXhXaWR0aCwgaW5kZXgpIHtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IG1heFdpZHRoc1tpbmRleF0gKyBoc3BhY2luZyAqIDIgKyAyOyBhKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3dJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnPSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICctJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJysnXG5cbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcblxuXG4gICAgICAgICAgICAgICAgaWYgKHJvd0luZGV4ICE9IGFyci5sZW5ndGggLSAxKSByZXN1bHQgKz0gJ1xcbic7XG5cblxuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHR1cGxlcyBpbiB0aGUgcmVsYXRpb25cbiAgICAgICAgICogQHBhcmFtIHByZWRpY2F0ZVxuICAgICAgICAgKiBAcGFyYW0gdmFsdWVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHJlbGF0aW9uLnVwZGF0ZShhZ2UuZ3QoMjApLCB7IGFnZSA6IGFnZS5vbGQoKS5wbHVzKDEwKSwgbmFtZSA6IG5hbWUub2xkKCkuc3Vic3RyKDAsMSkgfSk7XG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGUgOiBmdW5jdGlvbihwcmVkaWNhdGUsIHZhbHVlcyl7XG5cbiAgICAgICAgICAgIHByZWRpY2F0ZS5jb252ZXJ0QXR0cmlidXRlVG9UdXBsZSgpO1xuXG4gICAgICAgICAgICBfLmZvckVhY2godmFsdWVzLCBmdW5jdGlvbih2YWx1ZSl7XG5cbiAgICAgICAgICAgICAgICBpZihfLmlzRnVuY3Rpb24odmFsdWUpKXtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuY29udmVydEF0dHJpYnV0ZVRvVHVwbGUoKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbih0dXBsZSl7XG5cbiAgICAgICAgICAgICAgICBpZihwcmVkaWNhdGUuYXNzaWduVHVwbGUodHVwbGUpLnZhbHVlKCkgPT09IHRydWUpe1xuXG4gICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaCh2YWx1ZXMsIGZ1bmN0aW9uKGV4cHJlc3Npb24sIGtleSl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IF8uaXNGdW5jdGlvbihleHByZXNzaW9uKSA/IGV4cHJlc3Npb24uYXNzaWduVHVwbGUodHVwbGUpLnZhbHVlKCkgOiBleHByZXNzaW9uO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0dXBsZS5zZXQoa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSlcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIHR1cGxlcyBmcm9tIGEgcmVsYXRpb24gYmFzZWQgb24gYSBwcmVkaWNhdGVcbiAgICAgICAgICogQHBhcmFtIHByZWRpY2F0ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlV2hlcmUgOiBmdW5jdGlvbihwcmVkaWNhdGUpe1xuXG4gICAgICAgICAgICBwcmVkaWNhdGUuY29udmVydEF0dHJpYnV0ZVRvVHVwbGUoKTtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24odHVwbGUsIGluZGV4KXtcblxuICAgICAgICAgICAgICAgIGlmKHByZWRpY2F0ZS5hc3NpZ25UdXBsZSh0dXBsZSkudmFsdWUoKSA9PT0gdHJ1ZSl7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhhdC5yZW1vdmVBdChpbmRleCk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8vcmVnaW9uIE9wZXJhdGlvbnNcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtSZWxhdGlvbn0gcmVsYXRpb24gVGhlIHJlbGF0aW9uIHRvIGNvbXB1dGUgZGlmZmVyZW5jZSBhZ2FpbnN0XG4gICAgICAgICAqIEByZXR1cm5zIHtPcGVyYXRvcnMuRGlmZmVyZW5jZX0gVGhlIHJlc3VsdGluZyByZWxhdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBTaG9ydGN1dCB0byBjcmVhdGUgYSBEaWZmZXJlbmNlIHJlbGF0aW9uIGJhc2VkIG9uIHRoaXMgcmVsYXRpb24gYW5kIHRoZSBzcGVjaWZpZWQgb25lXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb24xID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgICAgIHtmaXJzdE5hbWUgOiB7dHlwZSA6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgICAgICAgICB7bGFzdE5hbWUgOiB7dHlwZSA6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWydKb2huJywnRG9lJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ0x1Y2lubycsJ1ZlbyddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydNYXJ5JywnUG9wcGlucyddLFxuICAgICAgICAgKiAgICAgICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbjIgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge2ZpcnN0TmFtZSA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgICAgIHtsYXN0TmFtZSA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ0pvaG4nLCdEb2UnXVxuICAgICAgICAgKiAgICAgICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBkaWZmID0gcmVsYXRpb24xLmRpZmZlcmVuY2UocmVsYXRpb24yKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IGZpcnN0TmFtZSA6IFRTdHJpbmcgfCBsYXN0TmFtZSA6IFRTdHJpbmcgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgTHVjaW5vICAgICAgICAgICAgICB8IFZlbyAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBNYXJ5ICAgICAgICAgICAgICAgIHwgUG9wcGlucyAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqL1xuICAgICAgICBkaWZmZXJlbmNlOiBmdW5jdGlvbiAocmVsYXRpb24pIHtcblxuICAgICAgICAgICAgZGVidWcucmVsYXRpb24udHJhY2UoJyNkaWZmZXJlbmNlJyk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgKHJlcXVpcmUoJy4vYWxnZWJyYS9EaWZmZXJlbmNlJykpKHRoaXMsIHJlbGF0aW9uKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtSZWxhdGlvbn0gcmVsYXRpb24gVGhlIHJlbGF0aW9uIHRvIGNvbXB1dGUgaW50ZXJzZWN0aW9uIGFnYWluc3RcbiAgICAgICAgICogQHJldHVybnMge09wZXJhdG9ycy5JbnRlcnNlY3Rpb259IFRoZSByZXN1bHRpbmcgcmVsYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogU2hvcnRjdXQgdG8gY3JlYXRlIGFuIEludGVyc2VjdCByZWxhdGlvbiBiYXNlZCBvbiB0aGlzIHJlbGF0aW9uIGFuZCB0aGUgc3BlY2lmaWVkIG9uZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uMSA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7Zmlyc3ROYW1lIDoge3R5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICAgICAge2xhc3ROYW1lIDoge3R5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsnSm9obicsJ0RvZSddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydMdWNpbm8nLCdWZW8nXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsnTWFyeScsJ1BvcHBpbnMnXSxcbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb24yID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgICAgIHtmaXJzdE5hbWUgOiB7dHlwZSA6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgICAgICAgICB7bGFzdE5hbWUgOiB7dHlwZSA6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWydKb2huJywnRG9lJ11cbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgaW50ZXJzZWN0aW9uID0gcmVsYXRpb24xLmludGVyc2VjdChyZWxhdGlvbjIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgZmlyc3ROYW1lIDogVFN0cmluZyB8IGxhc3ROYW1lIDogVFN0cmluZyB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBKb2huICAgICAgICAgICAgICAgIHwgRG9lICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqL1xuICAgICAgICBpbnRlcnNlY3Q6IGZ1bmN0aW9uIChyZWxhdGlvbikge1xuXG4gICAgICAgICAgICBkZWJ1Zy5yZWxhdGlvbi50cmFjZSgnI2ludGVyc2VjdCcpO1xuXG4gICAgICAgICAgICB2YXIgSW50ZXJzZWN0aW9uID0gcmVxdWlyZSgnLi9hbGdlYnJhL0ludGVyc2VjdGlvbicpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IEludGVyc2VjdGlvbih0aGlzLCByZWxhdGlvbik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uIFRoZSByZWxhdGlvbiB0byBjb21wdXRlIHRoZSBqb2luIGFnYWluc3RcbiAgICAgICAgICogQHJldHVybnMge09wZXJhdG9ycy5Kb2lufSBUaGUgcmVzdWx0aW5nIHJlbGF0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNob3J0Y3V0IHRvIGNyZWF0ZSBhIEpvaW4gcmVsYXRpb24gYmFzZWQgb24gdGhpcyByZWxhdGlvbiBhbmQgdGhlIHNwZWNpZmllZCBvbmVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbjEgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge2ZpcnN0TmFtZSA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgICAgIHtsYXN0TmFtZSA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ0pvaG4nLCdEb2UnXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsnTHVjaW5vJywnVmVvJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ01hcnknLCdQb3BwaW5zJ10sXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uMiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7TGFzdE5hbWUgOiB7dHlwZSA6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgICAgICAgICB7VGl0bGUgICAgOiB7dHlwZSA6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWydEb2UnLCdNciddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydQb3BwaW5zJywnTGFkeSddXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGpvaW4gPSByZWxhdGlvbjEuam9pbihyZWxhdGlvbjIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgZmlyc3ROYW1lIDogVFN0cmluZyB8IGxhc3ROYW1lIDogVFN0cmluZyB8IFRpdGxlIDogVFN0cmluZyB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBKb2huICAgICAgICAgICAgICAgIHwgRG9lICAgICAgICAgICAgICAgIHwgTXIgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IE1hcnkgICAgICAgICAgICAgICAgfCBQb3BwaW5zICAgICAgICAgICAgfCBMYWR5ICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICovXG4gICAgICAgIGpvaW46IGZ1bmN0aW9uIChyZWxhdGlvbikge1xuXG4gICAgICAgICAgICBkZWJ1Zy5yZWxhdGlvbi50cmFjZSgnI2pvaW4nKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyAocmVxdWlyZSgnLi9hbGdlYnJhL0pvaW4nKSkodGhpcywgcmVsYXRpb24pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvbiBUaGUgcmVsYXRpb24gdG8gY29tcHV0ZSBwcm9kdWN0IGFnYWluc3RcbiAgICAgICAgICogQHJldHVybnMge09wZXJhdG9ycy5Qcm9kdWN0fSBUaGUgcmVzdWx0aW5nIHJlbGF0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNob3J0Y3V0IHRvIGNyZWF0ZSBhIFByb2R1Y3QgcmVsYXRpb24gYmFzZWQgb24gdGhpcyByZWxhdGlvbiBhbmQgdGhlIHNwZWNpZmllZCBvbmVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbjEgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge2ZpcnN0TmFtZSA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgICAgIHtsYXN0TmFtZSA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ0pvaG4nLCdEb2UnXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsnTHVjaW5vJywnVmVvJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ01hcnknLCdQb3BwaW5zJ10sXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uMiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7dGl0bGUgOiB7dHlwZSA6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWydMYWR5J10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ01yJ11cbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcHJvZHVjdCA9IHJlbGF0aW9uMS5wcm9kdWN0KHJlbGF0aW9uMik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBmaXJzdE5hbWUgOiBUU3RyaW5nIHwgbGFzdE5hbWUgOiBUU3RyaW5nIHwgVGl0bGUgOiBUU3RyaW5nIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IEpvaG4gICAgICAgICAgICAgICAgfCBEb2UgICAgICAgICAgICAgICAgfCBMYWR5ICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgSm9obiAgICAgICAgICAgICAgICB8IERvZSAgICAgICAgICAgICAgICB8IE1yICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBMdWNpbm8gICAgICAgICAgICAgIHwgVmVvICAgICAgICAgICAgICAgIHwgTGFkeSAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IEx1Y2lubyAgICAgICAgICAgICAgfCBWZW8gICAgICAgICAgICAgICAgfCBNciAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgTWFyeSAgICAgICAgICAgICAgICB8IFBvcHBpbnMgICAgICAgICAgICB8IExhZHkgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBNYXJ5ICAgICAgICAgICAgICAgIHwgUG9wcGlucyAgICAgICAgICAgIHwgTXIgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqL1xuICAgICAgICBwcm9kdWN0OiBmdW5jdGlvbiAocmVsYXRpb24pIHtcblxuICAgICAgICAgICAgZGVidWcucmVsYXRpb24udHJhY2UoJyNwcm9kdWN0Jyk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgKHJlcXVpcmUoJy4vYWxnZWJyYS9Qcm9kdWN0JykpKHRoaXMsIHJlbGF0aW9uKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gYXR0cmlidXRlTmFtZXMgVGhlIHJlbGF0aW9uIHRvIGNvbXB1dGUgaW50ZXJzZWN0aW9uIGFnYWluc3RcbiAgICAgICAgICogQHJldHVybnMge09wZXJhdG9ycy5Qcm9qZWN0aW9ufSBUaGUgcmVzdWx0aW5nIHJlbGF0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNob3J0Y3V0IHRvIGNyZWF0ZSBhIFByb2plY3QgcmVsYXRpb24gYmFzZWQgb24gdGhpcyByZWxhdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgYXR0cmlidXRlTmFtZXMgcGFyYW1ldGVyIG11c3QgYmUgaW4gdGhlIGZvcm1hdCA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICByZWxhdGlvbi5wcm9qZWN0KFsnYXJndW1lbnQxJywgJ2FyZ3VtZW50MiddKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbjEgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge2ZpcnN0TmFtZSA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgICAgIHtsYXN0TmFtZSA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ0pvaG4nLCdEb2UnXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsnTHVjaW5vJywnVmVvJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ01hcnknLCdQb3BwaW5zJ10sXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGludGVyc2VjdGlvbiA9IHJlbGF0aW9uMS5wcm9qZWN0KFsnZmlyc3ROYW1lJ10pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgZmlyc3ROYW1lIDogVFN0cmluZyB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBKb2huICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IEx1Y2lubyAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgTWFyeSAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKi9cbiAgICAgICAgcHJvamVjdDogZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWVzKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnJlbGF0aW9uLnRyYWNlKCcjcHJvamVjdCcpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IChyZXF1aXJlKCcuL2FsZ2VicmEvUHJvamVjdGlvbicpKSh0aGlzLCBhdHRyaWJ1dGVOYW1lcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdOYW1lcyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmV3IGF0dHJpYnV0ZSBuYW1lcy5cbiAgICAgICAgICogQHJldHVybnMge09wZXJhdG9ycy5SZW5hbWV9IFRoZSByZXN1bHRpbmcgcmVsYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogU2hvcnRjdXQgdG8gY3JlYXRlIGEgUmVuYW1lIHJlbGF0aW9uIGJhc2VkIG9uIHRoaXMgcmVsYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbjEgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge2ZpcnN0TmFtZSA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgICAgIHtsYXN0TmFtZSA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ0pvaG4nLCdEb2UnXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsnTHVjaW5vJywnVmVvJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ01hcnknLCdQb3BwaW5zJ10sXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbmFtZSA9IHJlbGF0aW9uMS5yZW5hbWUoe2xhc3ROYW1lIDogJ0Jvb2dpZSd9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IGZpcnN0TmFtZSA6IFRTdHJpbmcgfCBCb29naWUgOiBUU3RyaW5nICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgSm9obiAgICAgICAgICAgICAgICB8IERvZSAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBMdWNpbm8gICAgICAgICAgICAgIHwgVmVvICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IE1hcnkgICAgICAgICAgICAgICAgfCBQb3BwaW5zICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICovXG4gICAgICAgIHJlbmFtZTogZnVuY3Rpb24gKG5ld05hbWVzKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnJlbGF0aW9uLnRyYWNlKCcjcmVuYW1lJyk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgKHJlcXVpcmUoJy4vYWxnZWJyYS9SZW5hbWUnKSkodGhpcywgbmV3TmFtZXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0byB0ZXN0IHRoZSB0dXBsZXMgYWdhaW5zdFxuICAgICAgICAgKiBAcmV0dXJucyB7T3BlcmF0b3JzLlJlc3RyaWN0aW9ufSBUaGUgcmVzdWx0aW5nIHJlbGF0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNob3J0Y3V0IHRvIGNyZWF0ZSBhIFJlc3RyaWN0IHJlbGF0aW9uIGJhc2VkIG9uIHRoaXMgcmVsYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7Zmlyc3ROYW1lIDoge3R5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICAgICAge2xhc3ROYW1lIDoge3R5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsnSm9obicsJ0RvZSddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydMdWNpbm8nLCdWZW8nXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsnTWFyeScsJ1BvcHBpbnMnXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsnUm9iZXJ0JywnUm9iZXJ0J11cbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBNdWx0aXBsZSB3YXlzIHRvIGJ1aWxkIGEgcHJlZGljYXRlOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gQ29tcGFyZSB3aXRoIHN0YXRpYyB2YWx1ZVxuICAgICAgICAgKiAgICAgcmVsYXRpb24ucmVzdHJpY3QocmVsYXRpb24uZ2V0KCdmaXJzdE5hbWUnKS5lcXVhbCgnSm9obicpKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IGZpcnN0TmFtZSA6IFRTdHJpbmcgfCBCb29naWUgOiBUU3RyaW5nICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgSm9obiAgICAgICAgICAgICAgICB8IERvZSAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gQ29tcGFyZSB0d28gYXR0cmlidXRlc1xuICAgICAgICAgKiAgICAgcmVsYXRpb24ucmVzdHJpY3QocmVsYXRpb24uZ2V0KCdmaXJzdE5hbWUnKS5lcXVhbChyZWxhdGlvbi5nZXQoJ2xhc3ROYW1lJykpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgZmlyc3ROYW1lIDogVFN0cmluZyB8IEJvb2dpZSA6IFRTdHJpbmcgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBSb2JlcnQgICAgICAgICAgICAgIHwgUm9iZXJ0ICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBDb21iaW5lIHdpdGggYW5kLCBvciwgbm90XG4gICAgICAgICAqICAgICByZWxhdGlvbi5yZXN0cmljdCggKHJlbGF0aW9uLmdldCgnZmlyc3ROYW1lJykubm90KCkuZXF1YWwoJ0pvaG4nKSkgLmFuZCggcmVsYXRpb24uZ2V0KCdsYXN0TmFtZScpLm5vdCgpLmVxdWFsKCdWZW8nKSApIClcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IGZpcnN0TmFtZSA6IFRTdHJpbmcgfCBCb29naWUgOiBUU3RyaW5nICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgTWFyeSAgICAgICAgICAgICAgICB8IFBvcHBpbnMgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBSb2JlcnQgICAgICAgICAgICAgIHwgUm9iZXJ0ICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqL1xuICAgICAgICByZXN0cmljdDogZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5yZWxhdGlvbi50cmFjZSgnI3Jlc3RyaWN0Jyk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgKHJlcXVpcmUoJy4vYWxnZWJyYS9SZXN0cmljdGlvbicpKSh0aGlzLCBwcmVkaWNhdGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG9ydGN1dCB0byBjcmVhdGUgYSBVbmlvbiByZWxhdGlvbiBiYXNlZCBvbiB0aGlzIHJlbGF0aW9uIGFuZCB0aGUgc3BlY2lmaWVkIG9uZVxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvbiBUaGUgcmVsYXRpb24gdG8gcGVyZm9ybSBVbmlvbiB3aXRoXG4gICAgICAgICAqIEByZXR1cm5zIHtPcGVyYXRvcnMuVW5pb259IFRoZSByZXN1bHRpbmcgcmVsYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHVuaW9uOiBmdW5jdGlvbiAocmVsYXRpb24pIHtcblxuICAgICAgICAgICAgZGVidWcucmVsYXRpb24udHJhY2UoJyN1bmlvbicpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IChyZXF1aXJlKCcuL2FsZ2VicmEvVW5pb24nKSkodGhpcywgcmVsYXRpb24pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvblxuICAgICAgICAgKiBAcmV0dXJucyB7T3BlcmF0b3JzLkNvbXBvc2l0aW9ufSBUaGUgcmVzdWx0aW5nIHJlbGF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBjb21wb3NlOiBmdW5jdGlvbiAocmVsYXRpb24pIHtcblxuICAgICAgICAgICAgZGVidWcucmVsYXRpb24udHJhY2UoJyNjb21wb3NlJyk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgKHJlcXVpcmUoJy4vYWxnZWJyYS9Db21wb3NpdGlvbicpKSh0aGlzLCByZWxhdGlvbik7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwaW5nQXR0cmlidXRlTmFtZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBncm91cGVkQXR0cmlidXRlTmFtZXNcbiAgICAgICAgICogQHJldHVybiB7T3BlcmF0b3JzLkdyb3VwfVxuICAgICAgICAgKi9cbiAgICAgICAgZ3JvdXA6IGZ1bmN0aW9uIChncm91cGluZ0F0dHJpYnV0ZU5hbWUsIGdyb3VwZWRBdHRyaWJ1dGVOYW1lcykge1xuXG4gICAgICAgICAgICBkZWJ1Zy5yZWxhdGlvbi50cmFjZSgnI2dyb3VwJyk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgKHJlcXVpcmUoJy4vYWxnZWJyYS9Hcm91cCcpKSh0aGlzLCBncm91cGluZ0F0dHJpYnV0ZU5hbWUsIGdyb3VwZWRBdHRyaWJ1dGVOYW1lcyk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gZ3JvdXBlZEF0dHJpYnV0ZU5hbWVzXG4gICAgICAgICAqIEByZXR1cm5zIHtPcGVyYXRvcnMuVW5ncm91cH1cbiAgICAgICAgICovXG4gICAgICAgIHVuZ3JvdXA6IGZ1bmN0aW9uIChncm91cGVkQXR0cmlidXRlTmFtZXMpIHtcblxuICAgICAgICAgICAgZGVidWcucmVsYXRpb24udHJhY2UoJyN1bmdyb3VwJyk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgKHJlcXVpcmUoJy4vYWxnZWJyYS9Vbmdyb3VwJykpKHRoaXMsIGdyb3VwZWRBdHRyaWJ1dGVOYW1lcyk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2VtaURpZmZlcmVuY2VcbiAgICAgICAgICogQHJldHVybnMge09wZXJhdG9ycy5TZW1pRGlmZmVyZW5jZX0gVGhlIHJlc3VsdGluZyByZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0gcmVsYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHNkaWZmZXJlbmNlOiBmdW5jdGlvbiAocmVsYXRpb24pIHtcblxuICAgICAgICAgICAgZGVidWcucmVsYXRpb24udHJhY2UoJyNzZGlmZmVyZW5jZScpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IChyZXF1aXJlKCcuL2FsZ2VicmEvU2VtaWRpZmZlcmVuY2UnKSkodGhpcywgcmVsYXRpb24pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlbWlKb2luXG4gICAgICAgICAqIEByZXR1cm5zIHtPcGVyYXRvcnMuU2VtaUpvaW59IFRoZSBSZXN1bHRpbmcgUmVsYXRpb25cbiAgICAgICAgICogQHBhcmFtIHJlbGF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzam9pbjogZnVuY3Rpb24gKHJlbGF0aW9uKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnJlbGF0aW9uLnRyYWNlKCcjc2pvaW4nKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyAocmVxdWlyZSgnLi9hbGdlYnJhL1NlbWlqb2luJykpKHRoaXMsIHJlbGF0aW9uKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG9ydGN1dCB0byBleGVjdXRlIGEgV3JhcCBvcGVyYXRpb25cbiAgICAgICAgICogQHBhcmFtIHdyYXBwaW5nQXR0cmlidXRlTmFtZSBUaGUgbmFtZSBvZiB0aGUgbmV3IHdyYXBwaW5nIGF0dHJpYnV0ZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSB3cmFwcGVkQXR0cmlidXRlcyBUaGUgYXR0cmlidXRlIG5hbWVzIHRvIGJlIHdyYXBwZWRcbiAgICAgICAgICogQHJldHVybnMge09wZXJhdG9ycy5XcmFwfSBUaGUgcmVzdWx0aW5nIHJlbGF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB3cmFwOiBmdW5jdGlvbiAod3JhcHBpbmdBdHRyaWJ1dGVOYW1lLCB3cmFwcGVkQXR0cmlidXRlcykge1xuXG4gICAgICAgICAgICBkZWJ1Zy5yZWxhdGlvbi50cmFjZSgnI3dyYXAnKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyAocmVxdWlyZSgnLi9hbGdlYnJhL1dyYXAnKSkodGhpcywgd3JhcHBpbmdBdHRyaWJ1dGVOYW1lLCB3cmFwcGVkQXR0cmlidXRlcyk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvcnRjdXQgdG8gZXhlY3V0ZSBhbiBVbndyYXAgb3BlcmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHdyYXBwZWRBdHRyaWJ1dGVOYW1lcyBUaGUgbmFtZXMgb2YgdGhlIHdyYXBwZWQgYXR0cmlidXRlcyB0byB1bndyYXBcbiAgICAgICAgICogQHJldHVybnMge09wZXJhdG9ycy5VbndyYXB9IFRoZSByZXN1bHRpbmcgcmVsYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHVud3JhcDogZnVuY3Rpb24gKHdyYXBwZWRBdHRyaWJ1dGVOYW1lcykge1xuXG4gICAgICAgICAgICBkZWJ1Zy5yZWxhdGlvbi50cmFjZSgnI3Vud3JhcCcpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IChyZXF1aXJlKCcuL2FsZ2VicmEvVW53cmFwJykpKHRoaXMsIHdyYXBwZWRBdHRyaWJ1dGVOYW1lcyk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvcnRjdXQgdG8gY3JlYXRlIGFuIEV4dGVuZCBvcGVyYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3RbXX0gZXhwcmVzc2lvbnMgVGhlIGV4cHJlc3Npb25zIHRvIGV2YWx1YXRlXG4gICAgICAgICAqIEByZXR1cm5zIHtPcGVyYXRvcnMuRXh0ZW5zaW9ufSBUaGUgcmVzdWx0aW5nIHJlbGF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uIChleHByZXNzaW9ucykge1xuXG4gICAgICAgICAgICBkZWJ1Zy5yZWxhdGlvbi50cmFjZSgnI2V4dGVuZCcpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IChyZXF1aXJlKCcuL2FsZ2VicmEvRXh0ZW5zaW9uJykpKHRoaXMsIGV4cHJlc3Npb25zKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG9ydGN1dCB0byB0aGUgU3VtbWFyaXplIG9wZXJhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfEF0dHJpYnV0ZVtdfSBhdHRyaWJ1dGVzIFRoZSBhdHRyaWJ1dGVzIHRvIHN1bW1hcml6ZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3VtbWFyaWVzIFN1bW1hcnkgZXhwcmVzc2lvbnNcbiAgICAgICAgICovXG4gICAgICAgIHN1bW1hcml6ZSA6IGZ1bmN0aW9uKGF0dHJpYnV0ZXMsIHN1bW1hcmllcyl7XG4gICAgICAgICAgICBkZWJ1Zy5yZWxhdGlvbi50cmFjZSgnI3N1bW1hcml6ZScpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IChyZXF1aXJlKCcuL2FsZ2VicmEvU3VtbWFyaXplJykpKHRoaXMsIGF0dHJpYnV0ZXMsIHN1bW1hcmllcyk7XG5cbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8vZW5kcmVnaW9uXG5cbiAgICAgICAgLy9yZWdpb24gQWdncmVnYXRlc1xuXG4gICAgICAgIGFsbCA6IGZ1bmN0aW9uKHByZWRpY2F0ZSl7XG5cbiAgICAgICAgICAgIHZhciBBbGwgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9hZ2dyZWdhdGUvQWxsLmpzJyk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgQWxsKHRoaXMsIHByZWRpY2F0ZSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhbnkgOiBmdW5jdGlvbihwcmVkaWNhdGUpe1xuXG4gICAgICAgICAgICB2YXIgQW55ID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvYWdncmVnYXRlL0FueS5qcycpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFueSh0aGlzLCBwcmVkaWNhdGUpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgY291bnQgOiBmdW5jdGlvbigpe1xuXG4gICAgICAgICAgICB2YXIgQ291bnQgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9hZ2dyZWdhdGUvQ291bnQuanMnKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb3VudCh0aGlzKTtcblxuICAgICAgICB9XG4gICAgICAgIC8vZW5kcmVnaW9uXG5cbiAgICB9LCB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgUmVsYXRpb24gdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1JlbGF0aW9uJ1xuICAgICAgICB9LFxuXG4gICAgICAgIHR5cGU6ICdSZWxhdGlvbicsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlc3RzIGZvciBlcXVhbGl0eSBiZXR3ZWVuIHR3byByZWxhdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHtSZWxhdGlvbn0gcmVsMVxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWwyXG5cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGVxdWFsOiBmdW5jdGlvbiAocmVsMSwgcmVsMikge1xuXG4gICAgICAgICAgICBkZWJ1Zy5yZWxhdGlvbi50cmFjZSgnUmVsYXRpb24uZXF1YWwnKTtcblxuICAgICAgICAgICAgaWYgKCFyZWwxLmhlYWRlcigpLmVxdWFsKHJlbDIuaGVhZGVyKCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZWwxLmNvbXB1dGUoKTtcbiAgICAgICAgICAgIHJlbDIuY29tcHV0ZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gU2V0LmVxdWFsKHJlbDEsIHJlbDIpO1xuXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVsYXRpb247XG4iLCJ2YXIgVHlwZSA9IHJlcXVpcmUoJy4vVHlwZS5qcycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBjb2VyY2UgPSByZXF1aXJlKCcuL2hlbHBlcnMvY29lcmNlJyk7XG52YXIgZXF1YWwgPSByZXF1aXJlKCcuL2hlbHBlcnMvZXF1YWwnKTtcbnZhciBjbG9uZSA9IHJlcXVpcmUoJy4vaGVscGVycy9jbG9uZScpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50ZW1pdHRlcjMnKS5FdmVudEVtaXR0ZXIzO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnLi9oZWxwZXJzL2RlYnVnLmpzJyk7XG5cblxudmFyIFNldCA9IFR5cGUuZXh0ZW5kKFxuXG4gICAge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIFNldFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2FyZ3NdIENvbnN0cnVjdG9yIGFyZ3VtZW50c1xuICAgICAgICAgKiBAcGFyYW0ge1R5cGV9IFthcmdzLnR5cGVdIFR5cGUgb2YgdGhlIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiB0aGUgc2V0XG4gICAgICAgICAqIEBleHRlbmRzIFR5cGVcbiAgICAgICAgICogQSBTZXQgaXMgYW4gdW5vcmRlcmVkIGNvbGxlY3Rpb24gb2YgZGlzdGluY3Qgb2JqZWN0cyAobm8gZHVwbGljYXRlcykuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKGFyZ3MpIHtcblxuICAgICAgICAgICAgZGVidWcuc2V0LnRyYWNlKCcjY29uc3RydWN0b3InKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0V2ZW50RW1pdHRlcn0gZWVcbiAgICAgICAgICAgICAqIEBleHRlcm5hbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmVlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgICAgICAgICB0aGlzLmVlLnNldE1heExpc3RlbmVycygwKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge1R5cGV9IF90eXBlXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl90eXBlID0gbnVsbDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5fSBfZWxlbWVudHNcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRzID0gW107XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IF9kZWxldGVkQ291bnRcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2RlbGV0ZWRDb3VudCA9IDA7XG5cblxuICAgICAgICAgICAgLy8gQ2FsbCBiaW5kRXZlbnRzIGlmIGlzIGRlZmluZWRcblxuICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbih0aGlzLmJpbmRFdmVudHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhcmdzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJncy50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZShhcmdzLnR5cGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChhcmdzLmVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHMoYXJncy5lbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cblxuXG4gICAgICAgICAgICAvLyBDYWxsIHBhcmVudCBjb25zdHJ1Y3RvclxuXG4gICAgICAgICAgICBUeXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBiaW5kRXZlbnRzIDogZnVuY3Rpb24oKXtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7U2V0fVxuICAgICAgICAgKlxuICAgICAgICAgKiBDbG9uZXMgYSBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnNldC50cmFjZSgnI2Nsb25lJyk7XG5cbiAgICAgICAgICAgIHZhciBuZXdTZXQgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih7dHlwZSA6IHRoaXMudHlwZSgpfSk7XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIG5ld1NldC5hZGQoZWxlbWVudCwgZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXdTZXQ7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVzdHJveXMgdGhlIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZGVzdHJveSA6IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgIC8vIERlbGV0ZXMgdGhlIGVsZW1lbnRzXG4gICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpe1xuXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBdChpbmRleCk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBEZWxldGVzIHRoZSBldmVudCBlbWl0dGVyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5lZTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGVsZW1lbnRzIG9mIHRoZSBzZXRcbiAgICAgICAgICogQHBhcmFtIHtTZXR9IFtlbGVtZW50c10gZWxlbWVudHMgb2YgdGhlIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfG51bGx8QXJyYXl9XG4gICAgICAgICAqIEB0aHJvd3MgV2lsbCB0aHJvdyBpZiB0aGUgdHlwZSBvZiB0aGUgU2V0IGhhcyBub3QgYmVlbiBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGVsZW1lbnRzOiBmdW5jdGlvbiAoZWxlbWVudHMpIHtcblxuICAgICAgICAgICAgZGVidWcuc2V0LnRyYWNlKCcjZWxlbWVudHMnKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSgpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGRlZmluZSB0aGUgdHlwZSBvZiB0aGUgc2V0IGZpcnN0Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50cykge1xuXG4gICAgICAgICAgICAgICAgaWYgKCFfLmlzQXJyYXkoZWxlbWVudHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VsZW1lbnRzIG11c3QgYmUgaW4gYXJyYXkgZm9ybWF0JylcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmVlLmVtaXQoJ2JlZm9yZVNldEVsZW1lbnRzJywgZWxlbWVudHMpO1xuXG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKGVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmVlLmVtaXQoJ2FmdGVyU2V0RWxlbWVudHMnLCBlbGVtZW50cyk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmVlLmVtaXQoJ2JlZm9yZUdldEVsZW1lbnRzJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtUeXBlfSBbdHlwZV0gVGhlIHR5cGUgb2YgdGhlIFNldFxuICAgICAgICAgKiBAcmV0dXJucyB7bnVsbHxUeXBlfVxuICAgICAgICAgKlxuICAgICAgICAgKiBHZXR0ZXIvU2V0dGVyIGZvciB0aGUgdHlwZSBwYXJhbWV0ZXIuIFdoZW4gdXNlZCB3aXRob3V0IHBhcmFtZXRlciwgd2lsbCByZXR1cm5cbiAgICAgICAgICogdGhlIHR5cGUgb2YgdGhlIFNldC4gV2hlbiB1c2VkIHdpdGggYSBwYXJhbWV0ZXIsIHdpbGwgc2V0IHRoZSBzZXQncyB0eXBlLlxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogZnVuY3Rpb24gKHR5cGUpIHtcblxuICAgICAgICAgICAgZGVidWcuc2V0LnRyYWNlKCcjdHlwZScpO1xuXG4gICAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBUaGUgXCJ0aGlzXCIgY29udGV4dCBmb3IgdGhlIGNhbGxiYWNrXG4gICAgICAgICAqXG4gICAgICAgICAqIEl0ZXJhdG9yIGZ1bmN0aW9uLiBPbmx5IGFuIGFsaWFzIGZvciBsb2Rhc2ggXy5mb3JFYWNoXG4gICAgICAgICAqL1xuICAgICAgICBlYWNoOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcblxuICAgICAgICAgICAgZGVidWcuc2V0LnRyYWNlKCcjZWFjaCcpO1xuXG4gICAgICAgICAgICBfLmZvckVhY2godGhpcy5lbGVtZW50cygpLCBmdW5jdGlvbihlbGVtZW50LCBpbmRleCl7XG5cbiAgICAgICAgICAgICAgICBpZihlbGVtZW50ICE9PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgICAgICAgICBpZihjYWxsYmFjay5jYWxsKGNvbnRleHQsIGVsZW1lbnQsIGluZGV4KSA9PT0gZmFsc2Upe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBUaGUgXCJ0aGlzXCIgY29udGV4dCBmb3IgdGhlIGNhbGxiYWNrXG4gICAgICAgICAqXG4gICAgICAgICAqIEl0ZXJhdG9yIGZ1bmN0aW9uLiBPbmx5IGFuIGFsaWFzIGZvciBsb2Rhc2ggXy5hbnlcbiAgICAgICAgICovXG4gICAgICAgIGFueSA6IGZ1bmN0aW9uKGNhbGxiYWNrLCBjb250ZXh0KXtcblxuICAgICAgICAgICAgZGVidWcuc2V0LnRyYWNlKCcjYW55Jyk7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgICAgICAgXy5hbnkodGhpcy5lbGVtZW50cygpLCBmdW5jdGlvbihlbGVtZW50LCBpbmRleCl7XG5cbiAgICAgICAgICAgICAgIHJldHVybiAoZWxlbWVudCAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgZWxlbWVudCwgaW5kZXgpKTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHsqfSBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NoZWNrRHVwbGljYXRlPXRydWVdIFRlc3RzIGZvciBkdXBsaWNhdGUgZWxlbWVudHMgaW4gdGhlIHNldC4gU2V0IHRvIGZhbHNlIHRvIHNraXAgdGhpc1xuICAgICAgICAgKiB2ZXJpZmljYXRpb24gaWYgeW91IGFyZSBzdXJlIHRoZSBlbGVtZW50IGlzIG5vdCBpbiB0aGUgc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBlbGVtZW50IHdhcyBhZGRlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICAgICAqXG4gICAgICAgICAqIERpcmVjdGx5IGFkZCBhbiBlbGVtZW50IHRvIHRoZSBzZXQuXG4gICAgICAgICAqL1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChlbGVtZW50LCBjaGVja0R1cGxpY2F0ZSkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5zZXQudHJhY2UoJyNhZGQnKTtcblxuICAgICAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQoY2hlY2tEdXBsaWNhdGUpKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuXG4gICAgICAgICAgICAgICAgZGVidWcuc2V0LnRyYWNlKCcjYWRkIGNvZXJjaW5nIGVsZW1lbnQnKTtcblxuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBjb2VyY2UodGhpcy50eXBlKCksIGVsZW1lbnQsIHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKChjaGVja0R1cGxpY2F0ZSAmJiAhdGhpcy5leGlzdHMoZWxlbWVudCkpIHx8ICFjaGVja0R1cGxpY2F0ZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWUuZW1pdCgnYmVmb3JlQWRkJywgZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0luZGV4ID0gdGhpcy5lbGVtZW50cygpLnB1c2goZWxlbWVudCkgLSAxO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWUuZW1pdCgnYWZ0ZXJBZGQnLCBlbGVtZW50LCBuZXdJbmRleCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHsqfSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIHJlbW92ZVxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IHdhcyByZW1vdmVkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgICAgICpcbiAgICAgICAgICogUmVtb3ZlcyBhbiBlbGVtZW50IGZyb20gdGhlIHNldC5cbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGVsZW1lbnQpIHtcblxuICAgICAgICAgICAgZGVidWcuc2V0LnRyYWNlKCcjcmVtb3ZlJyk7XG5cbiAgICAgICAgICAgIGVsZW1lbnQgPSBjb2VyY2UodGhpcy50eXBlKCksIGVsZW1lbnQpO1xuXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4KGVsZW1lbnQpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVBdChpbmRleCk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0byByZW1vdmUgdGhlIGVsZW1lbnRcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgZGVsZXRlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICAgICAqXG4gICAgICAgICAqIFJlbW92ZXMgYW4gZWxlbWVudCBmcm9tIHRoZSBzZXQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUF0OiBmdW5jdGlvbiAoaW5kZXgpIHtcblxuICAgICAgICAgICAgZGVidWcuc2V0LnRyYWNlKCcjcmVtb3ZlQXQnKTtcblxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmF0SW5kZXgoaW5kZXgpO1xuXG4gICAgICAgICAgICBpZihlbGVtZW50ID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5lZS5lbWl0KCdiZWZvcmVSZW1vdmUnLCBlbGVtZW50LCBpbmRleCk7XG5cbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMoKVtpbmRleF0gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHRoaXMuX2RlbGV0ZWRDb3VudCsrO1xuXG4gICAgICAgICAgICB0aGlzLmVlLmVtaXQoJ2FmdGVyUmVtb3ZlJywgZWxlbWVudCwgaW5kZXgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7bnVsbHwqfSBUaGUgZmlyc3QgZWxlbWVudCBvciBudWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBHZXRzIHRoZSBmaXJzdCBlbGVtZW50IGZyb20gdGhlIHNldC5cbiAgICAgICAgICovXG4gICAgICAgIGZpcnN0IDogZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgZGVidWcuc2V0LnRyYWNlKCcjZmlyc3QnKTtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF8uZmluZCh0aGlzLmVsZW1lbnRzKCksIGZ1bmN0aW9uKGVsZW1lbnQpe1xuXG4gICAgICAgICAgICAgICAgaWYoIV8uaXNVbmRlZmluZWQoZWxlbWVudCkpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZihfLmlzVW5kZWZpbmVkKHJlc3VsdCkpe1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ8bnVsbH0gSW5kZXggb2Ygb2JqZWN0IGlmIGZvdW5kLCBudWxsIG90aGVyd2lzZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBGaW5kIHRoZSBpbmRleCBvZiBhbiBlbGVtZW50IHdpdGggZGVmaW5lZCB0eXBlIGVxdWFsaXR5IG1ldGhvZHNcbiAgICAgICAgICovXG4gICAgICAgIF9pbmRleEJ5RXF1YWxpdHk6IGZ1bmN0aW9uIChvYmplY3QpIHtcblxuICAgICAgICAgICAgZGVidWcuc2V0LnRyYWNlKCcjaW5kZXhCeUVxdWFsaXR5Jyk7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuXG4gICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGVsZW1lbnQsIGtleSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGVxdWFsKHRoaXMudHlwZSgpLCBlbGVtZW50LCBvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gc2VhcmNoIGZvclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVsbHxudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCBpZiBmb3VuZCwgbnVsbCBvdGhlcndpc2VcbiAgICAgICAgICpcbiAgICAgICAgICogR2V0cyB0aGUgaW5kZXggb2YgYW4gZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgaW5kZXg6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnNldC50cmFjZSgnI2luZGV4Jyk7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuXG4gICAgICAgICAgICBlbGVtZW50ID0gY29lcmNlKHRoaXMudHlwZSgpLCBlbGVtZW50KTtcblxuICAgICAgICAgICAgaWYodGhpcy5faW5kZXgpe1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX2luZGV4KGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5kZXhCeUVxdWFsaXR5KGVsZW1lbnQpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50XG4gICAgICAgICAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0aW5nIGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGF0SW5kZXg6IGZ1bmN0aW9uIChpbmRleCkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5zZXQudHJhY2UoJyNhdEluZGV4Jyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzKClbaW5kZXhdO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBmaW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtudWxsfCp9IHRoZSByZXN1bHRpbmcgZWxlbWVudCBvciBudWxsIGlmIG5vdCBmb3VuZFxuICAgICAgICAgKlxuICAgICAgICAgKiBGaW5kcyBhbiBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBmaW5kOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5zZXQudHJhY2UoJyNmaW5kJyk7XG5cbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgoZWxlbWVudCk7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmF0SW5kZXgoaW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0geyp9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gY2hlY2sgZm9yXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBlbGVtZW50IGV4aXN0cywgZmFsc2UgaWYgbm90XG4gICAgICAgICAqXG4gICAgICAgICAqIENoZWNrcyBpZiBhbiBlbGVtZW50IGV4aXN0cyBpbiB0aGUgc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgZXhpc3RzOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5zZXQudHJhY2UoJyNleGlzdHMnKTtcblxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmluZGV4KGVsZW1lbnQpICE9PSBudWxsKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBOdW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnNldC50cmFjZSgnI2xlbmd0aCcpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50cygpLmxlbmd0aC10aGlzLl9kZWxldGVkQ291bnQ7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtTZXR9IHNldDIgVGhlIHNldCB0byBwZXJmb3JtIHVuaW9uIHdpdGhcbiAgICAgICAgICogQHJldHVybnMge1NldH0gVGhlIHJlc3VsdGluZyBzZXRcbiAgICAgICAgICpcbiAgICAgICAgICogVW5pb24gb2YgdHdvIHNldHMuIFJldHVybnMgYSBzZXQgY29udGFpbmluZyBhbGwgdGhlIGVsZW1lbnRzIGZyb20gQSBhbmQgQi5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBzZXQxID0gbmV3IGFmZmluaXR5LlNldChhZmZpbml0eS5JbnRlZ2VyLCBbMSwgMiwgM10pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHNldDIgPSBuZXcgYWZmaW5pdHkuU2V0KGFmZmluaXR5LkludGVnZXIsIFszLCA0LCA1XSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVzdWx0ID0gc2V0MS5zZXRVbmlvbihzZXQyKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIFNldCBoYXMgZWxlbWVudHMgWzEsIDIsIDMsIDQsIDVdIChub3RlIG5vIGR1cGxpY2F0ZXMpXG4gICAgICAgICAqL1xuICAgICAgICBzZXRVbmlvbjogZnVuY3Rpb24gKHNldDIpIHtcblxuICAgICAgICAgICAgZGVidWcuc2V0LnRyYWNlKCcjdW5pb24nKTtcblxuICAgICAgICAgICAgdmFyIHRoaXNUeXBlID0gdGhpcy50eXBlKCk7XG4gICAgICAgICAgICB2YXIgb3RoZXJUeXBlID0gc2V0Mi50eXBlKCk7XG5cbiAgICAgICAgICAgIHZhciB0eXBlID0gKHRoaXNUeXBlID09PSBvdGhlclR5cGUpID8gdGhpc1R5cGUgOiBudWxsO1xuXG4gICAgICAgICAgICB2YXIgbmV3U2V0ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKTtcblxuICAgICAgICAgICAgbmV3U2V0LnR5cGUodHlwZSk7XG5cbiAgICAgICAgICAgIF8uZm9yRWFjaChbdGhpcywgc2V0Ml0sIGZ1bmN0aW9uIChhU2V0KSB7XG5cbiAgICAgICAgICAgICAgICBhU2V0LmVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2V0LmFkZChjbG9uZShlbGVtZW50KSk7XG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXdTZXQ7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTZXR9IHNldDIgVGhlIHNldCBhY3RpbmcgYXMgYSBwYXN0cnkgY3V0dGVyXG4gICAgICAgICAqIEByZXR1cm5zIHtTZXR9XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBQZXJmb3JtIGEgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBzZXRzLiBSZXR1cm5zIGEgc2V0IHdpdGggdGhlIGVsZW1lbnRzIG9mIEEgd2l0aG91dFxuICAgICAgICAgKiAgICAgdGhvc2UgdGhhdCBBIGFuZCBCIGhhdmUgaW4gY29tbW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIHZhciBzZXQxID0gbmV3IGFmZmluaXR5LlNldChhZmZpbml0eS5JbnRlZ2VyLCBbMSwgMiwgM10pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIHZhciBzZXQyID0gbmV3IGFmZmluaXR5LlNldChhZmZpbml0eS5JbnRlZ2VyLCBbMywgNCwgNV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIHZhciByZXN1bHQgPSBzZXQxLnNldERpZmZlcmVuY2Uoc2V0Mik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgLy8gU2V0IGhhcyBlbGVtZW50cyBbMSwgMl1cbiAgICAgICAgICovXG4gICAgICAgIHNldERpZmZlcmVuY2U6IGZ1bmN0aW9uIChzZXQyKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnNldC50cmFjZSgnI2RpZmZlcmVuY2UnKTtcblxuICAgICAgICAgICAgdmFyIG5ld1NldCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gICAgICAgICAgICBuZXdTZXQudHlwZSh0aGlzLnR5cGUoKSk7XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuXG4gICAgICAgICAgICAgICAgaWYoIXNldDIuZXhpc3RzKGVsZW1lbnQpKXtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2V0LmFkZChjbG9uZShlbGVtZW50KSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXdTZXQ7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTZXR9IHNldDIgVGhlIHNldCB0byBwZXJmb3JtIHByb2R1Y3Qgd2l0aFxuICAgICAgICAgKiBAcmV0dXJucyB7U2V0fVxuICAgICAgICAgKlxuICAgICAgICAgKiBQZXJmb3JtcyBhIHByb2R1Y3Qgb2YgdHdvIHNldHMuIFJldHVybnMgYSBzZXQgd2l0aCBhbGwgdGhlIHBvc3NpYmxlIGNvbWJpbmF0aW9uc1xuICAgICAgICAgKiBvZiBlbGVtZW50cyBmcm9tIEEgY29tYmluZWQgd2l0aCB0aG9zZSBvZiBCLiBUaGlzIG9wZXJhdGlvbiB3aWxsIHJldHVybiBhIHNldCBjb250YWluaW5nXG4gICAgICAgICAqIHR1cGxlcyB3aXRoIGF0dHJpYnV0ZXMgeyAwIDogYXR0cjEsIDEgOiBhdHRyMn0uIDAgaXMgdGhlIGxlZnQgc2V0IGVsZW1lbnQsIDEgaXMgdGhlXG4gICAgICAgICAqIHJpZ2h0IHNldCBlbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHNldDEgPSBuZXcgYWZmaW5pdHkuU2V0KGFmZmluaXR5LkludGVnZXIsIFsxLCAyXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgc2V0MiA9IG5ldyBhZmZpbml0eS5TZXQoYWZmaW5pdHkuSW50ZWdlciwgWzMsIDRdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZXN1bHQgPSBzZXQxLnNldFByb2R1Y3Qoc2V0Mik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBTZXQgaGFzIGVsZW1lbnRzIFtUdXBsZSgwIDogMSwgMSA6IDMpLFR1cGxlKDAgOiAxLCAxIDogNCksVHVwbGUoMCA6IDIsIDEgOiAyKSxUdXBsZSgwIDogMiwgMSA6IDQpXVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0UHJvZHVjdDogZnVuY3Rpb24gKHNldDIpIHtcblxuICAgICAgICAgICAgZGVidWcuc2V0LnRyYWNlKCcjcHJvZHVjdCcpO1xuXG4gICAgICAgICAgICB2YXIgVHVwbGUgPSByZXF1aXJlKCcuL1R1cGxlLmpzJyk7XG5cbiAgICAgICAgICAgIHZhciBuZXdTZXQgPSBuZXcgU2V0KHt0eXBlOiBUdXBsZX0pO1xuXG4gICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGVsZW1lbnQxKSB7XG5cbiAgICAgICAgICAgICAgICBzZXQyLmVhY2goZnVuY3Rpb24gKGVsZW1lbnQyKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHR1cGxlID0gbmV3IFR1cGxlKHswOiBlbGVtZW50MSwgMTogZWxlbWVudDJ9KTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2V0LmFkZCh0dXBsZSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3U2V0O1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U2V0fSBzZXQyIFRoZSBzZXQgdG8gYmUgaW50ZXJzZWN0ZWQgd2l0aFxuICAgICAgICAgKiBAcmV0dXJucyB7U2V0fSBUaGUgcmVzdWx0aW5nIHNldFxuICAgICAgICAgKlxuICAgICAgICAgKiBQZXJmb3JtcyBhbiBpbnRlcnNlY3Rpb24gd2l0aCBhbm90aGVyIHNldC4gUmV0dXJucyBhIHNldCB3aXRoXG4gICAgICAgICAqIHRoZSBlbGVtZW50cyB0aGF0IEEgYW5kIEIgaGF2ZSBpbiBjb21tb24uXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgc2V0MSA9IG5ldyBhZmZpbml0eS5TZXQoYWZmaW5pdHkuSW50ZWdlciwgWzEsIDIsIDNdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBzZXQyID0gbmV3IGFmZmluaXR5LlNldChhZmZpbml0eS5JbnRlZ2VyLCBbMywgNCwgNV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlc3VsdCA9IHNldDEuc2V0SW50ZXJzZWN0aW9uKHNldDIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gU2V0IGhhcyBlbGVtZW50cyBbM11cbiAgICAgICAgICovXG4gICAgICAgIHNldEludGVyc2VjdGlvbjogZnVuY3Rpb24gKHNldDIpIHtcblxuICAgICAgICAgICAgZGVidWcuc2V0LnRyYWNlKCcjaW50ZXJzZWN0aW9uJyk7XG5cbiAgICAgICAgICAgIHZhciBuZXdTZXQgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXG4gICAgICAgICAgICBuZXdTZXQudHlwZSh0aGlzLnR5cGUoKSk7XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoZWxlbWVudDEpIHtcblxuICAgICAgICAgICAgICAgIGlmIChzZXQyLmV4aXN0cyhlbGVtZW50MSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2V0LmFkZChjbG9uZShlbGVtZW50MSksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3U2V0O1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U2V0fSBzZXQyIFRoZSBzZXQgdG8gcGVmb3JtIHN5bW1ldHJpYyBkaWZmZXJlbmNlIGFnYWluc3RcbiAgICAgICAgICogQHJldHVybnMge1NldH0gVGhlIHJlc3VsdGluZyBzZXRcbiAgICAgICAgICpcbiAgICAgICAgICogUGVyZm9ybXMgYSBzeW1tZXRyaWMgZGlmZmVyZW5jZS4gUmV0dXJucyBhIHNldCB3aXRoIHRoZSBlbGVtZW50cyB0aGF0IEFcbiAgICAgICAgICogYW5kIEIgZG8gbm90IGhhdmUgaW4gY29tbW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHNldDEgPSBuZXcgYWZmaW5pdHkuU2V0KGFmZmluaXR5LkludGVnZXIsIFsxLCAyLCAzXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgc2V0MiA9IG5ldyBhZmZpbml0eS5TZXQoYWZmaW5pdHkuSW50ZWdlciwgWzMsIDQsIDVdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZXN1bHQgPSBzZXQxLnNldFN5bW1ldHJpY0RpZmZlcmVuY2Uoc2V0Mik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBTZXQgaGFzIGVsZW1lbnRzIFsxLCAyLCA0LCA1XVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0U3ltbWV0cmljRGlmZmVyZW5jZTogZnVuY3Rpb24gKHNldDIpIHtcblxuICAgICAgICAgICAgZGVidWcuc2V0LnRyYWNlKCcjc3ltbWV0cmljRGlmZmVyZW5jZScpO1xuXG4gICAgICAgICAgICB2YXIgbmV3U2V0ID0gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKSh7dHlwZTogdGhpcy50eXBlKCl9KTtcblxuICAgICAgICAgICAgdmFyIHNldDEgPSB0aGlzO1xuXG4gICAgICAgICAgICBzZXQxLmVhY2goZnVuY3Rpb24gKGVsZW1lbnQxKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNldDIuZXhpc3RzKGVsZW1lbnQxKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTZXQuYWRkKGNsb25lKGVsZW1lbnQxKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc2V0Mi5lYWNoKGZ1bmN0aW9uIChlbGVtZW50Mikge1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzZXQxLmV4aXN0cyhlbGVtZW50MikpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2V0LmFkZChjbG9uZShlbGVtZW50MikpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXdTZXQ7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGFTZXRcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqXG4gICAgICAgICAqIERldGVybWluZSBpZiB0aGUgc2V0IGlzIGEgc3Vic2V0IG9mIGFub3RoZXIgc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgaXNTdWJzZXQgOiBmdW5jdGlvbihhU2V0KXtcblxuICAgICAgICAgICAgZGVidWcuc2V0LnRyYWNlKCcjaXNTdWJzZXQnKTtcblxuICAgICAgICAgICAgdmFyIG1hdGNoID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGVsZW1lbnQpe1xuICAgICAgICAgICAgICAgIGlmKCFhU2V0LmV4aXN0cyhlbGVtZW50KSl7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBhU2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKlxuICAgICAgICAgKiBEZXRlcm1pbmUgaWYgdGhlIHNldCBpcyBhIHN1cGVyc2V0IG9mIGFub3RoZXIgc2V0XG4gICAgICAgICAqL1xuICAgICAgICBpc1N1cGVyc2V0IDogZnVuY3Rpb24oYVNldCl7XG5cbiAgICAgICAgICAgIGRlYnVnLnNldC50cmFjZSgnI2lzU3VwZXJzZXQnKTtcblxuICAgICAgICAgICAgcmV0dXJuICFhU2V0LmlzU3Vic2V0KHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gYVNldFxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICpcbiAgICAgICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgc2V0IGlzIGEgcHJvcGVyIHN1YnNldCBvZiBhbm90aGVyIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgaXNQcm9wZXJTdWJzZXQgOiBmdW5jdGlvbihhU2V0KXtcblxuICAgICAgICAgICAgZGVidWcuc2V0LnRyYWNlKCcjaXNQcm9wZXJTdWJzZXQnKTtcblxuICAgICAgICAgICAgaWYodGhpcy5sZW5ndGgoKSA+PSBhU2V0Lmxlbmd0aCgpKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1N1YnNldChhU2V0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGFTZXRcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqXG4gICAgICAgICAqIERldGVybWluZSBpZiB0aGUgc2V0IGlzIGEgcHJvcGVyIHN1cGVyc2V0IG9mIGFub3RoZXIgc2V0XG4gICAgICAgICAqL1xuICAgICAgICBpc1Byb3BlclN1cGVyc2V0IDogZnVuY3Rpb24oYVNldCl7XG5cbiAgICAgICAgICAgIGRlYnVnLnNldC50cmFjZSgnI2lzUHJvcGVyU3VwZXJzZXQnKTtcblxuICAgICAgICAgICAgcmV0dXJuICFhU2V0LmlzUHJvcGVyU3Vic2V0KHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge1NldH0gYW5vdGhlclNldFxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICpcbiAgICAgICAgICogQ2hlY2tzIGlmIHR3byBzZXRzIGFyZSBlcXVhbFxuICAgICAgICAgKi9cbiAgICAgICAgZXF1YWw6IGZ1bmN0aW9uIChhbm90aGVyU2V0KSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnNldC50cmFjZSgnI2VxdWFsJyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLmVxdWFsKHRoaXMsIGFub3RoZXJTZXQpO1xuXG4gICAgICAgIH1cblxuXG5cblxuICAgIH0sIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTZXR9IHNldDEgVGhlIGZpcnN0IHNldCB0byBjb21wYXJlXG4gICAgICAgICAqIEBwYXJhbSB7U2V0fSBzZXQyIFRoZSBzZWNvbmQgc2V0IHRvIGNvbXBhcmVcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNldHMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKlxuICAgICAgICAgKiBDaGVja3MgaWYgdHdvIHNldHMgYXJlIGVxdWFsXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbDogZnVuY3Rpb24gKHNldDEsIHNldDIpIHtcblxuICAgICAgICAgICAgZGVidWcuc2V0LnRyYWNlKCcuZXF1YWwnKTtcblxuICAgICAgICAgICAgdmFyIHNldExlbmd0aDEgPSBzZXQxLmxlbmd0aCgpLFxuICAgICAgICAgICAgICAgIHNldExlbmd0aDIgPSBzZXQyLmxlbmd0aCgpLFxuICAgICAgICAgICAgICAgIG1pc21hdGNoID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgYm90aCBzZXRzIGFyZSBvZiB0aGUgc2FtZSB0eXBlXG5cbiAgICAgICAgICAgIGlmIChzZXQxLnR5cGUoKSAmJiBzZXQyLnR5cGUoKSAmJiAoc2V0MS50eXBlKCkgIT09IHNldDIudHlwZSgpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCBib3RoIHNldHMgYXJlIG9mIHRoZSBzYW1lIGxlbmd0aFxuICAgICAgICAgICAgaWYgKHNldExlbmd0aDEgIT09IHNldExlbmd0aDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbmQgZWFjaCBzZXQxIGl0ZW1zIGluIHNldDJcbiAgICAgICAgICAgIHNldDEuZWFjaChmdW5jdGlvbiAoZWxlbWVudDEpIHtcblxuICAgICAgICAgICAgICAgIHZhciBpbmRleDIgPSBzZXQyLmluZGV4KGVsZW1lbnQxKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleDIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuICFtaXNtYXRjaDtcblxuICAgICAgICB9XG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXQ7IiwidmFyIFR5cGUgPSByZXF1aXJlKCcuL1R5cGUuanMnKTtcbnZhciBIZWFkZXIgPSByZXF1aXJlKCcuL1R5cGUuanMnKTtcbnZhciBUU3RyaW5nID0gcmVxdWlyZSgnLi90eXBlcy9TdHJpbmcuanMnKTtcbnZhciBBdHRyaWJ1dGUgPSByZXF1aXJlKCcuL0F0dHJpYnV0ZS5qcycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBlcXVhbCA9IHJlcXVpcmUoJy4vaGVscGVycy9lcXVhbCcpO1xudmFyIHZhbHVlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3ZhbHVlJyk7XG52YXIgU2V0ID0gcmVxdWlyZSgnLi9TZXQuanMnKTtcbnZhciBUdXBsZSA9IFR5cGUuZXh0ZW5kKFxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIFR1cGxlXG4gICAgICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzXG4gICAgICAgICAqIEBleHRlbmRzIFR5cGVcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKGF0dHJpYnV0ZXMpIHtcblxuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG5cbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIV8uaXNPYmplY3QoYXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVHVwbGUgYXR0cmlidXRlcyBpbiB3cm9uZyBmb3JtYXQnKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBhO1xuXG4gICAgICAgICAgICAgICAgZm9yIChhIGluIGF0dHJpYnV0ZXMpIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoYSwgYXR0cmlidXRlc1thXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgVHlwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogSXRlcmF0b3IgZnVuY3Rpb24gdGhhdCBsb29wcyB0aHJvdWdoIGVhY2ggb2YgdGhlIHR1cGxlIGF0dHJpYnV0ZXNcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgRXhlY3V0aW9uIGNvbnRleHQgb2YgdGhlIGNhbGxiYWNrXG4gICAgICAgICAqL1xuICAgICAgICBlYWNoIDogZnVuY3Rpb24oY2FsbGJhY2ssIGNvbnRleHQpe1xuICAgICAgICAgICAgXy5mb3JJbih0aGlzLmF0dHJpYnV0ZXMsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29waWVzIGF0dHJpYnR1ZXMgZnJvbSBhbm90aGVyIHR1cGxlXG4gICAgICAgICAqIEBwYXJhbSB7VHVwbGV9IHR1cGxlIFR1cGxlIHRvIGNvcHkgYXR0cmlidXRlcyBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7SGVhZGVyfEF0dHJpYnV0ZVtdfFNldHxTdHJpbmdbXX0gW2F0dHJpYnV0ZXNBcmd1bWVudD1bXV0gQXR0cmlidXRlcyB0byBjb3B5XG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2V4Y2x1ZGU9ZmFsc2VdIERvIHdlIGV4Y2x1ZGUgb3IgaW5jbHVkZSB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgY29weSA6IGZ1bmN0aW9uKHR1cGxlLCBhdHRyaWJ1dGVzQXJndW1lbnQsIGV4Y2x1ZGUpe1xuXG4gICAgICAgICAgICBpZiAoZXhjbHVkZSAhPT0gdHJ1ZSAmJiBleGNsdWRlICE9PSBmYWxzZSl7XG4gICAgICAgICAgICAgICAgZXhjbHVkZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQoYXR0cmlidXRlc0FyZ3VtZW50KSAmJiAhXy5pc051bGwoYXR0cmlidXRlc0FyZ3VtZW50KSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBTZXQoe3R5cGU6IFRTdHJpbmd9KTtcblxuICAgICAgICAgICAgICAgIC8vIENvZXJjZSB0aGUgYXR0cmlidXRlcyBhcmd1bWVudCB0byBTZXQgb2Ygc3RyaW5nXG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXNBcmd1bWVudCBpbnN0YW5jZW9mIEhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzQXJndW1lbnQuZWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkKGF0dHJpYnV0ZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXNBcmd1bWVudCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzQXJndW1lbnQuZWFjaChmdW5jdGlvbiAoYXR0cmlidXRlQXJndW1lbnQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZUFyZ3VtZW50IGluc3RhbmNlb2YgQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChhdHRyaWJ1dGVBcmd1bWVudC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc1N0cmluZyhhdHRyaWJ1dGVBcmd1bWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkKGF0dHJpYnV0ZUFyZ3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc0FycmF5KGF0dHJpYnV0ZXNBcmd1bWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKGF0dHJpYnV0ZXNBcmd1bWVudCwgZnVuY3Rpb24gKGF0dHJpYnV0ZUFyZ3VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlQXJndW1lbnQgaW5zdGFuY2VvZiBBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkKGF0dHJpYnV0ZUFyZ3VtZW50Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKGF0dHJpYnV0ZUFyZ3VtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoYXR0cmlidXRlQXJndW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc1N0cmluZyhhdHRyaWJ1dGVzQXJndW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoYXR0cmlidXRlc0FyZ3VtZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzQXJndW1lbnQgPSByZXN1bHQ7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoYXR0cmlidXRlc0FyZ3VtZW50ICYmIGV4Y2x1ZGUgPT09IGZhbHNlKXtcblxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNBcmd1bWVudC5lYWNoKGZ1bmN0aW9uKGNvcGllZEF0dHJpYnV0ZSl7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQodmFsdWUoY29waWVkQXR0cmlidXRlKSwgdHVwbGUuZ2V0KHZhbHVlKGNvcGllZEF0dHJpYnV0ZSkpKTtcblxuICAgICAgICAgICAgICAgIH0sIHRoaXMpXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBfLmZvckVhY2godHVwbGUuYXR0cmlidXRlcywgZnVuY3Rpb24gKHR1cGxlQXR0cmlidXRlLCB0dXBsZUF0dHJpYnV0ZUtleSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzQXJndW1lbnQgJiYgZXhjbHVkZSA9PT0gdHJ1ZSl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0V4Y2x1ZGVkQXR0cmlidXRlID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNBcmd1bWVudC5lYWNoKGZ1bmN0aW9uKGV4Y2x1ZGVkQXR0cmlidXRlKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcXVhbChUU3RyaW5nLCBleGNsdWRlZEF0dHJpYnV0ZSwgdHVwbGVBdHRyaWJ1dGVLZXkpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNFeGNsdWRlZEF0dHJpYnV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighaXNFeGNsdWRlZEF0dHJpYnV0ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldCh0dXBsZUF0dHJpYnV0ZUtleSwgdHVwbGVBdHRyaWJ1dGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldCh0dXBsZUF0dHJpYnV0ZUtleSwgdHVwbGVBdHRyaWJ1dGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9LCB0aGlzKVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdCBmb3IgZXF1YWxpdHkgd2l0aCBhbm90aGVyIHR1cGxlXG4gICAgICAgICAqIEBwYXJhbSB7VHVwbGV9IHR1cGxlXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgZXF1YWxzOiBmdW5jdGlvbiAodHVwbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBUdXBsZS5lcXVhbCh0aGlzLCB0dXBsZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgYW4gYXR0cmlidXRlIHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVOYW1lIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUsIHZhbHVlKSB7XG5cbiAgICAgICAgICAgIGlmKHRoaXMucmVsYXRpb24pe1xuXG4gICAgICAgICAgICAgICAgdmFyIGNsb25lID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZvdW5kSW5kZXggPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucmVsYXRpb24uaGVhZGVyKCkuZ2V0KGF0dHJpYnV0ZU5hbWUpLnR5cGUuY29lcmNlKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGNsb25lLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgIC8vIExldCdzIGNoZWNrIGlmIHVwZGF0aW5nIHRoZSB0dXBsZSdzIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgIC8vIHdpbGwgY2F1c2UgYSBkdXBsaWNhdGUgdHVwbGUgaW4gdGhlIHJlbGF0aW9uXG5cbiAgICAgICAgICAgICAgICBpZigoZm91bmRJbmRleCA9IHRoaXMucmVsYXRpb24uaW5kZXgoY2xvbmUpKSAhPT0gbnVsbCAmJiAodGhpcy5yZWxhdGlvbi5hdEluZGV4KGZvdW5kSW5kZXgpICE9PSB0aGlzKSl7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGlvbi5yZW1vdmUodGhpcyk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpb24uZWUuZW1pdCgnYmVmb3JlVXBkYXRlJywgdGhpcywgYXR0cmlidXRlTmFtZSwgdmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9IHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpb24uZWUuZW1pdCgnYWZ0ZXJVcGRhdGUnLCB0aGlzLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID0gdmFsdWU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIGFuZCBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHtBdHRyaWJ1dGV8U3RyaW5nfSBhdHRyaWJ1dGVOYW1lIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxldGVzIGFuIGF0dHJpYnV0ZSBmcm9tIHRoZSB0dXBsZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlTmFtZSBUaGUgYXR0cmlidXRlIG5hbWUgdG8gZGVsZXRlXG4gICAgICAgICAqL1xuICAgICAgICBkZWxldGU6IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbG9uZXMgYSB0dXBsZVxuICAgICAgICAgKiBAcmV0dXJucyB7VHVwbGV9XG4gICAgICAgICAqL1xuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICB2YXIgYXR0cixcbiAgICAgICAgICAgICAgICBuZXdUdXBsZSA9IG5ldyAodGhpcy5jb25zdHJ1Y3RvcikoKTtcblxuICAgICAgICAgICAgXy5mb3JFYWNoKHRoaXMuYXR0cmlidXRlcywgZnVuY3Rpb24gKGF0dHJpYnV0ZSwga2V5KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGF0dHJpYnV0ZS5jbG9uZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ciA9IGF0dHJpYnV0ZS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHIgPSBhdHRyaWJ1dGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbmV3VHVwbGUuc2V0KGtleSwgYXR0cik7XG5cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3VHVwbGU7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0dXBsZVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdG9TdHJpbmcgOiBmdW5jdGlvbigpe1xuXG4gICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgICAgICAgICB2YXIgYXR0ckxlbmd0aCA9IE9iamVjdC5rZXlzKHRoaXMuYXR0cmlidXRlcykubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGF0dHJzID0gWydUdXBsZSh7J107XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihhdHRyaWJ1dGUsIGtleSl7XG5cbiAgICAgICAgICAgICAgICBhdHRycy5wdXNoKGtleS50b1N0cmluZygpKyAnIDogJyArIGF0dHJpYnV0ZS50b1N0cmluZygpKTtcblxuICAgICAgICAgICAgICAgIGlmKGNvdW50ICE9PSBhdHRyTGVuZ3RoLTEpe1xuICAgICAgICAgICAgICAgICAgICBhdHRycy5wdXNoKCcsICcpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY291bnQrKztcblxuICAgICAgICAgICAgfSx0aGlzKTtcblxuICAgICAgICAgICAgYXR0cnMucHVzaCgnfSknKTtcblxuICAgICAgICAgICAgcmV0dXJuIGF0dHJzLmpvaW4oJycpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9PYmplY3QgOiBmdW5jdGlvbihyZWN1cnNpdmUpe1xuXG4gICAgICAgICAgICByZWN1cnNpdmUgPSB0eXBlb2YocmVjdXJzaXZlKSAhPT0gJ3VuZGVmaW5lZCcgPyByZWN1cnNpdmUgOiBmYWxzZTtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oYXR0cmlidXRlLCBrZXkpIHtcblxuICAgICAgICAgICAgICAgIGlmKHJlY3Vyc2l2ZSAmJiAhIXRoaXMucmVsYXRpb24gJiYgISF0aGlzLnJlbGF0aW9uLmdldChrZXkpICYmICh0aGlzLnJlbGF0aW9uLmdldChrZXkpLnR5cGUgPT09IFR1cGxlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGF0dHJpYnV0ZS50b09iamVjdCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIH1cblxuXG4gICAgfSwge1xuXG4gICAgICAgIHR5cGU6ICdUdXBsZScsXG5cbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnVHVwbGUnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlc3QgZm9yIGVxdWFsaXR5IGJldHdlZW4gdHdvIHR1cGxlc1xuICAgICAgICAgKiBAcGFyYW0ge1R1cGxlfSB0dXBsZTFcbiAgICAgICAgICogQHBhcmFtIHtUdXBsZX0gdHVwbGUyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKiBAc3RhdGljXG5cbiAgICAgICAgICovXG4gICAgICAgIGVxdWFsOiBmdW5jdGlvbiAodHVwbGUxLCB0dXBsZTIpIHtcblxuICAgICAgICAgICAgdmFyIGtleTtcblxuICAgICAgICAgICAgaWYgKCEodHVwbGUxIGluc3RhbmNlb2YgVHVwbGUpIHx8ICEodHVwbGUyIGluc3RhbmNlb2YgVHVwbGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCB0dXBsZXMgYXJlIG9mIHRoZSB3cm9uZyB0eXBlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHRydWU7XG5cbiAgICAgICAgICAgIHR1cGxlMS5lYWNoKGZ1bmN0aW9uKGF0dHIsIGtleSl7XG5cbiAgICAgICAgICAgICAgICBpZih0dXBsZTIuZ2V0KGtleSkgPT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoIWVxdWFsKG51bGwsIGF0dHIsIHR1cGxlMi5nZXQoa2V5KSkpe1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIHRoYXQgdHdvIHR1cGxlcyBtYXRjaCBvbiB0aGUgZ2l2ZW4gYXR0cmlidXRlc1xuICAgICAgICAgKiBAcGFyYW0ge1R1cGxlfSB0dXBsZTFcbiAgICAgICAgICogQHBhcmFtIHtUdXBsZX0gdHVwbGUyXG4gICAgICAgICAqIEBwYXJhbSB7QXR0cmlidXRlW119IGF0dHJpYnV0ZXNcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqIEBzdGF0aWNcblxuICAgICAgICAgKi9cbiAgICAgICAgbWF0Y2hPbkF0dHJpYnV0ZXMgOiBmdW5jdGlvbih0dXBsZTEsIHR1cGxlMiwgYXR0cmlidXRlcyl7XG5cbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHRydWU7XG5cbiAgICAgICAgICAgIGF0dHJpYnV0ZXMuZWFjaChmdW5jdGlvbihhdHRyaWJ1dGUpe1xuXG4gICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZS5uYW1lO1xuXG4gICAgICAgICAgICAgICAgaWYoIWVxdWFsKG51bGwsIHR1cGxlMS5nZXQoYXR0cmlidXRlTmFtZSksIHR1cGxlMi5nZXQoYXR0cmlidXRlTmFtZSkpKXtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2VyY2VzIGFuIGFyYml0cmFyeSBvYmplY3QgdG8gdHlwZSBUdXBsZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdHxUdXBsZX0gdHVwbGVcbiAgICAgICAgICogQHBhcmFtIHJlbGF0aW9uIFRoZSBSZWxhdGlvbiB0byB3aGljaCBiZWxvbmdzIHRoZSB0dXBsZS5cbiAgICAgICAgICogQHJldHVybnMge1R1cGxlfVxuICAgICAgICAgKiBAc3RhdGljXG5cbiAgICAgICAgICovXG4gICAgICAgIGNvZXJjZTogZnVuY3Rpb24gKHR1cGxlLCByZWxhdGlvbikge1xuXG5cbiAgICAgICAgICAgIGlmKHR1cGxlIGluc3RhbmNlb2YgVHVwbGUpe1xuXG4gICAgICAgICAgICAgICAgLy8gR2l2ZW4gdHVwbGUgaXMgb2YgdHlwZSBUdXBsZS5cblxuICAgICAgICAgICAgICAgIHJldHVybiB0dXBsZTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGlmKCFfLmlzT2JqZWN0KHR1cGxlKSl7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSXQgaXMgbm90IGFuIG9iamVjdC4gSXQgY2FuJ3QgYmUgY29lcmNlZC5cblxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXcm9uZyBwYXJhbWV0ZXIgdHlwZS4gRXhwZWN0ZWQgYW4gb2JqZWN0IG9yIGEgVHVwbGUnKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEl0IGlzIG5vdCBhIFR1cGxlIGluc3RhbmNlLiBDaGVjayBpZiBpdCBtaWdodCBiZSBjb2VyY2VkLlxuICAgICAgICAgICAgICAgIGlmIChfLmlzQXJyYXkodHVwbGUpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQocmVsYXRpb24pIHx8IF8uaXNOdWxsKHJlbGF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29lcmNlIGFycmF5LWRlY2xhcmVkIHR1cGxlIGlmIG5vIHJlbGF0aW9uIGlzIHNwZWNpZmllZCcpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHJlbGF0aW9uLmhlYWRlcikpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29sbGVjdGlvbiBoYXMgaGVhZGVyXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXIgPSByZWxhdGlvbi5oZWFkZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJDb3VudCA9IGhlYWRlci5sZW5ndGgoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRlckNvdW50ID4gMCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGVhZGVyIGhhcyBvbmUgb3IgbW9yZSBhdHRyaWJ1dGVzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighaGVhZGVyLl9vcmRlcmVkRGVjbGFyYXRpb24pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb2VyY2UgYW4gYXJyYXkgZGVjbGFyZWQgdHVwbGUgaWYgdGhlIGhlYWRlciBoYXMgbm90IGJlZW4gZGVjbGFyZWQgaW4gYXJyYXkgZm9ybWF0JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihoZWFkZXJDb3VudCAhPT0gdHVwbGUubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29lcmNlIFR1cGxlLCBpdCBkb2VzIG5vdCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBhdHRyaWJ1dGVzIGFzIHRoZSBoZWFkZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VHVwbGUgPSBuZXcgVHVwbGUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIGF0dHJpYnV0ZXMgb2YgdGhlIGhlYWRlciBpbiBvcmRlclxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyLmVhY2goZnVuY3Rpb24oYXR0cmlidXRlLCBpbmRleCl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBjb3JyZXNwb25kaW5nIHR1cGxlIGF0dHJpYnV0ZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1R1cGxlLnNldChhdHRyaWJ1dGUubmFtZSwgdHVwbGVbaW5kZXhdKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1R1cGxlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHVwbGUgPSBuZXcgVHVwbGUodHVwbGUpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR1cGxlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVHVwbGU7IiwidmFyIEJhc2UgPSByZXF1aXJlKCcuL0Jhc2UuanMnKTtcblxudmFyIFR5cGUgPSBCYXNlLmV4dGVuZChcbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBUeXBlXG4gICAgICAgICAqIEBleHRlbmRzIEJhc2VcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgICAgICAgICAgLy90aGlzLl92YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgICAgICBCYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xvbmVzIHRoZSBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge1R5cGV9XG4gICAgICAgICAqL1xuICAgICAgICBjbG9uZSA6IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLl92YWx1ZSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVzdHJveXMgdGhlIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgZGVzdHJveSA6IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgfVxuXG4gICAgfSwge1xuXG4gICAgICAgIHR5cGUgOiAnVHlwZScsXG5cbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnVHlwZSdcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZTsiLCJ2YXIgUmVsYXRpb24gPSByZXF1aXJlKCcuLy4uL1JlbGF0aW9uLmpzJyk7XG52YXIgSGVhZGVyID0gcmVxdWlyZSgnLi8uLi9IZWFkZXIuanMnKTtcbnZhciBUdXBsZSA9IHJlcXVpcmUoJy4vLi4vVHVwbGUuanMnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvZGVidWcnKTtcblxudmFyIENvbXBvc2l0aW9uID0gUmVsYXRpb24uZXh0ZW5kKFxuXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgT3BlcmF0b3JzLkNvbXBvc2l0aW9uXG4gICAgICAgICAqIEBleHRlbmRzIFJlbGF0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uQSBUaGUgcmVsYXRpb24gQVxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvbkIgVGhlIHJlbGF0aW9uIEJcbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIENvbXBvc2l0aW9uIG9wZXJhdG9yIHdpbGwgcGVyZm9ybSBhIG5hdHVyYWwgam9pbiBiZXR3ZWVuIEEgYW5kIEIgd2hpbGUgcmVtb3ZpbmcgdGhlIGNvbW1vbiBhdHRyaWJ1dGVzXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25BID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgICAgIHtjaGFyYWN0ZXJJZDogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7Zmlyc3ROYW1lOiB7IHR5cGU6IGFmZmluaXR5LlN0cmluZ319LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2xhc3ROYW1lOiB7IHR5cGU6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWzEsICdKb2huJywgJ0RvZSddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzIsICdNYXJ5JywgJ1BvcHBpbnMnXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFszLCAnTHVja3knLCAnTHVrZSddXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IGNoYXJhY3RlcklkIDogVEludGVnZXIgfCBmaXJzdE5hbWUgOiBUU3RyaW5nIHwgbGFzdE5hbWUgOiBUU3RyaW5nIHxcbiAgICAgICAgICogICAgIC8vICs9PT09PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgLy8gfCAxICAgICAgICAgICAgICAgICAgICAgIHwgSm9obiAgICAgICAgICAgICAgICB8IERvZSAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMiAgICAgICAgICAgICAgICAgICAgICB8IE1hcnkgICAgICAgICAgICAgICAgfCBQb3BwaW5zICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDMgICAgICAgICAgICAgICAgICAgICAgfCBMdWNreSAgICAgICAgICAgICAgIHwgTHVrZSAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7Y2hhcmFjdGVySWQ6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2ZhbjogeyB0eXBlOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsxLCAnTXIgWCddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzEsICdNaXNzIERpYmJsZSddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzIsICdOYXQgQmliYmxlJ11cbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgY2hhcmFjdGVySWQgOiBUSW50ZWdlciB8IGZhbiA6IFRTdHJpbmcgfFxuICAgICAgICAgKiAgICAgLy8gKz09PT09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAvLyB8IDEgICAgICAgICAgICAgICAgICAgICAgfCBNciBYICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAxICAgICAgICAgICAgICAgICAgICAgIHwgTWlzcyBEaWJibGUgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMiAgICAgICAgICAgICAgICAgICAgICB8IE5hdCBCaWJibGUgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25DID0gcmVsYXRpb25BLmNvbXBvc2UocmVsYXRpb25CKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG9yXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25DID0gbmV3IGFmZmluaXR5LkNvbXBvc2l0aW9uKHJlbGF0aW9uQSwgcmVsYXRpb25CKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IGZpcnN0TmFtZSA6IFRTdHJpbmcgfCBsYXN0TmFtZSA6IFRTdHJpbmcgfCBmYW4gOiBUU3RyaW5nIHxcbiAgICAgICAgICogICAgIC8vICs9PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgLy8gfCBKb2huICAgICAgICAgICAgICAgIHwgRG9lICAgICAgICAgICAgICAgIHwgTXIgWCAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgSm9obiAgICAgICAgICAgICAgICB8IERvZSAgICAgICAgICAgICAgICB8IE1pc3MgRGliYmxlICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IE1hcnkgICAgICAgICAgICAgICAgfCBQb3BwaW5zICAgICAgICAgICAgfCBOYXQgQmliYmxlICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy9cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAocmVsYXRpb25BLCByZWxhdGlvbkIpIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gYXJnc1xuICAgICAgICAgICAgICogQHByb3BlcnR5IHtSZWxhdGlvbn0gYXJncy5sZWZ0XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge1JlbGF0aW9ufSBhcmdzLnJpZ2h0XG4gICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgZGVidWcuY29tcG9zZS50cmFjZSgnI2NvbnN0cnVjdG9yJyk7XG5cbiAgICAgICAgICAgIHRoaXMuYXJncyA9IHt9O1xuXG4gICAgICAgICAgICB0aGlzLmFyZ3MubGVmdCA9IHJlbGF0aW9uQTtcblxuICAgICAgICAgICAgdGhpcy5hcmdzLnJpZ2h0ID0gcmVsYXRpb25CO1xuXG4gICAgICAgICAgICBSZWxhdGlvbi5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLmNvbW1vbkF0dHJpYnV0ZXMgPSBudWxsO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYmluZEV2ZW50czogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5jb21wb3NlLnRyYWNlKCcjYmluZEV2ZW50cycpO1xuXG4gICAgICAgICAgICAvLyBDYWxsaW5nIHRoZSBwYXJlbnQgYmluZEV2ZW50c1xuICAgICAgICAgICAgQ29tcG9zaXRpb24uX19zdXBlcl9fLmJpbmRFdmVudHMuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgbGVmdCA9IHRoYXQuYXJncy5sZWZ0O1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhhdC5hcmdzLnJpZ2h0O1xuXG4gICAgICAgICAgICAvLyBiZWZvcmVHZXRIZWFkZXJcbiAgICAgICAgICAgIHRoaXMuZWUub25jZSgnYmVmb3JlR2V0SGVhZGVyJywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGxlZnRIZWFkZXIgPSBsZWZ0LmhlYWRlcigpO1xuICAgICAgICAgICAgICAgIHZhciByaWdodEhlYWRlciA9IHJpZ2h0LmhlYWRlcigpO1xuXG4gICAgICAgICAgICAgICAgZGVidWcuY29tcG9zZS50cmFjZSgnYmVmb3JlR2V0SGVhZGVyJyk7XG5cbiAgICAgICAgICAgICAgICBIZWFkZXIuYXNzZXJ0U2FtZU5hbWVTYW1lVHlwZShsZWZ0SGVhZGVyLCByaWdodEhlYWRlcik7XG5cbiAgICAgICAgICAgICAgICB0aGF0LmNvbW1vbkF0dHJpYnV0ZXMgPSBIZWFkZXIuY29tbW9uQXR0cmlidXRlcyhsZWZ0SGVhZGVyLCByaWdodEhlYWRlcik7XG5cbiAgICAgICAgICAgICAgICB0aGF0LmxlZnRBdHRyaWJ1dGVzID0gbGVmdEhlYWRlci5zZXREaWZmZXJlbmNlKHRoYXQuY29tbW9uQXR0cmlidXRlcyk7XG5cbiAgICAgICAgICAgICAgICB0aGF0LnJpZ2h0QXR0cmlidXRlcyA9IHJpZ2h0SGVhZGVyLnNldERpZmZlcmVuY2UodGhhdC5jb21tb25BdHRyaWJ1dGVzKTtcblxuICAgICAgICAgICAgICAgIHRoYXQuaGVhZGVyKCkuY29weShsZWZ0SGVhZGVyLnNldFVuaW9uKHJpZ2h0SGVhZGVyKS5zZXREaWZmZXJlbmNlKHRoYXQuY29tbW9uQXR0cmlidXRlcykpO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gYmVmb3JlR2V0Qm9keVxuICAgICAgICAgICAgdGhpcy5lZS5vbmNlKCdiZWZvcmVHZXRCb2R5JywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgZGVidWcuY29tcG9zZS50cmFjZSgnYmVmb3JlR2V0Qm9keScpO1xuXG4gICAgICAgICAgICAgICAgbGVmdC5lYWNoKGZ1bmN0aW9uICh0dXBsZSkgeyB0aGF0LmRvQWZ0ZXJBZGQobGVmdCwgdHVwbGUpOyB9KTtcblxuICAgICAgICAgICAgICAgIHJpZ2h0LmVhY2goZnVuY3Rpb24gKHR1cGxlKSB7IHRoYXQuZG9BZnRlckFkZChyaWdodCwgdHVwbGUpO30pO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbGVmdC5lZS5vbignYWZ0ZXJBZGQnLCBmdW5jdGlvbih0dXBsZSl7XG5cbiAgICAgICAgICAgICAgICB0aGF0LmRvQWZ0ZXJBZGQobGVmdCwgdHVwbGUpO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmlnaHQuZWUub24oJ2FmdGVyQWRkJywgZnVuY3Rpb24odHVwbGUpe1xuXG4gICAgICAgICAgICAgICAgdGhhdC5kb0FmdGVyQWRkKHJpZ2h0LCB0dXBsZSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsZWZ0LmVlLm9uKCdhZnRlclJlbW92ZScsIGZ1bmN0aW9uKHR1cGxlLCBpbmRleCl7XG5cbiAgICAgICAgICAgICAgICB0aGF0LmRvQWZ0ZXJSZW1vdmUobGVmdCwgdHVwbGUpO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmlnaHQuZWUub24oJ2FmdGVyUmVtb3ZlJywgZnVuY3Rpb24odHVwbGUsIGluZGV4KXtcblxuICAgICAgICAgICAgICAgIHRoYXQuZG9BZnRlclJlbW92ZShyaWdodCwgdHVwbGUpO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbGVmdC5lZS5vbignYWZ0ZXJVcGRhdGUnLCBmdW5jdGlvbih0dXBsZSwgYXR0cmlidXRlTmFtZSwgdmFsdWUpe1xuXG4gICAgICAgICAgICAgICAgdGhhdC5kb0FmdGVyVXBkYXRlKGxlZnQsIHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByaWdodC5lZS5vbignYWZ0ZXJVcGRhdGUnLCBmdW5jdGlvbih0dXBsZSwgYXR0cmlidXRlTmFtZSwgdmFsdWUpe1xuXG4gICAgICAgICAgICAgICAgdGhhdC5kb0FmdGVyVXBkYXRlKHJpZ2h0LCB0dXBsZSwgYXR0cmlidXRlTmFtZSwgdmFsdWUpO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBoYW5kbGVyIHdoZW4gdHVwbGVzIGFyZSBhZGRlZCB0byB0aGUgYmFzZSByZWxhdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHtSZWxhdGlvbn0gcmVsYXRpb24gcmVsYXRpb24gaW4gd2hpY2ggdGhlIHR1cGxlIHdhcyBhZGRlZFxuICAgICAgICAgKiBAcGFyYW0ge1R1cGxlfSB0dXBsZTEgdGhlIHR1cGxlIHRoYXQgd2FzIGFkZGVkXG4gICAgICAgICAqL1xuICAgICAgICBkb0FmdGVyQWRkIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlMSl7XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIG90aGVyUmVsYXRpb24gPSAocmVsYXRpb24gPT09IHRoYXQuYXJncy5sZWZ0ID8gdGhhdC5hcmdzLnJpZ2h0IDogdGhhdC5hcmdzLmxlZnQpO1xuXG4gICAgICAgICAgICBvdGhlclJlbGF0aW9uLmVhY2goZnVuY3Rpb24odHVwbGUyKXtcblxuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IFR1cGxlLm1hdGNoT25BdHRyaWJ1dGVzKHR1cGxlMSwgdHVwbGUyLCB0aGF0LmNvbW1vbkF0dHJpYnV0ZXMpO1xuXG4gICAgICAgICAgICAgICAgaWYobWF0Y2gpe1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21iaW5lZFR1cGxlID0gXy5leHRlbmQoe30sIHR1cGxlMS5hdHRyaWJ1dGVzLCB0dXBsZTIuYXR0cmlidXRlcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1R1cGxlID0gbmV3IFR1cGxlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhhdC5oZWFkZXIoKS5lYWNoKGZ1bmN0aW9uKGNvbXBvc2VBdHRyaWJ1dGUpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG9zZUF0dHJpYnV0ZU5hbWUgPSBjb21wb3NlQXR0cmlidXRlLm5hbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1R1cGxlLnNldChjb21wb3NlQXR0cmlidXRlTmFtZSwgY29tYmluZWRUdXBsZVtjb21wb3NlQXR0cmlidXRlTmFtZV0pXG5cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhhdC5hZGQobmV3VHVwbGUpO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgaGFuZGxlciB3aGVuIHR1cGxlcyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBiYXNlIHJlbGF0aW9ucy5cbiAgICAgICAgICogQHBhcmFtIHtSZWxhdGlvbn0gcmVsYXRpb24gUmVsYXRpb24gaW4gd2hpY2ggdGhlIHR1cGxlIHdhcyByZW1vdmVkXG4gICAgICAgICAqIEBwYXJhbSB7VHVwbGV9IHJlbW92ZWRUdXBsZSBUaGUgdHVwbGUgdGhhdCB3YXMgcmVtb3ZlZFxuICAgICAgICAgKi9cbiAgICAgICAgZG9BZnRlclJlbW92ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCByZW1vdmVkVHVwbGUpe1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBub25Db21tb25BdHRyaWJ1dGVzID0gKHJlbGF0aW9uID09PSB0aGF0LmFyZ3MubGVmdCA/IHRoYXQubGVmdEF0dHJpYnV0ZXMgOiB0aGF0LnJpZ2h0QXR0cmlidXRlcyk7XG5cbiAgICAgICAgICAgIC8vIEZpbmQgdHVwbGVzIHdoaWNoIG1hdGNoIHRoZSByZW1vdmVkIHR1cGxlIG9uIGl0cyBhdHRyaWJ1dGVzXG5cbiAgICAgICAgICAgIHRoYXQuZWFjaChmdW5jdGlvbih0dXBsZSwgaW5kZXgpe1xuXG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gVHVwbGUubWF0Y2hPbkF0dHJpYnV0ZXModHVwbGUsIHJlbW92ZWRUdXBsZSwgbm9uQ29tbW9uQXR0cmlidXRlcyk7XG5cbiAgICAgICAgICAgICAgICBpZihtYXRjaCl7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhhdC5yZW1vdmVBdChpbmRleCk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGhhbmRsZXIgd2hlbiB0dXBsZXMgYXJlIHVwZGF0ZWQgaW4gdGhlIGJhc2UgcmVsYXRpb25zXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uIFRoZSByZWxhdGlvbiB3aGVyZSB0aGUgdHVwbGUgd2FzIHVwZGF0ZWRcbiAgICAgICAgICogQHBhcmFtIHtUdXBsZX0gdHVwbGUgVGhlIHR1cGxlIHRoYXQgd2FzIHVwZGF0ZWRcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0aGF0IHdhcyB1cGRhdGVkXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICAgICAqL1xuICAgICAgICBkb0FmdGVyVXBkYXRlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpe1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBvdGhlclJlbGF0aW9uID0gKHJlbGF0aW9uID09PSB0aGF0LmFyZ3MubGVmdCA/IHRoYXQuYXJncy5yaWdodCA6IHRoYXQuYXJncy5sZWZ0KTtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuYXJncy5sZWZ0LmNvbXBvc2UodGhpcy5hcmdzLnJpZ2h0KTtcblxuICAgICAgICAgICAgdGhhdC5hZGp1c3RUbyhyZXN1bHQpO1xuXG4gICAgICAgIH1cblxuICAgIH0sIHtcblxuICAgICAgICB0eXBlIDogJ0NvbXBvc2l0aW9uJ1xuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9zaXRpb247IiwidmFyIFJlbGF0aW9uID0gcmVxdWlyZSgnLi8uLi9SZWxhdGlvbi5qcycpO1xudmFyIEhlYWRlciA9IHJlcXVpcmUoJy4vLi4vSGVhZGVyLmpzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2RlYnVnJyk7XG5cbnZhciBEaWZmZXJlbmNlID0gUmVsYXRpb24uZXh0ZW5kKFxuXG5cbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBPcGVyYXRvcnMuRGlmZmVyZW5jZVxuICAgICAgICAgKiBAZXh0ZW5kcyBSZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSBsZWZ0IFRoZSByZWxhdGlvbiBmcm9tIHdoaWNoIHRvIHJlbW92ZSB0aGUgdHVwbGVzXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJpZ2h0IFRoZSByZWxhdGlvbiB0aGF0IHdpbGwgYmUgc3Vic3RyYWN0ZWQgZnJvbSB0aGUgb3RoZXJcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIERpZmZlcmVuY2Ugb3BlcmF0aW9uIGdpdmVzIHRoZSBmaXJzdCByZWxhdGlvbidzIHR1cGxlcyBtaW51cyB0aG9zZSB0aGF0IGFyZSBpbiB0aGUgc2Vjb25kIHJlbGF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGxlZnQgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge2E6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2I6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2M6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19XG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWzEsIDIsIDNdLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzQsIDUsIDZdLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzcsIDgsIDldXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuXG4gICAgICAgICAqICAgICB2YXIgcmlnaHQgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge2E6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2I6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2M6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19XG4gICAgICAgICAqICAgICAgICAgIF0sIFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsxLCAyLCAzXVxuICAgICAgICAgKiAgICAgICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWwzID0gbGVmdC5kaWZmZXJlbmNlKHJpZ2h0KTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG9yXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsNCA9IG5ldyBhZmZpbml0eS5EaWZmZXJlbmNlKGxlZnQsIHJpZ2h0KVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBhIDogVEludGVnZXIgfCBiIDogVEludGVnZXIgfCBjIDogVEludGVnZXIgfFxuICAgICAgICAgKiAgICAgLy8gKz09PT09PT09PT09PT09Kz09PT09PT09PT09PT09Kz09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgLy8gfCA0ICAgICAgICAgICAgfCA1ICAgICAgICAgICAgfCA2ICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCA3ICAgICAgICAgICAgfCA4ICAgICAgICAgICAgfCA5ICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5kaWZmZXJlbmNlLnRyYWNlKCcjY29uc3RydWN0b3InKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gYXJnc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmFyZ3MgPSB7fTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge1JlbGF0aW9ufSBsZWZ0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuYXJncy5sZWZ0ID0gbGVmdDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge1JlbGF0aW9ufSByaWdodFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmFyZ3MucmlnaHQgPSByaWdodDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge1JlbGF0aW9uW119IHJlbGF0aW9uc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmFyZ3MucmVsYXRpb25zID0gW2xlZnQsIHJpZ2h0XTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGNvbXB1dGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gQ2FsbHMgdGhlIHBhcmVudCBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgUmVsYXRpb24uY2FsbCh0aGlzKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgYmluZEV2ZW50czogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5kaWZmZXJlbmNlLnRyYWNlKCcjYmluZEV2ZW50cycpO1xuXG4gICAgICAgICAgICBEaWZmZXJlbmNlLl9fc3VwZXJfXy5iaW5kRXZlbnRzLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIGxlZnQgPSB0aGF0LmFyZ3MubGVmdDtcbiAgICAgICAgICAgIHZhciByaWdodCA9IHRoYXQuYXJncy5yaWdodDtcblxuICAgICAgICAgICAgLy8gQmVmb3JlR2V0SGVhZGVyXG4gICAgICAgICAgICB0aGlzLmVlLm9uY2UoJ2JlZm9yZUdldEhlYWRlcicsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIHZhciBsZWZ0SGVhZGVyID0gbGVmdC5oZWFkZXIoKTtcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHRIZWFkZXIgPSByaWdodC5oZWFkZXIoKTtcblxuICAgICAgICAgICAgICAgIGRlYnVnLmRpZmZlcmVuY2UudHJhY2UoJ2JlZm9yZUdldEhlYWRlcicpO1xuXG4gICAgICAgICAgICAgICAgSGVhZGVyLmFzc2VydFVuaW9uQ29tcGF0aWJsZShsZWZ0SGVhZGVyLCByaWdodEhlYWRlcik7XG5cbiAgICAgICAgICAgICAgICB0aGF0LmhlYWRlcigpLmNvcHkobGVmdEhlYWRlcik7XG5cbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgIC8vIEJlZm9yZUdldEJvZHlcbiAgICAgICAgICAgIHRoaXMuZWUub25jZSgnYmVmb3JlR2V0Qm9keScsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIGRlYnVnLmRpZmZlcmVuY2UudHJhY2UoJ2JlZm9yZUdldEJvZHknKTtcblxuICAgICAgICAgICAgICAgIGxlZnQuZWFjaChmdW5jdGlvbiAodHVwbGUxKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0LmluZGV4KHR1cGxlMSkgPT09IG51bGwpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5hZGQodHVwbGUxLmNsb25lKCksIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRoYXQuY29tcHV0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbGVmdC5lZS5vbignYWZ0ZXJBZGQnLCBmdW5jdGlvbih0dXBsZSwgaW5kZXgpe1xuICAgICAgICAgICAgICAgIHRoYXQuYWZ0ZXJMZWZ0QWRkKGxlZnQsIHR1cGxlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByaWdodC5lZS5vbignYWZ0ZXJBZGQnLCBmdW5jdGlvbih0dXBsZSwgaW5kZXgpe1xuICAgICAgICAgICAgICAgIHRoYXQuYWZ0ZXJSaWdodEFkZChsZWZ0LCB0dXBsZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbGVmdC5lZS5vbignYWZ0ZXJSZW1vdmUnLCBmdW5jdGlvbih0dXBsZSwgaW5kZXgpe1xuICAgICAgICAgICAgICAgIHRoYXQuYWZ0ZXJMZWZ0UmVtb3ZlKHJpZ2h0LCB0dXBsZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmlnaHQuZWUub24oJ2FmdGVyUmVtb3ZlJywgZnVuY3Rpb24odHVwbGUsIGluZGV4KXtcbiAgICAgICAgICAgICAgICB0aGF0LmFmdGVyUmlnaHRSZW1vdmUocmlnaHQsIHR1cGxlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsZWZ0LmVlLm9uKCdhZnRlclVwZGF0ZScsIGZ1bmN0aW9uKHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpe1xuICAgICAgICAgICAgICAgIHRoYXQuYWZ0ZXJMZWZ0VXBkYXRlKGxlZnQsIHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJpZ2h0LmVlLm9uKCdhZnRlclVwZGF0ZScsIGZ1bmN0aW9uKHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpe1xuICAgICAgICAgICAgICAgIHRoYXQuYWZ0ZXJSaWdodFVwZGF0ZShyaWdodCwgdHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiB0dXBsZXMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgbGVmdCByZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1R1cGxlfSByZW1vdmVkVHVwbGVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGFmdGVyTGVmdFJlbW92ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCByZW1vdmVkVHVwbGUpe1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgdHVwbGUgaXMgbm90IHByZXNlbnQgaW4gdGhlIHJpZ2h0IHJlbGF0aW9uLFxuICAgICAgICAgICAgLy8gcmVtb3ZlIGl0XG4gICAgICAgICAgICBpZih0aGlzLmNvbXB1dGVkICYmIHRoaXMuYXJncy5yaWdodC5pbmRleChyZW1vdmVkVHVwbGUpID09PSBudWxsKXtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShyZW1vdmVkVHVwbGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHR1cGxlcyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSByaWdodCByZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1R1cGxlfSByZW1vdmVkVHVwbGVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGFmdGVyUmlnaHRSZW1vdmUgOiBmdW5jdGlvbihyZWxhdGlvbiwgcmVtb3ZlZFR1cGxlKXtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIHR1cGxlIGlzIHByZXNlbnQgaW4gdGhlIGxlZnQgcmVsYXRpb24sXG4gICAgICAgICAgICAvLyBhZGQgaXQuXG4gICAgICAgICAgICBpZih0aGlzLmNvbXB1dGVkICYmIHRoaXMuYXJncy5sZWZ0LmluZGV4KHJlbW92ZWRUdXBsZSkgIT09IG51bGwpe1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHJlbW92ZWRUdXBsZS5jbG9uZSgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiB0dXBsZXMgYXJlIGFkZGVkIHRvIHRoZSBsZWZ0IGJhc2UgcmVsYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtSZWxhdGlvbn0gcmVsYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtUdXBsZX0gYWRkZWRUdXBsZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgYWZ0ZXJMZWZ0QWRkIDogZnVuY3Rpb24ocmVsYXRpb24sIGFkZGVkVHVwbGUpe1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgdHVwbGUgaXMgbm90IGluIHRoZSByaWdodFxuICAgICAgICAgICAgLy8gcmVsYXRpb24sIGFkZCBpdC5cbiAgICAgICAgICAgIGlmKHRoaXMuY29tcHV0ZWQgJiYgdGhpcy5hcmdzLnJpZ2h0LmluZGV4KGFkZGVkVHVwbGUpID09PSBudWxsKXtcblxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGFkZGVkVHVwbGUuY2xvbmUoKSk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiB0dXBsZXMgYXJlIGFkZGVkIHRvIHRoZSByaWdodCBiYXNlIHJlbGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7VHVwbGV9IGFkZGVkVHVwbGVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGFmdGVyUmlnaHRBZGQgOiBmdW5jdGlvbihyZWxhdGlvbiwgYWRkZWRUdXBsZSl7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSB0dXBsZSBpcyBwcmVzZW50IGluIHRoZSBsZWZ0XG4gICAgICAgICAgICAvLyByZWxhdGlvbiwgcmVtb3ZlIGl0LlxuICAgICAgICAgICAgaWYodGhpcy5jb21wdXRlZCAmJiB0aGlzLmFyZ3MubGVmdC5pbmRleChhZGRlZFR1cGxlKSAhPT0gbnVsbCl7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShhZGRlZFR1cGxlKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHR1cGxlcyBhcmUgdXBkYXRlZCBvbiB0aGUgbGVmdCByZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufXJlbGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7VHVwbGV9IHR1cGxlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVOYW1lXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgYWZ0ZXJMZWZ0VXBkYXRlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpe1xuXG4gICAgICAgICAgICBpZih0aGlzLmNvbXB1dGVkKXtcblxuICAgICAgICAgICAgICAgIHZhciBvbGRSaWdodEluZGV4LCByaWdodEluZGV4LCBvbGRUdXBsZTtcblxuICAgICAgICAgICAgICAgIG9sZFR1cGxlID0gdHVwbGUuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIG9sZFR1cGxlLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPSBvbGRWYWx1ZTtcblxuICAgICAgICAgICAgICAgIG9sZFJpZ2h0SW5kZXggPSB0aGlzLmFyZ3MucmlnaHQuaW5kZXgob2xkVHVwbGUpO1xuICAgICAgICAgICAgICAgIHJpZ2h0SW5kZXggPSB0aGlzLmFyZ3MucmlnaHQuaW5kZXgodHVwbGUpO1xuXG4gICAgICAgICAgICAgICAgaWYob2xkUmlnaHRJbmRleCA9PT0gbnVsbCAmJiByaWdodEluZGV4ID09PSBudWxsKXtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmQob2xkVHVwbGUpLnNldChhdHRyaWJ1dGVOYW1lLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9sZFJpZ2h0SW5kZXggPT09IG51bGwgJiYgcmlnaHRJbmRleCAhPT0gbnVsbCl7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUob2xkVHVwbGUpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvbGRSaWdodEluZGV4ICE9PSBudWxsICYmIHJpZ2h0SW5kZXggPT09IG51bGwpe1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKHR1cGxlLmNsb25lKCkpO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiB0dXBsZXMgYXJlIHVwZGF0ZWQgb24gdGhlIHJpZ2h0IHJlbGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259cmVsYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtUdXBsZX0gdHVwbGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWVcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAgICAgKiBAcGFyYW0geyp9IG9sZFZhbHVlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBhZnRlclJpZ2h0VXBkYXRlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpe1xuXG4gICAgICAgICAgICBpZih0aGlzLmNvbXB1dGVkKXtcblxuICAgICAgICAgICAgICAgIHZhciBvbGRMZWZ0SW5kZXgsIGxlZnRJbmRleCwgb2xkVHVwbGU7XG5cbiAgICAgICAgICAgICAgICBvbGRUdXBsZSA9IHR1cGxlLmNsb25lKCk7XG5cbiAgICAgICAgICAgICAgICBvbGRUdXBsZS5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID0gb2xkVmFsdWU7XG5cbiAgICAgICAgICAgICAgICBvbGRMZWZ0SW5kZXggPSB0aGlzLmFyZ3MubGVmdC5pbmRleChvbGRUdXBsZSk7XG4gICAgICAgICAgICAgICAgbGVmdEluZGV4ID0gdGhpcy5hcmdzLmxlZnQuaW5kZXgodHVwbGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9sZExlZnRJbmRleCA9PT0gbnVsbCAmJiBsZWZ0SW5kZXggIT09IG51bGwpe1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKHR1cGxlKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2xkTGVmdEluZGV4ICE9PSBudWxsICYmIGxlZnRJbmRleCAhPT0gbnVsbCl7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQob2xkVHVwbGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKHR1cGxlKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2xkTGVmdEluZGV4ICE9PSBudWxsICYmIGxlZnRJbmRleCA9PT0gbnVsbCl7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQob2xkVHVwbGUpO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LCB7XG5cbiAgICAgICAgdHlwZSA6ICdEaWZmZXJlbmNlJ1xuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGlmZmVyZW5jZTsiLCJ2YXIgUmVsYXRpb24gPSByZXF1aXJlKCcuLy4uL1JlbGF0aW9uLmpzJyk7XG52YXIgSGVhZGVyID0gcmVxdWlyZSgnLi8uLi9IZWFkZXIuanMnKTtcbnZhciBBdHRyaWJ1dGUgPSByZXF1aXJlKCcuLy4uL0F0dHJpYnV0ZS5qcycpO1xudmFyIFR1cGxlID0gcmVxdWlyZSgnLi8uLi9UdXBsZS5qcycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9kZWJ1ZycpO1xuXG52YXIgRXh0ZW5kID0gUmVsYXRpb24uZXh0ZW5kKFxuICAgIHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHJlbGF0aW9uLCBleHByZXNzaW9ucykge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAY2xhc3MgT3BlcmF0b3JzLkV4dGVuc2lvblxuICAgICAgICAgICAgICogQGV4dGVuZHMgUmVsYXRpb25cbiAgICAgICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uIFR7aGUgcmVsYXRpb24gZnJvbSB3aGljaCB0byByZW1vdmUgdGhlIHR1cGxlc1xuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3RbXX0gZXhwcmVzc2lvbnMgVGhlIGFyZ3VtZW50cyBmcm9tIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgbmV3IGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGUgRXh0ZW5kIG9wZXJhdGlvbiBhbGxvd3MgdGhlIGFkZGl0aW9uIG9mIGNhbGN1bGF0ZWQge0BsaW5rIEhlYWRlcn0ge0BsaW5rIEF0dHJpYnV0ZX1zXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgIHZhciByZWxhdGlvbkEgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgICAgICogICAgICAgICAgICAgIHtuYW1lOiB7IHR5cGU6IGFmZmluaXR5LlN0cmluZ319LFxuICAgICAgICAgICAgICogICAgICAgICAgICAgIHtib3JuOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICAgICAqICAgICAgICAgICAgICB7ZGllZDogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX1cbiAgICAgICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgICAgICogICAgICAgICAgICAgIFsnQXJpc3RvdGxlJywgLTM4NCwgLTMyMl0sXG4gICAgICAgICAgICAgKiAgICAgICAgICAgICAgWydQbGF0bycsICAgICAtNDI4LCAtMzQ4XSxcbiAgICAgICAgICAgICAqICAgICAgICAgICAgICBbJ1NvY3JhdGVzJywgIC00NzAsIC0zOTldXG4gICAgICAgICAgICAgKiAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgdmFyIGJvcm4gPSByZWxhdGlvbkEuZ2V0KCdib3JuJyk7XG4gICAgICAgICAgICAgKiAgICAgdmFyIGRpZWQgPSByZWxhdGlvbkEuZ2V0KCdkaWVkJyk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgIHZhciByZWxhdGlvbkIgPSByZWxhdGlvbkEuZXh0ZW5kKFt7IGxpdmVkIDogZGllZC5taW51cyhib3JuKSB9XSk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgIC8vb3JcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgLy8gTElWRUQgPSBESUVEIC0gQk9STlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICB2YXIgcmVsYXRpb25CID0gbmV3IGFmZmluaXR5LkV4dGVuZChyZWxhdGlvbkEsIFt7IGxpdmVkIDogZGllZC5taW51cyhib3JuKSB9XSk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwtRVhURU5ERUQgQVRUUi0tPlxuICAgICAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICAgICAqICAgICAvLyB8IG5hbWUgOiBUU3RyaW5nIHwgYm9ybiA6IFRJbnRlZ2VyIHwgZGllZCA6IFRJbnRlZ2VyIHwgbGl2ZWQgOiBUSW50ZWdlciB8XG4gICAgICAgICAgICAgKiAgICAgLy8gKz09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgICAgICogICAgIC8vIHwgQXJpc3RvdGxlICAgICAgfCAtMzg0ICAgICAgICAgICAgfCAtMzIyICAgICAgICAgICAgfCA2MiAgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAgICAgKiAgICAgLy8gfCBQbGF0byAgICAgICAgICB8IC00MjggICAgICAgICAgICB8IC0zNDggICAgICAgICAgICB8IDgwICAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICAgICAqICAgICAvLyB8IFNvY3JhdGVzICAgICAgIHwgLTQ3MCAgICAgICAgICAgIHwgLTM5OSAgICAgICAgICAgIHwgNzEgICAgICAgICAgICAgICB8XG4gICAgICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgICAgICogICAgIC8vXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgIC8vIFBvc3NpYmxlIHRvIGFkZCBtdWx0aXBsZSBhdHRyaWJ1dGVzIGluIG9uZSBjYWxsIDpcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgLy8gTElWRUQgPSBESUVEIC0gQk9STiwgU0lOQ0UgPSBZRUFSKE5PVygpKS1ESUVEXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgIHZhciByZWxhdGlvbkIgPSBuZXcgYWZmaW5pdHkuRXh0ZW5kKHJlbGF0aW9uQSwgW1xuICAgICAgICAgICAgICogICAgICAgICAgeyBsaXZlZCA6IGRpZWQubWludXMoYm9ybikgfSxcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgc2luY2U6IGFmZmluaXR5LnllYXIoYWZmaW5pdHkubm93KCkpLm1pbnVzKGRpZWQpIH1cbiAgICAgICAgICAgICAqICAgICBdKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC1FWFRFTkRFRCBBVFRSLS0+IDwtRVhURU5ERUQgQVRUUi0tPlxuICAgICAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAgICAgKiAgICAgLy8gfCBuYW1lIDogVFN0cmluZyB8IGJvcm4gOiBUSW50ZWdlciB8IGRpZWQgOiBUSW50ZWdlciB8IGxpdmVkIDogVEludGVnZXIgfCBzaW5jZSA6IFRJbnRlZ2VyIHxcbiAgICAgICAgICAgICAqICAgICAvLyArPT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgICAgICogICAgIC8vIHwgQXJpc3RvdGxlICAgICAgfCAtMzg0ICAgICAgICAgICAgfCAtMzIyICAgICAgICAgICAgfCA2MiAgICAgICAgICAgICAgIHwgMjMzNSAgICAgICAgICAgICB8XG4gICAgICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICAgICAqICAgICAvLyB8IFBsYXRvICAgICAgICAgIHwgLTQyOCAgICAgICAgICAgIHwgLTM0OCAgICAgICAgICAgIHwgODAgICAgICAgICAgICAgICB8IDIzNjIgICAgICAgICAgICAgfFxuICAgICAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAgICAgKiAgICAgLy8gfCBTb2NyYXRlcyAgICAgICB8IC00NzAgICAgICAgICAgICB8IC0zOTkgICAgICAgICAgICB8IDcxICAgICAgICAgICAgICAgfCAyNDEzICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgICAgICogICAgIC8vXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgIC8vIFBvc3NpYmxlIHRvIGhhdmUgY3VzdG9tIGRlZmluZWQgZnVuY3Rpb25zXG4gICAgICAgICAgICAgKiAgICAgLy8gQmV3YXJlIHRob3VnaCB0byByZXR1cm4gdGhlIHJpZ2h0IGRhdGEgdHlwZSAoZGl2aXNpb25zIGJ5IHplcm8sIHRhbijPgC8yKSwgLi4uKVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICAvLyBZb3UgbWF5IGFzIHdlbGwgdXNlIHRoaXMgZmVhdHVyZSwgYnV0IHNpbmNlIGFmZmluaXR5IHdpbGwgbGF0ZXIgYmUgYSBTUUwgcGFyc2VyIHRvbyxcbiAgICAgICAgICAgICAqICAgICAvLyBpdCB3aWxsIG9idmlvdXNseSBub3Qgc3VwcG9ydCB0aGUgdHJhbnNsYXRpb24gb2YgY3VzdG9tIGRlZmluZWQgZnVuY3Rpb25zIGludG8gU1FMIGNvZGUuXG4gICAgICAgICAgICAgKiAgICAgLy8gSWYgeW91IHBsYW4gaGF2ZSB1c2Ugb2YgYWZmaW5pdHkncyBmdXR1cmUgU1FMIHBhcnNlciwgYmV3YXJlIHRoYXQgdGhlc2UgY3VzdG9tIGZ1bmN0aW9uc1xuICAgICAgICAgICAgICogICAgIC8vIHdpbGwgb25seSBydW4gaW4gamF2YXNjcmlwdCwgYmVjYXVzZSB3ZSBuZWVkIHRoZSBBU1Qgc28gd2UgY2FuIGNvbnZlcnQgaXQgdG8gU1FMLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICAvLyBJIHdvdWxkIGhhdmUgbG92ZWQgamF2YXNjcmlwdCB0byBzdXBwb3J0IG92ZXJsb2FkaW5nIG9mIG9wZXJhdG9ycywgYnV0IHRoYXQgd29uJ3RcbiAgICAgICAgICAgICAqICAgICAvLyBoYXBwZW4gYW55dGltZSBzb29uLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICB2YXIgcmVsYXRpb25CID0gcmVsYXRpb24uZXh0ZW5kKFtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgICAgICB7J2xpdmVkJyA6IHtmdW5jdGlvbih0dXBsZSl7XG4gICAgICAgICAgICAgKiAgICAgICAgICAgICAgcmV0dXJuIHR1cGxlLmdldCgnZGllZCcpLXR1cGxlLmdldCgnYm9ybicpO1xuICAgICAgICAgICAgICogICAgICAgICAgfSwgdHlwZSA6IGFmZmluaXR5LkludGVnZXJ9LFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICAgICAgIHsnZGllZCcgOiB7ZnVuY3Rpb24odHVwbGUpe1xuICAgICAgICAgICAgICogICAgICAgICAgICAgIHJldHVybiAyMDE0IC0gdHVwbGUuZ2V0KCdkaWVkJylcbiAgICAgICAgICAgICAqICAgICAgICAgIH0sIHR5cGUgOiBhZmZpbml0eS5JbnRlZ2VyfSxcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgXSk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIGRlYnVnLmV4dGVuZC50cmFjZSgnI2NvbnN0cnVjdG9yJyk7XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBhcmdzXG4gICAgICAgICAgICAqIEBwcm9wZXJ0eSB7UmVsYXRpb259IGFyZ3MucmVsYXRpb25cbiAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheX0gYXJncy5leHByZXNzaW9uc1xuICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgdGhpcy5hcmdzID0ge307XG5cbiAgICAgICAgICAgIHRoaXMuYXJncy5yZWxhdGlvbiA9IHJlbGF0aW9uO1xuXG4gICAgICAgICAgICB0aGlzLmFyZ3MuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcblxuICAgICAgICAgICAgLy8gQ29lcmNlIHRoZSBhcmd1bWVudCB0byBhbiBhcnJheSBpZiBpdCBpcyBub3QgYWxyZWFkeVxuXG4gICAgICAgICAgICBpZiAoIV8uaXNBcnJheSh0aGlzLmFyZ3MuZXhwcmVzc2lvbnMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcmdzLmV4cHJlc3Npb25zID0gW3RoaXMuYXJncy5leHByZXNzaW9uc107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRocm93IGFuIGVycm9yIGlmIHRoZSBleHByZXNzaW9uIGFycmF5IGlzIG9mIGxlbmd0aCAwXG4gICAgICAgICAgICBpZiAodGhpcy5hcmdzLmV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgZGVmaW5lIGV4cHJlc3Npb25zIScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWxhdGlvbi5jYWxsKHRoaXMpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYmluZEV2ZW50czogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5leHRlbmQudHJhY2UoJyNiaW5kRXZlbnRzJyk7XG5cbiAgICAgICAgICAgIC8vIENhbGxpbmcgdGhlIHBhcmVudCBiaW5kRXZlbnRzXG4gICAgICAgICAgICBFeHRlbmQuX19zdXBlcl9fLmJpbmRFdmVudHMuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSB0aGF0LmFyZ3MuZXhwcmVzc2lvbnM7XG5cbiAgICAgICAgICAgIHZhciByZWxhdGlvbiA9IHRoYXQuYXJncy5yZWxhdGlvbjtcblxuICAgICAgICAgICAgLy8vIEJlZm9yZUdldEhlYWRlclxuXG4gICAgICAgICAgICB0aGlzLmVlLm9uY2UoJ2JlZm9yZUdldEhlYWRlcicsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIGRlYnVnLmV4dGVuZC50cmFjZSgnYmVmb3JlR2V0SGVhZGVyJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGJhc2UgcmVsYXRpb25cblxuICAgICAgICAgICAgICAgIHRoYXQuaGVhZGVyKCkuY29weShyZWxhdGlvbi5oZWFkZXIoKSk7XG5cbiAgICAgICAgICAgICAgICAvLy8gUGFyc2UgZXh0ZW5zaW9uIGF0dHJpYnV0ZXNcblxuICAgICAgICAgICAgICAgIF8uZm9yT3duKGV4cHJlc3Npb25zLCBmdW5jdGlvbiAoZXhwcmVzc2lvbiwga2V5KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwcmVzc2lvbiBtdXN0IGJlIGFuIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICBpZiAoIV8uaXNPYmplY3QoZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dyb25nIGV4cHJlc3Npb24gZm9ybWF0JylcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXhwcmVzc2lvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwcmVzc2lvbiBtdXN0IGhhdmUgb25seSBvbmUgcGFyYW1ldGVyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmhhbmRsZWQgZXhwcmVzc2lvbiBkZWNsYXJhdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIGFkZFxuICAgICAgICAgICAgICAgICAgICB2YXIgZXh0ZW5zaW9uTmFtZSA9IGtleXNbMF07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICB2YXIgZXh0ZW5zaW9uUGFyYW0gPSBleHByZXNzaW9uW2V4dGVuc2lvbk5hbWVdO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHBhcmFtIGlzIG9ubHkgYW4gQXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgIGlmKGV4dGVuc2lvblBhcmFtIGluc3RhbmNlb2YgQXR0cmlidXRlKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBzYW1lIHR5cGUgYXMgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IGV4dGVuc2lvblBhcmFtLnR5cGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGF0dHJpYnV0ZSB0byBUdXBsZUF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnNba2V5XVtleHRlbnNpb25OYW1lXSA9IGV4dGVuc2lvblBhcmFtID0gbmV3IChyZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy90dXBsZS9BdHRyaWJ1dGUnKSkoZXh0ZW5zaW9uUGFyYW0ubmFtZSk7XG5cblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBhdHRyaWJ1dGVzIG9iamVjdHMgdG8gZnVuY3Rpb25zIHRoYXQgaXRlcmF0ZSB0aHJvdWdoIHR1cGxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uUGFyYW0uY29udmVydEF0dHJpYnV0ZVRvVHVwbGUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSByZXR1cm4gdHlwZSBvZiB0aGUgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IGV4dGVuc2lvblBhcmFtLnR5cGUoKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gS2V5IG11c3Qgbm90IGFscmVhZHkgZXhpc3QgaW4gdGhlIGN1cnJlbnQgaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LmhlYWRlcigpLmdldChleHRlbnNpb25OYW1lKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWxhdGlvbiBleHRlbnNpb24gbmFtZSBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgaGVhZGVyJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIG5ldyBoZWFkZXIgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgIHZhciBleHRlbnNpb25BdHRyaWJ1dGUgPSBuZXcgQXR0cmlidXRlKHt0eXBlOiB0eXBlLCBuYW1lOiBleHRlbnNpb25OYW1lfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGF0dHJpYnV0ZSBpcyBhIGNhbGN1bGF0ZWQgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbkF0dHJpYnV0ZS5jYWxjdWxhdGVkKHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgYXR0cmlidXRlIGluIHRoZSBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5oZWFkZXIoKS5hZGQoZXh0ZW5zaW9uQXR0cmlidXRlKTtcblxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgIC8vLyBCZWZvcmVHZXRCb2R5XG5cbiAgICAgICAgICAgIHRoaXMuZWUub25jZSgnYmVmb3JlR2V0Qm9keScsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIGRlYnVnLmV4dGVuZC50cmFjZSgnYmVmb3JlR2V0Qm9keScpO1xuXG4gICAgICAgICAgICAgICAgcmVsYXRpb24uZWFjaChmdW5jdGlvbiAodHVwbGUpIHtcblxuICAgICAgICAgICAgICAgICAgICB0aGF0LmFmdGVyQWRkKHJlbGF0aW9uLCB0dXBsZSk7XG5cbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmVsYXRpb24uZWUub24oJ2FmdGVyQWRkJywgZnVuY3Rpb24odHVwbGUsIGluZGV4KXtcbiAgICAgICAgICAgICAgICB0aGF0LmFmdGVyQWRkKHRoYXQuYXJncy5yZWxhdGlvbiwgdHVwbGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJlbGF0aW9uLmVlLm9uKCdhZnRlclJlbW92ZScsIGZ1bmN0aW9uKHR1cGxlLCBpbmRleCl7XG4gICAgICAgICAgICAgICAgdGhhdC5hZnRlclJlbW92ZSh0aGF0LmFyZ3MucmVsYXRpb24sIHR1cGxlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZWxhdGlvbi5lZS5vbignYWZ0ZXJVcGRhdGUnLCBmdW5jdGlvbih0dXBsZSwgYXR0cmlidXRlTmFtZSwgdmFsdWUsIG9sZFZhbHVlKXtcbiAgICAgICAgICAgICAgICB0aGF0LmFmdGVyVXBkYXRlKHRoYXQuYXJncy5yZWxhdGlvbiwgdHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBleHRlbmQgZXhwcmVzc2lvbnMgdmFsdWVzIGZvciBhIHR1cGxlXG4gICAgICAgICAqIEBwYXJhbSB7VHVwbGV9IHR1cGxlIFRoZSB0dXBsZSB0byBjYWxjdWxhdGUgZXhwcmVzc2lvbnMgYWdhaW5zdFxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNsb25lIGVpdGhlciB0byByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIHR1cGxlLCBvciB0aGUgcGFzc2VkIGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtUdXBsZX0gVGhlIGJ1aWx0IHR1cGxlXG4gICAgICAgICAqL1xuICAgICAgICBidWlsZFR1cGxlIDogZnVuY3Rpb24odHVwbGUsIGNsb25lKXtcblxuICAgICAgICAgICAgaWYgKF8uaXNCb29sZWFuKGNsb25lKSl7XG4gICAgICAgICAgICAgICAgLy8gY2xvbmUgPSBjbG9uZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgbmV3VHVwbGU7XG5cbiAgICAgICAgICAgIGlmIChjbG9uZSl7XG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHR1cGxlIHdlIGFyZSBnb2luZyB0byBhZGRcbiAgICAgICAgICAgICAgICBuZXdUdXBsZSA9IG5ldyBUdXBsZSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29weSB0aGUgYXR0cmlidXRlcyBmcm9tIHRoZSBiYXNlIHR1cGxlXG4gICAgICAgICAgICAgICAgbmV3VHVwbGUuY29weSh0dXBsZSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBuZXdUdXBsZSA9IHR1cGxlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF8uZm9yRWFjaCh0aGF0LmFyZ3MuZXhwcmVzc2lvbnMsIGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBuZXcgYXR0cmlidXRlIG5hbWVcbiAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IE9iamVjdC5rZXlzKGV4cHJlc3Npb24pWzBdO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZXZhbHVhdGlvbiBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZUV4cHJlc3Npb24gPSBleHByZXNzaW9uW2F0dHJpYnV0ZU5hbWVdO1xuXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlRXhwcmVzc2lvbi5hc3NpZ25UdXBsZShuZXdUdXBsZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBuZXcgdmFsdWVcbiAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvblZhbHVlID0gYXR0cmlidXRlRXhwcmVzc2lvbi52YWx1ZSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gTGV0J3Mgc2V0IHRoZSBuZXcgdmFsdWUgaW4gdGhlIHR1cGxlXG4gICAgICAgICAgICAgICAgbmV3VHVwbGUuc2V0KGF0dHJpYnV0ZU5hbWUsIGV4cHJlc3Npb25WYWx1ZSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3VHVwbGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJBZGQgOiBmdW5jdGlvbihyZWxhdGlvbiwgYWRkZWRUdXBsZSl7XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgdGhhdC5hZGQodGhhdC5idWlsZFR1cGxlKGFkZGVkVHVwbGUpKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyUmVtb3ZlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlLCBpbmRleCl7XG5cbiAgICAgICAgICAgIHZhciBteVR1cGxlID0gdGhpcy5idWlsZFR1cGxlKHR1cGxlKTtcblxuICAgICAgICAgICAgdGhpcy5yZW1vdmUobXlUdXBsZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJVcGRhdGUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSl7XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIHR1cGxlQ2xvbmUgPSB0dXBsZS5jbG9uZSgpO1xuXG4gICAgICAgICAgICB0dXBsZUNsb25lLnNldChhdHRyaWJ1dGVOYW1lLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgICAgIHR1cGxlQ2xvbmUgPSB0aGF0LmJ1aWxkVHVwbGUodHVwbGVDbG9uZSk7XG5cbiAgICAgICAgICAgIHZhciBteVR1cGxlID0gIHRoYXQuZmluZCh0dXBsZUNsb25lKTtcblxuICAgICAgICAgICAgbXlUdXBsZSA9IHRoYXQuZmluZChteVR1cGxlKTtcblxuICAgICAgICAgICAgbXlUdXBsZS5zZXQoYXR0cmlidXRlTmFtZSwgdmFsdWUpO1xuXG4gICAgICAgICAgICB0aGF0LmJ1aWxkVHVwbGUobXlUdXBsZSwgZmFsc2UpO1xuXG4gICAgICAgIH1cblxuICAgIH0sIHtcblxuICAgICAgICB0eXBlIDogJ0V4dGVuc2lvbidcblxuICAgIH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4dGVuZDsiLCJ2YXIgUmVsYXRpb24gPSByZXF1aXJlKCcuLy4uL1JlbGF0aW9uLmpzJyk7XG52YXIgSGVhZGVyID0gcmVxdWlyZSgnLi8uLi9IZWFkZXIuanMnKTtcbnZhciBUdXBsZSA9IHJlcXVpcmUoJy4vLi4vVHVwbGUuanMnKTtcbnZhciBBdHRyaWJ1dGUgPSByZXF1aXJlKCcuLy4uL0F0dHJpYnV0ZS5qcycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9kZWJ1ZycpO1xuXG5cblxuXG52YXIgR3JvdXAgPSBSZWxhdGlvbi5leHRlbmQoXG5cbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBPcGVyYXRvcnMuR3JvdXBcbiAgICAgICAgICogQGV4dGVuZHMgUmVsYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtSZWxhdGlvbn0gcmVsYXRpb24gVGhlIHJlbGF0aW9uIHRvIGdyb3VwXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVOYW1lIFRoZSBuZXcgZ3JvdXBlZCBhdHRyaWJ1dGUgbmFtZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBhdHRyaWJ1dGVzIFRoZSBhdHRyaWJ1dGVzIHRvIGdyb3VwXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBHcm91cCBvcGVyYXRpb24gd2lsbCBncm91cCB0aGUgc3BlY2lmaWVkIHR1cGxlJ3MgYXR0cmlidXRlcyBpbnRvIG9uZS5cbiAgICAgICAgICogVGhlIHJlc3VsdGluZyB0dXBsZXMgd2lsbCBoYXZlIGFuIHtAbGluayBBdHRyaWJ1dGV9IHdob3NlIHtAbGluayBUeXBlfSB3aWxsIGJlIGEge0BsaW5rIFJlbGF0aW9ufS4gU2VlIGV4YW1wbGUuXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25BID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgICAgIHthOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtiOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtjOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsxLCAyLCAzXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFs0LCA1LCA2XSxcbiAgICAgICAgICogICAgICAgICAgICAgIFs0LCA5LCA5XSxcbiAgICAgICAgICogICAgICAgICAgICAgIFs3LCA4LCA5XVxuICAgICAgICAgKiAgICAgICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkIgPSByZWxhdGlvbkEuZ3JvdXAoJ2dyb3VwZWRBdHRyaWJ1dGUnLCBbJ2InLCAnYyddKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy9vclxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQiA9IG5ldyBhZmZpbml0eS5Hcm91cChyZWxhdGlvbkEsICdncm91cGVkQXR0cmlidXRlJywgWydiJywnYyddKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gICAgICAgICAgICAgICAgIDwtLS0tR1JPVVBJTkcgQVRUUklCVVRFLS0tLS0tLS0tLT5cbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IGEgOiBUSW50ZWdlciB8IGdyb3VwZWRBdHRyaWJ1dGUgOiBSZWxhdGlvbiAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKz09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgIC8vIHwgMSAgICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKyB8XG4gICAgICAgICAqICAgICAvLyB8ICAgICAgICAgICAgICB8IHwgYiA6IFRJbnRlZ2VyIHwgYyA6IFRJbnRlZ2VyIHwgfFxuICAgICAgICAgKiAgICAgLy8gfCAgICAgICAgICAgICAgfCArPT09PT09PT09PT09PT0rPT09PT09PT09PT09PT0rIHxcbiAgICAgICAgICogICAgIC8vIHwgICAgICAgICAgICAgIHwgfCAyICAgICAgICAgICAgfCAzICAgICAgICAgICAgfCB8XG4gICAgICAgICAqICAgICAvLyB8ICAgICAgICAgICAgICB8ICstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLSsgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgNCAgICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKyB8XG4gICAgICAgICAqICAgICAvLyB8ICAgICAgICAgICAgICB8IHwgYiA6IFRJbnRlZ2VyIHwgYyA6IFRJbnRlZ2VyIHwgfFxuICAgICAgICAgKiAgICAgLy8gfCAgICAgICAgICAgICAgfCArPT09PT09PT09PT09PT0rPT09PT09PT09PT09PT0rIHxcbiAgICAgICAgICogICAgIC8vIHwgICAgICAgICAgICAgIHwgfCA1ICAgICAgICAgICAgfCA2ICAgICAgICAgICAgfCB8XG4gICAgICAgICAqICAgICAvLyB8ICAgICAgICAgICAgICB8ICstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLSsgfFxuICAgICAgICAgKiAgICAgLy8gfCAgICAgICAgICAgICAgfCB8IDkgICAgICAgICAgICB8IDkgICAgICAgICAgICB8IHxcbiAgICAgICAgICogICAgIC8vIHwgICAgICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKyB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCA3ICAgICAgICAgICAgfCArLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgICogICAgIC8vIHwgICAgICAgICAgICAgIHwgfCBiIDogVEludGVnZXIgfCBjIDogVEludGVnZXIgfCB8XG4gICAgICAgICAqICAgICAvLyB8ICAgICAgICAgICAgICB8ICs9PT09PT09PT09PT09PSs9PT09PT09PT09PT09PSsgfFxuICAgICAgICAgKiAgICAgLy8gfCAgICAgICAgICAgICAgfCB8IDggICAgICAgICAgICB8IDkgICAgICAgICAgICB8IHxcbiAgICAgICAgICogICAgIC8vIHwgICAgICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKyB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIChyZWxhdGlvbiwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlcykge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBhcmdzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge1JlbGF0aW9ufSBhcmdzLnJlbGF0aW9uXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gYXJncy5ncm91cGluZ0F0dHJpYnV0ZU5hbWVcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nW119IGFyZ3MuZ3JvdXBlZEF0dHJpYnV0ZU5hbWVzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0F0dHJpYnV0ZVtdfSBhcmdzLmdyb3VwZWRBdHRyaWJ1dGVzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0F0dHJpYnV0ZX0gYXJncy5ncm91cGluZ0F0dHJpYnV0ZVxuICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIGRlYnVnLmdyb3VwLnRyYWNlKCcjY29uc3RydWN0b3InKTtcblxuICAgICAgICAgICAgdGhpcy5hcmdzID0ge307XG5cbiAgICAgICAgICAgIHRoaXMuYXJncy5yZWxhdGlvbiA9IHJlbGF0aW9uO1xuXG4gICAgICAgICAgICB0aGlzLmFyZ3MuZ3JvdXBpbmdBdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcblxuICAgICAgICAgICAgdGhpcy5hcmdzLmdyb3VwZWRBdHRyaWJ1dGVOYW1lcyA9IGF0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgIHRoaXMuYXJncy5ncm91cGVkQXR0cmlidXRlcyA9IFtdO1xuXG4gICAgICAgICAgICB0aGlzLmFyZ3MuZ3JvdXBpbmdBdHRyaWJ1dGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBDYWxsaW5nIHRoZSBwYXJlbnQgY29uc3RydWN0b3JcbiAgICAgICAgICAgIFJlbGF0aW9uLmNhbGwodGhpcyk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLmdyb3VwLnRyYWNlKCcjYmluZEV2ZW50cycpO1xuXG4gICAgICAgICAgICAvLyBDYWxsaW5nIHRoZSBwYXJlbnQgYmluZEV2ZW50c1xuICAgICAgICAgICAgR3JvdXAuX19zdXBlcl9fLmJpbmRFdmVudHMuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGdyb3VwZWRBdHRyaWJ1dGVOYW1lcyA9IHRoaXMuYXJncy5ncm91cGVkQXR0cmlidXRlTmFtZXMsXG4gICAgICAgICAgICAgICAgZ3JvdXBpbmdBdHRyaWJ1dGVOYW1lID0gdGhpcy5hcmdzLmdyb3VwaW5nQXR0cmlidXRlTmFtZSxcbiAgICAgICAgICAgICAgICByZWxhdGlvbiA9IHRoaXMuYXJncy5yZWxhdGlvbixcbiAgICAgICAgICAgICAgICBncm91cGVkQXR0cmlidXRlcyA9IHRoYXQuYXJncy5ncm91cGVkQXR0cmlidXRlcztcblxuICAgICAgICAgICAgLy8gQmVmb3JlR2V0SGVhZGVyXG4gICAgICAgICAgICB0aGF0LmVlLm9uY2UoJ2JlZm9yZUdldEhlYWRlcicsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIC8vIFdlIHdhbnQgdG8gaGF2ZSB0aGlzIGtpbmQgb2YgcmVsYXRpb25cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICAgICAgICAvLyB8IGF0dHIzIDogPHR5cGU+IHwgYXR0cjQgOiA8dHlwZT4gfCBncm91cGVkQXR0ciA6IFJlbGF0aW9uICAgICAgICAgICAgICB8XG4gICAgICAgICAgICAgICAgLy8gKz09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gV2hlcmUgYXR0cjMgYW5kIGF0dHI0IGFyZSBub24gZ3JvdXBlZCBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgLy8gYW5kIGdyb3VwZWRBdHRyIHdpbGwgY29udGFpbiB0aGUgZ3JvdXBlZCBhdHRyaWJ1dGVzIHJlbGF0aW9uc1xuICAgICAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVyID0gcmVsYXRpb24uaGVhZGVyKCk7XG5cbiAgICAgICAgICAgICAgICBkZWJ1Zy5ncm91cC50cmFjZSgnYmVmb3JlR2V0SGVhZGVyJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBhdHRyaWJ1dGVzIHNwZWNpZmllZCBpbiBncm91cGVkQXR0cmlidXRlTmFtZXMgZXhpc3RzIGluIHRoZSBiYXNlIGhlYWRlclxuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChncm91cGVkQXR0cmlidXRlTmFtZXMsIGZ1bmN0aW9uKGdyb3VwZWRBdHRyaWJ1dGVOYW1lKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoaGVhZGVyLmdldChncm91cGVkQXR0cmlidXRlTmFtZSkgPT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRyaWJ1dGUgd2l0aCBuYW1lIFwiJytncm91cGVkQXR0cmlidXRlTmFtZSsnXCIgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGhlYWRlcicpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIG9mIHRoZSByZWxhdGlvbidzIGhlYWRlciBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgaGVhZGVyLmVhY2goZnVuY3Rpb24oYXR0cmlidXRlKXtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgYXR0cmlidXRlIGlzIHBhcnQgb2YgdGhlIGdyb3VwZWQgYXR0cmlidXRlc1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmVzZW50ID0gXy5hbnkoZ3JvdXBlZEF0dHJpYnV0ZU5hbWVzLCBmdW5jdGlvbihncm91cGVkQXR0cmlidXRlTmFtZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ3JvdXBlZEF0dHJpYnV0ZU5hbWUgPT09IGF0dHJpYnV0ZS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZighcHJlc2VudCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCBpcyBub3QgcHJlc2VudCwgYWRkIGl0IHRvIHRoZSBoZWFkZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmhlYWRlcigpLmFkZChhdHRyaWJ1dGUuY2xvbmUoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCBpcyBwcmVzZW50LCBzdG9yZSBpdCBpbiB0aGUgZ3JvdXBlZEF0dHJpYnV0ZU5hbWVzIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cGVkQXR0cmlidXRlcy5wdXNoKGF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gTGV0J3MgY3JlYXRlIHRoZSBncm91cGluZ0F0dHJpYnV0ZU5hbWUgYW5kIGFkZCBpdCB0byB0aGUgaGVhZGVyXG5cbiAgICAgICAgICAgICAgICB0aGF0LmFyZ3MuZ3JvdXBpbmdBdHRyaWJ1dGUgPSBuZXcgQXR0cmlidXRlKHtuYW1lIDogZ3JvdXBpbmdBdHRyaWJ1dGVOYW1lLCB0eXBlIDogUmVsYXRpb259KTtcblxuICAgICAgICAgICAgICAgIHRoYXQuaGVhZGVyKCkuYWRkKHRoYXQuYXJncy5ncm91cGluZ0F0dHJpYnV0ZSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgIC8vIEJlZm9yZUdldEJvZHlcbiAgICAgICAgICAgIHRoYXQuZWUub25jZSgnYmVmb3JlR2V0Qm9keScsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIGRlYnVnLmdyb3VwLnRyYWNlKCdiZWZvcmVHZXRCb2R5Jyk7XG5cblxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgaGVhZGVyIGlzIGNvbXB1dGVkXG5cbiAgICAgICAgICAgICAgICB0aGF0LmhlYWRlcigpO1xuXG5cbiAgICAgICAgICAgICAgICAvLyBMZXQncyBsb29wIHRocm91Z2ggZWFjaCBvZiB0aGUgcmVsYXRpb24ncyB0dXBsZXNcblxuICAgICAgICAgICAgICAgIHJlbGF0aW9uLmVhY2goZnVuY3Rpb24odHVwbGUpe1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgdmFyaWFibGUgd2lsbCBzdG9yZSB0aGUgdHVwbGUgZ3JvdXBlZCBhdHRyaWJ1dGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cGVkQXR0cmlidXRlVmFsdWVzID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB2YXJpYWJsZSB3aWxsIHN0b3JlIHRoZSB0dXBsZSBub24tZ3JvdXBlZCBhdHRyaWJ1dGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIHZhciBub25Hcm91cGVkQXR0cmlidXRlVmFsdWVzID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm93LCB3ZSB3aWxsIGJ1aWxkIHRoZXNlIHZhcmlhYmxlc1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIExldCdzIGxvb3AgdGhyb3VnaCBlYWNoIG9mIHRoZSB0dXBsZSdzIGF0dHJpYnV0ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgdHVwbGUuZWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgdHVwbGUgYXR0cmlidXRlIGlzIGdyb3VwZWQgb3Igbm90IGdyb3VwZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncm91cGVkID0gXy5hbnkodGhhdC5hcmdzLmdyb3VwZWRBdHRyaWJ1dGVzLCBmdW5jdGlvbihncm91cGVkQXR0cmlidXRlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5ID09PSBncm91cGVkQXR0cmlidXRlLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZ3JvdXBlZCl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUdXBsZSBhdHRyaWJ1dGUgaXMgcGFydCBvZiB0aGUgZ3JvdXBlZCBhdHRyaWJ1dGVzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cGVkQXR0cmlidXRlVmFsdWVzW2tleV0gPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFR1cGxlIGF0dHJpYnV0ZSBpcyBub3QgcGFydCBvZiB0aGUgZ3JvdXBlZCBhdHRyaWJ1dGVzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub25Hcm91cGVkQXR0cmlidXRlVmFsdWVzW2tleV0gPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGdyb3VwZWRBdHRyaWJ1dGVWYWx1ZXMgYW5kIG5vbkdyb3VwZWRBdHRyaWJ1dGVWYWx1ZXMgYXJlIG5vdyBidWlsdFxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBzdGFydGVkIHdpdGggYSB0dXBsZSBsaWtlXG4gICAgICAgICAgICAgICAgICAgIC8vIHsgYXR0cjEgOiB2YWx1ZSwgYXR0cjIgOiB2YWx1ZSwgYXR0cjM6IHZhbHVlLCBhdHRyNCA6IHZhbHVlfVxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBncm91cGVkICdhdHRyMScgYW5kICdhdHRyMidcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gQW5kIHdlIHNpbXBseSBkaXZpZGVkIHRoZSB0dXBsZXMgaW50byB0d28gb2JqZWN0cywgb25lIGNvbnRhaW5pbmcgdGhlIGF0dHJpYnV0ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCBhcmUgc3VwcG9zZWQgdG8gYmUgZ3JvdXBlZCwgYW5kIGFub3RoZXIgdGhhdCBpcyBub3Qgc3VwcG9zZWQgdG8gYmUgZ3JvdXBlZFxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGV5IHNob3VsZCBsb29rIHNvbWV3aGF0IGxpa2UgOlxuICAgICAgICAgICAgICAgICAgICAvLyBncm91cGVkQXR0cmlidXRlVmFsdWVzIDogeyBhdHRyMSA6IHZhbHVlLCBhdHRyMiA6IHZhbHVlLCAuLi4gfVxuICAgICAgICAgICAgICAgICAgICAvLyBub25Hcm91cGVkQXR0cmlidXRlVmFsdWVzIDogeyBhdHRyMyA6IHZhbHVlLCBhdHRyNCA6IHZhbHVlLCAuLi59XG5cblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0d28gdHVwbGVzIGhhdmUgdGhlIHNhbWUgbm9uIGdyb3VwZWQgYXR0cmlidXRlIHZhbHVlcywgd2hhdCB3ZSB3aWxsIGRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIG1lcmdlIHRoZWlyIG5vbkdyb3VwZWRBdHRyaWJ1dGVWYWx1ZXMgaW50byBhIFwibmVzdGVkIHJlbGF0aW9uXCIsIG1lYW5pbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCB3ZSB3aWxsIGhhdmUgYSByZWxhdGlvbiB0aGF0IHdpbGwgY29udGFpbiByZWxhdGlvbnMuXG5cblxuICAgICAgICAgICAgICAgICAgICAvLyBMZXQncyBsb29wIHRocm91Z2ggZWFjaCB0dXBsZSBvZiB0aGUgYmVpbmctYnVpbHQgcmVsYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHNlZSBpZiBhIHR1cGxlIGFscmVhZHkgZXhpc3RzIHdpdGggdGhlIHNhbWUgbm9uR3JvdXBlZEF0dHJpYnV0ZVZhbHVlc1xuXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoaW5nVHVwbGUgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZWFjaChmdW5jdGlvbih0dXBsZSl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF8uZm9yT3duKG5vbkdyb3VwZWRBdHRyaWJ1dGVWYWx1ZXMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodHVwbGUuZ2V0KGtleSkgIT09IHZhbHVlKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihtYXRjaCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmdUdXBsZSA9IHR1cGxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGluZ1R1cGxlID09PSBudWxsKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSB0dXBsZSB3aXRoIHRoZSBzYW1lIG5vbiBncm91cGVkIGF0dHJpYnV0ZSB2YWx1ZXMgaGFzIG5vdCBiZWVuIGZvdW5kLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugd2lsbCBjcmVhdGUgaXQgYW5kIGNyZWF0ZSB0aGUgbmVzdGVkIHJlbGF0aW9uIHRvby5cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1R1cGxlID0gbmV3IFR1cGxlKG5vbkdyb3VwZWRBdHRyaWJ1dGVWYWx1ZXMpO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgdHVwbGUgc2hvdWxkIGxvb2sgbGlrZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHwgYXR0cjMgOiA8dHlwZT4gfCBhdHRyNCA6IDx0eXBlPiB8XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyArPT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09K1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gfCB2YWx1ZSAgICAgICAgICB8IHZhbHVlICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0rXG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRpbmcgdGhlIHJlbGF0aW9uXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdSZWxhdGlvbiA9IG5ldyBSZWxhdGlvbigpO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZGluZyB0aGUgZ3JvdXBlZCBhdHRyaWJ1dGVzIHRvIHRoZSBuZXcgbmVzdGVkIHJlbGF0aW9uIGhlYWRlclxuXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmZvck93bihncm91cGVkQXR0cmlidXRlcywgZnVuY3Rpb24oYXR0cmlidXRlKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1JlbGF0aW9uLmhlYWRlcigpLmFkZChhdHRyaWJ1dGUuY2xvbmUoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSB3aWxsIHN0b3JlIHRoZSByZWxhdGlvbiBoZWFkZXIgaW4gdGhlIHJvb3QgcmVsYXRpb24gaGVhZGVyIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU28gdGhhdCB3ZSB3aWxsIGtub3cgd2hhdCBraW5kIG9mIHJlbGF0aW9uIHRoaXMgaXMgd2l0aG91dCBoYXZpbmcgdG8gYWNjZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYm9keVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmFyZ3MuZ3JvdXBpbmdBdHRyaWJ1dGUucmVsYXRpb25IZWFkZXIgPSBuZXdSZWxhdGlvbi5oZWFkZXIoKS5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHJlbGF0aW9uIHNob3VsZCBsb29rIGxpa2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB8IGF0dHIxIDogPHR5cGU+IHwgYXR0cjIgOiA8dHlwZT4gfFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKz09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PStcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXR0aW5nIHRoZSByZWxhdGlvbiBpbiB0aGUgdHVwbGUgZ3JvdXBlZCBhdHRyaWJ1dGVcblxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VHVwbGUuc2V0KGdyb3VwaW5nQXR0cmlidXRlTmFtZSwgbmV3UmVsYXRpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdHVwbGUgd2lsbCBub3cgYmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHwgYXR0cjMgOiA8dHlwZT4gfCBhdHRyNCA6IDx0eXBlPiB8IGdyb3VwZWRBdHRyIDogUmVsYXRpb24gICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICs9PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHwgdmFsdWUgICAgICAgICAgfCB2YWx1ZSAgICAgICAgICB8ICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHwgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICB8IHwgYXR0cjEgOiA8dHlwZT4gfCBhdHRyMiA6IDx0eXBlPiB8IHxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHwgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICB8ICs9PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT0rIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcblxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZGluZyB0aGUgdHVwbGUgdG8gdGhlIHJlbGF0aW9uXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYWRkKG5ld1R1cGxlLCBmYWxzZSk7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSBtYXRjaGluZyB0dXBsZSBub3cgZXhpc3RzIGJlY2F1c2Ugd2UganVzdCBjcmVhdGVkIGl0XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nVHVwbGUgPSBuZXdUdXBsZTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY3JlYXRlIHRoZSB0dXBsZSB0aGF0IHdpbGwgYmUgaW5zZXJ0ZWQgaW4gdGhlIG5lc3RlZCByZWxhdGlvblxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXN0ZWRUdXBsZSA9IG5ldyBUdXBsZShncm91cGVkQXR0cmlidXRlVmFsdWVzKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhZGQgdGhpcyB0dXBsZSB0byB0aGUgbmVzdGVkIHJlbGF0aW9uXG5cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmdUdXBsZS5nZXQoZ3JvdXBpbmdBdHRyaWJ1dGVOYW1lKS5hZGQobmVzdGVkVHVwbGUsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBbmQgdm9pbMOgIVxuXG4gICAgICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEJpbmRzIHRoZSBiYXNlIHJlbGF0aW9uIGFmdGVyQWRkIGV2ZW50XG4gICAgICAgICAgICB0aGF0LmFyZ3MucmVsYXRpb24uZWUub24oJ2FmdGVyQWRkJywgZnVuY3Rpb24odHVwbGUsIGluZGV4KXtcbiAgICAgICAgICAgICAgICB0aGF0LmFmdGVyQWRkKHJlbGF0aW9uLCB0dXBsZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQmluZHMgdGhlIGJhc2UgcmVsYXRpb24gYWZ0ZXJSZW1vdmUgZXZlbnRcbiAgICAgICAgICAgIHRoYXQuYXJncy5yZWxhdGlvbi5lZS5vbignYWZ0ZXJSZW1vdmUnLCBmdW5jdGlvbih0dXBsZSwgaW5kZXgpe1xuICAgICAgICAgICAgICAgIHRoYXQuYWZ0ZXJSZW1vdmUocmVsYXRpb24sIHR1cGxlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBCaW5kcyB0aGUgYmFzZSByZWxhdGlvbiBhZnRlclVwZGF0ZSBldmVudFxuICAgICAgICAgICAgdGhhdC5hcmdzLnJlbGF0aW9uLmVlLm9uKCdhZnRlclVwZGF0ZScsIGZ1bmN0aW9uKHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpe1xuICAgICAgICAgICAgICAgIHRoYXQuYWZ0ZXJVcGRhdGUocmVsYXRpb24sIHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgaGFuZGxlciB3aGVuIGEgdHVwbGUgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIGJhc2UgcmVsYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtSZWxhdGlvbn0gcmVsYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtUdXBsZX0gdHVwbGVcbiAgICAgICAgICovXG4gICAgICAgIGFmdGVyQWRkIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcbiAgICAgICAgICAgIGRlYnVnLmdyb3VwLnRyYWNlKCdHcm91cCNhZnRlckFkZCcpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuYXJncy5yZWxhdGlvbi5ncm91cCh0aGlzLmFyZ3MuZ3JvdXBpbmdBdHRyaWJ1dGVOYW1lLCB0aGlzLmFyZ3MuZ3JvdXBlZEF0dHJpYnV0ZU5hbWVzKTtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0VG8ocmVzdWx0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgaGFuZGxlciB3aGVuIGEgdHVwbGUgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBiYXNlIHJlbGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7VHVwbGV9IHR1cGxlXG4gICAgICAgICAqL1xuICAgICAgICBhZnRlclJlbW92ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSl7XG4gICAgICAgICAgICBkZWJ1Zy5ncm91cC50cmFjZSgnR3JvdXAjYWZ0ZXJSZW1vdmUnKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmFyZ3MucmVsYXRpb24uZ3JvdXAodGhpcy5hcmdzLmdyb3VwaW5nQXR0cmlidXRlTmFtZSwgdGhpcy5hcmdzLmdyb3VwZWRBdHRyaWJ1dGVOYW1lcyk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFRvKHJlc3VsdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGhhbmRsZXIgd2hlbiBhIHR1cGxlIGhhcyBiZWVuIHVwZGF0ZWQgZnJvbSB0aGUgYmFzZSByZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1R1cGxlfSB0dXBsZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlTmFtZVxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gb2xkVmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIGFmdGVyVXBkYXRlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpe1xuICAgICAgICAgICAgZGVidWcuZ3JvdXAudHJhY2UoJ0dyb3VwI2FmdGVyVXBkYXRlJyk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5hcmdzLnJlbGF0aW9uLmdyb3VwKHRoaXMuYXJncy5ncm91cGluZ0F0dHJpYnV0ZU5hbWUsIHRoaXMuYXJncy5ncm91cGVkQXR0cmlidXRlTmFtZXMpO1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RUbyhyZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICB9LCB7XG5cbiAgICAgICAgdHlwZSA6ICdHcm91cCdcblxuICAgIH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyb3VwOyIsInZhciBSZWxhdGlvbiA9IHJlcXVpcmUoJy4vLi4vUmVsYXRpb24uanMnKTtcbnZhciBIZWFkZXIgPSByZXF1aXJlKCcuLy4uL0hlYWRlci5qcycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9kZWJ1ZycpO1xuXG5cbnZhciBJbnRlcnNlY3Rpb24gPSBSZWxhdGlvbi5leHRlbmQoXG5cbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBPcGVyYXRvcnMuSW50ZXJzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uQVxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvbkJcbiAgICAgICAgICogQGV4dGVuZHMgUmVsYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGludGVyc2VjdGlvbiBjcmVhdGVzIGEgbmV3IHJlbGF0aW9uIHdpdGggdHVwbGVzIGNvbW1vbiBpbiByZWxhdGlvbkEgYW5kIHJlbGF0aW9uQlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbDEgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAge2E6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICAge2I6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICAge2M6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19XG4gICAgICAgICAqICAgICAgIF0sIFtcbiAgICAgICAgICogICAgICAgICAgIFsxLCAyLCAzXSxcbiAgICAgICAgICogICAgICAgICAgIFs0LCA1LCA2XSxcbiAgICAgICAgICogICAgICAgICAgIFs3LCA4LCA5XVxuICAgICAgICAgKiAgICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWwyID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAge2E6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICB7YjogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgIHtjOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fVxuICAgICAgICAgKiAgICAgIF0sIFtcbiAgICAgICAgICogICAgICAgICAgWzEsIDIsIDNdXG4gICAgICAgICAqICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqdiAgICBhciByZWwzID0gbmV3IGFmZmluaXR5LkludGVyc2VjdGlvbihyZWwxLCByZWwyKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgYSA6IFRJbnRlZ2VyIHwgYiA6IFRJbnRlZ2VyIHwgYyA6IFRJbnRlZ2VyIHxcbiAgICAgICAgICogICAgIC8vICs9PT09PT09PT09PT09PSs9PT09PT09PT09PT09PSs9PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgIC8vIHwgMSAgICAgICAgICAgIHwgMiAgICAgICAgICAgIHwgMyAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICovXG5cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIChyZWxhdGlvbkEsIHJlbGF0aW9uQikge1xuXG4gICAgICAgICAgICB0aGlzLnJlbHMgPSBbcmVsYXRpb25BLCByZWxhdGlvbkJdO1xuXG4gICAgICAgICAgICBSZWxhdGlvbi5jYWxsKHRoaXMpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYmluZEV2ZW50czogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5pbnRlcnNlY3Rpb24udHJhY2UoJyNiaW5kRXZlbnRzJyk7XG5cbiAgICAgICAgICAgIEludGVyc2VjdGlvbi5fX3N1cGVyX18uYmluZEV2ZW50cy5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciByZWwxID0gdGhhdC5yZWxzWzBdLFxuICAgICAgICAgICAgICAgIHJlbDIgPSB0aGF0LnJlbHNbMV07XG5cblxuICAgICAgICAgICAgLy8gQmVmb3JlR2V0SGVhZGVyXG5cbiAgICAgICAgICAgIHRoaXMuZWUub25jZSgnYmVmb3JlR2V0SGVhZGVyJywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlcjEgPSByZWwxLmhlYWRlcigpO1xuICAgICAgICAgICAgICAgIHZhciBoZWFkZXIyID0gcmVsMi5oZWFkZXIoKTtcblxuICAgICAgICAgICAgICAgIGRlYnVnLmludGVyc2VjdGlvbi50cmFjZSgnYmVmb3JlR2V0SGVhZGVyJyk7XG5cbiAgICAgICAgICAgICAgICBIZWFkZXIuYXNzZXJ0VW5pb25Db21wYXRpYmxlKGhlYWRlcjEsIGhlYWRlcjIpO1xuXG4gICAgICAgICAgICAgICAgdGhhdC5oZWFkZXIoKS5jb3B5KGhlYWRlcjEpO1xuXG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICAvLyBCZWZvcmVHZXRCb2R5XG5cbiAgICAgICAgICAgIHRoaXMuZWUub25jZSgnYmVmb3JlR2V0Qm9keScsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIGRlYnVnLmludGVyc2VjdGlvbi50cmFjZSgnYmVmb3JlR2V0Qm9keScpO1xuXG4gICAgICAgICAgICAgICAgcmVsMS5lYWNoKGZ1bmN0aW9uICh0dXBsZTEpIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVsMi5pbmRleCh0dXBsZTEpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmFkZCh0dXBsZTEuY2xvbmUoKSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyTGVmdEFkZCA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSl7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlckxlZnRSZW1vdmUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUpe1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJMZWZ0VXBkYXRlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpe1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJSaWdodEFkZCA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSl7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlclJpZ2h0UmVtb3ZlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyUmlnaHRVcGRhdGUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSl7XG5cbiAgICAgICAgfVxuXG4gICAgfSwge1xuXG4gICAgICAgIHR5cGUgOiAnSW50ZXJzZWN0aW9uJ1xuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJzZWN0aW9uOyIsInZhciBSZWxhdGlvbiA9IHJlcXVpcmUoJy4vLi4vUmVsYXRpb24uanMnKTtcbnZhciBIZWFkZXIgPSByZXF1aXJlKCcuLy4uL0hlYWRlci5qcycpO1xudmFyIFR1cGxlID0gcmVxdWlyZSgnLi8uLi9UdXBsZS5qcycpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2RlYnVnJyk7XG5cbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cblxuXG52YXIgSm9pbiA9IFJlbGF0aW9uLmV4dGVuZChcblxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIE9wZXJhdG9ycy5Kb2luXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uQVxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvbkJcbiAgICAgICAgICogQGV4dGVuZHMgUmVsYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIEpvaW4gb3BlcmF0aW9uIHJldHVybnMgYWxsIHBvc3NpYmxlIGNvbWJpbmF0aW9ucyBvZiB0dXBsZXMgZnJvbSByZWxhdGlvbkEgYW5kIHJlbGF0aW9uQiB3aGVyZVxuICAgICAgICAgKiB0aGUgdHVwbGVzIGhhdmUgdGhlIHNhbWUgdmFsdWUgZm9yIHRoZWlyIGNvbW1vbiBhdHRyaWJ1dGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQSA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7Y2hhcmFjdGVySWQ6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2ZpcnN0TmFtZTogeyB0eXBlOiBhZmZpbml0eS5TdHJpbmd9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtsYXN0TmFtZTogeyB0eXBlOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsxLCAnSm9obicsICdEb2UnXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsyLCAnTWFyeScsICdQb3BwaW5zJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbMywgJ0x1Y2t5JywgJ0x1a2UnXVxuICAgICAgICAgKiAgICAgICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkIgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge2NoYXJhY3RlcklkOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtmYW46IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbMSwgJ01yIFgnXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsxLCAnTWlzcyBEaWJibGUnXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsyLCAnTmF0IEJpYmJsZSddXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQyA9IHJlbGF0aW9uQS5qb2luKHJlbGF0aW9uQik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBvclxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQyA9IG5ldyBhZmZpbml0eS5Kb2luKHJlbGF0aW9uQSwgcmVsYXRpb25CKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gPC0tLUNPTU1PTiBBVFRSSUJVVEUtLS0tPlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBjaGFyYWN0ZXJJZCA6IFRJbnRlZ2VyIHwgZmlyc3ROYW1lIDogVFN0cmluZyB8IGxhc3ROYW1lIDogVFN0cmluZyB8IGZhbiA6IFRTdHJpbmcgfFxuICAgICAgICAgKiAgICAgLy8gKz09PT09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgLy8gfCAxICAgICAgICAgICAgICAgICAgICAgIHwgSm9obiAgICAgICAgICAgICAgICB8IERvZSAgICAgICAgICAgICAgICB8IE1yIFggICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAyICAgICAgICAgICAgICAgICAgICAgIHwgSm9obiAgICAgICAgICAgICAgICB8IERvZSAgICAgICAgICAgICAgICB8IE1pc3MgRGliYmxlICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAzICAgICAgICAgICAgICAgICAgICAgIHwgTWFyeSAgICAgICAgICAgICAgICB8IFBvcHBpbnMgICAgICAgICAgICB8IE5hdCBCaWJibGUgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy9cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAocmVsYXRpb25BLCByZWxhdGlvbkIpIHtcblxuICAgICAgICAgICAgdGhpcy5yZWxzID0gW3JlbGF0aW9uQSwgcmVsYXRpb25CXTtcbiAgICAgICAgICAgIHRoaXMuX2NvbW1vbkF0dHJpYnV0ZXMgPSBbXTtcblxuICAgICAgICAgICAgUmVsYXRpb24uY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYmluZEV2ZW50czogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5qb2luLnRyYWNlKCcjYmluZEV2ZW50cycpO1xuXG4gICAgICAgICAgICBKb2luLl9fc3VwZXJfXy5iaW5kRXZlbnRzLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIHJlbDEgPSB0aGF0LnJlbHNbMF07XG4gICAgICAgICAgICB2YXIgcmVsMiA9IHRoYXQucmVsc1sxXTtcblxuICAgICAgICAgICAgLy8gQmVmb3JlR2V0SGVhZGVyXG5cbiAgICAgICAgICAgIHRoaXMuZWUub25jZSgnYmVmb3JlR2V0SGVhZGVyJywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgZGVidWcuam9pbi50cmFjZSgnYmVmb3JlR2V0SGVhZGVyJyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVyMSA9IHJlbDEuaGVhZGVyKCk7XG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlcjIgPSByZWwyLmhlYWRlcigpO1xuXG4gICAgICAgICAgICAgICAgSGVhZGVyLmFzc2VydFNhbWVOYW1lU2FtZVR5cGUoaGVhZGVyMSwgaGVhZGVyMik7XG5cbiAgICAgICAgICAgICAgICB0aGF0LmNvbW1vbkF0dHJpYnV0ZXMgPSBIZWFkZXIuY29tbW9uQXR0cmlidXRlcyhoZWFkZXIxLCBoZWFkZXIyKTtcblxuICAgICAgICAgICAgICAgIHRoYXQuaGVhZGVyKCkuY29weShoZWFkZXIxKTtcbiAgICAgICAgICAgICAgICB0aGF0LmhlYWRlcigpLmNvcHkoaGVhZGVyMik7XG5cbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgIC8vIEJlZm9yZUdldEJvZHlcblxuICAgICAgICAgICAgdGhpcy5lZS5vbmNlKCdiZWZvcmVHZXRCb2R5JywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgdGhhdC5oZWFkZXIoKTtcblxuICAgICAgICAgICAgICAgIGRlYnVnLmpvaW4udHJhY2UoJ2JlZm9yZUdldEJvZHknKTtcblxuICAgICAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIGJvZHkgb2YgdGhlIGZpcnN0IHJlbGF0aW9uXG4gICAgICAgICAgICAgICAgcmVsMS5lYWNoKGZ1bmN0aW9uICh0dXBsZTEpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBMb29wIHRocm91Z2ggZWFjaCB0dXBsZXMgb2YgdGhlIHNlY29uZCByZWxhdGlvblxuICAgICAgICAgICAgICAgICAgICByZWwyLmVhY2goZnVuY3Rpb24gKHR1cGxlMikge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBUdXBsZS5tYXRjaE9uQXR0cmlidXRlcyh0dXBsZTEsIHR1cGxlMiwgdGhhdC5jb21tb25BdHRyaWJ1dGVzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBtYXRjaCB3YXMgZGV0ZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xvbmUgdGhlIGZpcnN0IHR1cGxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1R1cGxlID0gbmV3IFR1cGxlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHRoZSBqb2luZWQgdHVwbGUgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1R1cGxlLmNvcHkodHVwbGUxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdUdXBsZS5jb3B5KHR1cGxlMik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVuIGFkZCBpdCB0byB0aGUgcmVsYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmFkZChuZXdUdXBsZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoYXQpO1xuXG4gICAgICAgICAgICAgICAgfSwgdGhhdClcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoYXQucmVsc1swXS5lZS5vbignYWZ0ZXJBZGQnLCBmdW5jdGlvbih0dXBsZSwgaW5kZXgpe1xuICAgICAgICAgICAgICAgIHRoYXQuYWZ0ZXJMZWZ0QWRkKHRoYXQucmVsc1swXSwgdHVwbGUsIGluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGF0LnJlbHNbMV0uZWUub24oJ2FmdGVyQWRkJywgZnVuY3Rpb24odHVwbGUsIGluZGV4KXtcbiAgICAgICAgICAgICAgICB0aGF0LmFmdGVyUmlnaHRBZGQodGhhdC5yZWxzWzFdLCB0dXBsZSwgaW5kZXgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoYXQucmVsc1swXS5lZS5vbignYWZ0ZXJSZW1vdmUnLCBmdW5jdGlvbih0dXBsZSwgaW5kZXgpe1xuICAgICAgICAgICAgICAgIHRoYXQuYWZ0ZXJMZWZ0UmVtb3ZlKHRoYXQucmVsc1swXSwgdHVwbGUsIGluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGF0LnJlbHNbMV0uZWUub24oJ2FmdGVyUmVtb3ZlJywgZnVuY3Rpb24odHVwbGUsIGluZGV4KXtcbiAgICAgICAgICAgICAgICB0aGF0LmFmdGVyUmlnaHRSZW1vdmUodGhhdC5yZWxzWzBdLCB0dXBsZSwgaW5kZXgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoYXQucmVsc1swXS5lZS5vbignYWZ0ZXJVcGRhdGUnLCBmdW5jdGlvbih0dXBsZSwgYXR0cmlidXRlTmFtZSwgdmFsdWUsIG9sZFZhbHVlKXtcbiAgICAgICAgICAgICAgICB0aGF0LmFmdGVyTGVmdFVwZGF0ZSh0aGF0LnJlbHNbMF0sIHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoYXQucmVsc1sxXS5lZS5vbignYWZ0ZXJVcGRhdGUnLCBmdW5jdGlvbih0dXBsZSwgYXR0cmlidXRlTmFtZSwgdmFsdWUsIG9sZFZhbHVlKXtcbiAgICAgICAgICAgICAgICB0aGF0LmFmdGVyTGVmdFVwZGF0ZSh0aGF0LnJlbHNbMF0sIHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyTGVmdEFkZCA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSl7XG4gICAgICAgICAgICBkZWJ1Zy5ncm91cC50cmFjZSgnSm9pbiNhZnRlckxlZnRBZGQnKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlbHNbMF0uam9pbih0aGlzLnJlbHNbMV0pO1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RUbyhyZXN1bHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyTGVmdFJlbW92ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSl7XG4gICAgICAgICAgICBkZWJ1Zy5ncm91cC50cmFjZSgnSm9pbiNhZnRlckxlZnRSZW1vdmUnKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlbHNbMF0uam9pbih0aGlzLnJlbHNbMV0pO1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RUbyhyZXN1bHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyTGVmdFVwZGF0ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSwgYXR0cmlidXRlTmFtZSwgdmFsdWUsIG9sZFZhbHVlKXtcbiAgICAgICAgICAgIGRlYnVnLmdyb3VwLnRyYWNlKCdKb2luI2FmdGVyTGVmdFVwZGF0ZScpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVsc1swXS5qb2luKHRoaXMucmVsc1sxXSk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFRvKHJlc3VsdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJSaWdodEFkZCA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSl7XG4gICAgICAgICAgICBkZWJ1Zy5ncm91cC50cmFjZSgnSm9pbiNhZnRlclJpZ2h0QWRkJyk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZWxzWzBdLmpvaW4odGhpcy5yZWxzWzFdKTtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0VG8ocmVzdWx0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlclJpZ2h0UmVtb3ZlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcbiAgICAgICAgICAgIGRlYnVnLmdyb3VwLnRyYWNlKCdKb2luI2FmdGVyUmlnaHRSZW1vdmUnKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlbHNbMF0uam9pbih0aGlzLnJlbHNbMV0pO1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RUbyhyZXN1bHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyUmlnaHRVcGRhdGUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSl7XG4gICAgICAgICAgICBkZWJ1Zy5ncm91cC50cmFjZSgnSm9pbiNhZnRlclJpZ2h0VXBkYXRlJyk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZWxzWzBdLmpvaW4odGhpcy5yZWxzWzFdKTtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0VG8ocmVzdWx0KTtcbiAgICAgICAgfVxuXG4gICAgfSwge1xuXG4gICAgICAgIHR5cGUgOiAnSm9pbidcblxuICAgIH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpvaW47IiwidmFyIFJlbGF0aW9uID0gcmVxdWlyZSgnLi8uLi9SZWxhdGlvbi5qcycpO1xudmFyIEhlYWRlciA9IHJlcXVpcmUoJy4vLi4vSGVhZGVyLmpzJyk7XG52YXIgVHVwbGUgPSByZXF1aXJlKCcuLy4uL1R1cGxlLmpzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2RlYnVnJyk7XG5cblxuXG52YXIgUHJvZHVjdCA9IFJlbGF0aW9uLmV4dGVuZChcblxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIE9wZXJhdG9ycy5Qcm9kdWN0XG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uQVxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvbkJcbiAgICAgICAgICogQGV4dGVuZHMgUmVsYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogRXhhbXBsZSA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25BID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgICAgIHtjaGFyYWN0ZXJJZDogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7Zmlyc3ROYW1lOiB7IHR5cGU6IGFmZmluaXR5LlN0cmluZ319LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2xhc3ROYW1lOiB7IHR5cGU6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWzEsICdKb2huJywgJ0RvZSddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzIsICdNYXJ5JywgJ1BvcHBpbnMnXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFszLCAnTHVja3knLCAnTHVrZSddXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7cHJvZHVjdDogeyB0eXBlOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsnRG9sbCddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydQbGF5TW9iaWxlJ10sXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQyA9IHJlbGF0aW9uQS5wcm9kdWN0KHJlbGF0aW9uQik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBvclxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQyA9IG5ldyBhZmZpbml0eS5Qcm9kdWN0KHJlbGF0aW9uQSwgcmVsYXRpb25CKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgY2hhcmFjdGVySWQgOiBUSW50ZWdlciB8IGZpcnN0TmFtZSA6IFRTdHJpbmcgfCBsYXN0TmFtZSA6IFRTdHJpbmcgfCBwcm9kdWN0IDogVFN0cmluZyB8XG4gICAgICAgICAqICAgICAvLyArPT09PT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgLy8gfCAxICAgICAgICAgICAgICAgICAgICAgIHwgSm9obiAgICAgICAgICAgICAgICB8IERvZSAgICAgICAgICAgICAgICB8IERvbGwgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDIgICAgICAgICAgICAgICAgICAgICAgfCBKb2huICAgICAgICAgICAgICAgIHwgRG9lICAgICAgICAgICAgICAgIHwgUGxheU1vYmlsZSAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMSAgICAgICAgICAgICAgICAgICAgICB8IE1hcnkgICAgICAgICAgICAgICAgfCBQb3BwaW5zICAgICAgICAgICAgfCBEb2xsICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAyICAgICAgICAgICAgICAgICAgICAgIHwgTWFyeSAgICAgICAgICAgICAgICB8IFBvcHBpbnMgICAgICAgICAgICB8IFBsYXlNb2JpbGUgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDEgICAgICAgICAgICAgICAgICAgICAgfCBMdWNreSAgICAgICAgICAgICAgIHwgTHVrZSAgICAgICAgICAgICAgIHwgRG9sbCAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMiAgICAgICAgICAgICAgICAgICAgICB8IEx1Y2t5ICAgICAgICAgICAgICAgfCBMdWtlICAgICAgICAgICAgICAgfCBQbGF5TW9iaWxlICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy9cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAocmVsYXRpb25BLCByZWxhdGlvbkIpIHtcblxuICAgICAgICAgICAgZGVidWcucHJvZHVjdC50cmFjZSgnI2NvbnN0cnVjdG9yJyk7XG5cbiAgICAgICAgICAgIHRoaXMucmVscyA9IFtyZWxhdGlvbkEsIHJlbGF0aW9uQl07XG5cbiAgICAgICAgICAgIFJlbGF0aW9uLmNhbGwodGhpcyk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnByb2R1Y3QudHJhY2UoJyNiaW5kRXZlbnRzJyk7XG5cbiAgICAgICAgICAgIFByb2R1Y3QuX19zdXBlcl9fLmJpbmRFdmVudHMuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgcmVsMSA9IHRoaXMucmVsc1swXTtcbiAgICAgICAgICAgIHZhciByZWwyID0gdGhpcy5yZWxzWzFdO1xuXG4gICAgICAgICAgICAvLyBCZWZvcmVHZXRIZWFkZXJcblxuICAgICAgICAgICAgdGhhdC5lZS5vbmNlKCdiZWZvcmVHZXRIZWFkZXInLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICBkZWJ1Zy5wcm9kdWN0LnRyYWNlKCdiZWZvcmVHZXRIZWFkZXInKTtcblxuICAgICAgICAgICAgICAgIHZhciBoZWFkZXIxID0gcmVsMS5oZWFkZXIoKTtcbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVyMiA9IHJlbDIuaGVhZGVyKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSB0d28gcmVsYXRpb25zIGhhdmUgZGlzam9pbnQgaGVhZGVyc1xuICAgICAgICAgICAgICAgIEhlYWRlci5hc3NlcnREaXNqb2ludChoZWFkZXIxLCBoZWFkZXIyKTtcblxuICAgICAgICAgICAgICAgIHRoYXQuaGVhZGVyKCkuY29weShoZWFkZXIxLnNldFVuaW9uKGhlYWRlcjIpKTtcblxuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgLy8gQmVmb3JlR2V0Qm9keVxuXG4gICAgICAgICAgICB0aGF0LmVlLm9uY2UoJ2JlZm9yZUdldEJvZHknLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICBkZWJ1Zy5wcm9kdWN0LnRyYWNlKCdiZWZvcmVHZXRCb2R5Jyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdHVwbGVTZXQgPSByZWwxLnNldFByb2R1Y3QocmVsMik7XG5cbiAgICAgICAgICAgICAgICB0dXBsZVNldC5lYWNoKGZ1bmN0aW9uICh0dXBsZVBhaXIpIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VHVwbGUgPSBuZXcgVHVwbGUoKTtcblxuICAgICAgICAgICAgICAgICAgICBuZXdUdXBsZS5jb3B5KHR1cGxlUGFpci5nZXQoJzAnKSk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1R1cGxlLmNvcHkodHVwbGVQYWlyLmdldCgnMScpKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGF0LmFkZChuZXdUdXBsZSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgfSwgdGhhdCk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJMZWZ0QWRkIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyTGVmdFJlbW92ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSl7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlckxlZnRVcGRhdGUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSl7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlclJpZ2h0QWRkIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyUmlnaHRSZW1vdmUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUpe1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJSaWdodFVwZGF0ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSwgYXR0cmlidXRlTmFtZSwgdmFsdWUsIG9sZFZhbHVlKXtcblxuICAgICAgICB9XG5cbiAgICB9LCB7XG5cbiAgICAgICAgdHlwZSA6ICdQcm9kdWN0J1xuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvZHVjdDsiLCJ2YXIgUmVsYXRpb24gPSByZXF1aXJlKCcuLy4uL1JlbGF0aW9uLmpzJyk7XG52YXIgSGVhZGVyID0gcmVxdWlyZSgnLi8uLi9IZWFkZXIuanMnKTtcbnZhciBUdXBsZSA9IHJlcXVpcmUoJy4vLi4vVHVwbGUuanMnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvZGVidWcnKTtcblxuXG5cbnZhciBQcm9qZWN0aW9uID0gUmVsYXRpb24uZXh0ZW5kKFxuXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgT3BlcmF0b3JzLlByb2plY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtSZWxhdGlvbn0gcmVsYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gYXJnc1xuICAgICAgICAgKiBAZXh0ZW5kcyBSZWxhdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBFeGFtcGxlIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkEgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge2NoYXJhY3RlcklkOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtmaXJzdE5hbWU6IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7bGFzdE5hbWU6IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbMSwgJ0pvaG4nLCAnRG9lJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbMiwgJ01hcnknLCAnUG9wcGlucyddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzMsICdMdWNreScsICdMdWtlJ11cbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgY2hhcmFjdGVySWQgOiBUSW50ZWdlciB8IGZpcnN0TmFtZSA6IFRTdHJpbmcgfCBsYXN0TmFtZSA6IFRTdHJpbmcgfFxuICAgICAgICAgKiAgICAgLy8gKz09PT09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAvLyB8IDEgICAgICAgICAgICAgICAgICAgICAgfCBKb2huICAgICAgICAgICAgICAgIHwgRG9lICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAyICAgICAgICAgICAgICAgICAgICAgIHwgTWFyeSAgICAgICAgICAgICAgICB8IFBvcHBpbnMgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMyAgICAgICAgICAgICAgICAgICAgICB8IEx1Y2t5ICAgICAgICAgICAgICAgfCBMdWtlICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25CID0gcmVsYXRpb25BLnByb2plY3QoWydmaXJzdE5hbWUnXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBvclxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQyA9IG5ldyBhZmZpbml0eS5Qcm9qZWN0aW9uKHJlbGF0aW9uQSwgWydmaXJzdE5hbWUnXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBmaXJzdE5hbWUgOiBUU3RyaW5nIHxcbiAgICAgICAgICogICAgIC8vICs9PT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAvLyB8IEpvaG4gICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgTWFyeSAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBMdWNreSAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHJlbGF0aW9uLCBhcmdzKSB7XG5cbiAgICAgICAgICAgIHRoaXMucmVsID0gcmVsYXRpb247XG4gICAgICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuXG4gICAgICAgICAgICBSZWxhdGlvbi5jYWxsKHRoaXMpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYmluZEV2ZW50czogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5wcm9qZWN0aW9uLnRyYWNlKCcjYmluZEV2ZW50cycpO1xuXG4gICAgICAgICAgICBQcm9qZWN0aW9uLl9fc3VwZXJfXy5iaW5kRXZlbnRzLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIHJlbGF0aW9uID0gdGhpcy5yZWw7XG5cbiAgICAgICAgICAgIHRoYXQuZWUub25jZSgnYmVmb3JlR2V0Qm9keScsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIGRlYnVnLnByb2plY3Rpb24udHJhY2UoJ2JlZm9yZUdldEJvZHknKTtcblxuICAgICAgICAgICAgICAgIHJlbGF0aW9uLmVhY2goZnVuY3Rpb24gKHR1cGxlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1R1cGxlID0gbmV3IFR1cGxlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbmV3VHVwbGUuY29weSh0dXBsZSwgdGhhdC5hcmdzKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGF0LmFkZChuZXdUdXBsZSk7XG5cbiAgICAgICAgICAgICAgICB9LCB0aGF0KVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhhdC5lZS5vbmNlKCdiZWZvcmVHZXRIZWFkZXInLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICBkZWJ1Zy5wcm9qZWN0aW9uLnRyYWNlKCdiZWZvcmVHZXRIZWFkZXInKTtcblxuICAgICAgICAgICAgICAgIHRoYXQuaGVhZGVyKCkuY29weShyZWxhdGlvbi5oZWFkZXIoKS5wcm9qZWN0KHRoYXQuYXJncykpXG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBCaW5kcyB0aGUgYmFzZSByZWxhdGlvbiBhZnRlckFkZCBldmVudFxuICAgICAgICAgICAgcmVsYXRpb24uZWUub24oJ2FmdGVyQWRkJywgZnVuY3Rpb24odHVwbGUsIGluZGV4KXtcbiAgICAgICAgICAgICAgICB0aGF0LmFmdGVyQWRkKHJlbGF0aW9uLCB0dXBsZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQmluZHMgdGhlIGJhc2UgcmVsYXRpb24gYWZ0ZXJSZW1vdmUgZXZlbnRcbiAgICAgICAgICAgIHJlbGF0aW9uLmVlLm9uKCdhZnRlclJlbW92ZScsIGZ1bmN0aW9uKHR1cGxlLCBpbmRleCl7XG4gICAgICAgICAgICAgICAgdGhhdC5hZnRlclJlbW92ZShyZWxhdGlvbiwgdHVwbGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEJpbmRzIHRoZSBiYXNlIHJlbGF0aW9uIGFmdGVyVXBkYXRlIGV2ZW50XG4gICAgICAgICAgICByZWxhdGlvbi5lZS5vbignYWZ0ZXJVcGRhdGUnLCBmdW5jdGlvbih0dXBsZSwgYXR0cmlidXRlTmFtZSwgdmFsdWUsIG9sZFZhbHVlKXtcbiAgICAgICAgICAgICAgICB0aGF0LmFmdGVyVXBkYXRlKHJlbGF0aW9uLCB0dXBsZSwgYXR0cmlidXRlTmFtZSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJBZGQgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUpe1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlbGF0aW9uLnByb2plY3QodGhpcy5hcmdzKTtcbiAgICAgICAgICAgIGRlYnVnLmdyb3VwLnRyYWNlKCdQcm9qZWN0aW9uI2FmdGVyQWRkJyk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFRvKHJlc3VsdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJSZW1vdmUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUpe1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlbGF0aW9uLnByb2plY3QodGhpcy5hcmdzKTtcbiAgICAgICAgICAgIGRlYnVnLmdyb3VwLnRyYWNlKCdQcm9qZWN0aW9uI2FmdGVyUmVtb3ZlJyk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFRvKHJlc3VsdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJVcGRhdGUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSl7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVsYXRpb24ucHJvamVjdCh0aGlzLmFyZ3MpO1xuICAgICAgICAgICAgZGVidWcuZ3JvdXAudHJhY2UoJ1Byb2plY3Rpb24jYWZ0ZXJVcGRhdGUnKTtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0VG8ocmVzdWx0KTtcbiAgICAgICAgfVxuXG4gICAgfSwge1xuXG4gICAgICAgIHR5cGUgOiAnUHJvamVjdGlvbidcblxuICAgIH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2plY3Rpb247IiwidmFyIFJlbGF0aW9uID0gcmVxdWlyZSgnLi8uLi9SZWxhdGlvbi5qcycpO1xudmFyIFR1cGxlID0gcmVxdWlyZSgnLi8uLi9UdXBsZS5qcycpO1xudmFyIFNldCA9IHJlcXVpcmUoJy4vLi4vU2V0LmpzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2RlYnVnJyk7XG5cblxuXG52YXIgUmVuYW1lID0gUmVsYXRpb24uZXh0ZW5kKFxuXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgT3BlcmF0b3JzLlJlbmFtZVxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xuICAgICAgICAgKiBAZXh0ZW5kcyBSZWxhdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBFeGFtcGxlIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkEgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge2NoYXJhY3RlcklkOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtmaXJzdE5hbWU6IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7bGFzdE5hbWU6IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbMSwgJ0pvaG4nLCAnRG9lJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbMiwgJ01hcnknLCAnUG9wcGlucyddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzMsICdMdWNreScsICdMdWtlJ11cbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25CID0gcmVsYXRpb25BLnJlbmFtZSh7J2ZpcnN0TmFtZSc6J2ZhbWlseU5hbWUnfSlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG9yXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25DID0gbmV3IGFmZmluaXR5LlByb2plY3Rpb24ocmVsYXRpb25BLCB7J2xhc3ROYW1lJzonZmFtaWx5TmFtZSd9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC0tUkVOQU1FRCBBVFRSSUJVVEUtLS0+XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBjaGFyYWN0ZXJJZCA6IFRJbnRlZ2VyIHwgZmlyc3ROYW1lIDogVFN0cmluZyB8IGZhbWlseU5hbWUgOiBUU3RyaW5nIHxcbiAgICAgICAgICogICAgIC8vICs9PT09PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAvLyB8IDEgICAgICAgICAgICAgICAgICAgICAgfCBKb2huICAgICAgICAgICAgICAgIHwgRG9lICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMiAgICAgICAgICAgICAgICAgICAgICB8IE1hcnkgICAgICAgICAgICAgICAgfCBQb3BwaW5zICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAzICAgICAgICAgICAgICAgICAgICAgIHwgTHVja3kgICAgICAgICAgICAgICB8IEx1a2UgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHJlbGF0aW9uLCBhcmdzKSB7XG5cbiAgICAgICAgICAgIHRoaXMucmVsYXRpb24gPSByZWxhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG5cbiAgICAgICAgICAgIFJlbGF0aW9uLmNhbGwodGhpcyk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnJlbmFtZS50cmFjZSgnI2JpbmRFdmVudHMnKTtcblxuICAgICAgICAgICAgUmVuYW1lLl9fc3VwZXJfXy5iaW5kRXZlbnRzLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgdGhhdC5lZS5vbmNlKCdiZWZvcmVHZXRCb2R5JywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgZGVidWcucmVuYW1lLnRyYWNlKCdiZWZvcmVHZXRCb2R5Jyk7XG5cbiAgICAgICAgICAgICAgICAvL3ZhciBhLCBiLCB0dXBsZUNvdW50LCB0dXBsZSwgdHVwbGVzLCBrZXlzLCBrZXlDb3VudCwga2V5LCBuZXdOYW1lO1xuXG4gICAgICAgICAgICAgICAgLy90aGF0Ll9ib2R5ID0gbmV3IFNldCh7dHlwZTogVHVwbGV9KTtcblxuICAgICAgICAgICAgICAgIC8vdHVwbGVzID0gdGhhdC5yZWxhdGlvbi5ib2R5KCk7XG4gICAgICAgICAgICAgICAgLy90dXBsZUNvdW50ID0gdHVwbGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvL2tleXMgPSBPYmplY3Qua2V5cyh0aGF0LmFyZ3MpO1xuICAgICAgICAgICAgICAgIC8va2V5Q291bnQgPSBrZXlzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIHRoYXQucmVsYXRpb24uZWFjaChmdW5jdGlvbih0dXBsZSl7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1R1cGxlID0gdHVwbGUuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgICAgICBfLmZvckluKHRoYXQuYXJncywgZnVuY3Rpb24odmFsdWUsIGtleSl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHZhbHVlICE9PSBrZXkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1R1cGxlLnNldCh2YWx1ZSwgbmV3VHVwbGUuZ2V0KGtleSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBuZXdUdXBsZS5hdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhhdC5hZGQobmV3VHVwbGUsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhhdC5lZS5vbmNlKCdiZWZvcmVHZXRIZWFkZXInLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICBkZWJ1Zy5yZW5hbWUudHJhY2UoJ2JlZm9yZUdldEhlYWRlcicpO1xuXG4gICAgICAgICAgICAgICAgdGhhdC5oZWFkZXIoKS5jb3B5KHRoYXQucmVsYXRpb24uaGVhZGVyKCkucmVuYW1lKHRoYXQuYXJncykpO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyQWRkIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlbGF0aW9uLnJlbmFtZSh0aGlzLmFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RUbyhyZXN1bHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyUmVtb3ZlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlbGF0aW9uLnJlbmFtZSh0aGlzLmFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RUbyhyZXN1bHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyVXBkYXRlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpe1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVsYXRpb24ucmVuYW1lKHRoaXMuYXJncyk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFRvKHJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgIH0sIHtcblxuXG5cbiAgICB9LCB7XG5cbiAgICAgICAgdHlwZSA6ICdSZW5hbWUnXG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZW5hbWU7IiwidmFyIFJlbGF0aW9uID0gcmVxdWlyZSgnLi8uLi9SZWxhdGlvbi5qcycpO1xudmFyIEhlYWRlciA9IHJlcXVpcmUoJy4vLi4vSGVhZGVyLmpzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2RlYnVnJyk7XG52YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uL0Z1bmN0aW9uLmpzJyk7XG5cblxuXG52YXIgUmVzdHJpY3Rpb24gPSBSZWxhdGlvbi5leHRlbmQoXG5cbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBPcGVyYXRvcnMuUmVzdHJpY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtSZWxhdGlvbn0gcmVsYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlXG4gICAgICAgICAqIEBleHRlbmRzIFJlbGF0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEV4YW1wbGUgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQSA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7Y2hhcmFjdGVySWQ6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2ZpcnN0TmFtZTogeyB0eXBlOiBhZmZpbml0eS5TdHJpbmd9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtsYXN0TmFtZTogeyB0eXBlOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsxLCAnSm9obicsICdEb2UnXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsyLCAnTWFyeScsICdQb3BwaW5zJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbMywgJ0x1Y2t5JywgJ0x1a2UnXVxuICAgICAgICAgKiAgICAgICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBjaGFyYWN0ZXJJZCA9IHJlbGF0aW9uQS5nZXQoJ2NoYXJhY3RlcklkJylcbiAgICAgICAgICogICAgIHZhciBmaXJzdE5hbWUgPSByZWxhdGlvbkEuZ2V0KCdmaXJzdE5hbWUnKVxuICAgICAgICAgKiAgICAgdmFyIGxhc3ROYW1lID0gcmVsYXRpb25BLmdldCgnbGFzdE5hbWUnKVxuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQyA9IHJlbGF0aW9uQS5yZXN0cmljdChjaGFyYWN0ZXJJZC5lcXVhbHMoMSkpXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBvclxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQyA9IG5ldyBhZmZpbml0eS5Qcm9qZWN0aW9uKHJlbGF0aW9uQSwgY2hhcmFjdGVySWQuZXF1YWxzKDEpKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBjaGFyYWN0ZXJJZCA6IFRJbnRlZ2VyIHwgZmlyc3ROYW1lIDogVFN0cmluZyB8IGxhc3ROYW1lIDogVFN0cmluZyB8XG4gICAgICAgICAqICAgICAvLyArPT09PT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgIC8vIHwgMSAgICAgICAgICAgICAgICAgICAgICB8IEpvaG4gICAgICAgICAgICAgICAgfCBEb2UgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHJlbGF0aW9uLCBwcmVkaWNhdGUpIHtcblxuICAgICAgICAgICAgdGhpcy5yZWwgPSByZWxhdGlvbjtcbiAgICAgICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICAgICAgUmVsYXRpb24uY2FsbCh0aGlzKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGJpbmRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgZGVidWcucmVzdHJpY3Rpb24udHJhY2UoJyNiaW5kRXZlbnRzJyk7XG5cbiAgICAgICAgICAgIFJlc3RyaWN0aW9uLl9fc3VwZXJfXy5iaW5kRXZlbnRzLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuXG4gICAgICAgICAgICB0aGF0LmVlLm9uY2UoJ2JlZm9yZUdldEhlYWRlcicsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIGRlYnVnLnJlc3RyaWN0aW9uLnRyYWNlKCdiZWZvcmVHZXRIZWFkZXInKTtcblxuICAgICAgICAgICAgICAgIHRoYXQuaGVhZGVyKCkuY29weSh0aGF0LnJlbC5oZWFkZXIoKSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgIHRoYXQuZWUub25jZSgnYmVmb3JlR2V0Qm9keScsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIHRoYXQucmVsLmVhY2goIGZ1bmN0aW9uICh0dXBsZSkgeyB0aGF0LmFmdGVyQWRkKHR1cGxlKTsgfSlcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoYXQucmVsLmVlLm9uKCdhZnRlckFkZCcsIGZ1bmN0aW9uKHR1cGxlKXtcbiAgICAgICAgICAgICAgICB0aGF0LmFmdGVyQWRkKHR1cGxlKTtcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlckFkZCA6IGZ1bmN0aW9uKHR1cGxlKXtcblxuICAgICAgICAgICAgZGVidWcucmVzdHJpY3Rpb24udHJhY2UoJ2FmdGVyQWRkJyk7XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgdGhhdC5oZWFkZXIoKTtcblxuICAgICAgICAgICAgaWYodGhhdC5wcmVkaWNhdGUgaW5zdGFuY2VvZiBGdW5jdGlvbil7XG5cbiAgICAgICAgICAgICAgICB0aGF0LnByZWRpY2F0ZS5jb252ZXJ0QXR0cmlidXRlVG9UdXBsZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoYXQucHJlZGljYXRlLmFzc2lnblR1cGxlKHR1cGxlKS52YWx1ZSgpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYWRkKHR1cGxlLmNsb25lKCksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc0Z1bmN0aW9uKHRoYXQucHJlZGljYXRlKSkge1xuXG4gICAgICAgICAgICAgICAgaWYodGhhdC5wcmVkaWNhdGUodHVwbGUpKXtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5hZGQodHVwbGUuY2xvbmUoKSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbnN1cHBvcnRlZCBwcmVkaWNhdGUgdHlwZScpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlclJlbW92ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSl7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZWxhdGlvbi5yZXN0cmljdCh0aGlzLnByZWRpY2F0ZSk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFRvKHJlc3VsdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJVcGRhdGUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSl7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZWxhdGlvbi5yZXN0cmljdCh0aGlzLnByZWRpY2F0ZSk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFRvKHJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgIH0sIHtcblxuICAgICAgICB0eXBlIDogJ1Jlc3RyaWN0aW9uJ1xuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVzdHJpY3Rpb247IiwidmFyIFJlbGF0aW9uID0gcmVxdWlyZSgnLi8uLi9SZWxhdGlvbi5qcycpO1xudmFyIEhlYWRlciA9IHJlcXVpcmUoJy4vLi4vSGVhZGVyLmpzJyk7XG52YXIgVHVwbGUgPSByZXF1aXJlKCcuLy4uL1R1cGxlLmpzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2RlYnVnJyk7XG52YXIgZXF1YWwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvZXF1YWwnKTtcblxuXG5cbnZhciBTZW1pRGlmZmVyZW5jZSA9IFJlbGF0aW9uLmV4dGVuZChcblxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIE9wZXJhdG9ycy5TZW1pRGlmZmVyZW5jZVxuICAgICAgICAgKiBAZXh0ZW5kcyBSZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvbkEgVGhlIHJlbGF0aW9uIGZyb20gd2hpY2ggdG8gc2VlayB0dXBsZXMgd2l0aCBubyBjb3VudGVycGFydFxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvbkIgVGhlIHJlbGF0aW9uIGNvbnRhaW5pbmcgdGhlIGNvdW50ZXJwYXJ0c1xuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgU2VtaURpZmZlcmVuY2Ugd2lsbCBmaW5kIGFsbCB0dXBsZXMgaW4gQSB0aGF0IGRvIG5vdCBoYXZlIGEgY291bnRlcnBhcnQgaW4gQiBvbiB0aGVpciBjb21tb24gYXR0cmlidXRlc1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gRmluZCB0aGUgY2hhcmFjdGVycyB0aGF0IGRvIG5vdCBoYXZlIGZhbnNcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkEgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge2NoYXJhY3RlcklkOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtmaXJzdE5hbWU6IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7bGFzdE5hbWU6IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbMSwgJ0pvaG4nLCAnRG9lJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbMiwgJ01hcnknLCAnUG9wcGlucyddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzMsICdMdWNreScsICdMdWtlJ11cbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25CID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgICAgIHtjaGFyYWN0ZXJJZDogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7ZmFuOiB7IHR5cGU6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWzEsICdNciBYJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbMSwgJ01pc3MgRGliYmxlJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbMiwgJ05hdCBCaWJibGUnXVxuICAgICAgICAgKiAgICAgICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkMgPSByZWxhdGlvbkEuc2RpZmZlcmVuY2UocmVsYXRpb25CKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG9yXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25DID0gbmV3IGFmZmluaXR5LlNlbWlEaWZmZXJlbmNlKHJlbGF0aW9uQSwgcmVsYXRpb25CKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IGNoYXJhY3RlcklkIDogVEludGVnZXIgfCBmaXJzdE5hbWUgOiBUU3RyaW5nIHwgbGFzdE5hbWUgOiBUU3RyaW5nIHxcbiAgICAgICAgICogICAgIC8vICs9PT09PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgLy8gfCAzICAgICAgICAgICAgICAgICAgICAgIHwgTHVja3kgICAgICAgICAgICAgICB8IEx1a2UgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vXG4gICAgICAgICAqICAgICAvLyBMdWNreSBMdWtlIGlzIHRoZSBvbmx5IGNoYXJhY3RlciB3aXRob3V0IGEgZmFuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHJlbGF0aW9uQSwgcmVsYXRpb25CKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnNlbWlEaWZmZXJlbmNlLnRyYWNlKCcjY29uc3RydWN0b3InKTtcblxuICAgICAgICAgICAgdGhpcy5yZWxzID0gW3JlbGF0aW9uQSwgcmVsYXRpb25CXTtcblxuICAgICAgICAgICAgUmVsYXRpb24uY2FsbCh0aGlzKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGJpbmRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgZGVidWcuc2VtaURpZmZlcmVuY2UudHJhY2UoJyNiaW5kRXZlbnRzJyk7XG5cbiAgICAgICAgICAgIC8vIENhbGxpbmcgdGhlIHBhcmVudCBiaW5kRXZlbnRzXG4gICAgICAgICAgICBTZW1pRGlmZmVyZW5jZS5fX3N1cGVyX18uYmluZEV2ZW50cy5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIEJlZm9yZUdldEhlYWRlclxuICAgICAgICAgICAgdGhpcy5lZS5vbmNlKCdiZWZvcmVHZXRIZWFkZXInLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICBkZWJ1Zy5zZW1pRGlmZmVyZW5jZS50cmFjZSgnYmVmb3JlR2V0SGVhZGVyJyk7XG5cbiAgICAgICAgICAgICAgICBIZWFkZXIuYXNzZXJ0U2FtZU5hbWVTYW1lVHlwZSh0aGF0LnJlbHNbMF0uaGVhZGVyKCksIHRoYXQucmVsc1sxXS5oZWFkZXIoKSk7XG5cbiAgICAgICAgICAgICAgICB0aGF0LmNvbW1vbkF0dHJpYnV0ZXMgPSB0aGF0LnJlbHNbMF0uaGVhZGVyKCkuc2V0SW50ZXJzZWN0aW9uKHRoYXQucmVsc1sxXS5oZWFkZXIoKSk7XG5cbiAgICAgICAgICAgICAgICB0aGF0LmhlYWRlcigpLmNvcHkodGhhdC5yZWxzWzBdLmhlYWRlcigpKTtcblxuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgLy8gQmVmb3JlR2V0Qm9keVxuICAgICAgICAgICAgdGhpcy5lZS5vbmNlKCdiZWZvcmVHZXRCb2R5JywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgdGhhdC5oZWFkZXIoKTtcblxuICAgICAgICAgICAgICAgIGRlYnVnLnNlbWlEaWZmZXJlbmNlLnRyYWNlKCdiZWZvcmVHZXRCb2R5Jyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVsMSA9IHRoYXQucmVsc1swXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVsMiA9IHRoYXQucmVsc1sxXTtcblxuICAgICAgICAgICAgICAgIHJlbDEuZWFjaChmdW5jdGlvbih0dXBsZTEpe1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3VudGVycGFydCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoYXQuY29tbW9uQXR0cmlidXRlcy5sZW5ndGgoKSA+IDApe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZWwyLmVhY2goZnVuY3Rpb24odHVwbGUyKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHR1cGxlMSBoYXMgc2FtZSBjb21tb24gYXR0cmlidXRlcyBhcyB0dXBsZTJcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IFR1cGxlLm1hdGNoT25BdHRyaWJ1dGVzKHR1cGxlMSwgdHVwbGUyLCB0aGF0LmNvbW1vbkF0dHJpYnV0ZXMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYobWF0Y2gpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVycGFydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZighY291bnRlcnBhcnQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5hZGQodHVwbGUxLmNsb25lKCksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlckxlZnRBZGQgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUpe1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJMZWZ0UmVtb3ZlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyTGVmdFVwZGF0ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSwgYXR0cmlidXRlTmFtZSwgdmFsdWUsIG9sZFZhbHVlKXtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyUmlnaHRBZGQgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUpe1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJSaWdodFJlbW92ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSl7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlclJpZ2h0VXBkYXRlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpe1xuXG4gICAgICAgIH1cblxuICAgIH0sIHtcblxuICAgICAgICB0eXBlIDogJ1NlbWlEaWZmZXJlbmNlJ1xuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2VtaURpZmZlcmVuY2U7IiwidmFyIFJlbGF0aW9uID0gcmVxdWlyZSgnLi8uLi9SZWxhdGlvbi5qcycpO1xudmFyIEhlYWRlciA9IHJlcXVpcmUoJy4vLi4vSGVhZGVyLmpzJyk7XG52YXIgVHVwbGUgPSByZXF1aXJlKCcuLy4uL1R1cGxlLmpzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2RlYnVnJyk7XG52YXIgZXF1YWwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvZXF1YWwnKTtcblxuXG5cbnZhciBTZW1pSm9pbiA9IFJlbGF0aW9uLmV4dGVuZChcblxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIE9wZXJhdG9ycy5TZW1pSm9pblxuICAgICAgICAgKiBAZXh0ZW5kcyBSZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvbkEgVGhlIHJlbGF0aW9uIGZyb20gd2hpY2ggdG8gc2VlayB0dXBsZXMgd2l0aCB0aGVpciBjb3VudGVycGFydHMgaW4gQlxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvbkIgVGhlIHJlbGF0aW9uIGNvbnRhaW5pbmcgdGhlIGNvdW50ZXJwYXJ0c1xuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgU2VtaUpvaW4gd2lsbCBmaW5kIGFsbCB0dXBsZXMgaW4gQSB0aGF0IGhhdmUgYSBjb3VudGVycGFydCBpbiBCIG9uIHRoZWlyIGNvbW1vbiBhdHRyaWJ1dGVzXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBGaW5kIHRoZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBmYW5zXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25BID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgICAgIHtjaGFyYWN0ZXJJZDogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7Zmlyc3ROYW1lOiB7IHR5cGU6IGFmZmluaXR5LlN0cmluZ319LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2xhc3ROYW1lOiB7IHR5cGU6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWzEsICdKb2huJywgJ0RvZSddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzIsICdNYXJ5JywgJ1BvcHBpbnMnXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFszLCAnTHVja3knLCAnTHVrZSddXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7Y2hhcmFjdGVySWQ6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2ZhbjogeyB0eXBlOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsxLCAnTXIgWCddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzEsICdNaXNzIERpYmJsZSddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzIsICdOYXQgQmliYmxlJ11cbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25DID0gcmVsYXRpb25BLnNqb2luKHJlbGF0aW9uQik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBvclxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQyA9IG5ldyBhZmZpbml0eS5TZW1pSm9pbihyZWxhdGlvbkEsIHJlbGF0aW9uQilcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBjaGFyYWN0ZXJJZCA6IFRJbnRlZ2VyIHwgZmlyc3ROYW1lIDogVFN0cmluZyB8IGxhc3ROYW1lIDogVFN0cmluZyB8XG4gICAgICAgICAqICAgICAvLyArPT09PT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgIC8vIHwgMSAgICAgICAgICAgICAgICAgICAgICB8IEpvaG4gICAgICAgICAgICAgICAgfCBEb2UgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDIgICAgICAgICAgICAgICAgICAgICAgfCBNYXJ5ICAgICAgICAgICAgICAgIHwgUG9wcGlucyAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy9cbiAgICAgICAgICogICAgIC8vIEpvaG4gRG9lIGFuZCBNYXJ5IFBvcHBpbnMgaGF2ZSBmYW5zXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHJlbGF0aW9uQSwgcmVsYXRpb25CKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnNlbWlKb2luLnRyYWNlKCcjY29uc3RydWN0b3InKTtcblxuICAgICAgICAgICAgdGhpcy5yZWxzID0gW3JlbGF0aW9uQSwgcmVsYXRpb25CXTtcblxuICAgICAgICAgICAgUmVsYXRpb24uY2FsbCh0aGlzKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGJpbmRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgZGVidWcuc2VtaUpvaW4udHJhY2UoJyNiaW5kRXZlbnRzJyk7XG5cbiAgICAgICAgICAgIC8vIENhbGxpbmcgdGhlIHBhcmVudCBiaW5kRXZlbnRzXG4gICAgICAgICAgICBTZW1pSm9pbi5fX3N1cGVyX18uYmluZEV2ZW50cy5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIEJlZm9yZUdldEhlYWRlclxuICAgICAgICAgICAgdGhpcy5lZS5vbmNlKCdiZWZvcmVHZXRIZWFkZXInLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICBkZWJ1Zy5zZW1pSm9pbi50cmFjZSgnYmVmb3JlR2V0SGVhZGVyJyk7XG5cbiAgICAgICAgICAgICAgICBIZWFkZXIuYXNzZXJ0U2FtZU5hbWVTYW1lVHlwZSh0aGF0LnJlbHNbMF0uaGVhZGVyKCksIHRoYXQucmVsc1sxXS5oZWFkZXIoKSk7XG5cbiAgICAgICAgICAgICAgICB0aGF0LmNvbW1vbkF0dHJpYnV0ZXMgPSB0aGF0LnJlbHNbMF0uaGVhZGVyKCkuc2V0SW50ZXJzZWN0aW9uKHRoYXQucmVsc1sxXS5oZWFkZXIoKSk7XG5cbiAgICAgICAgICAgICAgICB0aGF0LmhlYWRlcigpLmNvcHkodGhhdC5yZWxzWzBdLmhlYWRlcigpKTtcblxuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgLy8gQmVmb3JlR2V0Qm9keVxuICAgICAgICAgICAgdGhpcy5lZS5vbmNlKCdiZWZvcmVHZXRCb2R5JywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgZGVidWcuc2VtaUpvaW4udHJhY2UoJ2JlZm9yZUdldEJvZHknKTtcblxuICAgICAgICAgICAgICAgIHZhciByZWxhdGlvbjEgPSB0aGF0LnJlbHNbMF07XG4gICAgICAgICAgICAgICAgdmFyIHJlbGF0aW9uMiA9IHRoYXQucmVsc1sxXTtcblxuICAgICAgICAgICAgICAgIHJlbGF0aW9uMS5lYWNoKGZ1bmN0aW9uKHR1cGxlMSl7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ZXJwYXJ0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuY29tbW9uQXR0cmlidXRlcy5sZW5ndGgoKSA+IDApe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGlvbjIuZWFjaChmdW5jdGlvbih0dXBsZTIpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gVHVwbGUubWF0Y2hPbkF0dHJpYnV0ZXModHVwbGUxLCB0dXBsZTIsIHRoYXQuY29tbW9uQXR0cmlidXRlcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihtYXRjaCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJwYXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKGNvdW50ZXJwYXJ0KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYWRkKHR1cGxlMS5jbG9uZSgpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJMZWZ0QWRkIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyTGVmdFJlbW92ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSl7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlckxlZnRVcGRhdGUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSl7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlclJpZ2h0QWRkIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyUmlnaHRSZW1vdmUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUpe1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJSaWdodFVwZGF0ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSwgYXR0cmlidXRlTmFtZSwgdmFsdWUsIG9sZFZhbHVlKXtcblxuICAgICAgICB9XG5cbiAgICB9LCB7XG5cbiAgICAgICAgdHlwZSA6ICdTZW1pSm9pbidcblxuICAgIH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbWlKb2luOyIsInZhciBSZWxhdGlvbiA9IHJlcXVpcmUoJy4vLi4vUmVsYXRpb24uanMnKTtcbnZhciBIZWFkZXIgPSByZXF1aXJlKCcuLy4uL0hlYWRlci5qcycpO1xudmFyIFR1cGxlID0gcmVxdWlyZSgnLi8uLi9UdXBsZS5qcycpO1xudmFyIEF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4vLi4vQXR0cmlidXRlLmpzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2RlYnVnJyk7XG5cbnZhciBTdW1tYXJpemUgPSBSZWxhdGlvbi5leHRlbmQoe1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIE9wZXJhdG9ycy5TdW1tYXJpemVcbiAgICAgKiBAZXh0ZW5kcyBSZWxhdGlvblxuICAgICAqXG4gICAgICogVGhlIFN1bW1hcml6ZSBvcGVyYXRpb24gd2lsbCBiZSB0aGUgcHJvamVjdGlvbiByZXN1bHQgb2YgZ2l2ZW4gcmVsYXRpb24gYXR0cmlidXRlc1xuICAgICAqIHdoaWxlIGV4dGVuZGluZyB0aGlzIHJlc3VsdGluZyByZWxhdGlvbiB3aXRoIGNhbGN1bGF0ZWQgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIEV4YW1wbGUgOlxuICAgICAqXG4gICAgICogICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICogICAgICAgICB7IGlkIDoge3R5cGUgOiBhZmZpbml0eS5JbnRlZ2VyfSB9LFxuICAgICAqICAgICAgICAgeyBuYW1lIDoge3R5cGUgOiBhZmZpbml0eS5TdHJpbmd9IH0sXG4gICAgICogICAgICAgICB7IGFnZSA6IHt0eXBlIDogYWZmaW5pdHkuSW50ZWdlcn0gfSxcbiAgICAgKiAgICAgXSxbXG4gICAgICogICAgICAgICBbMSwgJ0pvaG4gRG9lJywgMjNdLFxuICAgICAqICAgICAgICAgWzIsICdKb2huIERvZScsIDM1XSxcbiAgICAgKiAgICAgICAgIFszLCAnSm9obiBEb2UnLCAyN10sXG4gICAgICogICAgICAgICBbNCwgJ0JvIERlcmVrJywgMTJdLFxuICAgICAqICAgICAgICAgWzUsICdCbyBEZXJlaycsIDddLFxuICAgICAqICAgICAgICAgWzYsICdNYXJpbHluIE1vbnJvZScsIDE2XSxcbiAgICAgKiAgICAgXSk7XG4gICAgICpcbiAgICAgKiAgICAgdmFyIGFnZSA9IHJlbGF0aW9uLmdldCgnYWdlJyk7XG4gICAgICpcbiAgICAgKiAgICAgdmFyIHN1bW1hcml6ZWQgPSByZWxhdGlvbi5zdW1tYXJpemUoXG4gICAgICogICAgICAgICBbJ25hbWUnXSxcbiAgICAgKiAgICAgICAgIFtcbiAgICAgKiAgICAgICAgICAgICB7IFwiYWdlLmF2ZygpXCIgOiBhZ2UuYXZnKCkgICAgICAgIH0sXG4gICAgICogICAgICAgICAgICAgeyBcImFnZS5zdW0oKVwiIDogYWdlLnN1bSgpICAgICAgICB9LFxuICAgICAqICAgICAgICAgICAgIHsgXCJjb3VudCgpXCIgICA6IGFmZmluaXR5LmNvdW50KCkgfVxuICAgICAqICAgICAgICAgXVxuICAgICAqICAgICApO1xuICAgICAqXG4gICAgICogICAgIHN1bW1hcml6ZWQucHJpbnQoKTtcbiAgICAgKlxuICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKiAgICAgLy8gfCBuYW1lIDogU3RyaW5nICAgIHwgYWdlLmF2ZygpIDogRmxvYXQgICAgfCBhZ2Uuc3VtKCkgOiBGbG9hdCAgIHwgY291bnQoKSA6IEludGVnZXIgICB8XG4gICAgICogICAgIC8vICs9PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09K1xuICAgICAqICAgICAvLyB8IEpvaG4gRG9lICAgICAgICAgfCAyOC4zMzMzMzMzMzMzMzMzMzIgICB8IDg1ICAgICAgICAgICAgICAgICAgfCAzICAgICAgICAgICAgICAgICAgIHxcbiAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICogICAgIC8vIHwgQm8gRGVyZWsgICAgICAgICB8IDkuNSAgICAgICAgICAgICAgICAgIHwgMTkgICAgICAgICAgICAgICAgICB8IDIgICAgICAgICAgICAgICAgICAgfFxuICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKiAgICAgLy8gfCBNYXJpbHluIE1vbnJvZSAgIHwgMTYgICAgICAgICAgICAgICAgICAgfCAxNiAgICAgICAgICAgICAgICAgIHwgMSAgICAgICAgICAgICAgICAgICB8XG4gICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IFN1bW1hcnkgcmVsYXRpb25cbiAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvbiBUaGUgcmVsYXRpb24gdG8gc3VtbWFyaXplXG4gICAgICogQHBhcmFtIHtBdHRyaWJ1dGVbXXxTdHJpbmdbXX0gYXR0cmlidXRlcyBUaGUgYXR0cmlidXRlcyB0byBrZWVwXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gc3VtbWFyaWVzIFRoZSBzdW1tYXJ5IGV4cHJlc3Npb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgOiBmdW5jdGlvbihyZWxhdGlvbiwgYXR0cmlidXRlcywgc3VtbWFyaWVzKXtcblxuICAgICAgICB0aGlzLmFyZ3MgPSB7fTtcblxuICAgICAgICB0aGlzLmFyZ3MucmVsYXRpb24gPSByZWxhdGlvbjtcblxuICAgICAgICB0aGlzLmFyZ3MuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG5cbiAgICAgICAgdGhpcy5hcmdzLnN1bW1hcmllcyA9IHN1bW1hcmllcztcblxuICAgICAgICBSZWxhdGlvbi5jYWxsKHRoaXMpO1xuXG4gICAgfSxcblxuICAgIGJpbmRFdmVudHMgOiBmdW5jdGlvbigpe1xuXG4gICAgICAgIGRlYnVnLnNlbWlKb2luLnRyYWNlKCcjYmluZEV2ZW50cycpO1xuXG4gICAgICAgIC8vIENhbGxpbmcgdGhlIHBhcmVudCBiaW5kRXZlbnRzXG4gICAgICAgIFN1bW1hcml6ZS5fX3N1cGVyX18uYmluZEV2ZW50cy5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICB0aGF0LmVlLm9uY2UoJ2JlZm9yZUdldEhlYWRlcicsIGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgIHZhciByZWxhdGlvbiA9IHRoYXQuYXJncy5yZWxhdGlvbjtcblxuICAgICAgICAgICAgdmFyIGhlYWRlciA9IHJlbGF0aW9uLmhlYWRlcigpO1xuXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoYXQuYXJncy5hdHRyaWJ1dGVzO1xuXG4gICAgICAgICAgICB2YXIgc3VtbWFyaWVzID0gdGhhdC5hcmdzLnN1bW1hcmllcztcblxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgZ2l2ZW4gYXR0cmlidXRlcyBleGlzdCBpbiB0aGVcbiAgICAgICAgICAgIC8vIGJhc2UgaGVhZGVyLlxuICAgICAgICAgICAgSGVhZGVyLmFzc2VydEF0dHJpYnV0ZXNFeGlzdChoZWFkZXIsIGF0dHJpYnV0ZXMpO1xuXG4gICAgICAgICAgICAvLyBDb3B5IHRoZSBnaXZlbiBhdHRyaWJ1dGVzIGZyb20gdGhlIGJhc2UgaGVhZGVyXG4gICAgICAgICAgICB0aGF0LmhlYWRlcigpLmNvcHkocmVsYXRpb24uaGVhZGVyKCksIGF0dHJpYnV0ZXMpO1xuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIHN1bW1hcmllcyBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBfLmZvckVhY2goc3VtbWFyaWVzLCBmdW5jdGlvbihzdW1tYXJ5KXtcblxuICAgICAgICAgICAgICAgIHZhciBzdW1tYXJ5TmFtZSA9IE9iamVjdC5rZXlzKHN1bW1hcnkpWzBdO1xuXG4gICAgICAgICAgICAgICAgdmFyIHN1bW1hcnlFeHByZXNzaW9uID0gc3VtbWFyeVtzdW1tYXJ5TmFtZV07XG5cbiAgICAgICAgICAgICAgICB2YXIgc3VtbWFyeVR5cGUgPSBzdW1tYXJ5RXhwcmVzc2lvbi50eXBlKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbmV3QXR0cmlidXRlID0gbmV3IEF0dHJpYnV0ZSh7bmFtZSA6IHN1bW1hcnlOYW1lLCB0eXBlIDogc3VtbWFyeVR5cGV9KTtcblxuICAgICAgICAgICAgICAgIHRoYXQuaGVhZGVyKCkuYWRkKG5ld0F0dHJpYnV0ZSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoYXQuZWUub25jZSgnYmVmb3JlR2V0Qm9keScsIGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgIHZhciByZWxhdGlvbiA9IHRoYXQuYXJncy5yZWxhdGlvbjtcblxuICAgICAgICAgICAgdmFyIGhlYWRlciA9IHJlbGF0aW9uLmhlYWRlcigpO1xuXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoYXQuYXJncy5hdHRyaWJ1dGVzO1xuXG4gICAgICAgICAgICB2YXIgc3VtbWFyaWVzID0gdGhhdC5hcmdzLnN1bW1hcmllcztcblxuICAgICAgICAgICAgdmFyIGluc3RhbmNlQXR0cmlidXRlcyA9IG5ldyBIZWFkZXIoKTtcblxuICAgICAgICAgICAgaW5zdGFuY2VBdHRyaWJ1dGVzLmNvcHkoaGVhZGVyLCBhdHRyaWJ1dGVzKTtcblxuICAgICAgICAgICAgLy8gVGhlc2UgYXJlIHRoZSBhdHRyaWJ1dGVzIHRoYXQgd2lsbCBiZSBncm91cGVkXG4gICAgICAgICAgICB2YXIgb3RoZXJBdHRyaWJ1dGVzID0gaGVhZGVyLnNldERpZmZlcmVuY2UoaW5zdGFuY2VBdHRyaWJ1dGVzKTtcblxuICAgICAgICAgICAgdmFyIG90aGVyQXR0cmlidXRlTmFtZXMgPSBbXTtcblxuICAgICAgICAgICAgb3RoZXJBdHRyaWJ1dGVzLmVhY2goZnVuY3Rpb24ob3RoZXJBdHRyaWJ1dGUpe1xuICAgICAgICAgICAgICAgIG90aGVyQXR0cmlidXRlTmFtZXMucHVzaChvdGhlckF0dHJpYnV0ZS5uYW1lKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYW4gaW50ZXJtZWRpYXJ5IGdyb3VwIHJlbGF0aW9uXG4gICAgICAgICAgICB2YXIgZ3JvdXBlZCA9IHJlbGF0aW9uLmdyb3VwKCdfX19ncm91cGVkX19fJywgb3RoZXJBdHRyaWJ1dGVOYW1lcyk7XG5cbiAgICAgICAgICAgIGdyb3VwZWQuZWFjaChmdW5jdGlvbihncm91cGVkVHVwbGUpe1xuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSB0dXBsZSB0aGF0IHdpbGwgYmUgaW5zZXJ0ZWRcbiAgICAgICAgICAgICAgICB2YXIgbmV3VHVwbGUgPSBuZXcgVHVwbGUoKTtcblxuICAgICAgICAgICAgICAgIC8vIENvcHkgdGhlIG5vbi1ncm91cGVkIGF0dHJpYnV0ZXMgaW50byB0aGUgbmV3IHR1cGxlXG4gICAgICAgICAgICAgICAgbmV3VHVwbGUuY29weShncm91cGVkVHVwbGUsIGF0dHJpYnV0ZXMpO1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBncm91cGVkIHJlbGF0aW9uXG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwZWRSZWxhdGlvbiA9IGdyb3VwZWRUdXBsZS5nZXQoJ19fX2dyb3VwZWRfX18nKTtcblxuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChzdW1tYXJpZXMsIGZ1bmN0aW9uKHN1bW1hcnkpe1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdW1tYXJ5TmFtZSA9IE9iamVjdC5rZXlzKHN1bW1hcnkpWzBdO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdW1tYXJ5RXhwcmVzc2lvbiA9IHN1bW1hcnlbc3VtbWFyeU5hbWVdO1xuXG4gICAgICAgICAgICAgICAgICAgIHN1bW1hcnlFeHByZXNzaW9uLnJlbGF0aW9uID0gZ3JvdXBlZFJlbGF0aW9uO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdW1tYXJ5VmFsdWUgPSBzdW1tYXJ5RXhwcmVzc2lvbi52YWx1ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIG5ld1R1cGxlLnNldChzdW1tYXJ5TmFtZSwgc3VtbWFyeVZhbHVlKTtcblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhhdC5hZGQobmV3VHVwbGUpO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KVxuXG4gICAgfSxcblxuICAgIGFmdGVyQWRkIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcblxuICAgIH0sXG5cbiAgICBhZnRlclJlbW92ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSl7XG5cbiAgICB9LFxuXG4gICAgYWZ0ZXJVcGRhdGUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSl7XG5cbiAgICB9XG5cbn0sIHtcblxuICAgIHR5cGUgOiAnU3VtbWFyaXplJ1xuXG59KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFN1bW1hcml6ZTsiLCJ2YXIgUmVsYXRpb24gPSByZXF1aXJlKCcuLy4uL1JlbGF0aW9uLmpzJyk7XG52YXIgSGVhZGVyID0gcmVxdWlyZSgnLi8uLi9IZWFkZXIuanMnKTtcbnZhciBUdXBsZSA9IHJlcXVpcmUoJy4vLi4vVHVwbGUuanMnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvZGVidWcnKTtcblxuXG5cbnZhciBVbmdyb3VwID0gUmVsYXRpb24uZXh0ZW5kKFxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIE9wZXJhdG9ycy5Vbmdyb3VwXG4gICAgICAgICAqIEBleHRlbmRzIFJlbGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uIFRoZSByZWxhdGlvbiB0byB1bmdyb3VwXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGdyb3VwZWRBdHRyaWJ1dGVzIFRoZSBncm91cGVkIGF0dHJpYnV0ZSBuYW1lcyB0byB1bmdyb3VwXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBVbmdyb3VwIG9wZXJhdGlvbiB3aWxsIHVuZ3JvdXAgdGhlIHNwZWNpZmllZCBncm91cGVkIGF0dHJpYnV0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25BID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgICAgIHthOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtiOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtjOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsxLCAyLCAzXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFs0LCA1LCA2XSxcbiAgICAgICAgICogICAgICAgICAgICAgIFs0LCA5LCA5XSxcbiAgICAgICAgICogICAgICAgICAgICAgIFs3LCA4LCA5XVxuICAgICAgICAgKiAgICAgICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkIgPSByZWxhdGlvbkEuZ3JvdXAoJ2dyb3VwZWRBdHRyaWJ1dGUnLCBbJ2InLCAnYyddKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgYSA6IFRJbnRlZ2VyIHwgZ3JvdXBlZEF0dHJpYnV0ZSA6IFJlbGF0aW9uICAgICB8XG4gICAgICAgICAqICAgICAvLyArPT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgLy8gfCAxICAgICAgICAgICAgfCArLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgICogICAgIC8vIHwgICAgICAgICAgICAgIHwgfCBiIDogVEludGVnZXIgfCBjIDogVEludGVnZXIgfCB8XG4gICAgICAgICAqICAgICAvLyB8ICAgICAgICAgICAgICB8ICs9PT09PT09PT09PT09PSs9PT09PT09PT09PT09PSsgfFxuICAgICAgICAgKiAgICAgLy8gfCAgICAgICAgICAgICAgfCB8IDIgICAgICAgICAgICB8IDMgICAgICAgICAgICB8IHxcbiAgICAgICAgICogICAgIC8vIHwgICAgICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKyB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCA0ICAgICAgICAgICAgfCArLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgICogICAgIC8vIHwgICAgICAgICAgICAgIHwgfCBiIDogVEludGVnZXIgfCBjIDogVEludGVnZXIgfCB8XG4gICAgICAgICAqICAgICAvLyB8ICAgICAgICAgICAgICB8ICs9PT09PT09PT09PT09PSs9PT09PT09PT09PT09PSsgfFxuICAgICAgICAgKiAgICAgLy8gfCAgICAgICAgICAgICAgfCB8IDUgICAgICAgICAgICB8IDYgICAgICAgICAgICB8IHxcbiAgICAgICAgICogICAgIC8vIHwgICAgICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKyB8XG4gICAgICAgICAqICAgICAvLyB8ICAgICAgICAgICAgICB8IHwgOSAgICAgICAgICAgIHwgOSAgICAgICAgICAgIHwgfFxuICAgICAgICAgKiAgICAgLy8gfCAgICAgICAgICAgICAgfCArLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDcgICAgICAgICAgICB8ICstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLSsgfFxuICAgICAgICAgKiAgICAgLy8gfCAgICAgICAgICAgICAgfCB8IGIgOiBUSW50ZWdlciB8IGMgOiBUSW50ZWdlciB8IHxcbiAgICAgICAgICogICAgIC8vIHwgICAgICAgICAgICAgIHwgKz09PT09PT09PT09PT09Kz09PT09PT09PT09PT09KyB8XG4gICAgICAgICAqICAgICAvLyB8ICAgICAgICAgICAgICB8IHwgOCAgICAgICAgICAgIHwgOSAgICAgICAgICAgIHwgfFxuICAgICAgICAgKiAgICAgLy8gfCAgICAgICAgICAgICAgfCArLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25DID0gcmVsYXRpb25CLnVuZ3JvdXAoWydncm91cGVkQXR0cmlidXRlJ10pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gICAgICAgICAgICAgICAgIDwtLS0tVU5HUk9VUEVEIEFUVFJJQlVURVMtLS0tPlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBhIDogVEludGVnZXIgfCBiIDogVEludGVnZXIgfCBjIDogVEludGVnZXIgfFxuICAgICAgICAgKiAgICAgLy8gKz09PT09PT09PT09PT09Kz09PT09PT09PT09PT09Kz09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgLy8gfCAxICAgICAgICAgICAgfCAyICAgICAgICAgICAgfCAzICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCA0ICAgICAgICAgICAgfCA1ICAgICAgICAgICAgfCA2ICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCA0ICAgICAgICAgICAgfCA5ICAgICAgICAgICAgfCA5ICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCA3ICAgICAgICAgICAgfCA4ICAgICAgICAgICAgfCA5ICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgcmVsYXRpb25DLmVxdWFsKHJlbGF0aW9uQSkgLy8gdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIChyZWxhdGlvbiwgZ3JvdXBlZEF0dHJpYnV0ZXMpIHtcblxuICAgICAgICAgICAgZGVidWcudW5ncm91cC50cmFjZSgnI2NvbnN0cnVjdG9yJyk7XG5cbiAgICAgICAgICAgIHRoaXMucmVsYXRpb24gPSByZWxhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBlZEF0dHJpYnV0ZU5hbWVzID0gZ3JvdXBlZEF0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgIFJlbGF0aW9uLmNhbGwodGhpcyk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnVuZ3JvdXAudHJhY2UoJyNiaW5kRXZlbnRzJyk7XG5cbiAgICAgICAgICAgIC8vIENhbGxpbmcgdGhlIHBhcmVudCBiaW5kRXZlbnRzXG4gICAgICAgICAgICBVbmdyb3VwLl9fc3VwZXJfXy5iaW5kRXZlbnRzLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgLy8gQmVmb3JlR2V0SGVhZGVyXG4gICAgICAgICAgICB0aGlzLmVlLm9uY2UoJ2JlZm9yZUdldEhlYWRlcicsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIGRlYnVnLnVuZ3JvdXAudHJhY2UoJ2JlZm9yZUdldEhlYWRlcicpO1xuXG4gICAgICAgICAgICAgICAgLy8gTGV0J3MgXCJmbGF0dGVuXCIgdGhlIGhlYWRlcnMuIFdlIHdpbGwgYWRkIHRoZSBuZXN0ZWQgcmVsYXRpb24gaGVhZGVyIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAvLyB0byB0aGlzIHJlbGF0aW9uXG5cbiAgICAgICAgICAgICAgICBfLmZvckVhY2godGhhdC5ncm91cGVkQXR0cmlidXRlTmFtZXMsIGZ1bmN0aW9uKGdyb3VwZWRBdHRyaWJ1dGVOYW1lKXtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBIFJWQSAocmVsYXRpb24tdmFsdWVkIGF0dHJpYnV0ZSkgc3RvcmVzIGEgY29weSBvZiB0aGUgaGVhZGVyIG9mIGl0J3MgbmVzdGVkIHJlbGF0aW9uc1xuICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgYXR0cmlidXRlLnJlbGF0aW9uSGVhZGVyIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVsYXRpb25IZWFkZXIgPSB0aGF0LnJlbGF0aW9uLmhlYWRlcigpLmdldChncm91cGVkQXR0cmlidXRlTmFtZSkucmVsYXRpb25IZWFkZXI7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhhdC5oZWFkZXIoKS5jb3B5KHJlbGF0aW9uSGVhZGVyKTtcblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gTGV0J3MgYWRkIGFsbCB0aGUgb3RoZXIgbm9uLWdyb3VwZWQgYXR0cmlidXRlcyB0byB0aGUgaGVhZGVyXG5cbiAgICAgICAgICAgICAgICB0aGF0LnJlbGF0aW9uLmhlYWRlcigpLmVhY2goZnVuY3Rpb24oYXR0cmlidXRlKXtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBlZCA9IF8uYW55KHRoYXQuZ3JvdXBlZEF0dHJpYnV0ZU5hbWVzLCBmdW5jdGlvbihncm91cGVkQXR0cmlidXRlTmFtZSl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBncm91cGVkQXR0cmlidXRlTmFtZSA9PT0gYXR0cmlidXRlLm5hbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoIWdyb3VwZWQpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmhlYWRlcigpLmFkZChhdHRyaWJ1dGUuY2xvbmUoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBCZWZvcmVHZXRCb2R5XG4gICAgICAgICAgICB0aGlzLmVlLm9uY2UoJ2JlZm9yZUdldEJvZHknLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICBkZWJ1Zy51bmdyb3VwLnRyYWNlKCdiZWZvcmVHZXRCb2R5Jyk7XG5cbiAgICAgICAgICAgICAgICB0aGF0LnJlbGF0aW9uLmVhY2goZnVuY3Rpb24odHVwbGUpe1xuXG4gICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaCh0aGF0Lmdyb3VwZWRBdHRyaWJ1dGVOYW1lcywgZnVuY3Rpb24oZ3JvdXBlZEF0dHJpYnV0ZU5hbWUpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0dXBsZS5nZXQoZ3JvdXBlZEF0dHJpYnV0ZU5hbWUpLmVhY2goZnVuY3Rpb24obmVzdGVkVHVwbGUpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1R1cGxlID0gbmV3IFR1cGxlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHRoZSBub24gZ3JvdXBlZCBhdHRyaWJ1dGVzIGZyb20gdGhlIHJvb3QgdHVwbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdUdXBsZS5jb3B5KHR1cGxlLCB0aGF0Lmdyb3VwZWRBdHRyaWJ1dGVOYW1lcywgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHRoZSBhdHRyaWJ1dGVzIGZyb20gdGhlIG5lc3RlZCB0dXBsZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VHVwbGUuY29weShuZXN0ZWRUdXBsZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmFkZChuZXdUdXBsZSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyQWRkIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlbGF0aW9uLnVuZ3JvdXAodGhpcy5ncm91cGVkQXR0cmlidXRlTmFtZXMpO1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RUbyhyZXN1bHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyUmVtb3ZlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlbGF0aW9uLnVuZ3JvdXAodGhpcy5ncm91cGVkQXR0cmlidXRlTmFtZXMpO1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RUbyhyZXN1bHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyVXBkYXRlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpe1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVsYXRpb24udW5ncm91cCh0aGlzLmdyb3VwZWRBdHRyaWJ1dGVOYW1lcyk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFRvKHJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgIH0sIHtcblxuICAgICAgICB0eXBlIDogJ1VuZ3JvdXAnXG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBVbmdyb3VwOyIsInZhciBSZWxhdGlvbiA9IHJlcXVpcmUoJy4vLi4vUmVsYXRpb24uanMnKTtcbnZhciBIZWFkZXIgPSByZXF1aXJlKCcuLy4uL0hlYWRlci5qcycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9kZWJ1ZycpO1xuXG5cblxudmFyIFVuaW9uID0gUmVsYXRpb24uZXh0ZW5kKFxuXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgT3BlcmF0b3JzLlVuaW9uXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uQVxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvbkJcbiAgICAgICAgICogQGV4dGVuZHMgUmVsYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogRXhhbXBsZSA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25BID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgICAgIHtjaGFyYWN0ZXJJZDogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7Zmlyc3ROYW1lOiB7IHR5cGU6IGFmZmluaXR5LlN0cmluZ319LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2xhc3ROYW1lOiB7IHR5cGU6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWzEsICdKb2huJywgJ0RvZSddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzIsICdNYXJ5JywgJ1BvcHBpbnMnXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFszLCAnTHVja3knLCAnTHVrZSddXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7Y2hhcmFjdGVySWQ6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2ZpcnN0TmFtZTogeyB0eXBlOiBhZmZpbml0eS5TdHJpbmd9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtsYXN0TmFtZTogeyB0eXBlOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsxLCAnTXInLCAnWCddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzIsICdMYWR5JywgJ0dhZ2EnXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFszLCAnQm8nLCAnVnJpbCddXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQyA9IHJlbGF0aW9uQS51bmlvbihyZWxhdGlvbkIpXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBvclxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQyA9IG5ldyBhZmZpbml0eS5VbmlvbihyZWxhdGlvbkEsIHJlbGF0aW9uQik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgY2hhcmFjdGVySWQgOiBUSW50ZWdlciB8IGZpcnN0TmFtZSA6IFRTdHJpbmcgfCBsYXN0TmFtZSA6IFRTdHJpbmcgfFxuICAgICAgICAgKiAgICAgLy8gKz09PT09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT0rICAgLVxuICAgICAgICAgKiAgICAgLy8gfCAxICAgICAgICAgICAgICAgICAgICAgIHwgSm9obiAgICAgICAgICAgICAgICB8IERvZSAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tKyAgICB8XG4gICAgICAgICAqICAgICAvLyB8IDIgICAgICAgICAgICAgICAgICAgICAgfCBNYXJ5ICAgICAgICAgICAgICAgIHwgUG9wcGlucyAgICAgICAgICAgIHwgICAgfCBSZWxhdGlvbkFcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tKyAgICB8XG4gICAgICAgICAqICAgICAvLyB8IDMgICAgICAgICAgICAgICAgICAgICAgfCBMdWNreSAgICAgICAgICAgICAgIHwgTHVrZSAgICAgICAgICAgICAgIHwgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rICAgLVxuICAgICAgICAgKiAgICAgLy8gfCAxICAgICAgICAgICAgICAgICAgICAgIHwgTXIgICAgICAgICAgICAgICAgICB8IFggICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tKyAgICB8XG4gICAgICAgICAqICAgICAvLyB8IDIgICAgICAgICAgICAgICAgICAgICAgfCBMYWR5ICAgICAgICAgICAgICAgIHwgR2FnYSAgICAgICAgICAgICAgIHwgICAgfCBSZWxhdGlvbkJcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tKyAgICB8XG4gICAgICAgICAqICAgICAvLyB8IDMgICAgICAgICAgICAgICAgICAgICAgfCBCbyAgICAgICAgICAgICAgICAgIHwgVnJpbCAgICAgICAgICAgICAgIHwgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rICAgLVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIChyZWxhdGlvbkEsIHJlbGF0aW9uQikge1xuICAgICAgICAgICAgdGhpcy5yZWxzID0gW3JlbGF0aW9uQSwgcmVsYXRpb25CXTtcbiAgICAgICAgICAgIFJlbGF0aW9uLmNhbGwodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmluZEV2ZW50czogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBkZWJ1Zy51bmlvbi50cmFjZSgnI2JpbmRFdmVudHMnKTtcblxuICAgICAgICAgICAgVW5pb24uX19zdXBlcl9fLmJpbmRFdmVudHMuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGF0LmVlLm9uY2UoJ2JlZm9yZUdldEJvZHknLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICBkZWJ1Zy51bmlvbi50cmFjZSgnYmVmb3JlR2V0Qm9keScpO1xuXG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKHRoYXQucmVscywgZnVuY3Rpb24gKHJlbGF0aW9uKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpb24uZWFjaChmdW5jdGlvbih0dXBsZSl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYWRkKHR1cGxlLmNsb25lKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgfSwgdGhhdClcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoYXQuZWUub25jZSgnYmVmb3JlR2V0SGVhZGVyJywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgZGVidWcudW5pb24udHJhY2UoJ2JlZm9yZUdldEhlYWRlcicpO1xuXG4gICAgICAgICAgICAgICAgSGVhZGVyLmFzc2VydFVuaW9uQ29tcGF0aWJsZSh0aGF0LnJlbHNbMF0uaGVhZGVyKCksIHRoYXQucmVsc1sxXS5oZWFkZXIoKSk7XG5cbiAgICAgICAgICAgICAgICB0aGF0LmhlYWRlcigpLmNvcHkodGhhdC5yZWxzWzBdLmhlYWRlcigpKTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlckxlZnRBZGQgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUpe1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJMZWZ0UmVtb3ZlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyTGVmdFVwZGF0ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSwgYXR0cmlidXRlTmFtZSwgdmFsdWUsIG9sZFZhbHVlKXtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyUmlnaHRBZGQgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUpe1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJSaWdodFJlbW92ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSl7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlclJpZ2h0VXBkYXRlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpe1xuXG4gICAgICAgIH1cblxuICAgIH0sIHtcblxuICAgICAgICB0eXBlIDogJ1VuaW9uJ1xuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVW5pb247IiwidmFyIFJlbGF0aW9uID0gcmVxdWlyZSgnLi8uLi9SZWxhdGlvbi5qcycpO1xudmFyIEhlYWRlciA9IHJlcXVpcmUoJy4vLi4vSGVhZGVyLmpzJyk7XG52YXIgVHVwbGUgPSByZXF1aXJlKCcuLy4uL1R1cGxlLmpzJyk7XG52YXIgU2V0ID0gcmVxdWlyZSgnLi8uLi9TZXQuanMnKTtcbnZhciBBdHRyaWJ1dGUgPSByZXF1aXJlKCcuLy4uL0F0dHJpYnV0ZS5qcycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9kZWJ1ZycpO1xuXG5cblxudmFyIFVud3JhcCA9IFJlbGF0aW9uLmV4dGVuZChcblxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIE9wZXJhdG9ycy5VbndyYXBcbiAgICAgICAgICogQGV4dGVuZHMgUmVsYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtSZWxhdGlvbn0gcmVsYXRpb24gVGhlIHJlbGF0aW9uIHRvIFVud3JhcFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfFN0cmluZ3xTZXR8SGVhZGVyfSBhdHRyaWJ1dGVOYW1lcyBUaGUgbmFtZSBvZiB0aGUgd3JhcHBlZCBhdHRyaWJ1dGVzIHRvIHVud3JhcFxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgVW53cmFwIG9wZXJhdG9yIHdpbGwgcmV2ZXJzZSB0aGUge0BsaW5rIE9wZXJhdG9ycy5XcmFwfSBvcGVyYXRpb24sIGNvbnZlcnRpbmcgYSB0dXBsZS12YWx1ZWQgYXR0cmlidXRlIGludG9cbiAgICAgICAgICogdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIHR1cGxlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkEgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge2NoYXJhY3RlcklkOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtmaXJzdE5hbWU6IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7bGFzdE5hbWU6IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbMSwgJ0pvaG4nLCAnRG9lJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbMiwgJ01hcnknLCAnUG9wcGlucyddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzMsICdMdWNreScsICdMdWtlJ11cbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25CID0gcmVsYXRpb25BLlVud3JhcCgnVW53cmFwcGVkQXR0cmlidXRlJywgWydmaXJzdE5hbWUnLCdsYXN0TmFtZSddKTtcbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBjaGFyYWN0ZXJJZCA6IFRJbnRlZ2VyIHwgdW53cmFwcGVkQXR0cmlidXRlIDogVHVwbGUgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArPT09PT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgIC8vIHwgMSAgICAgICAgICAgICAgICAgICAgICB8IFR1cGxle2ZpcnN0TmFtZSA6ICdKb2huJywgbGFzdE5hbWUgOiAnRG9lJ30gICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDIgICAgICAgICAgICAgICAgICAgICAgfCBUdXBsZXtmaXJzdE5hbWUgOiAnTWFyeScsIGxhc3ROYW1lIDogJ1BvcHBpbnMnfXxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAzICAgICAgICAgICAgICAgICAgICAgIHwgVHVwbGV7Zmlyc3ROYW1lIDogJ0x1Y2t5JywgbGFzdE5hbWUgOiAnTHVrZSd9ICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25DID0gcmVsYXRpb25CLnVud3JhcCgndW53cmFwcGVkQXR0cmlidXRlJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBvclxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQyA9IG5ldyBhZmZpbml0eS5VbndyYXAocmVsYXRpb25CLCAndW53cmFwcGVkQXR0cmlidXRlJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgPC0tLS0tLS1VTldSQVBQRUQgQVRUUklCVVRFUy0tLS0tLS0tLS0tLS0tLT5cbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBjaGFyYWN0ZXJJZCA6IFRJbnRlZ2VyIHwgZmlyc3ROYW1lIDogVFN0cmluZyB8IGxhc3ROYW1lIDogVFN0cmluZyB8XG4gICAgICAgICAqICAgICAvLyArPT09PT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgIC8vIHwgMSAgICAgICAgICAgICAgICAgICAgICB8IEpvaG4gICAgICAgICAgICAgICAgfCBEb2UgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDIgICAgICAgICAgICAgICAgICAgICAgfCBNYXJ5ICAgICAgICAgICAgICAgIHwgUG9wcGlucyAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAzICAgICAgICAgICAgICAgICAgICAgIHwgTHVja3kgICAgICAgICAgICAgICB8IEx1a2UgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAocmVsYXRpb24sIGF0dHJpYnV0ZU5hbWVzKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnVud3JhcC50cmFjZSgnI2NvbnN0cnVjdG9yJyk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSByZWxhdGlvbiBhcmd1bWVudCBpcyBvZiBnb29kIHR5cGVcbiAgICAgICAgICAgIGlmKCEocmVsYXRpb24gaW5zdGFuY2VvZiBSZWxhdGlvbikpe1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NwZWNpZmllZCByZWxhdGlvbiBpcyBvZiB3cm9uZyB0eXBlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBhdHRyaWJ1dGVOYW1lcyBpcyBhIHN0cmluZywgY29lcmNlIGl0IHRvIGFuIGFycmF5XG4gICAgICAgICAgICBpZihfLmlzU3RyaW5nKGF0dHJpYnV0ZU5hbWVzKSl7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZXMgPSBbYXR0cmlidXRlTmFtZXNdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgYXR0cmlidXRlTmFtZXMgaXMgbm90IGFuIGFycmF5IG9yIHNldCwgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgICAgIGlmKCFfLmlzQXJyYXkoYXR0cmlidXRlTmFtZXMpICYmICEoYXR0cmlidXRlTmFtZXMgaW5zdGFuY2VvZiBTZXQpKXtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHR5cGUgb2Ygc3BlY2lmaWVkIGF0dHJpYnV0ZU5hbWVzIHRvIHVud3JhcCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihfLmlzQXJyYXkoYXR0cmlidXRlTmFtZXMpICYmIGF0dHJpYnV0ZU5hbWVzLmxlbmd0aCA8PSAwKXtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHNwZWNpZnkgYXR0cmlidXRlcyB0byB1bndyYXAhJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKChhdHRyaWJ1dGVOYW1lcyBpbnN0YW5jZW9mIFNldCkgJiYgYXR0cmlidXRlTmFtZXMubGVuZ3RoKCkgPD0gMCl7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGF0dHJpYnV0ZXMgdG8gdW53cmFwIScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZU5hbWVzID0gYXR0cmlidXRlTmFtZXM7XG4gICAgICAgICAgICB0aGlzLnJlbGF0aW9uID0gcmVsYXRpb247XG5cbiAgICAgICAgICAgIFJlbGF0aW9uLmNhbGwodGhpcyk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnVud3JhcC50cmFjZSgnI2JpbmRFdmVudHMnKTtcblxuICAgICAgICAgICAgLy8gQ2FsbGluZyB0aGUgcGFyZW50IGJpbmRFdmVudHNcbiAgICAgICAgICAgIFVud3JhcC5fX3N1cGVyX18uYmluZEV2ZW50cy5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICB2YXIgcmVsYXRpb24gPSB0aGlzLnJlbGF0aW9uO1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIEJlZm9yZUdldEhlYWRlclxuICAgICAgICAgICAgdGhpcy5lZS5vbmNlKCdiZWZvcmVHZXRIZWFkZXInLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICBkZWJ1Zy51bndyYXAudHJhY2UoJ2JlZm9yZUdldEhlYWRlcicpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29weSBhbGwgYXR0cmlidXRlcyBmcm9tIHRoZSBiYXNlIGhlYWRlciB0aGF0IHdpbGwgbm90IGJlIHVud3JhcHBlZFxuICAgICAgICAgICAgICAgIHRoYXQuaGVhZGVyKCkuY29weShyZWxhdGlvbi5oZWFkZXIoKSwgdGhhdC5hdHRyaWJ1dGVOYW1lcywgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgYWxsIGF0dHJpYnV0ZXMgdGhhdCB3ZXJlIHdyYXBwZWQgaW4gdGhlIGJhc2UgcmVsYXRpb25cbiAgICAgICAgICAgICAgICB2YXIgYWxyZWFkeVdyYXBwZWRBdHRyaWJ1dGVzID0gbmV3IEhlYWRlcigpO1xuICAgICAgICAgICAgICAgIHJlbGF0aW9uLmhlYWRlcigpLmVhY2goZnVuY3Rpb24oYXR0cmlidXRlKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoYXR0cmlidXRlLndyYXBwZWRBdHRyaWJ1dGVzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscmVhZHlXcmFwcGVkQXR0cmlidXRlcy5hZGQoYXR0cmlidXRlLmNsb25lKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGF0dHJpYnV0ZXMgd2hpY2ggd2lsbCBiZSB1bndyYXBwZWRcbiAgICAgICAgICAgICAgICB2YXIgdW53cmFwcGVkQXR0cmlidXRlcyA9IG5ldyBIZWFkZXIoKTtcbiAgICAgICAgICAgICAgICB1bndyYXBwZWRBdHRyaWJ1dGVzLmNvcHkocmVsYXRpb24uaGVhZGVyKCksIHRoYXQuYXR0cmlidXRlTmFtZXMpO1xuICAgICAgICAgICAgICAgIHRoYXQudW53cmFwcGVkQXR0cmlidXRlcyA9IHVud3JhcHBlZEF0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGF0dHJpYnV0ZXMgd2hpY2ggd2lsbCBub3QgYmUgdW53cmFwcGVkXG4gICAgICAgICAgICAgICAgdmFyIG5vblVud3JhcHBlZEF0dHJpYnV0ZXMgPSBuZXcgSGVhZGVyKCk7XG4gICAgICAgICAgICAgICAgbm9uVW53cmFwcGVkQXR0cmlidXRlcy5jb3B5KHJlbGF0aW9uLmhlYWRlcigpLCB0aGF0LmF0dHJpYnV0ZU5hbWVzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGF0Lm5vblVud3JhcHBlZEF0dHJpYnV0ZXMgPSBub25VbndyYXBwZWRBdHRyaWJ1dGVzO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgYXR0cmlidXRlcyB0byBiZSB1bndyYXBwZWQgYXJlIHdyYXBwZWQuIFdlIHdvdWxkIG5vdCB3YW50XG4gICAgICAgICAgICAgICAgLy8gdG8gdW53cmFwIG5vbi13cmFwcGVkIGF0dHJpYnV0ZXMhXG4gICAgICAgICAgICAgICAgaWYoIXVud3JhcHBlZEF0dHJpYnV0ZXMuaXNTdWJzZXQoYWxyZWFkeVdyYXBwZWRBdHRyaWJ1dGVzKSl7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3BlY2lmaWVkIGF0dHJpYnV0ZXMgYXJlIG5vdCBhbGwgd3JhcHBlZCBhdHRyaWJ1dGVzLiBNdXN0IHNwZWNpZnkgYXR0cmlidXRlcyB3aGljaCBhcmUgd3JhcHBlZC4nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgYWxsIG5lc3RlZCB1bndyYXBwZWQgYXR0cmlidXRlcyBpbiB0aGUgaGVhZGVyXG4gICAgICAgICAgICAgICAgdW53cmFwcGVkQXR0cmlidXRlcy5lYWNoKGZ1bmN0aW9uKHVud3JhcHBlZEF0dHJpYnV0ZSl7XG4gICAgICAgICAgICAgICAgICAgIHVud3JhcHBlZEF0dHJpYnV0ZS53cmFwcGVkQXR0cmlidXRlcy5lYWNoKGZ1bmN0aW9uKHdyYXBwZWRBdHRyaWJ1dGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5oZWFkZXIoKS5hZGQod3JhcHBlZEF0dHJpYnV0ZS5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQmVmb3JlR2V0Qm9keVxuICAgICAgICAgICAgdGhpcy5lZS5vbmNlKCdiZWZvcmVHZXRCb2R5JywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgZGVidWcudW53cmFwLnRyYWNlKCdiZWZvcmVHZXRCb2R5Jyk7XG5cbiAgICAgICAgICAgICAgICAvLyBMb29wIHRocm91Z2ggZWFjaCB0dXBsZSBvZiB0aGUgcmVsYXRpb25cbiAgICAgICAgICAgICAgICB0aGF0LnJlbGF0aW9uLmVhY2goZnVuY3Rpb24odHVwbGUpe1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgdHVwbGUgdG8gYmUgaW5zZXJ0ZWRcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1R1cGxlID0gbmV3IFR1cGxlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQXNzaWduIHRoZSB2YWx1ZXMgdG8gdGhlIGF0dHJpYnV0ZXMgd2hpY2ggd2lsbCBub3QgYmUgdW53cmFwcGVkXG4gICAgICAgICAgICAgICAgICAgIHRoYXQubm9uVW53cmFwcGVkQXR0cmlidXRlcy5lYWNoKGZ1bmN0aW9uKGF0dHJpYnV0ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdUdXBsZS5zZXQoYXR0cmlidXRlLm5hbWUsIHR1cGxlLmdldChhdHRyaWJ1dGUubmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBMb29wIHRocm91Z2ggdGhlIGF0dHJpYnV0ZXMgdG8gYmUgdW53cmFwcGVkXG4gICAgICAgICAgICAgICAgICAgIHRoYXQudW53cmFwcGVkQXR0cmlidXRlcy5lYWNoKGZ1bmN0aW9uKHVud3JhcHBlZEF0dHJpYnV0ZSl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCB0aGUgd3JhcHBlZCBhdHRyaWJ1dGUgaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bndyYXBwZWRBdHRyaWJ1dGUud3JhcHBlZEF0dHJpYnV0ZXMuZWFjaChmdW5jdGlvbih3cmFwcGVkQXR0cmlidXRlKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgdHVwbGUgdmFsdWUgZm9yIHRoaXMgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VHVwbGUuc2V0KHdyYXBwZWRBdHRyaWJ1dGUubmFtZSwgdHVwbGUuZ2V0KHVud3JhcHBlZEF0dHJpYnV0ZS5uYW1lKS5nZXQod3JhcHBlZEF0dHJpYnV0ZS5uYW1lKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhhdC5hZGQobmV3VHVwbGUpO1xuXG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlckFkZCA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSl7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZWxhdGlvbi51bndyYXAodGhpcy5hdHRyaWJ1dGVOYW1lcyk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFRvKHJlc3VsdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJSZW1vdmUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUpe1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVsYXRpb24udW53cmFwKHRoaXMuYXR0cmlidXRlTmFtZXMpO1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RUbyhyZXN1bHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyVXBkYXRlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpe1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVsYXRpb24udW53cmFwKHRoaXMuYXR0cmlidXRlTmFtZXMpO1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RUbyhyZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICB9LCB7XG5cbiAgICAgICAgdHlwZSA6ICdVbndyYXAnXG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBVbndyYXA7IiwidmFyIFJlbGF0aW9uID0gcmVxdWlyZSgnLi8uLi9SZWxhdGlvbi5qcycpO1xudmFyIFNldCA9IHJlcXVpcmUoJy4vLi4vU2V0LmpzJyk7XG52YXIgSGVhZGVyID0gcmVxdWlyZSgnLi8uLi9IZWFkZXIuanMnKTtcbnZhciBBdHRyaWJ1dGUgPSByZXF1aXJlKCcuLy4uL0F0dHJpYnV0ZS5qcycpO1xudmFyIFR1cGxlID0gcmVxdWlyZSgnLi8uLi9UdXBsZS5qcycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9kZWJ1ZycpO1xuXG5cblxudmFyIFdyYXAgPSBSZWxhdGlvbi5leHRlbmQoXG5cbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBPcGVyYXRvcnMuV3JhcFxuICAgICAgICAgKiBAZXh0ZW5kcyBSZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvbkEgVGhlIHJlbGF0aW9uIHRvIHdyYXBcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHdyYXBwaW5nQXR0cmlidXRlTmFtZSBUaGUgbmFtZSBvZiB0aGUgd3JhcHBpbmcgYXR0cmlidXRlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHdyYXBwZWRBdHRyaWJ1dGVzIFRoZSB3cmFwcGVkQXR0cmlidXRlcyB0byB3cmFwXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBXcmFwIHdpbGwgZ2F0aGVyIG11bHRpcGxlIHdyYXBwZWRBdHRyaWJ1dGVzIGludG8gYSBzaW5nbGUgb25lLCBjb252ZXJ0aW5nIHRoZW0gdG8gYSB0dXBsZS12YWx1ZWQgYXR0cmlidXRlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25BID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgICAgIHtjaGFyYWN0ZXJJZDogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7Zmlyc3ROYW1lOiB7IHR5cGU6IGFmZmluaXR5LlN0cmluZ319LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2xhc3ROYW1lOiB7IHR5cGU6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWzEsICdKb2huJywgJ0RvZSddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzIsICdNYXJ5JywgJ1BvcHBpbnMnXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFszLCAnTHVja3knLCAnTHVrZSddXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IGNoYXJhY3RlcklkIDogVEludGVnZXIgfCBmaXJzdE5hbWUgOiBUU3RyaW5nIHwgbGFzdE5hbWUgOiBUU3RyaW5nIHxcbiAgICAgICAgICogICAgIC8vICs9PT09PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgLy8gfCAxICAgICAgICAgICAgICAgICAgICAgIHwgSm9obiAgICAgICAgICAgICAgICB8IERvZSAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMiAgICAgICAgICAgICAgICAgICAgICB8IE1hcnkgICAgICAgICAgICAgICAgfCBQb3BwaW5zICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDMgICAgICAgICAgICAgICAgICAgICAgfCBMdWNreSAgICAgICAgICAgICAgIHwgTHVrZSAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQyA9IHJlbGF0aW9uQS53cmFwKCd3cmFwcGVkQXR0cmlidXRlJywgWydmaXJzdE5hbWUnLCdsYXN0TmFtZSddKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG9yXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25DID0gbmV3IGFmZmluaXR5LldyYXAocmVsYXRpb25BLCAnd3JhcHBlZEF0dHJpYnV0ZScsIFsnZmlyc3ROYW1lJywnbGFzdE5hbWUnXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgPC0tLS1XUkFQUElORyBBVFRSSUJVVEUtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT5cbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBjaGFyYWN0ZXJJZCA6IFRJbnRlZ2VyIHwgd3JhcHBlZEF0dHJpYnV0ZSA6IFR1cGxlICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArPT09PT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgIC8vIHwgMSAgICAgICAgICAgICAgICAgICAgICB8IFR1cGxle2ZpcnN0TmFtZSA6ICdKb2huJywgbGFzdE5hbWUgOiAnRG9lJ30gICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDIgICAgICAgICAgICAgICAgICAgICAgfCBUdXBsZXtmaXJzdE5hbWUgOiAnTWFyeScsIGxhc3ROYW1lIDogJ1BvcHBpbnMnfXxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAzICAgICAgICAgICAgICAgICAgICAgIHwgVHVwbGV7Zmlyc3ROYW1lIDogJ0x1Y2t5JywgbGFzdE5hbWUgOiAnTHVrZSd9ICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHJlbGF0aW9uQSwgd3JhcHBpbmdBdHRyaWJ1dGVOYW1lLCB3cmFwcGVkQXR0cmlidXRlcykge1xuXG4gICAgICAgICAgICBkZWJ1Zy53cmFwLnRyYWNlKCcjY29uc3RydWN0b3InKTtcblxuICAgICAgICAgICAgdGhpcy5yZWxhdGlvbiA9IHJlbGF0aW9uQTtcblxuICAgICAgICAgICAgQXR0cmlidXRlLmFzc2VydFZhbGlkTmFtZSh3cmFwcGluZ0F0dHJpYnV0ZU5hbWUpO1xuXG4gICAgICAgICAgICBpZighXy5pc0FycmF5KHdyYXBwZWRBdHRyaWJ1dGVzKSAmJiAhKHdyYXBwZWRBdHRyaWJ1dGVzIGluc3RhbmNlb2YgU2V0KSl7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcmFwcGVkIGF0dHJpYnV0ZXMgbXVzdCBiZSBhbiBhcnJheSBvciBzZXQgb2YgYXR0cmlidXRlcyAvIGF0dHJpYnV0ZSBuYW1lcycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihfLmlzQXJyYXkod3JhcHBlZEF0dHJpYnV0ZXMpICYmIHdyYXBwZWRBdHRyaWJ1dGVzLmxlbmd0aCA8PSAwKXtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIG11c3QgYmUgYXQgbGVhc3Qgb25lIGF0dHJpYnV0ZSB0byB3cmFwJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHdyYXBwZWRBdHRyaWJ1dGVzIGluc3RhbmNlb2YgU2V0ICYmIHdyYXBwZWRBdHRyaWJ1dGVzLmxlbmd0aCgpIDw9IDApe1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgbXVzdCBiZSBhdCBsZWFzdCBvbmUgYXR0cmlidXRlIHRvIHdyYXAnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy53cmFwcGVkQXR0cmlidXRlTmFtZSA9IHdyYXBwaW5nQXR0cmlidXRlTmFtZTtcbiAgICAgICAgICAgIHRoaXMud3JhcHBlZEF0dHJpYnV0ZXMgPSB3cmFwcGVkQXR0cmlidXRlcztcblxuICAgICAgICAgICAgUmVsYXRpb24uY2FsbCh0aGlzKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGJpbmRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgZGVidWcud3JhcC50cmFjZSgnI2JpbmRFdmVudHMnKTtcblxuICAgICAgICAgICAgLy8gQ2FsbGluZyB0aGUgcGFyZW50IGJpbmRFdmVudHNcbiAgICAgICAgICAgIFdyYXAuX19zdXBlcl9fLmJpbmRFdmVudHMuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBCZWZvcmVHZXRIZWFkZXJcbiAgICAgICAgICAgIHRoaXMuZWUub25jZSgnYmVmb3JlR2V0SGVhZGVyJywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgZGVidWcud3JhcC50cmFjZSgnYmVmb3JlR2V0SGVhZGVyJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBwYXNzZWQgYXR0cmlidXRlcyBleGlzdCBpbiB0aGUgYmFzZSBoZWFkZXJcbiAgICAgICAgICAgICAgICBIZWFkZXIuYXNzZXJ0QXR0cmlidXRlc0V4aXN0KHRoYXQucmVsYXRpb24sIHRoYXQud3JhcHBlZEF0dHJpYnV0ZXMpO1xuXG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgd3JhcHBlZCBhdHRyaWJ1dGVzLCBjb252ZXJ0IHRoZW0gdG8gYSBIZWFkZXIgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZEF0dHJpYnV0ZXMgPSBuZXcgSGVhZGVyKCk7XG4gICAgICAgICAgICAgICAgd3JhcHBlZEF0dHJpYnV0ZXMuY29weSh0aGF0LnJlbGF0aW9uLmhlYWRlcigpLCB0aGF0LndyYXBwZWRBdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICB0aGF0LndyYXBwZWRBdHRyaWJ1dGVzID0gd3JhcHBlZEF0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBub24gd3JhcHBlZCBhdHRyaWJ1dGVzIGluIGFub3RoZXIgdmFyaWFibGUsIGFuZFxuICAgICAgICAgICAgICAgIC8vIGNvcHkgdGhlIGF0dHJpYnV0ZXMgaW4gdGhpcyBoZWFkZXJcbiAgICAgICAgICAgICAgICB0aGF0Lm5vbldyYXBwZWRBdHRyaWJ1dGVzID0gbmV3IEhlYWRlcigpO1xuICAgICAgICAgICAgICAgIHRoYXQubm9uV3JhcHBlZEF0dHJpYnV0ZXMuY29weSh0aGF0LnJlbGF0aW9uLmhlYWRlcigpLCB0aGF0LndyYXBwZWRBdHRyaWJ1dGVzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGF0LmhlYWRlcigpLmNvcHkodGhhdC5ub25XcmFwcGVkQXR0cmlidXRlcyk7XG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHdyYXBwZWQgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgdmFyIG5ld1dyYXBwZWRBdHRyaWJ1dGUgPSBuZXcgQXR0cmlidXRlKHtuYW1lIDogdGhhdC53cmFwcGVkQXR0cmlidXRlTmFtZSwgdHlwZSA6IFR1cGxlfSlcblxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSB3cmFwcGVkIGhlYWRlciBpbiB0aGUgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgbmV3V3JhcHBlZEF0dHJpYnV0ZS53cmFwcGVkQXR0cmlidXRlcyA9IHRoYXQud3JhcHBlZEF0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgaXQgdG8gdGhlIGhlYWRlclxuICAgICAgICAgICAgICAgIHRoYXQuaGVhZGVyKCkuYWRkKG5ld1dyYXBwZWRBdHRyaWJ1dGUpO1xuXG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICAvLyBCZWZvcmVHZXRCb2R5XG4gICAgICAgICAgICB0aGlzLmVlLm9uY2UoJ2JlZm9yZUdldEJvZHknLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICBkZWJ1Zy53cmFwLnRyYWNlKCdiZWZvcmVHZXRCb2R5Jyk7XG5cbiAgICAgICAgICAgICAgICB0aGF0LnJlbGF0aW9uLmVhY2goZnVuY3Rpb24odHVwbGUpe1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgdHVwbGUgd2Ugd2lsbCBsYXRlciBpbnNlcnRcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1R1cGxlID0gbmV3IFR1cGxlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29weSB0aGUgdmFsdWUgb2YgdGhlIG5vbi13cmFwcGVkIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAgICAgbmV3VHVwbGUuY29weSh0dXBsZSwgdGhhdC5ub25XcmFwcGVkQXR0cmlidXRlcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBuZXN0ZWQgdHVwbGVcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5lc3RlZFR1cGxlID0gbmV3IFR1cGxlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29weSB0aGUgdmFsdWVzIG9mIHRoZSB3cmFwcGVkIGF0dHJpYnV0ZXMgaW4gdGhlIG5lc3RlZCB0dXBsZVxuICAgICAgICAgICAgICAgICAgICBuZXN0ZWRUdXBsZS5jb3B5KHR1cGxlLCB0aGF0LndyYXBwZWRBdHRyaWJ1dGVzKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIG5lc3RlZCB0dXBsZSB0byB0aGUgY29udGFpbmluZyB0dXBsZVxuICAgICAgICAgICAgICAgICAgICBuZXdUdXBsZS5zZXQodGhhdC53cmFwcGVkQXR0cmlidXRlTmFtZSwgbmVzdGVkVHVwbGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYWRkKG5ld1R1cGxlKTtcblxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJBZGQgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUpe1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVsYXRpb24ud3JhcCh0aGlzLndyYXBwZWRBdHRyaWJ1dGVOYW1lLCB0aGlzLndyYXBwZWRBdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0VG8ocmVzdWx0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlclJlbW92ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSl7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZWxhdGlvbi53cmFwKHRoaXMud3JhcHBlZEF0dHJpYnV0ZU5hbWUsIHRoaXMud3JhcHBlZEF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RUbyhyZXN1bHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyVXBkYXRlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpe1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVsYXRpb24ud3JhcCh0aGlzLndyYXBwZWRBdHRyaWJ1dGVOYW1lLCB0aGlzLndyYXBwZWRBdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0VG8ocmVzdWx0KTtcbiAgICAgICAgfVxuXG4gICAgfSwge1xuXG4gICAgICAgIHR5cGUgOiAnV3JhcCdcblxuICAgIH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyYXA7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbicpO1xuXG52YXIgQm9vbGVhbiA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvQm9vbGVhbi5qcycpO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG52YXIgQWxsID0gRnVuY3Rpb24uZXh0ZW5kKHtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuQWdncmVnYXRlLkFsbFxuICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBGdW5jdGlvbnMgdGhhdCBjaGVja3MgaWYgYWxsIHRoZSB0dXBsZXMgaW4gYSByZWxhdGlvbiBtYXRjaCB0aGVcbiAgICAgKiBnaXZlbiBib29sZWFuIHByZWRpY2F0ZS5cbiAgICAgKlxuICAgICAqIEV4YW1wbGUgOlxuICAgICAqXG4gICAgICogICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICogICAgICAgICB7IG5hbWUgOiB7IHR5cGUgOiBhZmZpbml0eS5TdHJpbmcgfSB9LFxuICAgICAqICAgICAgICAgeyBhZ2UgOiB7IHR5cGUgOiBhZmZpbml0eS5JbnRlZ2VyIH0gfVxuICAgICAqICAgICBdLFtcbiAgICAgKiAgICAgICAgIFsnSm9obiBEb2UnLCAyM10sXG4gICAgICogICAgICAgICBbJ01hcmsgQ2xpbnRvbicsIDM2XSxcbiAgICAgKiAgICAgICAgIFsnU3VwZXIgV29tYW4nLCA1Nl1cbiAgICAgKiAgICAgXSk7XG4gICAgICpcbiAgICAgKiAgICAgdmFyIG5hbWUgPSByZWxhdGlvbi5nZXQoJ25hbWUnKTtcbiAgICAgKiAgICAgdmFyIGFnZSA9IHJlbGF0aW9uLmdldCgnYWdlJylcbiAgICAgKlxuICAgICAqICAgICB2YXIgYWxsID0gcmVsYXRpb24uYWxsKGFnZS5ndCgyMCkpO1xuICAgICAqXG4gICAgICogICAgIGNvbnNvbGUubG9nKGFsbC52YWx1ZSgpKTtcbiAgICAgKlxuICAgICAqICAgICAvLyB0cnVlXG4gICAgICovXG5cbiAgICBjb25zdHJ1Y3RvciA6IGZ1bmN0aW9uKHJlbGF0aW9uLCBwcmVkaWNhdGUpe1xuXG4gICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywwKSk7XG5cbiAgICAgICAgdGhpcy5uYW1lID0gJ0FsbCc7XG5cbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG5cbiAgICAgICAgdGhpcy5yZWxhdGlvbiA9IHJlbGF0aW9uO1xuXG4gICAgICAgIHRoaXMudHlwZShCb29sZWFuKTtcblxuICAgIH0sXG5cblxuICAgIHZhbHVlIDogZnVuY3Rpb24oKXtcblxuICAgICAgICB2YXIgcmVsYXRpb24gPSB0aGlzLnJlbGF0aW9uO1xuXG4gICAgICAgIHZhciBwcmVkaWNhdGUgPSB0aGlzLnByZWRpY2F0ZTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcblxuICAgICAgICBwcmVkaWNhdGUuY29udmVydEF0dHJpYnV0ZVRvVHVwbGUoKTtcblxuICAgICAgICByZWxhdGlvbi5lYWNoKGZ1bmN0aW9uKHR1cGxlKXtcblxuICAgICAgICAgICAgcHJlZGljYXRlLmFzc2lnblR1cGxlKHR1cGxlKTtcblxuICAgICAgICAgICAgaWYoIHByZWRpY2F0ZS52YWx1ZSgpID09PSBmYWxzZSApe1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQWxsOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24nKTtcblxudmFyIEJvb2xlYW4gPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL0Jvb2xlYW4uanMnKTtcblxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxudmFyIEFueSA9IEZ1bmN0aW9uLmV4dGVuZCh7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLkFnZ3JlZ2F0ZS5BbnlcbiAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAqXG4gICAgICogRnVuY3Rpb25zIHRoYXQgY2hlY2tzIGlmIGFueSBvZiB0aGUgdHVwbGVzIGluIGEgcmVsYXRpb24gbWF0Y2ggdGhlXG4gICAgICogZ2l2ZW4gYm9vbGVhbiBwcmVkaWNhdGUuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIDpcbiAgICAgKlxuICAgICAqICAgICB2YXIgcmVsYXRpb24gPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAqICAgICAgICAgeyBuYW1lIDogeyB0eXBlIDogYWZmaW5pdHkuU3RyaW5nIH0gfSxcbiAgICAgKiAgICAgICAgIHsgYWdlIDogeyB0eXBlIDogYWZmaW5pdHkuSW50ZWdlciB9IH1cbiAgICAgKiAgICAgXSxbXG4gICAgICogICAgICAgICBbJ0pvaG4gRG9lJywgMjNdLFxuICAgICAqICAgICAgICAgWydNYXJrIENsaW50b24nLCAzNl0sXG4gICAgICogICAgICAgICBbJ1N1cGVyIFdvbWFuJywgNTZdXG4gICAgICogICAgIF0pO1xuICAgICAqXG4gICAgICogICAgIHZhciBuYW1lID0gcmVsYXRpb24uZ2V0KCduYW1lJyk7XG4gICAgICogICAgIHZhciBhZ2UgPSByZWxhdGlvbi5nZXQoJ2FnZScpXG4gICAgICpcbiAgICAgKiAgICAgdmFyIGFueSA9IHJlbGF0aW9uLmFueShhZ2UuZ3QoNTApKTtcbiAgICAgKlxuICAgICAqICAgICBjb25zb2xlLmxvZyhhbnkudmFsdWUoKSk7XG4gICAgICpcbiAgICAgKiAgICAgLy8gdHJ1ZVxuICAgICAqL1xuXG4gICAgY29uc3RydWN0b3IgOiBmdW5jdGlvbihyZWxhdGlvbiwgcHJlZGljYXRlKXtcblxuICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMCkpO1xuXG4gICAgICAgIHRoaXMubmFtZSA9ICdBbnknO1xuXG4gICAgICAgIHRoaXMudHlwZShCb29sZWFuKTtcblxuICAgICAgICB0aGlzLnJlbGF0aW9uID0gcmVsYXRpb247XG5cbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG5cbiAgICB9LFxuXG4gICAgdmFsdWUgOiBmdW5jdGlvbigpe1xuXG4gICAgICAgIHZhciByZWxhdGlvbiA9IHRoaXMucmVsYXRpb247XG5cbiAgICAgICAgdmFyIHByZWRpY2F0ZSA9IHRoaXMucHJlZGljYXRlO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgICBwcmVkaWNhdGUuY29udmVydEF0dHJpYnV0ZVRvVHVwbGUoKTtcblxuICAgICAgICByZWxhdGlvbi5lYWNoKGZ1bmN0aW9uKHR1cGxlKXtcblxuICAgICAgICAgICAgcHJlZGljYXRlLmFzc2lnblR1cGxlKHR1cGxlKTtcblxuICAgICAgICAgICAgaWYoIHByZWRpY2F0ZS52YWx1ZSgpID09PSB0cnVlICl7XG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbnk7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbicpO1xuXG52YXIgRmxvYXQgPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL0Zsb2F0LmpzJyk7XG5cbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbnZhciBBdmVyYWdlID0gRnVuY3Rpb24uZXh0ZW5kKHtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuQWdncmVnYXRlLkF2ZXJhZ2VcbiAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAqXG4gICAgICogRnVuY3Rpb25zIHRoYXQgcmV0dXJucyB0aGUgYXZlcmFnZSBmb3IgYSByZWxhdGlvblxuICAgICAqIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogRXhhbXBsZSA6XG4gICAgICpcbiAgICAgKiAgICAgdmFyIHJlbGF0aW9uID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgKiAgICAgICAgIHsgbmFtZSA6IHsgdHlwZSA6IGFmZmluaXR5LlN0cmluZyB9IH0sXG4gICAgICogICAgICAgICB7IGFnZSA6IHsgdHlwZSA6IGFmZmluaXR5LkludGVnZXIgfSB9XG4gICAgICogICAgIF0sW1xuICAgICAqICAgICAgICAgWydKb2huIERvZScsIDIzXSxcbiAgICAgKiAgICAgICAgIFsnTWFyayBDbGludG9uJywgMzZdLFxuICAgICAqICAgICAgICAgWydTdXBlciBXb21hbicsIDU2XVxuICAgICAqICAgICBdKTtcbiAgICAgKlxuICAgICAqICAgICB2YXIgYWdlID0gcmVsYXRpb24uZ2V0KCdhZ2UnKTtcbiAgICAgKlxuICAgICAqICAgICB2YXIgbWF4ID0gcmVsYXRpb24uYXZnKGFnZSlcbiAgICAgKlxuICAgICAqICAgICBjb25zb2xlLmxvZyhtYXgudmFsdWUoKSk7XG4gICAgICpcbiAgICAgKiAgICAgLy8gMzguMzMzMzMzMzNcbiAgICAgKi9cblxuICAgIGNvbnN0cnVjdG9yIDogZnVuY3Rpb24oYXR0cmlidXRlKXtcblxuICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMCkpO1xuXG4gICAgICAgIHRoaXMubmFtZSA9ICdBdmVyYWdlJztcblxuICAgICAgICB0aGlzLnR5cGUoRmxvYXQpO1xuXG4gICAgICAgIHRoaXMuYXR0cmlidXRlID0gYXR0cmlidXRlO1xuXG4gICAgICAgIHRoaXMucmVsYXRpb24gPSBhdHRyaWJ1dGUuaGVhZGVyLnJlbGF0aW9uO1xuXG4gICAgfSxcblxuICAgIHZhbHVlIDogZnVuY3Rpb24oKXtcblxuICAgICAgICB2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGU7XG5cbiAgICAgICAgdmFyIHJlbGF0aW9uID0gdGhpcy5yZWxhdGlvbjtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gMDtcblxuICAgICAgICB2YXIgbGVuZ3RoID0gcmVsYXRpb24ubGVuZ3RoKCk7XG5cbiAgICAgICAgcmVsYXRpb24uZWFjaChmdW5jdGlvbih0dXBsZSl7XG5cbiAgICAgICAgICAgIHJlc3VsdCArPSB0dXBsZS5nZXQoYXR0cmlidXRlLm5hbWUpO1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCAvIGxlbmd0aDtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXZlcmFnZTsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uJyk7XG5cbnZhciBJbnRlZ2VyID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9JbnRlZ2VyLmpzJyk7XG5cbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbnZhciBDb3VudCA9IEZ1bmN0aW9uLmV4dGVuZCh7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLkFnZ3JlZ2F0ZS5Db3VudFxuICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBGdW5jdGlvbnMgdGhhdCBjb3VudHMgdGhlIG51bWJlciBvZiB0dXBsZXNcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgOlxuICAgICAqXG4gICAgICogICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICogICAgICAgICB7IG5hbWUgOiB7IHR5cGUgOiBhZmZpbml0eS5TdHJpbmcgfSB9LFxuICAgICAqICAgICAgICAgeyBhZ2UgOiB7IHR5cGUgOiBhZmZpbml0eS5JbnRlZ2VyIH0gfVxuICAgICAqICAgICBdLFtcbiAgICAgKiAgICAgICAgIFsnSm9obiBEb2UnLCAyM10sXG4gICAgICogICAgICAgICBbJ01hcmsgQ2xpbnRvbicsIDM2XSxcbiAgICAgKiAgICAgICAgIFsnU3VwZXIgV29tYW4nLCA1Nl1cbiAgICAgKiAgICAgXSk7XG4gICAgICpcbiAgICAgKiAgICAgdmFyIGNvdW50ID0gcmVsYXRpb24uY291bnQoKVxuICAgICAqXG4gICAgICogICAgIGNvbnNvbGUubG9nKGNvdW50LnZhbHVlKCkpO1xuICAgICAqXG4gICAgICogICAgIC8vIDNcbiAgICAgKi9cblxuICAgIGNvbnN0cnVjdG9yIDogZnVuY3Rpb24ocmVsYXRpb24pe1xuXG4gICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywwKSk7XG5cbiAgICAgICAgdGhpcy5uYW1lID0gJ0NvdW50JztcblxuICAgICAgICB0aGlzLnR5cGUoSW50ZWdlcik7XG5cbiAgICAgICAgdGhpcy5yZWxhdGlvbiA9IHJlbGF0aW9uO1xuXG4gICAgfSxcblxuICAgIHZhbHVlIDogZnVuY3Rpb24oKXtcblxuICAgICAgICByZXR1cm4gdGhpcy5yZWxhdGlvbi5sZW5ndGgoKTtcblxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ291bnQ7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbicpO1xuXG52YXIgY29tcGFyZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy9jb21wYXJlLmpzJyk7XG5cbnZhciBJbnRlZ2VyID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9JbnRlZ2VyLmpzJyk7XG5cbnZhciBNYXhpbXVtID0gRnVuY3Rpb24uZXh0ZW5kKHtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuQWdncmVnYXRlLk1heGltdW1cbiAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAqXG4gICAgICogRnVuY3Rpb25zIHRoYXQgcmV0dXJucyB0aGUgbGFyZ2VzdCB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgaW4gYSByZWxhdGlvbi5cbiAgICAgKlxuICAgICAqIEV4YW1wbGUgOlxuICAgICAqXG4gICAgICogICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICogICAgICAgICB7IG5hbWUgOiB7IHR5cGUgOiBhZmZpbml0eS5TdHJpbmcgfSB9LFxuICAgICAqICAgICAgICAgeyBhZ2UgOiB7IHR5cGUgOiBhZmZpbml0eS5JbnRlZ2VyIH0gfVxuICAgICAqICAgICBdLFtcbiAgICAgKiAgICAgICAgIFsnSm9obiBEb2UnLCAyM10sXG4gICAgICogICAgICAgICBbJ01hcmsgQ2xpbnRvbicsIDM2XSxcbiAgICAgKiAgICAgICAgIFsnU3VwZXIgV29tYW4nLCA1Nl1cbiAgICAgKiAgICAgXSk7XG4gICAgICpcbiAgICAgKiAgICAgdmFyIGFnZSA9IHJlbGF0aW9uLmdldCgnYWdlJyk7XG4gICAgICpcbiAgICAgKiAgICAgdmFyIG1heCA9IHJlbGF0aW9uLm1heChhZ2UpXG4gICAgICpcbiAgICAgKiAgICAgY29uc29sZS5sb2cobWF4LnZhbHVlKCkpO1xuICAgICAqXG4gICAgICogICAgIC8vIDU2XG4gICAgICovXG5cbiAgICBjb25zdHJ1Y3RvciA6IGZ1bmN0aW9uKGF0dHJpYnV0ZSl7XG5cbiAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDApKTtcblxuICAgICAgICB0aGlzLm5hbWUgPSAnTWF4aW11bSc7XG5cbiAgICAgICAgdGhpcy50eXBlKEludGVnZXIpO1xuXG4gICAgICAgIHRoaXMuYXR0cmlidXRlID0gYXR0cmlidXRlO1xuXG4gICAgICAgIHRoaXMucmVsYXRpb24gPSBhdHRyaWJ1dGUuaGVhZGVyLnJlbGF0aW9uO1xuXG4gICAgfSxcblxuICAgIHZhbHVlIDogZnVuY3Rpb24oKXtcblxuICAgICAgICB2YXIgcmVsYXRpb24gPSB0aGlzLnJlbGF0aW9uO1xuXG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZTtcblxuICAgICAgICB2YXIgdHlwZSA9IHRoaXMuYXR0cmlidXRlLnR5cGU7XG5cbiAgICAgICAgdmFyIG1heCA9IG51bGw7XG5cbiAgICAgICAgcmVsYXRpb24uZWFjaChmdW5jdGlvbih0dXBsZSl7XG5cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHR1cGxlLmdldChhdHRyaWJ1dGUubmFtZSk7XG5cbiAgICAgICAgICAgIGlmKG1heCA9PT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBjb21wYXJlKHR5cGUsIHZhbHVlLCBtYXgpID4gMCApe1xuICAgICAgICAgICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBtYXg7XG5cbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXhpbXVtOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24nKTtcblxudmFyIGNvbXBhcmUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvY29tcGFyZS5qcycpO1xuXG52YXIgSW50ZWdlciA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvSW50ZWdlci5qcycpO1xuXG52YXIgTWluaW11bSA9IEZ1bmN0aW9uLmV4dGVuZCh7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLkFnZ3JlZ2F0ZS5NaW5pbXVtXG4gICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEZ1bmN0aW9ucyB0aGF0IHJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUgb2YgYW4gYXR0cmlidXRlIGluIGEgcmVsYXRpb24uXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIDpcbiAgICAgKlxuICAgICAqICAgICB2YXIgcmVsYXRpb24gPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAqICAgICAgICAgeyBuYW1lIDogeyB0eXBlIDogYWZmaW5pdHkuU3RyaW5nIH0gfSxcbiAgICAgKiAgICAgICAgIHsgYWdlIDogeyB0eXBlIDogYWZmaW5pdHkuSW50ZWdlciB9IH1cbiAgICAgKiAgICAgXSxbXG4gICAgICogICAgICAgICBbJ0pvaG4gRG9lJywgMjNdLFxuICAgICAqICAgICAgICAgWydNYXJrIENsaW50b24nLCAzNl0sXG4gICAgICogICAgICAgICBbJ1N1cGVyIFdvbWFuJywgNTZdXG4gICAgICogICAgIF0pO1xuICAgICAqXG4gICAgICogICAgIHZhciBhZ2UgPSByZWxhdGlvbi5nZXQoJ2FnZScpO1xuICAgICAqXG4gICAgICogICAgIHZhciBtaW4gPSByZWxhdGlvbi5taW4oYWdlKTtcbiAgICAgKlxuICAgICAqICAgICBjb25zb2xlLmxvZyhtaW4udmFsdWUoKSk7XG4gICAgICpcbiAgICAgKiAgICAgLy8gMjNcbiAgICAgKi9cblxuICAgIGNvbnN0cnVjdG9yIDogZnVuY3Rpb24oYXR0cmlidXRlKXtcblxuICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMCkpO1xuXG4gICAgICAgIHRoaXMubmFtZSA9ICdNaW5pbXVtJztcblxuICAgICAgICB0aGlzLnR5cGUoSW50ZWdlcik7XG5cbiAgICAgICAgdGhpcy5hdHRyaWJ1dGUgPSBhdHRyaWJ1dGU7XG5cbiAgICAgICAgdGhpcy5yZWxhdGlvbiA9IGF0dHJpYnV0ZS5oZWFkZXIucmVsYXRpb247XG5cbiAgICB9LFxuXG4gICAgdmFsdWUgOiBmdW5jdGlvbigpe1xuXG4gICAgICAgIHZhciByZWxhdGlvbiA9IHRoaXMucmVsYXRpb247XG5cbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlO1xuXG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5hdHRyaWJ1dGUudHlwZTtcblxuICAgICAgICB2YXIgbWluID0gbnVsbDtcblxuICAgICAgICByZWxhdGlvbi5lYWNoKGZ1bmN0aW9uKHR1cGxlKXtcblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdHVwbGUuZ2V0KGF0dHJpYnV0ZS5uYW1lKTtcblxuICAgICAgICAgICAgaWYobWluID09PSBudWxsKXtcbiAgICAgICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGNvbXBhcmUodHlwZSwgdmFsdWUsIG1pbikgPCAwICl7XG4gICAgICAgICAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG1pbjtcblxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWluaW11bTsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uJyk7XG5cbnZhciBGbG9hdCA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvRmxvYXQuanMnKTtcblxudmFyIFZhcmlhbmNlID0gcmVxdWlyZSgnLi9WYXJpYW5jZS5qcycpO1xuXG52YXIgU3RhbmRhcmREZXZpYXRpb24gPSBGdW5jdGlvbi5leHRlbmQoe1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIEZ1bmN0aW9ucy5BZ2dyZWdhdGUuU3RhbmRhcmREZXZpYXRpb25cbiAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAqXG4gICAgICogRnVuY3Rpb25zIHRoYXQgcmV0dXJucyB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uXG4gICAgICogb2YgYW4gYXR0cmlidXRlIGluIGEgcmVsYXRpb25cbiAgICAgKlxuICAgICAqIEV4YW1wbGUgOlxuICAgICAqXG4gICAgICogICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICogICAgICAgICB7IG5hbWUgOiB7IHR5cGUgOiBhZmZpbml0eS5TdHJpbmcgfSB9LFxuICAgICAqICAgICAgICAgeyBhZ2UgOiB7IHR5cGUgOiBhZmZpbml0eS5JbnRlZ2VyIH0gfVxuICAgICAqICAgICBdLFtcbiAgICAgKiAgICAgICAgIFsnSm9obiBEb2UnLCAyM10sXG4gICAgICogICAgICAgICBbJ01hcmsgQ2xpbnRvbicsIDM2XSxcbiAgICAgKiAgICAgICAgIFsnU3VwZXIgV29tYW4nLCA1Nl1cbiAgICAgKiAgICAgXSk7XG4gICAgICpcbiAgICAgKiAgICAgdmFyIGFnZSA9IHJlbGF0aW9uLmdldCgnYWdlJyk7XG4gICAgICpcbiAgICAgKiAgICAgdmFyIHN0ZGV2ID0gcmVsYXRpb24uc3RhbmRhcmREZXZpYXRpb24oYWdlKVxuICAgICAqXG4gICAgICogICAgIGNvbnNvbGUubG9nKHN0ZGV2LnZhbHVlKCkpO1xuICAgICAqXG4gICAgICogICAgIC8vIDE2LjYyMzI3Njg1MzFcbiAgICAgKi9cblxuICAgIGNvbnN0cnVjdG9yIDogZnVuY3Rpb24oYXR0cmlidXRlKXtcblxuICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMCkpO1xuXG4gICAgICAgIHRoaXMubmFtZSA9ICdTdGFuZGFyZERldmlhdGlvbic7XG5cbiAgICAgICAgdGhpcy50eXBlKEZsb2F0KTtcblxuICAgICAgICB0aGlzLmF0dHJpYnV0ZSA9IGF0dHJpYnV0ZTtcblxuICAgIH0sXG5cbiAgICB2YWx1ZSA6IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlO1xuXG4gICAgICAgIHZhciB2YXJpYW5jZSA9IG5ldyBWYXJpYW5jZShhdHRyaWJ1dGUpLnZhbHVlKCk7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh2YXJpYW5jZSk7XG5cbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFuZGFyZERldmlhdGlvbjsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uJyk7XG5cbnZhciBGbG9hdCA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvRmxvYXQuanMnKTtcblxudmFyIFN1bSA9IEZ1bmN0aW9uLmV4dGVuZCh7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLkFnZ3JlZ2F0ZS5Db3VudFxuICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBGdW5jdGlvbnMgdGhhdCBjYWxjdWxhdGVzIHRoZSBzdW0gb2YgYWxsIHZhbHVlcyBmb3JcbiAgICAgKiBhbiBhdHRyaWJ1dGUgaW4gYSByZWxhdGlvblxuICAgICAqXG4gICAgICogRXhhbXBsZSA6XG4gICAgICpcbiAgICAgKiAgICAgdmFyIHJlbGF0aW9uID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgKiAgICAgICAgIHsgbmFtZSA6IHsgdHlwZSA6IGFmZmluaXR5LlN0cmluZyB9IH0sXG4gICAgICogICAgICAgICB7IGFnZSA6IHsgdHlwZSA6IGFmZmluaXR5LkludGVnZXIgfSB9XG4gICAgICogICAgIF0sW1xuICAgICAqICAgICAgICAgWydKb2huIERvZScsIDIzXSxcbiAgICAgKiAgICAgICAgIFsnTWFyayBDbGludG9uJywgMzZdLFxuICAgICAqICAgICAgICAgWydTdXBlciBXb21hbicsIDU2XVxuICAgICAqICAgICBdKTtcbiAgICAgKlxuICAgICAqICAgICB2YXIgYWdlID0gcmVsYXRpb24uZ2V0KCdhZ2UnKTtcbiAgICAgKlxuICAgICAqICAgICB2YXIgc3VtID0gcmVsYXRpb24uc3VtKGFnZSk7XG4gICAgICpcbiAgICAgKiAgICAgY29uc29sZS5sb2coc3VtLnZhbHVlKCkpO1xuICAgICAqXG4gICAgICogICAgIC8vIDExNVxuICAgICAqL1xuXG4gICAgY29uc3RydWN0b3IgOiBmdW5jdGlvbihhdHRyaWJ1dGUpe1xuXG4gICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywwKSk7XG5cbiAgICAgICAgdGhpcy5uYW1lID0gJ1N1bSc7XG5cbiAgICAgICAgdGhpcy50eXBlKEZsb2F0KTtcblxuICAgICAgICB0aGlzLmF0dHJpYnV0ZSA9IGF0dHJpYnV0ZTtcblxuICAgICAgICB0aGlzLnJlbGF0aW9uID0gYXR0cmlidXRlLmhlYWRlci5yZWxhdGlvbjtcblxuICAgIH0sXG5cbiAgICB2YWx1ZSA6IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgdmFyIHJlbGF0aW9uID0gdGhpcy5yZWxhdGlvbjtcblxuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHRoaXMuYXR0cmlidXRlLm5hbWU7XG5cbiAgICAgICAgdmFyIHN1bSA9IDA7XG5cbiAgICAgICAgcmVsYXRpb24uZWFjaChmdW5jdGlvbih0dXBsZSl7XG5cbiAgICAgICAgICAgIHN1bSArPSB0dXBsZS5nZXQoYXR0cmlidXRlTmFtZSk7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHN1bTtcblxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3VtOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24nKTtcblxudmFyIEF2ZXJhZ2UgPSByZXF1aXJlKCcuL0F2ZXJhZ2UuanMnKTtcblxudmFyIEZsb2F0ID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9GbG9hdC5qcycpO1xuXG52YXIgVmFyaWFuY2UgPSBGdW5jdGlvbi5leHRlbmQoe1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIEZ1bmN0aW9ucy5BZ2dyZWdhdGUuVmFyaWFuY2VcbiAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAqXG4gICAgICogRnVuY3Rpb25zIHRoYXQgcmV0dXJucyB0aGUgdmFyaWFuY2VcbiAgICAgKiBvZiBhdHRyaWJ1dGUgdmFsdWVzIGluIGEgcmVsYXRpb25cbiAgICAgKlxuICAgICAqIEV4YW1wbGUgOlxuICAgICAqXG4gICAgICogICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICogICAgICAgICB7IG5hbWUgOiB7IHR5cGUgOiBhZmZpbml0eS5TdHJpbmcgfSB9LFxuICAgICAqICAgICAgICAgeyBhZ2UgOiB7IHR5cGUgOiBhZmZpbml0eS5JbnRlZ2VyIH0gfVxuICAgICAqICAgICBdLFtcbiAgICAgKiAgICAgICAgIFsnSm9obiBEb2UnLCAyM10sXG4gICAgICogICAgICAgICBbJ01hcmsgQ2xpbnRvbicsIDM2XSxcbiAgICAgKiAgICAgICAgIFsnU3VwZXIgV29tYW4nLCA1Nl1cbiAgICAgKiAgICAgXSk7XG4gICAgICpcbiAgICAgKiAgICAgdmFyIGFnZSA9IHJlbGF0aW9uLmdldCgnYWdlJyk7XG4gICAgICpcbiAgICAgKiAgICAgdmFyIHZhcmlhbmNlID0gcmVsYXRpb24udmFyaWFuY2UoYWdlKVxuICAgICAqXG4gICAgICogICAgIGNvbnNvbGUubG9nKHZhcmlhbmNlLnZhbHVlKCkpO1xuICAgICAqXG4gICAgICogICAgIC8vIDE4NC4yMjIyMlxuICAgICAqL1xuXG4gICAgY29uc3RydWN0b3IgOiBmdW5jdGlvbihhdHRyaWJ1dGUpe1xuXG4gICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywwKSk7XG5cbiAgICAgICAgdGhpcy5uYW1lID0gJ1N1bSc7XG5cbiAgICAgICAgdGhpcy50eXBlKEZsb2F0KTtcblxuICAgICAgICB0aGlzLmF0dHJpYnV0ZSA9IGF0dHJpYnV0ZTtcblxuICAgICAgICB0aGlzLnJlbGF0aW9uID0gYXR0cmlidXRlLmhlYWRlci5yZWxhdGlvblxuXG4gICAgfSxcblxuICAgIHZhbHVlIDogZnVuY3Rpb24oKXtcblxuICAgICAgICB2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGU7XG5cbiAgICAgICAgdmFyIHJlbGF0aW9uID0gdGhpcy5yZWxhdGlvbjtcblxuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHRoaXMuYXR0cmlidXRlLm5hbWU7XG5cbiAgICAgICAgdmFyIGF2ZXJhZ2UgPSBuZXcgQXZlcmFnZShhdHRyaWJ1dGUpLnZhbHVlKCk7XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHJlbGF0aW9uLmxlbmd0aCgpO1xuXG4gICAgICAgIHZhciB0b3RhbFZhcmlhbmNlID0gMDtcblxuICAgICAgICByZWxhdGlvbi5lYWNoKGZ1bmN0aW9uKHR1cGxlKXtcblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdHVwbGUuZ2V0KGF0dHJpYnV0ZU5hbWUpO1xuXG4gICAgICAgICAgICB0b3RhbFZhcmlhbmNlICs9IE1hdGgucG93KCh2YWx1ZSAtIGF2ZXJhZ2UpLCAyKTtcblxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdG90YWxWYXJpYW5jZSAvIGxlbmd0aDtcblxuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZhcmlhbmNlOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24uanMnKTtcbnZhciBUQm9vbGVhbiA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvQm9vbGVhbi5qcycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBlcXVhbCA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy9lcXVhbCcpO1xuXG52YXIgRkVxdWFsID0gRnVuY3Rpb24uZXh0ZW5kKFxuXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLkNvbXBhcmFibGUuRXF1YWxcbiAgICAgICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogRnVuY3Rpb24gdGhhdCBjb21wYXJlcyBpZiB0d28gdmFsdWVzIGFyZSBlcXVhbC4gT25seSBhcHBsaWVzXG4gICAgICAgICAqIHRvIHR5cGVzIHRoYXQgaW1wbGVtZW50IGEgc3RhdGljIFwiZXF1YWxcIiBtZXRob2Qgb3IgdG8gcHJpbWl0aXZlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiB1c2VkIHdpdGggYW4gRXh0ZW5zaW9uIG9wZXJhdG9yIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgcGhpbG9zb3BoZXJzID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgICAgIHtuYW1lOiB7IHR5cGU6IGFmZmluaXR5LlN0cmluZ319LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2Jvcm46IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2RpZWQ6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19XG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWydBcmlzdG90bGUnLCAtMzg0LCAtMzIyXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsnUGxhdG8nLCAgICAgLTQyOCwgLTM0OF0sXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ1NvY3JhdGVzJywgIC00NzAsIC0zOTldXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIG5hbWUgPSBwaGlsb3NvcGhlcnMuZ2V0KCduYW1lJyk7XG4gICAgICAgICAqICAgICAgYm9ybiA9IHBoaWxvc29waGVycy5nZXQoJ2Jvcm4nKTtcbiAgICAgICAgICogICAgICBkaWVkID0gcGhpbG9zb3BoZXJzLmdldCgnZGllZCcpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IHBoaWxvc29waGVycy5leHRlbmQoW3sgZGllZEluMzIyQkMgOiBkaWVkLmVxKC0zMjIpIH1dKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBvciBlcXVpdmFsZW50IDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSBwaGlsb3NvcGhlcnMuZXh0ZW5kKFt7IGRpZWRJbjMyMkJDIDogbmV3IGFmZmluaXR5LkVxdWFsKGRpZWQsIC0zMjIpIH1dKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICBleHRlbmRlZC5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IG5hbWUgOiBUU3RyaW5nIHwgYm9ybiA6IFRJbnRlZ2VyIHwgZGllZCA6IFRJbnRlZ2VyIHwgZGllZEluMzIyQkMgOiBUQm9vbGVhbiB8XG4gICAgICAgICAqICAgICAgLy8gKz09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgIC8vIHwgQXJpc3RvdGxlICAgICAgfCAtMzg0ICAgICAgICAgICAgfCAtMzIyICAgICAgICAgICAgfCB0cnVlICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBQbGF0byAgICAgICAgICB8IC00MjggICAgICAgICAgICB8IC0zNDggICAgICAgICAgICB8IGZhbHNlICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IFNvY3JhdGVzICAgICAgIHwgLTQ3MCAgICAgICAgICAgIHwgLTM5OSAgICAgICAgICAgIHwgZmFsc2UgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHVzZWQgd2l0aCBhIFJlc3RyaWN0aW9uIG9wZXJhdG9yIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgcmVzdHJpY3RlZCA9IHBoaWxvc29waGVycy5yZXN0cmljdChkaWVkLmVxKC0zMjIpKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBvciBlcXVpdmFsZW50IDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgcmVzdHJpY3RlZCA9IHBoaWxvc29waGVycy5yZXN0cmljdChuZXcgYWZmaW5pdHkuRXF1YWwoZGllZCwgLTMyMikpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHJlc3RyaWN0ZWQucHJpbnQoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IG5hbWUgOiBUU3RyaW5nIHwgYm9ybiA6IFRJbnRlZ2VyIHwgZGllZCA6IFRJbnRlZ2VyIHxcbiAgICAgICAgICogICAgICAvLyArPT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgICAvLyB8IEFyaXN0b3RsZSAgICAgIHwgLTM4NCAgICAgICAgICAgIHwgLTMyMiAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywwKSk7XG5cbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdFcXVhbHMnO1xuXG4gICAgICAgICAgICB0aGlzLnR5cGUoVEJvb2xlYW4pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb25cbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gZXF1YWwobnVsbCwgdGhpcy5wYXJhbWV0ZXJzWzBdLCB0aGlzLnBhcmFtZXRlcnNbMV0pO1xuXG4gICAgICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRkVxdWFsOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24uanMnKTtcbnZhciBUQm9vbGVhbiA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvQm9vbGVhbi5qcycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBjb21wYXJlID0gcmVxdWlyZSgnLi8uLi8uLi9oZWxwZXJzL2NvbXBhcmUnKTtcblxudmFyIEdyZWF0ZXJUaGFuID0gRnVuY3Rpb24uZXh0ZW5kKFxuXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLkNvbXBhcmFibGUuR3JlYXRlclRoYW5cbiAgICAgICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogRnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgYSB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gYW5vdGhlciBvbmUuXG4gICAgICAgICAqIE9ubHkgYXBwbGllcyB0byB0eXBlcyB0aGF0IGltcGxlbWVudCB0aGUgc3RhdGljIFwiY29tcGFyZVwiIG1ldGhvZFxuICAgICAgICAgKiBvciB0byBwcmltaXRpdmVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHVzZWQgd2l0aCBhbiBFeHRlbnNpb24gb3BlcmF0b3IgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBwaGlsb3NvcGhlcnMgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge25hbWU6IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7Ym9ybjogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7ZGllZDogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ0FyaXN0b3RsZScsIC0zODQsIC0zMjJdLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydQbGF0bycsICAgICAtNDI4LCAtMzQ4XSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsnU29jcmF0ZXMnLCAgLTQ3MCwgLTM5OV1cbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgbmFtZSA9IHBoaWxvc29waGVycy5nZXQoJ25hbWUnKTtcbiAgICAgICAgICogICAgICBib3JuID0gcGhpbG9zb3BoZXJzLmdldCgnYm9ybicpO1xuICAgICAgICAgKiAgICAgIGRpZWQgPSBwaGlsb3NvcGhlcnMuZ2V0KCdkaWVkJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gcGhpbG9zb3BoZXJzLmV4dGVuZChbeyBkaWVkQWZ0ZXIzNTBCQyA6IGRpZWQuZ3QoLTMyMikgfV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vIG9yIGVxdWl2YWxlbnQgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IHBoaWxvc29waGVycy5leHRlbmQoW3sgZGllZEFmdGVyMzUwQkMgOiBuZXcgYWZmaW5pdHkuR3JlYXRlclRoYW4oZGllZCwgLTMyMikgfV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgbmFtZSA6IFRTdHJpbmcgfCBib3JuIDogVEludGVnZXIgfCBkaWVkIDogVEludGVnZXIgfCBkaWVkQWZ0ZXIzNTBCQyA6IFRCb29sZWFuIHxcbiAgICAgICAgICogICAgICAvLyArPT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAgLy8gfCBBcmlzdG90bGUgICAgICB8IC0zODQgICAgICAgICAgICB8IC0zMjIgICAgICAgICAgICB8IHRydWUgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IFBsYXRvICAgICAgICAgIHwgLTQyOCAgICAgICAgICAgIHwgLTM0OCAgICAgICAgICAgIHwgdHJ1ZSAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgU29jcmF0ZXMgICAgICAgfCAtNDcwICAgICAgICAgICAgfCAtMzk5ICAgICAgICAgICAgfCB0cnVlICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gdXNlZCB3aXRoIGEgUmVzdHJpY3Rpb24gb3BlcmF0b3IgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciByZXN0cmljdGVkID0gcGhpbG9zb3BoZXJzLnJlc3RyaWN0KGRpZWQuZ3QoLTM1MCkpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vIG9yIGVxdWl2YWxlbnQgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciByZXN0cmljdGVkID0gcGhpbG9zb3BoZXJzLnJlc3RyaWN0KG5ldyBhZmZpbml0eS5HcmVhdGVyVGhhbihkaWVkLCAtMzUwKSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgcmVzdHJpY3RlZC5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgbmFtZSA6IFRTdHJpbmcgfCBib3JuIDogVEludGVnZXIgfCBkaWVkIDogVEludGVnZXIgfFxuICAgICAgICAgKiAgICAgIC8vICs9PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgIC8vIHwgQXJpc3RvdGxlICAgICAgfCAtMzg0ICAgICAgICAgICAgfCAtMzIyICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgUGxhdG8gICAgICAgICAgfCAtNDI4ICAgICAgICAgICAgfCAtMzQ4ICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ0dyZWF0ZXJUaGFuJztcblxuICAgICAgICAgICAgdGhpcy50eXBlKFRCb29sZWFuKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIChjb21wYXJlKG51bGwsIHRoaXMucGFyYW1ldGVyc1swXSwgdGhpcy5wYXJhbWV0ZXJzWzFdKSA+IDApO1xuXG4gICAgICAgIH1cblxuICAgIH0se1xuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gR3JlYXRlclRoYW47IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIGNvbXBhcmUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvY29tcGFyZScpO1xudmFyIFRCb29sZWFuID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9Cb29sZWFuLmpzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG52YXIgRkxhcmdlclRoYW5FcXVhbCA9IEZ1bmN0aW9uLmV4dGVuZChcblxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIEZ1bmN0aW9ucy5Db21wYXJhYmxlLkdyZWF0ZXJUaGFuRXF1YWxcbiAgICAgICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogRnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgYSB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYW5vdGhlciBvbmUuIEl0IG9ubHkgYXBwbGllc1xuICAgICAgICAgKiB0byB0eXBlcyB0aGF0IGltcGxlbWVudCBhIHN0YXRpYyBcImNvbXBhcmVcIiBtZXRob2Qgb3IgdG8gcHJpbWl0aXZlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiB1c2VkIHdpdGggYW4gRXh0ZW5zaW9uIG9wZXJhdG9yIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgcGhpbG9zb3BoZXJzID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgICAgIHtuYW1lOiB7IHR5cGU6IGFmZmluaXR5LlN0cmluZ319LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2Jvcm46IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2RpZWQ6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19XG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWydBcmlzdG90bGUnLCAtMzg0LCAtMzIyXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsnUGxhdG8nLCAgICAgLTQyOCwgLTM0OF0sXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ1NvY3JhdGVzJywgIC00NzAsIC0zOTldXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIG5hbWUgPSBwaGlsb3NvcGhlcnMuZ2V0KCduYW1lJyk7XG4gICAgICAgICAqICAgICAgYm9ybiA9IHBoaWxvc29waGVycy5nZXQoJ2Jvcm4nKTtcbiAgICAgICAgICogICAgICBkaWVkID0gcGhpbG9zb3BoZXJzLmdldCgnZGllZCcpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IHBoaWxvc29waGVycy5leHRlbmQoW3sgZGllZFNpbmNlMzQ4QkMgOiBkaWVkLmd0ZSgtMzQ4KSB9XSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gb3IgZXF1aXZhbGVudCA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gcGhpbG9zb3BoZXJzLmV4dGVuZChbeyBkaWVkU2luY2UzNDhCQyA6IG5ldyBhZmZpbml0eS5HcmVhdGVyVGhhbkVxdWFsKGRpZWQsIC0zNDgpIH1dKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICBleHRlbmRlZC5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IG5hbWUgOiBUU3RyaW5nIHwgYm9ybiA6IFRJbnRlZ2VyIHwgZGllZCA6IFRJbnRlZ2VyIHwgZGllZFNpbmNlMzQ4QkMgOiBUQm9vbGVhbiB8XG4gICAgICAgICAqICAgICAgLy8gKz09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgIC8vIHwgQXJpc3RvdGxlICAgICAgfCAtMzg0ICAgICAgICAgICAgfCAtMzIyICAgICAgICAgICAgfCBmYWxzZSAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBQbGF0byAgICAgICAgICB8IC00MjggICAgICAgICAgICB8IC0zNDggICAgICAgICAgICB8IHRydWUgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IFNvY3JhdGVzICAgICAgIHwgLTQ3MCAgICAgICAgICAgIHwgLTM5OSAgICAgICAgICAgIHwgdHJ1ZSAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHVzZWQgd2l0aCBhIFJlc3RyaWN0aW9uIG9wZXJhdG9yIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgcmVzdHJpY3RlZCA9IHBoaWxvc29waGVycy5yZXN0cmljdChkaWVkLmd0ZSgtMzQ4KSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gb3IgZXF1aXZhbGVudCA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIHJlc3RyaWN0ZWQgPSBwaGlsb3NvcGhlcnMucmVzdHJpY3QobmV3IGFmZmluaXR5LkdyZWF0ZXJUaGFuRXF1YWwoZGllZCwgLTM0OCkpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHJlc3RyaWN0ZWQucHJpbnQoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IG5hbWUgOiBUU3RyaW5nIHwgYm9ybiA6IFRJbnRlZ2VyIHwgZGllZCA6IFRJbnRlZ2VyIHxcbiAgICAgICAgICogICAgICAvLyArPT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgICAvLyB8IEFyaXN0b3RsZSAgICAgIHwgLTM4NCAgICAgICAgICAgIHwgLTMyMiAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IFBsYXRvICAgICAgICAgIHwgLTQyOCAgICAgICAgICAgIHwgLTM0OCAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdHcmVhdGVyVGhhbkVxdWFsJztcblxuICAgICAgICAgICAgdGhpcy50eXBlKFRCb29sZWFuKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIChjb21wYXJlKG51bGwsIHRoaXMucGFyYW1ldGVyc1swXSwgdGhpcy5wYXJhbWV0ZXJzWzFdKSA+PSAwKTtcblxuICAgICAgICB9XG5cbiAgICB9LHtcblxuXG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBGTGFyZ2VyVGhhbkVxdWFsOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24uanMnKTtcbnZhciBjb21wYXJlID0gcmVxdWlyZSgnLi8uLi8uLi9oZWxwZXJzL2NvbXBhcmUnKTtcbnZhciBUQm9vbGVhbiA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvQm9vbGVhbi5qcycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxudmFyIEZTbWFsbGVyVGhhbiA9IEZ1bmN0aW9uLmV4dGVuZChcblxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIEZ1bmN0aW9ucy5Db21wYXJhYmxlLlNtYWxsZXJUaGFuXG4gICAgICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIGEgdmFsdWUgaXMgc21hbGxlciB0aGFuIGFub3RoZXIgb25lLiBJdCBvbmx5IGFwcGxpZXNcbiAgICAgICAgICogdG8gdHlwZXMgdGhhdCBpbXBsZW1lbnQgYSBzdGF0aWMgXCJjb21wYXJlXCIgbWV0aG9kIG9yIHRvIHByaW1pdGl2ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gdXNlZCB3aXRoIGFuIEV4dGVuc2lvbiBvcGVyYXRvciA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIHBoaWxvc29waGVycyA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7bmFtZTogeyB0eXBlOiBhZmZpbml0eS5TdHJpbmd9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtib3JuOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtkaWVkOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsnQXJpc3RvdGxlJywgLTM4NCwgLTMyMl0sXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ1BsYXRvJywgICAgIC00MjgsIC0zNDhdLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydTb2NyYXRlcycsICAtNDcwLCAtMzk5XVxuICAgICAgICAgKiAgICAgICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICBuYW1lID0gcGhpbG9zb3BoZXJzLmdldCgnbmFtZScpO1xuICAgICAgICAgKiAgICAgIGJvcm4gPSBwaGlsb3NvcGhlcnMuZ2V0KCdib3JuJyk7XG4gICAgICAgICAqICAgICAgZGllZCA9IHBoaWxvc29waGVycy5nZXQoJ2RpZWQnKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSBwaGlsb3NvcGhlcnMuZXh0ZW5kKFt7IGRpZWRCZWZvcmUzNDhCQyA6IGRpZWQuc3QoLTM0OCkgfV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vIG9yIGVxdWl2YWxlbnQgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IHBoaWxvc29waGVycy5leHRlbmQoW3sgZGllZEJlZm9yZTM0OEJDIDogbmV3IGFmZmluaXR5LlNtYWxsZXJUaGFuKGRpZWQsIC0zNDgpIH1dKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICBleHRlbmRlZC5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBuYW1lIDogVFN0cmluZyB8IGJvcm4gOiBUSW50ZWdlciB8IGRpZWQgOiBUSW50ZWdlciB8IGRpZWRCZWZvcmUzNDhCQyA6IFRCb29sZWFuIHxcbiAgICAgICAgICogICAgICAvLyArPT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgIC8vIHwgQXJpc3RvdGxlICAgICAgfCAtMzg0ICAgICAgICAgICAgfCAtMzIyICAgICAgICAgICAgfCB0cnVlICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IFBsYXRvICAgICAgICAgIHwgLTQyOCAgICAgICAgICAgIHwgLTM0OCAgICAgICAgICAgIHwgZmFsc2UgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBTb2NyYXRlcyAgICAgICB8IC00NzAgICAgICAgICAgICB8IC0zOTkgICAgICAgICAgICB8IGZhbHNlICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHVzZWQgd2l0aCBhIFJlc3RyaWN0aW9uIG9wZXJhdG9yIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgcmVzdHJpY3RlZCA9IHBoaWxvc29waGVycy5yZXN0cmljdChkaWVkLnN0KC0zNDgpKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBvciBlcXVpdmFsZW50IDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgcmVzdHJpY3RlZCA9IHBoaWxvc29waGVycy5yZXN0cmljdChuZXcgYWZmaW5pdHkuU21hbGxlclRoYW4oZGllZCwgLTM0OCkpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHJlc3RyaWN0ZWQucHJpbnQoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IG5hbWUgOiBUU3RyaW5nIHwgYm9ybiA6IFRJbnRlZ2VyIHwgZGllZCA6IFRJbnRlZ2VyIHxcbiAgICAgICAgICogICAgICAvLyArPT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgICAvLyB8IEFyaXN0b3RsZSAgICAgIHwgLTM4NCAgICAgICAgICAgIHwgLTMyMiAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdTbWFsbGVyVGhhbic7XG5cbiAgICAgICAgICAgIHRoaXMudHlwZShUQm9vbGVhbik7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgcmVzdWx0IG9mIHRoZSBmdW5jdGlvblxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiAoY29tcGFyZShudWxsLCB0aGlzLnBhcmFtZXRlcnNbMF0sIHRoaXMucGFyYW1ldGVyc1sxXSkgPCAwKTtcblxuICAgICAgICB9XG5cbiAgICB9LHtcblxuXG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBGU21hbGxlclRoYW47IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIGNvbXBhcmUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvY29tcGFyZScpO1xudmFyIFRCb29sZWFuID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9Cb29sZWFuLmpzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG52YXIgRlNtYWxsZXJUaGFuRXF1YWwgPSBGdW5jdGlvbi5leHRlbmQoXG5cbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuQ29tcGFyYWJsZS5TbWFsbGVyVGhhbkVxdWFsXG4gICAgICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIGEgdmFsdWUgaXMgc21hbGxlciB0aGFuIG9yIGVxdWFsIHRvIGFub3RoZXIgb25lLiBJdCBvbmx5IGFwcGxpZXNcbiAgICAgICAgICogdG8gdHlwZXMgdGhhdCBpbXBsZW1lbnQgYSBzdGF0aWMgXCJjb21wYXJlXCIgbWV0aG9kIG9yIHRvIHByaW1pdGl2ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gdXNlZCB3aXRoIGFuIEV4dGVuc2lvbiBvcGVyYXRvciA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIHBoaWxvc29waGVycyA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7bmFtZTogeyB0eXBlOiBhZmZpbml0eS5TdHJpbmd9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtib3JuOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtkaWVkOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsnQXJpc3RvdGxlJywgLTM4NCwgLTMyMl0sXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ1BsYXRvJywgICAgIC00MjgsIC0zNDhdLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydTb2NyYXRlcycsICAtNDcwLCAtMzk5XVxuICAgICAgICAgKiAgICAgICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICBuYW1lID0gcGhpbG9zb3BoZXJzLmdldCgnbmFtZScpO1xuICAgICAgICAgKiAgICAgIGJvcm4gPSBwaGlsb3NvcGhlcnMuZ2V0KCdib3JuJyk7XG4gICAgICAgICAqICAgICAgZGllZCA9IHBoaWxvc29waGVycy5nZXQoJ2RpZWQnKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSBwaGlsb3NvcGhlcnMuZXh0ZW5kKFt7IGRpZWRVcFRvMzQ4QkMgOiBkaWVkLnN0ZSgtMzQ4KSB9XSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gb3IgZXF1aXZhbGVudCA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gcGhpbG9zb3BoZXJzLmV4dGVuZChbeyBkaWVkVXBUbzM0OEJDIDogbmV3IGFmZmluaXR5LlNtYWxsZXJUaGFuRXF1YWwoZGllZCwgLTM0OCkgfV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBuYW1lIDogVFN0cmluZyB8IGJvcm4gOiBUSW50ZWdlciB8IGRpZWQgOiBUSW50ZWdlciB8IGRpZWRVcFRvMzQ4QkMgOiBUQm9vbGVhbiB8XG4gICAgICAgICAqICAgICAgLy8gKz09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAgLy8gfCBBcmlzdG90bGUgICAgICB8IC0zODQgICAgICAgICAgICB8IC0zMjIgICAgICAgICAgICB8IHRydWUgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBQbGF0byAgICAgICAgICB8IC00MjggICAgICAgICAgICB8IC0zNDggICAgICAgICAgICB8IHRydWUgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBTb2NyYXRlcyAgICAgICB8IC00NzAgICAgICAgICAgICB8IC0zOTkgICAgICAgICAgICB8IGZhbHNlICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gdXNlZCB3aXRoIGEgUmVzdHJpY3Rpb24gb3BlcmF0b3IgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciByZXN0cmljdGVkID0gcGhpbG9zb3BoZXJzLnJlc3RyaWN0KGRpZWQuc3RlKC0zNDgpKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBvciBlcXVpdmFsZW50IDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgcmVzdHJpY3RlZCA9IHBoaWxvc29waGVycy5yZXN0cmljdChuZXcgYWZmaW5pdHkuU21hbGxlclRoYW5FcXVhbChkaWVkLCAtMzQ4KSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgcmVzdHJpY3RlZC5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgbmFtZSA6IFRTdHJpbmcgfCBib3JuIDogVEludGVnZXIgfCBkaWVkIDogVEludGVnZXIgfFxuICAgICAgICAgKiAgICAgIC8vICs9PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgIC8vIHwgQXJpc3RvdGxlICAgICAgfCAtMzg0ICAgICAgICAgICAgfCAtMzIyICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgUGxhdG8gICAgICAgICAgfCAtNDI4ICAgICAgICAgICAgfCAtMzQ4ICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ1NtYWxsZXJUaGFuRXF1YWwnO1xuXG4gICAgICAgICAgICB0aGlzLnR5cGUoVEJvb2xlYW4pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb25cbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gKGNvbXBhcmUobnVsbCwgdGhpcy5wYXJhbWV0ZXJzWzBdLCB0aGlzLnBhcmFtZXRlcnNbMV0pIDw9IDApO1xuXG4gICAgICAgIH1cblxuICAgIH0se1xuXG5cblxuICAgIH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZTbWFsbGVyVGhhbkVxdWFsOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24uanMnKTtcbnZhciBUQm9vbGVhbiA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvQm9vbGVhbi5qcycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxudmFyIEFuZCA9IEZ1bmN0aW9uLmV4dGVuZChcbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuQ29ubmVjdGl2ZS5BbmRcbiAgICAgICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogRnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgaXRzIGFyZ3VtZW50cyBhbGwgcmV0dXJuIGEgdHJ1ZSBib29sZWFuLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHVzZWQgd2l0aCBhbiBFeHRlbnNpb24gb3BlcmF0b3IgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBwaGlsb3NvcGhlcnMgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge25hbWU6IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7Ym9ybjogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7ZGllZDogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ0FyaXN0b3RsZScsIC0zODQsIC0zMjJdLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydQbGF0bycsICAgICAtNDI4LCAtMzQ4XSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsnU29jcmF0ZXMnLCAgLTQ3MCwgLTM5OV1cbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgbmFtZSA9IHBoaWxvc29waGVycy5nZXQoJ25hbWUnKTtcbiAgICAgICAgICogICAgICBib3JuID0gcGhpbG9zb3BoZXJzLmdldCgnYm9ybicpO1xuICAgICAgICAgKiAgICAgIGRpZWQgPSBwaGlsb3NvcGhlcnMuZ2V0KCdkaWVkJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gcGhpbG9zb3BoZXJzLmV4dGVuZChbeyBcIjMyMnRvMzg0QkNcIiA6IGRpZWQuZXEoLTMyMikuYW5kKGJvcm4uZXEoLTM4NCkpIH1dKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBvciBlcXVpdmFsZW50IDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSBwaGlsb3NvcGhlcnMuZXh0ZW5kKFtcbiAgICAgICAgICogICAgICAgICAgeyBkaWVkSW4zMjJCQyA6IG5ldyBhZmZpbml0eS5BbmQobmV3IGFmZmluaXR5LkVxdWFsKGRpZWQsIC0zMjIpLCBuZXcgYWZmaW5pdHkuRXF1YWwoYm9ybiwgLTM4NCkpIH1cbiAgICAgICAgICogICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICBleHRlbmRlZC5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IG5hbWUgOiBUU3RyaW5nIHwgYm9ybiA6IFRJbnRlZ2VyIHwgZGllZCA6IFRJbnRlZ2VyIHwgMzIydG8zODRCQyA6IFRCb29sZWFuICB8XG4gICAgICAgICAqICAgICAgLy8gKz09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgIC8vIHwgQXJpc3RvdGxlICAgICAgfCAtMzg0ICAgICAgICAgICAgfCAtMzIyICAgICAgICAgICAgfCB0cnVlICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBQbGF0byAgICAgICAgICB8IC00MjggICAgICAgICAgICB8IC0zNDggICAgICAgICAgICB8IGZhbHNlICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IFNvY3JhdGVzICAgICAgIHwgLTQ3MCAgICAgICAgICAgIHwgLTM5OSAgICAgICAgICAgIHwgZmFsc2UgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHVzZWQgd2l0aCBhIFJlc3RyaWN0aW9uIG9wZXJhdG9yIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgcmVzdHJpY3RlZCA9IHBoaWxvc29waGVycy5yZXN0cmljdChkaWVkLmVxKC0zMjIpLmFuZChib3JuLmVxKC0zODQpKSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gb3IgZXF1aXZhbGVudCA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIHJlc3RyaWN0ZWQgPSBwaGlsb3NvcGhlcnMucmVzdHJpY3QoXG4gICAgICAgICAqICAgICAgICAgIG5ldyBhZmZpbml0eS5BbmQobmV3IGFmZmluaXR5LkVxdWFsKGRpZWQsIC0zMjIpLCBuZXcgYWZmaW5pdHkuRXF1YWwoYm9ybiwgLTM4NCkpXG4gICAgICAgICAqICAgICAgKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICByZXN0cmljdGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBuYW1lIDogVFN0cmluZyB8IGJvcm4gOiBUSW50ZWdlciB8IGRpZWQgOiBUSW50ZWdlciB8XG4gICAgICAgICAqICAgICAgLy8gKz09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAgLy8gfCBBcmlzdG90bGUgICAgICB8IC0zODQgICAgICAgICAgICB8IC0zMjIgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcblxuICAgICAgICAgICAgdGhpcy50eXBlKFRCb29sZWFuKTtcblxuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ0FuZCc7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZnVuY3Rpb24gcmV0dXJuIHZhbHVlXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIF8uZXZlcnkodGhpcy5wYXJhbWV0ZXJzLCBmdW5jdGlvbihwYXJhbWV0ZXIpe1xuXG4gICAgICAgICAgICAgICAgaWYoIV8uaXNCb29sZWFuKHBhcmFtZXRlcikpe1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXIgPSBwYXJhbWV0ZXIudmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtZXRlcjtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfVxuXG4gICAgfSx7XG5cblxuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQW5kOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24uanMnKTtcbnZhciBUQm9vbGVhbiA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvQm9vbGVhbi5qcycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxudmFyIE5vdCA9IEZ1bmN0aW9uLmV4dGVuZChcblxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIEZ1bmN0aW9ucy5Db25uZWN0aXZlLk5vdFxuICAgICAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBGdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiBpdHMgYXJndW1lbnQgcmV0dXJucyBmYWxzZVxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHVzZWQgd2l0aCBhbiBFeHRlbnNpb24gb3BlcmF0b3IgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBwaGlsb3NvcGhlcnMgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge25hbWU6IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7Ym9ybjogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7ZGllZDogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ0FyaXN0b3RsZScsIC0zODQsIC0zMjJdLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydQbGF0bycsICAgICAtNDI4LCAtMzQ4XSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsnU29jcmF0ZXMnLCAgLTQ3MCwgLTM5OV1cbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgbmFtZSA9IHBoaWxvc29waGVycy5nZXQoJ25hbWUnKTtcbiAgICAgICAgICogICAgICBib3JuID0gcGhpbG9zb3BoZXJzLmdldCgnYm9ybicpO1xuICAgICAgICAgKiAgICAgIGRpZWQgPSBwaGlsb3NvcGhlcnMuZ2V0KCdkaWVkJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gcGhpbG9zb3BoZXJzLmV4dGVuZChbeyBcIm5vdEJvcm5JbjM4NEJDXCIgOiBib3JuLm5vdCgpLmVxKC0zODQpIH1dKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBvciBlcXVpdmFsZW50IDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSBwaGlsb3NvcGhlcnMuZXh0ZW5kKFtcbiAgICAgICAgICogICAgICAgICAgeyBkaWVkSW4zMjJCQyA6IG5ldyBhZmZpbml0eS5Ob3QobmV3IGFmZmluaXR5LkVxdWFsKGJvcm4sIC0zMjIpKSB9XG4gICAgICAgICAqICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgZXh0ZW5kZWQucHJpbnQoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgbmFtZSA6IFRTdHJpbmcgfCBib3JuIDogVEludGVnZXIgfCBkaWVkIDogVEludGVnZXIgfCBub3RCb3JuSW4zODRCQyA6IFRCb29sZWFuICB8XG4gICAgICAgICAqICAgICAgLy8gKz09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgICAvLyB8IEFyaXN0b3RsZSAgICAgIHwgLTM4NCAgICAgICAgICAgIHwgLTMyMiAgICAgICAgICAgIHwgZmFsc2UgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBQbGF0byAgICAgICAgICB8IC00MjggICAgICAgICAgICB8IC0zNDggICAgICAgICAgICB8IHRydWUgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgU29jcmF0ZXMgICAgICAgfCAtNDcwICAgICAgICAgICAgfCAtMzk5ICAgICAgICAgICAgfCB0cnVlICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiB1c2VkIHdpdGggYSBSZXN0cmljdGlvbiBvcGVyYXRvciA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIHJlc3RyaWN0ZWQgPSBwaGlsb3NvcGhlcnMucmVzdHJpY3QoYm9ybi5ub3QoKS5lcSgtMzg0KSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gb3IgZXF1aXZhbGVudCA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIHJlc3RyaWN0ZWQgPSBwaGlsb3NvcGhlcnMucmVzdHJpY3QoXG4gICAgICAgICAqICAgICAgICAgIG5ldyBhZmZpbml0eS5Ob3QobmV3IGFmZmluaXR5LkVxdWFsKGJvcm4sIC0zMjIpKVxuICAgICAgICAgKiAgICAgICk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgcmVzdHJpY3RlZC5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgbmFtZSA6IFRTdHJpbmcgfCBib3JuIDogVEludGVnZXIgfCBkaWVkIDogVEludGVnZXIgfFxuICAgICAgICAgKiAgICAgIC8vICs9PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgIC8vIHwgUGxhdG8gICAgICAgICAgfCAtNDI4ICAgICAgICAgICAgfCAtMzQ4ICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgU29jcmF0ZXMgICAgICAgfCAtNDcwICAgICAgICAgICAgfCAtMzk5ICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgdGhpcy50eXBlKFRCb29sZWFuKTtcblxuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ05vdCc7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZnVuY3Rpb24gcmV0dXJuIHZhbHVlXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgaWYoIV8uaXNCb29sZWFuKHRoaXMucGFyYW1ldGVyc1swXSkpe1xuICAgICAgICAgICAgICAgIHJldHVybiAhdGhpcy5wYXJhbWV0ZXJzWzBdLnZhbHVlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5wYXJhbWV0ZXJzWzBdO1xuXG4gICAgICAgIH1cblxuICAgIH0se1xuXG5cblxuICAgIH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vdDsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uLmpzJyk7XG52YXIgVEJvb2xlYW4gPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL0Jvb2xlYW4uanMnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbnZhciBPciA9IEZ1bmN0aW9uLmV4dGVuZChcbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuQ29ubmVjdGl2ZS5PclxuICAgICAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBGdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiBvbmUgb2YgaXRzIGFyZ3VtZW50cyByZXR1cm4gdHJ1ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHVzZWQgd2l0aCBhbiBFeHRlbnNpb24gb3BlcmF0b3IgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBwaGlsb3NvcGhlcnMgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge25hbWU6IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7Ym9ybjogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7ZGllZDogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ0FyaXN0b3RsZScsIC0zODQsIC0zMjJdLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydQbGF0bycsICAgICAtNDI4LCAtMzQ4XSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsnU29jcmF0ZXMnLCAgLTQ3MCwgLTM5OV1cbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgbmFtZSA9IHBoaWxvc29waGVycy5nZXQoJ25hbWUnKTtcbiAgICAgICAgICogICAgICBib3JuID0gcGhpbG9zb3BoZXJzLmdldCgnYm9ybicpO1xuICAgICAgICAgKiAgICAgIGRpZWQgPSBwaGlsb3NvcGhlcnMuZ2V0KCdkaWVkJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gcGhpbG9zb3BoZXJzLmV4dGVuZChbeyBcImJvcm4zODRvcjQyOEJDXCIgOiBib3JuLmVxKC0zODQpLm9yKGJvcm4uZXEoLTQyOCkpIH1dKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBvciBlcXVpdmFsZW50IDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSBwaGlsb3NvcGhlcnMuZXh0ZW5kKFtcbiAgICAgICAgICogICAgICAgICAgeyBkaWVkSW4zMjJCQyA6IG5ldyBhZmZpbml0eS5PcihuZXcgYWZmaW5pdHkuRXF1YWwoYm9ybiwgLTM4NCksIG5ldyBhZmZpbml0eS5FcXVhbChib3JuLCAtNDI4KSkgfVxuICAgICAgICAgKiAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IG5hbWUgOiBUU3RyaW5nIHwgYm9ybiA6IFRJbnRlZ2VyIHwgZGllZCA6IFRJbnRlZ2VyIHwgYm9ybjM4NG9yNDI4QkMgOiBUQm9vbGVhbiAgfFxuICAgICAgICAgKiAgICAgIC8vICs9PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAgLy8gfCBBcmlzdG90bGUgICAgICB8IC0zODQgICAgICAgICAgICB8IC0zMjIgICAgICAgICAgICB8IHRydWUgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgUGxhdG8gICAgICAgICAgfCAtNDI4ICAgICAgICAgICAgfCAtMzQ4ICAgICAgICAgICAgfCB0cnVlICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IFNvY3JhdGVzICAgICAgIHwgLTQ3MCAgICAgICAgICAgIHwgLTM5OSAgICAgICAgICAgIHwgZmFsc2UgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gdXNlZCB3aXRoIGEgUmVzdHJpY3Rpb24gb3BlcmF0b3IgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciByZXN0cmljdGVkID0gcGhpbG9zb3BoZXJzLnJlc3RyaWN0KGJvcm4uZXEoLTM4NCkub3IoYm9ybi5lcSgtNDI4KSkpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vIG9yIGVxdWl2YWxlbnQgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciByZXN0cmljdGVkID0gcGhpbG9zb3BoZXJzLnJlc3RyaWN0KFxuICAgICAgICAgKiAgICAgICAgICBuZXcgYWZmaW5pdHkuT3IobmV3IGFmZmluaXR5LkVxdWFsKGJvcm4sIC0zODQpLCBuZXcgYWZmaW5pdHkuRXF1YWwoYm9ybiwgLTQyOCkpXG4gICAgICAgICAqICAgICAgKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICByZXN0cmljdGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBuYW1lIDogVFN0cmluZyB8IGJvcm4gOiBUSW50ZWdlciB8IGRpZWQgOiBUSW50ZWdlciB8XG4gICAgICAgICAqICAgICAgLy8gKz09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAgLy8gfCBBcmlzdG90bGUgICAgICB8IC0zODQgICAgICAgICAgICB8IC0zMjIgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBQbGF0byAgICAgICAgICB8IC00MjggICAgICAgICAgICB8IC0zNDggICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICB0aGlzLnR5cGUoVEJvb2xlYW4pO1xuXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSAnT3InO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuXG4gICAgICAgICAgICByZXR1cm4gXy5hbnkodGhpcy5wYXJhbWV0ZXJzLCBmdW5jdGlvbihwYXJhbWV0ZXIpe1xuXG4gICAgICAgICAgICAgICAgaWYoIV8uaXNCb29sZWFuKHBhcmFtZXRlcikpe1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXIgPSBwYXJhbWV0ZXIudmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtZXRlcjtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfVxuXG4gICAgfSx7XG5cblxuICAgIH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9yOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24uanMnKTtcbnZhciBUSW50ZWdlciA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvSW50ZWdlci5qcycpO1xudmFyIHZhbHVlID0gcmVxdWlyZSgnLi8uLi8uLi9oZWxwZXJzL3ZhbHVlJyk7XG5cbnZhciBGRGF5T2ZNb250aCA9IEZ1bmN0aW9uLmV4dGVuZChcbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuRGF0ZS5EYXlPZk1vbnRoXG4gICAgICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEZ1bmN0aW9uIHRoYXQgZXh0cmFjdHMgYSBkYXRlJ3MgZGF5IG9mIHRoZSBtb250aFxuICAgICAgICAgKlxuICAgICAgICAgKiBXaXRoIGV4dGVuZCBvcGVyYXRpb24gOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBldmVudHMgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICB7ZGF0ZSA6IHt0eXBlIDogYWZmaW5pdHkuRGF0ZX19LFxuICAgICAgICAgKiAgICAgICAgICB7bmFtZSA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgW25ldyBEYXRlKDIwMTQsIDEsIDA3KSwgJ1NvY2hpJ10sXG4gICAgICAgICAqICAgICAgICAgIFtuZXcgRGF0ZSgyMDE0LCAwLCAwMiksICdDaG9jb2xhdGUgcnVzaCddLFxuICAgICAgICAgKiAgICAgICAgICBbbmV3IERhdGUoMjAxNCwgMywgMTUpLCAnTWlsbGlvbnRoIGNvZmZlZSBkcmFuayddXG4gICAgICAgICAqICAgICAgXSlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZGF0ZSA9IGV2ZW50cy5nZXQoJ2RhdGUnKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IGV2ZW50cy5leHRlbmQoWyB7IFwiZGF0ZS5kYXlPZk1vbnRoKClcIiA6IGRhdGUuZGF5T2ZNb250aCgpIH0gXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gb3IgZXF1aXZhbGVudFxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IGV2ZW50cy5leHRlbmQoWyB7IFwiZGF0ZS5kYXlPZk1vbnRoKClcIiA6IG5ldyBhZmZpbml0eS5EYXlPZk1vbnRoKGRhdGUpIH0gXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgZXh0ZW5kZWQucHJpbnQoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIHwgZGF0ZSA6IERhdGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBuYW1lIDogU3RyaW5nICAgICAgICAgICAgfCBkYXRlLmRheU9mTW9udGgoKSA6IEludGVnZXIgICB8XG4gICAgICAgICAqICAgICAgKz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgICB8IEZyaSBGZWIgMDcgMjAxNCAwMDowMDowMCBHTVQtMDUwMCAoRVNUKSAgIHwgU29jaGkgICAgICAgICAgICAgICAgICAgIHwgNyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgfCBUaHUgSmFuIDAyIDIwMTQgMDA6MDA6MDAgR01ULTA1MDAgKEVTVCkgICB8IENob2NvbGF0ZSBydXNoICAgICAgICAgICB8IDIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIHwgVHVlIEFwciAxNSAyMDE0IDAwOjAwOjAwIEdNVC0wNDAwIChFRFQpICAgfCBNaWxsaW9udGggY29mZmVlIGRyYW5rICAgfCAxNSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuXG4gICAgICAgICAgICB0aGlzLnR5cGUoVEludGVnZXIpO1xuXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSAnRGF5T2ZNb250aCc7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZnVuY3Rpb24ncyByZXR1cm4gdmFsdWVcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMF0pLmdldERhdGUoKTtcblxuICAgICAgICB9XG5cbiAgICB9LHtcblxuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRkRheU9mTW9udGg7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIFRJbnRlZ2VyID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9JbnRlZ2VyLmpzJyk7XG52YXIgdmFsdWUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvdmFsdWUnKTtcblxudmFyIEZEYXlPZldlZWsgPSBGdW5jdGlvbi5leHRlbmQoXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLkRhdGUuRGF5T2ZXZWVrXG4gICAgICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEZ1bmN0aW9uIHRoYXQgZXh0cmFjdHMgYSBkYXRlJ3MgZGF5IG9mIHRoZSB3ZWVrXG4gICAgICAgICAqXG4gICAgICAgICAqIFN1bmRheSBpcyAwLCBTYXR1cmRheSBpcyA2XG4gICAgICAgICAqXG4gICAgICAgICAqIFdpdGggZXh0ZW5kIG9wZXJhdGlvbiA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV2ZW50cyA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgIHtkYXRlIDoge3R5cGUgOiBhZmZpbml0eS5EYXRlfX0sXG4gICAgICAgICAqICAgICAgICAgIHtuYW1lIDoge3R5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICBbbmV3IERhdGUoMjAxNCwgMSwgMDcpLCAnU29jaGknXSxcbiAgICAgICAgICogICAgICAgICAgW25ldyBEYXRlKDIwMTQsIDAsIDAyKSwgJ0Nob2NvbGF0ZSBydXNoJ10sXG4gICAgICAgICAqICAgICAgICAgIFtuZXcgRGF0ZSgyMDE0LCAzLCAxNSksICdNaWxsaW9udGggY29mZmVlIGRyYW5rJ11cbiAgICAgICAgICogICAgICBdKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBkYXRlID0gZXZlbnRzLmdldCgnZGF0ZScpXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gZXZlbnRzLmV4dGVuZChbIHsgXCJkYXRlLmRheU9mV2VlaygpXCIgOiBkYXRlLmRheU9mV2VlaygpIH0gXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gb3IgZXF1aXZhbGVudFxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IGV2ZW50cy5leHRlbmQoWyB7IFwiZGF0ZS5kYXlPZldlZWsoKVwiIDogbmV3IGFmZmluaXR5LkRheU9mV2VlayhkYXRlKSB9IF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgZGF0ZSA6IERhdGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBuYW1lIDogU3RyaW5nICAgICAgICAgICAgfCBkYXRlLmRheU9mV2VlaygpIDogSW50ZWdlciAgIHxcbiAgICAgICAgICogICAgICAvLyArPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAgLy8gfCBGcmkgRmViIDA3IDIwMTQgMDA6MDA6MDAgR01ULTA1MDAgKEVTVCkgICB8IFNvY2hpICAgICAgICAgICAgICAgICAgICB8IDUgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IFRodSBKYW4gMDIgMjAxNCAwMDowMDowMCBHTVQtMDUwMCAoRVNUKSAgIHwgQ2hvY29sYXRlIHJ1c2ggICAgICAgICAgIHwgNCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgVHVlIEFwciAxNSAyMDE0IDAwOjAwOjAwIEdNVC0wNDAwIChFRFQpICAgfCBNaWxsaW9udGggY29mZmVlIGRyYW5rICAgfCAyICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcblxuICAgICAgICAgICAgdGhpcy50eXBlKFRJbnRlZ2VyKTtcblxuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ0RheU9mV2Vlayc7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZnVuY3Rpb24gcmV0dXJuIHZhbHVlXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUodGhpcy5wYXJhbWV0ZXJzWzBdKS5nZXREYXkoKTtcblxuICAgICAgICB9XG5cbiAgICB9LHtcblxuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRkRheU9mV2VlazsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uLmpzJyk7XG52YXIgVEludGVnZXIgPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL0ludGVnZXIuanMnKTtcbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy92YWx1ZScpO1xuXG52YXIgRkRheU9mWWVhciA9IEZ1bmN0aW9uLmV4dGVuZChcbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuRGF0ZS5EYXlPZlllYXJcbiAgICAgICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogRnVuY3Rpb24gdGhhdCBleHRyYWN0cyBhIGRhdGUncyBkYXkgb2YgdGhlIHllYXJcbiAgICAgICAgICpcbiAgICAgICAgICogSmFudWFyeSAxc3QgaXMgMFxuICAgICAgICAgKlxuICAgICAgICAgKiBXaXRoIGV4dGVuZCBvcGVyYXRpb24gOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBldmVudHMgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICB7ZGF0ZSA6IHt0eXBlIDogYWZmaW5pdHkuRGF0ZX19LFxuICAgICAgICAgKiAgICAgICAgICB7bmFtZSA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgW25ldyBEYXRlKDIwMTQsIDEsIDA3KSwgJ1NvY2hpJ10sXG4gICAgICAgICAqICAgICAgICAgIFtuZXcgRGF0ZSgyMDE0LCAwLCAwMiksICdDaG9jb2xhdGUgcnVzaCddLFxuICAgICAgICAgKiAgICAgICAgICBbbmV3IERhdGUoMjAxNCwgMywgMTUpLCAnTWlsbGlvbnRoIGNvZmZlZSBkcmFuayddXG4gICAgICAgICAqICAgICAgXSlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZGF0ZSA9IGV2ZW50cy5nZXQoJ2RhdGUnKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IGV2ZW50cy5leHRlbmQoWyB7IFwiZGF0ZS5kYXlPZlllYXIoKVwiIDogZGF0ZS5kYXlPZlllYXIoKSB9IF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vIG9yIGVxdWl2YWxlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSBldmVudHMuZXh0ZW5kKFsgeyBcImRhdGUuZGF5T2ZZZWFyKClcIiA6IG5ldyBhZmZpbml0eS5EYXlPZlllYXIoZGF0ZSkgfSBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICBleHRlbmRlZC5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IGRhdGUgOiBEYXRlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgbmFtZSA6IFN0cmluZyAgICAgICAgICAgIHwgZGF0ZS5kYXlPZlllYXIoKSA6IEludGVnZXIgICB8XG4gICAgICAgICAqICAgICAgLy8gKz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgIC8vIHwgRnJpIEZlYiAwNyAyMDE0IDAwOjAwOjAwIEdNVC0wNTAwIChFU1QpICAgfCBTb2NoaSAgICAgICAgICAgICAgICAgICAgfCAzNyAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBUaHUgSmFuIDAyIDIwMTQgMDA6MDA6MDAgR01ULTA1MDAgKEVTVCkgICB8IENob2NvbGF0ZSBydXNoICAgICAgICAgICB8IDEgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IFR1ZSBBcHIgMTUgMjAxNCAwMDowMDowMCBHTVQtMDQwMCAoRURUKSAgIHwgTWlsbGlvbnRoIGNvZmZlZSBkcmFuayAgIHwgMTA0ICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG5cbiAgICAgICAgICAgIHRoaXMudHlwZShUSW50ZWdlcik7XG5cbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdEYXlPZlllYXInO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgdmFyIGRhdGUgPSB2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMF0pO1xuXG4gICAgICAgICAgICB2YXIgYmVnaW4gPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksMCwxKTtcblxuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbCgoZGF0ZSAtIGJlZ2luKSAvIDg2NDAwMDAwKTtcblxuICAgICAgICB9XG5cbiAgICB9LHtcblxuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRkRheU9mWWVhcjsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uLmpzJyk7XG52YXIgVEludGVnZXIgPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL0ludGVnZXIuanMnKTtcbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy92YWx1ZScpO1xuXG52YXIgRkhvdXJzID0gRnVuY3Rpb24uZXh0ZW5kKFxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIEZ1bmN0aW9ucy5EYXRlLkhvdXJzXG4gICAgICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEZ1bmN0aW9uIHRoYXQgZXh0cmFjdHMgYSBkYXRlJ3MgaG91cnMgY29tcG9uZW50IGFzIGFuIGludGVnZXJcbiAgICAgICAgICpcbiAgICAgICAgICogTWlkbmlnaHQgaXMgMFxuICAgICAgICAgKlxuICAgICAgICAgKiBXaXRoIGV4dGVuZCBvcGVyYXRpb24gOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciB3b2tlVXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgKiAgICAgIHdva2VVcC5zZXRIb3Vycyg4KTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgYnJlYWtmYXN0ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICogICAgICBicmVha2Zhc3Quc2V0SG91cnMoOSlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZGlubmVyID0gbmV3IERhdGUoKTtcbiAgICAgICAgICogICAgICBkaW5uZXIuc2V0SG91cnMoMTgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBldmVudHMgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICB7dGltZSA6IHt0eXBlIDogYWZmaW5pdHkuRGF0ZX19LFxuICAgICAgICAgKiAgICAgICAgICB7bmFtZSA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgW3dva2VVcCwgJ1dva2UgVXAnXSxcbiAgICAgICAgICogICAgICAgICAgW2JyZWFrZmFzdCwgJ0JyZWFrZmFzdCddLFxuICAgICAgICAgKiAgICAgICAgICBbZGlubmVyLCAnRGlubmVyJ11cbiAgICAgICAgICogICAgICBdKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciB0aW1lID0gZXZlbnRzLmdldCgndGltZScpXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gZXZlbnRzLmV4dGVuZChbIHsgXCJ0aW1lLmhvdXJzKClcIiA6IHRpbWUuaG91cnMoKSB9IF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vIG9yIGVxdWl2YWxlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSBldmVudHMuZXh0ZW5kKFsgeyBcInRpbWUuaG91cnMoKVwiIDogbmV3IGFmZmluaXR5LkhvdXJzKHRpbWUpIH0gXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgZXh0ZW5kZWQucHJpbnQoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IHRpbWUgOiBEYXRlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgbmFtZSA6IFN0cmluZyAgIHwgdGltZS5ob3VycygpIDogSW50ZWdlciAgIHxcbiAgICAgICAgICogICAgICAvLyArPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgICAvLyB8IFN1biBKdW4gMjkgMjAxNCAwODo0MzozOSBHTVQtMDQwMCAoRURUKSAgIHwgV29rZSBVcCAgICAgICAgIHwgOCAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IFN1biBKdW4gMjkgMjAxNCAwOTo0MzozOSBHTVQtMDQwMCAoRURUKSAgIHwgQnJlYWtmYXN0ICAgICAgIHwgOSAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IFN1biBKdW4gMjkgMjAxNCAxODo0MzozOSBHTVQtMDQwMCAoRURUKSAgIHwgRGlubmVyICAgICAgICAgIHwgMTggICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuXG4gICAgICAgICAgICB0aGlzLnR5cGUoVEludGVnZXIpO1xuXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSAnSG91cnMnO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGZ1bmN0aW9uJ3MgcmV0dXJuIHZhbHVlXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUodGhpcy5wYXJhbWV0ZXJzWzBdKS5nZXRIb3VycygpO1xuXG4gICAgICAgIH1cblxuICAgIH0se1xuXG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBGSG91cnM7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIFRJbnRlZ2VyID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9JbnRlZ2VyLmpzJyk7XG52YXIgdmFsdWUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvdmFsdWUnKTtcblxudmFyIEZNaWxsaXNlY29uZHMgPSBGdW5jdGlvbi5leHRlbmQoXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLkRhdGUuTWlsbGlzZWNvbmRzXG4gICAgICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEZ1bmN0aW9uIHRoYXQgZXh0cmFjdHMgYSBkYXRlJ3MgbWlsbGlzZWNvbmRzIGNvbXBvbmVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBNaWRuaWdodCBpcyAwXG4gICAgICAgICAqXG4gICAgICAgICAqIFdpdGggZXh0ZW5kIG9wZXJhdGlvbiA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGRhdGUxID0gbmV3IERhdGUoKTtcbiAgICAgICAgICogICAgICBkYXRlMS5zZXRNaWxsaXNlY29uZHMoMTAwKTtcbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZGF0ZTIgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgKiAgICAgIGRhdGUyLnNldE1pbGxpc2Vjb25kcygyMDApO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBkYXRlMyA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAqICAgICAgZGF0ZTMuc2V0TWlsbGlzZW9jbmRzKDMwMCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV2ZW50cyA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgIHt0aW1lIDoge3R5cGUgOiBhZmZpbml0eS5EYXRlfX1cbiAgICAgICAgICogICAgICBdLFtcbiAgICAgICAgICogICAgICAgICBbZGF0ZTFdLCBbZGF0ZTJdLCBbZGF0ZTNdXG4gICAgICAgICAqICAgICAgXSlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgdGltZSA9IGV2ZW50cy5nZXQoJ3RpbWUnKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IGV2ZW50cy5leHRlbmQoWyB7IFwidGltZS5taWxsaXNlY29uZHMoKVwiIDogdGltZS5taWxsaXNlY29uZHMoKSB9IF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vIG9yIGVxdWl2YWxlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSBldmVudHMuZXh0ZW5kKFsgeyBcInRpbWUubWlsbGlzZWNvbmRzKClcIiA6IG5ldyBhZmZpbml0eS5NaWxsaXNlY29uZHModGltZSkgfSBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICBleHRlbmRlZC5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IHRpbWUgOiBEYXRlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdGltZS5taWxsaXNlY29uZHMoKSA6IEludGVnZXIgICB8XG4gICAgICAgICAqICAgICAgLy8gKz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgIC8vIHwgU3VuIEp1biAyOSAyMDE0IDA4OjQ0OjE3IEdNVC0wNDAwIChFRFQpICAgfCAxMDAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBTdW4gSnVuIDI5IDIwMTQgMDg6NDQ6MTcgR01ULTA0MDAgKEVEVCkgICB8IDIwMCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IFN1biBKdW4gMjkgMjAxNCAwODo0NDoxNyBHTVQtMDQwMCAoRURUKSAgIHwgNTU3ICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG5cbiAgICAgICAgICAgIHRoaXMudHlwZShUSW50ZWdlcik7XG5cbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdNaWxsaXNlY29uZHMnO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGZ1bmN0aW9uIHJldHVybiB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlKHRoaXMucGFyYW1ldGVyc1swXSkuZ2V0TWlsbGlzZWNvbmRzKCk7XG5cbiAgICAgICAgfVxuXG4gICAgfSx7XG5cblxuICAgIH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZNaWxsaXNlY29uZHM7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIFRJbnRlZ2VyID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9JbnRlZ2VyLmpzJyk7XG52YXIgdmFsdWUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvdmFsdWUnKTtcblxudmFyIEZNaW51dGVzID0gRnVuY3Rpb24uZXh0ZW5kKFxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIEZ1bmN0aW9ucy5EYXRlLk1pbnV0ZXNcbiAgICAgICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogRnVuY3Rpb24gdGhhdCBleHRyYWN0cyBhIGRhdGUncyBtaW51dGVzIGNvbXBvbmVudCBhcyBhbiBpbnRlZ2VyXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqIFdpdGggZXh0ZW5kIG9wZXJhdGlvbiA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIHF1YXJ0ZXJUb0ZpdmUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgKiAgICAgIHF1YXJ0ZXJUb0ZpdmUuc2V0SG91cnMoNCk7XG4gICAgICAgICAqICAgICAgcXVhcnRlclRvRml2ZS5zZXRNaW51dGVzKDQ1KTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZml2ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAqICAgICAgZml2ZS5zZXRIb3Vycyg1KVxuICAgICAgICAgKiAgICAgIGZpdmUuc2V0TWludXRlcygwKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgc2l4VGhpcnR5ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICogICAgICBzaXhUaGlydHkuc2V0SG91cnMoNik7XG4gICAgICAgICAqICAgICAgc2l4VGhpcnR5LnNldE1pbnV0ZXMoMzApO1xuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBldmVudHMgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICB7dGltZSA6IHt0eXBlIDogYWZmaW5pdHkuRGF0ZX19LFxuICAgICAgICAgKiAgICAgICAgICB7bmFtZSA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgW3F1YXJ0ZXJUb0ZpdmUsICdRdWFydGVyIHRvIEZpdmUnXSxcbiAgICAgICAgICogICAgICAgICAgW2ZpdmUsICdGaXZlJ10sXG4gICAgICAgICAqICAgICAgICAgIFtzaXhUaGlydHksICdTaXggVGhpcnR5J11cbiAgICAgICAgICogICAgICBdKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciB0aW1lID0gZXZlbnRzLmdldCgndGltZScpXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gZXZlbnRzLmV4dGVuZChbIHsgXCJ0aW1lLm1pbnV0ZXMoKVwiIDogdGltZS5taW51dGVzKCkgfSBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBvciBlcXVpdmFsZW50XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gZXZlbnRzLmV4dGVuZChbIHsgXCJ0aW1lLm1pbnV0ZXMoKVwiIDogbmV3IGFmZmluaXR5Lk1pbnV0ZXModGltZSkgfSBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICBleHRlbmRlZC5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IHRpbWUgOiBEYXRlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgbmFtZSA6IFN0cmluZyAgICAgfCB0aW1lLm1pbnV0ZXMoKSA6IEludGVnZXIgICB8XG4gICAgICAgICAqICAgICAgLy8gKz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgIC8vIHwgU3VuIEp1biAyOSAyMDE0IDA0OjQ1OjQ5IEdNVC0wNDAwIChFRFQpICAgfCBRdWFydGVyIHRvIEZpdmUgICB8IDQ1ICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBTdW4gSnVuIDI5IDIwMTQgMDU6MDA6NDkgR01ULTA0MDAgKEVEVCkgICB8IEZpdmUgICAgICAgICAgICAgIHwgMCAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IFN1biBKdW4gMjkgMjAxNCAwNjozMDo0OSBHTVQtMDQwMCAoRURUKSAgIHwgU2l4IFRoaXJ0eSAgICAgICAgfCAzMCAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG5cbiAgICAgICAgICAgIHRoaXMudHlwZShUSW50ZWdlcik7XG5cbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdNaW51dGVzJztcblxuICAgICAgICB9LFxuXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMF0pLmdldE1pbnV0ZXMoKTtcblxuICAgICAgICB9XG5cbiAgICB9LHtcblxuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRk1pbnV0ZXM7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIFRJbnRlZ2VyID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9JbnRlZ2VyLmpzJyk7XG52YXIgdmFsdWUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvdmFsdWUnKTtcblxudmFyIEZNb250aCA9IEZ1bmN0aW9uLmV4dGVuZChcbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuRGF0ZS5Nb250aFxuICAgICAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBGdW5jdGlvbiB0aGF0IGV4dHJhY3RzIGEgZGF0ZSdzIG1vbnRoIG51bWJlclxuICAgICAgICAgKlxuICAgICAgICAgKiBKYW51YXJ5IGlzIDBcbiAgICAgICAgICpcbiAgICAgICAgICogV2l0aCBleHRlbmQgb3BlcmF0aW9uIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXZlbnRzID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAge2RhdGUgOiB7dHlwZSA6IGFmZmluaXR5LkRhdGV9fSxcbiAgICAgICAgICogICAgICAgICAge25hbWUgOiB7dHlwZSA6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgIFtuZXcgRGF0ZSgyMDE0LCAxLCAwNyksICdTb2NoaSddLFxuICAgICAgICAgKiAgICAgICAgICBbbmV3IERhdGUoMjAxNCwgMCwgMDIpLCAnQ2hvY29sYXRlIHJ1c2gnXSxcbiAgICAgICAgICogICAgICAgICAgW25ldyBEYXRlKDIwMTQsIDMsIDE1KSwgJ01pbGxpb250aCBjb2ZmZWUgZHJhbmsnXVxuICAgICAgICAgKiAgICAgIF0pXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGRhdGUgPSBldmVudHMuZ2V0KCdkYXRlJylcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSBldmVudHMuZXh0ZW5kKFsgeyBcImRhdGUubW9udGgoKVwiIDogZGF0ZS5tb250aCgpIH0gXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gb3IgZXF1aXZhbGVudFxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IGV2ZW50cy5leHRlbmQoWyB7IFwiZGF0ZS5tb250aCgpXCIgOiBuZXcgYWZmaW5pdHkuTW9udGgoZGF0ZSkgfSBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICBleHRlbmRlZC5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgZGF0ZSA6IERhdGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBuYW1lIDogU3RyaW5nICAgICAgICAgICAgfCBkYXRlLm1vbnRoKCkgOiBJbnRlZ2VyICAgfFxuICAgICAgICAgKiAgICAgIC8vICs9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgIC8vIHwgRnJpIEZlYiAwNyAyMDE0IDAwOjAwOjAwIEdNVC0wNTAwIChFU1QpICAgfCBTb2NoaSAgICAgICAgICAgICAgICAgICAgfCAxICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgVGh1IEphbiAwMiAyMDE0IDAwOjAwOjAwIEdNVC0wNTAwIChFU1QpICAgfCBDaG9jb2xhdGUgcnVzaCAgICAgICAgICAgfCAwICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgVHVlIEFwciAxNSAyMDE0IDAwOjAwOjAwIEdNVC0wNDAwIChFRFQpICAgfCBNaWxsaW9udGggY29mZmVlIGRyYW5rICAgfCAzICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcblxuICAgICAgICAgICAgdGhpcy50eXBlKFRJbnRlZ2VyKTtcblxuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ01vbnRoJztcblxuICAgICAgICB9LFxuXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMF0pLmdldE1vbnRoKCk7XG5cbiAgICAgICAgfVxuXG4gICAgfSx7XG5cblxuICAgIH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZNb250aDsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uLmpzJyk7XG52YXIgVEludGVnZXIgPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL0ludGVnZXIuanMnKTtcbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy92YWx1ZScpO1xuXG52YXIgU2Vjb25kcyA9IEZ1bmN0aW9uLmV4dGVuZChcbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuRGF0ZS5TZWNvbmRzXG4gICAgICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEZ1bmN0aW9uIHRoYXQgZXh0cmFjdHMgYSBkYXRlJ3Mgc2Vjb25kIG51bWJlclxuICAgICAgICAgKlxuICAgICAgICAgKiBXaXRoIGV4dGVuZCBvcGVyYXRpb24gOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBldmVudHMgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICB7ZGF0ZSA6IHt0eXBlIDogYWZmaW5pdHkuRGF0ZX19LFxuICAgICAgICAgKiAgICAgICAgICB7bmFtZSA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgW25ldyBEYXRlKCksICdOb3cnXSxcbiAgICAgICAgICogICAgICBdKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBkYXRlID0gZXZlbnRzLmdldCgnZGF0ZScpXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gZXZlbnRzLmV4dGVuZChbIHsgXCJkYXRlLnNlY29uZHMoKVwiIDogZGF0ZS5zZWNvbmRzKCkgfSBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBvciBlcXVpdmFsZW50XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gZXZlbnRzLmV4dGVuZChbIHsgXCJkYXRlLnNlY29uZHMoKVwiIDogbmV3IGFmZmluaXR5LlNlY29uZHMoZGF0ZSkgfSBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICBleHRlbmRlZC5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBkYXRlIDogRGF0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IG5hbWUgOiBTdHJpbmcgICB8IGRhdGUuc2Vjb25kcygpIDogSW50ZWdlciAgIHxcbiAgICAgICAgICogICAgICAvLyArPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgIC8vIHwgU3VuIEp1biAyOSAyMDE0IDA4OjUxOjA1IEdNVC0wNDAwIChFRFQpICAgfCBOb3cgICAgICAgICAgICAgfCA1ICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvL1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG5cbiAgICAgICAgICAgIHRoaXMudHlwZShUSW50ZWdlcik7XG5cbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdTZWNvbmRzJztcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBmdW5jdGlvbiByZXR1cm4gdmFsdWVcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMF0pLmdldFNlY29uZHMoKTtcblxuICAgICAgICB9XG5cbiAgICB9LHtcblxuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2Vjb25kczsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uLmpzJyk7XG52YXIgSW50ZWdlciA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvSW50ZWdlci5qcycpO1xudmFyIHZhbHVlID0gcmVxdWlyZSgnLi8uLi8uLi9oZWxwZXJzL3ZhbHVlJyk7XG5cbnZhciBUaW1lc3RhbXAgPSBGdW5jdGlvbi5leHRlbmQoXG5cbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuRGF0ZS5UaW1lc3RhbXBcbiAgICAgICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogRnVuY3Rpb24gdGhhdCBleHRyYWN0cyBhIGRhdGUncyB0aW1lc3RhbXBcbiAgICAgICAgICpcbiAgICAgICAgICogV2l0aCBleHRlbmQgb3BlcmF0aW9uIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXZlbnRzID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAge2RhdGUgOiB7dHlwZSA6IGFmZmluaXR5LkRhdGV9fSxcbiAgICAgICAgICogICAgICAgICAge25hbWUgOiB7dHlwZSA6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgIFtuZXcgRGF0ZSgpLCAnTm93J10sXG4gICAgICAgICAqICAgICAgXSlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZGF0ZSA9IGV2ZW50cy5nZXQoJ2RhdGUnKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IGV2ZW50cy5leHRlbmQoWyB7IFwiZGF0ZS50aW1lc3RhbXAoKVwiIDogZGF0ZS50cygpIH0gXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gb3IgZXF1aXZhbGVudFxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IGV2ZW50cy5leHRlbmQoWyB7IFwiZGF0ZS50aW1lc3RhbXAoKVwiIDogbmV3IGFmZmluaXR5LlRpbWVzdGFtcChkYXRlKSB9IF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgZGF0ZSA6IERhdGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBuYW1lIDogU3RyaW5nICAgfCBkYXRlLnRpbWVzdGFtcCgpIDogSW50ZWdlciAgIHxcbiAgICAgICAgICogICAgICAvLyArPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAgLy8gfCBTdW4gSnVuIDI5IDIwMTQgMTA6MDI6MzQgR01ULTA0MDAgKEVEVCkgICB8IE5vdyAgICAgICAgICAgICB8IDE0MDQwNTA1NTQ4MDUgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuXG4gICAgICAgICAgICB0aGlzLnR5cGUoSW50ZWdlcik7XG5cbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdUaW1lc3RhbXAnO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgdmFyIHBhcmFtID0gdmFsdWUodGhpcy5wYXJhbWV0ZXJzWzBdKTtcblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlKHRoaXMucGFyYW1ldGVyc1swXSkuZ2V0VGltZSgpO1xuXG4gICAgICAgIH1cblxuICAgIH0se1xuXG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lc3RhbXA7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIFRJbnRlZ2VyID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9JbnRlZ2VyLmpzJyk7XG52YXIgdmFsdWUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvdmFsdWUnKTtcblxudmFyIFdlZWtPZlllYXIgPSBGdW5jdGlvbi5leHRlbmQoXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLkRhdGUuV2Vla09mWWVhclxuICAgICAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBGdW5jdGlvbiB0aGF0IGV4dHJhY3RzIGEgZGF0ZSdzIHdlZWsgbnVtYmVyICgwLTUxKVxuICAgICAgICAgKlxuICAgICAgICAgKiBXaXRoIGV4dGVuZCBvcGVyYXRpb24gOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBldmVudHMgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICB7ZGF0ZSA6IHt0eXBlIDogYWZmaW5pdHkuRGF0ZX19LFxuICAgICAgICAgKiAgICAgICAgICB7bmFtZSA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgW25ldyBEYXRlKDIwMTQsIDAyLCAwNyksICdTb2NoaSddLFxuICAgICAgICAgKiAgICAgICAgICBbbmV3IERhdGUoMjAxNCwgMDEsIDAyKSwgJ0Nob2NvbGF0ZSBydXNoJ10sXG4gICAgICAgICAqICAgICAgICAgIFtuZXcgRGF0ZSgyMDE0LCAwNCwgMTUpLCAnTWlsbGlvbnRoIGNvZmZlZSBkcmFuayddXG4gICAgICAgICAqICAgICAgXSlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZGF0ZSA9IGV2ZW50cy5nZXQoJ2RhdGUnKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IGV2ZW50cy5leHRlbmQoWyB7IFwiZGF0ZS53ZWVrT2ZZZWFyKClcIiA6IGRhdGUud2Vla09mWWVhcigpIH0gXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gb3IgZXF1aXZhbGVudFxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IGV2ZW50cy5leHRlbmQoWyB7IFwiZGF0ZS53ZWVrT2ZZZWFyKClcIiA6IG5ldyBhZmZpbml0eS53ZWVrT2ZZZWFyKGRhdGUpIH0gXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgZXh0ZW5kZWQucHJpbnQoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgZGF0ZSA6IERhdGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBuYW1lIDogU3RyaW5nICAgICAgICAgICAgfCBkYXRlLndlZWtPZlllYXIoKSA6IEludGVnZXIgICB8XG4gICAgICAgICAqICAgICAgLy8gKz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgICAvLyB8IEZyaSBNYXIgMDcgMjAxNCAwMDowMDowMCBHTVQtMDUwMCAoRVNUKSAgIHwgU29jaGkgICAgICAgICAgICAgICAgICAgIHwgMTAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBTdW4gRmViIDAyIDIwMTQgMDA6MDA6MDAgR01ULTA1MDAgKEVTVCkgICB8IENob2NvbGF0ZSBydXNoICAgICAgICAgICB8IDUgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgVGh1IE1heSAxNSAyMDE0IDAwOjAwOjAwIEdNVC0wNDAwIChFRFQpICAgfCBNaWxsaW9udGggY29mZmVlIGRyYW5rICAgfCAyMCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvL1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG5cbiAgICAgICAgICAgIHRoaXMudHlwZShUSW50ZWdlcik7XG5cbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdXZWVrT2ZZZWFyJztcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBmdW5jdGlvbiByZXR1cm4gdmFsdWVcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHZhciBkID0gbmV3IERhdGUoK3ZhbHVlKHRoaXMucGFyYW1ldGVyc1swXSkpO1xuICAgICAgICAgICAgZC5zZXRIb3VycygwLDAsMCk7XG4gICAgICAgICAgICBkLnNldERhdGUoZC5nZXREYXRlKCkrNC0oZC5nZXREYXkoKXx8NykpO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbCgoKChkLW5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwwLDEpKS84LjY0ZTcpKzEpLzcpO1xuXG4gICAgICAgIH1cblxuICAgIH0se1xuXG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWVrT2ZZZWFyOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24uanMnKTtcbnZhciBUSW50ZWdlciA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvSW50ZWdlci5qcycpO1xudmFyIHZhbHVlID0gcmVxdWlyZSgnLi8uLi8uLi9oZWxwZXJzL3ZhbHVlJyk7XG5cbnZhciBZZWFyID0gRnVuY3Rpb24uZXh0ZW5kKFxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIEZ1bmN0aW9ucy5EYXRlLlllYXJcbiAgICAgICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogRnVuY3Rpb24gdGhhdCBleHRyYWN0cyBhIGRhdGUncyBmdWxsIHllYXIgbnVtYmVyXG4gICAgICAgICAqXG4gICAgICAgICAqIFdpdGggZXh0ZW5kIG9wZXJhdGlvbiA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV2ZW50cyA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgIHtkYXRlIDoge3R5cGUgOiBhZmZpbml0eS5EYXRlfX0sXG4gICAgICAgICAqICAgICAgICAgIHtuYW1lIDoge3R5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICBbbmV3IERhdGUoMjAxMywgMDEsIDAyKV0sXG4gICAgICAgICAqICAgICAgICAgIFtuZXcgRGF0ZSgyMDExLCAwNiwgMzApXSxcbiAgICAgICAgICogICAgICAgICAgW25ldyBEYXRlKDIwMTAsIDA0LCAxNSldXG4gICAgICAgICAqICAgICAgXSlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZGF0ZSA9IGV2ZW50cy5nZXQoJ2RhdGUnKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IGV2ZW50cy5leHRlbmQoWyB7IFwiZGF0ZS55ZWFyKClcIiA6IGRhdGUueWVhcigpIH0gXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gb3IgZXF1aXZhbGVudFxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IGV2ZW50cy5leHRlbmQoWyB7IFwiZGF0ZS55ZWFyKClcIiA6IG5ldyBhZmZpbml0eS5ZZWFyKGRhdGUpIH0gXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgZXh0ZW5kZWQucHJpbnQoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgZGF0ZSA6IERhdGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBuYW1lIDogU3RyaW5nICAgICAgICAgICAgfCBkYXRlLnllYXIoKSA6IEludGVnZXIgICB8XG4gICAgICAgICAqICAgICAgLy8gKz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgICAvLyB8IEZyaSBNYXIgMDcgMjAxNCAwMDowMDowMCBHTVQtMDUwMCAoRVNUKSAgIHwgU29jaGkgICAgICAgICAgICAgICAgICAgIHwgMjAxNCAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBTdW4gRmViIDAyIDIwMTQgMDA6MDA6MDAgR01ULTA1MDAgKEVTVCkgICB8IENob2NvbGF0ZSBydXNoICAgICAgICAgICB8IDIwMTQgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgVGh1IE1heSAxNSAyMDE0IDAwOjAwOjAwIEdNVC0wNDAwIChFRFQpICAgfCBNaWxsaW9udGggY29mZmVlIGRyYW5rICAgfCAyMDE0ICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuXG4gICAgICAgICAgICB0aGlzLnR5cGUoVEludGVnZXIpO1xuXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSAnWWVhcic7XG5cbiAgICAgICAgfSxcblxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUodGhpcy5wYXJhbWV0ZXJzWzBdKS5nZXRGdWxsWWVhcigpO1xuXG4gICAgICAgIH1cblxuICAgIH0se1xuXG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBZZWFyOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24uanMnKTtcbnZhciBUTnVtZXJpYyA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvTnVtZXJpYy5qcycpO1xudmFyIHZhbHVlID0gcmVxdWlyZSgnLi8uLi8uLi9oZWxwZXJzL3ZhbHVlJyk7XG5cbnZhciBBYnNvbHV0ZSA9IEZ1bmN0aW9uLmV4dGVuZChcbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuTnVtZXJpYy5BYnNvbHV0ZVxuICAgICAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBGdW5jdGlvbiB0aGF0IGV4dHJhY3RzIHRoZSBBYnNvbHV0ZSB2YWx1ZSBvZiBhIE51bWJlclxuICAgICAgICAgKlxuICAgICAgICAgKiBFeGFtcGxlIHdpdGggRXh0ZW5kIG9wZXJhdG9yIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgcmVsYXRpb24gPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICB7IEEgOiAge3R5cGUgOiBhZmZpbml0eS5JbnRlZ2VyfSB9LFxuICAgICAgICAgKiAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICBbLTEwXSwgWy01XSwgWzBdLCBbNV0sIFsxMF1dXG4gICAgICAgICAqICAgICAgXSlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgQSA9IHJlbGF0aW9uLmdldCgnQScpO1xuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbeyBcIkEuYWJzKClcIiA6IEEuYWJzKCkgfV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vIG9yXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKFt7IFwiQS5hYnMoKVwiIDogbmV3IGFmZmluaXR5LkFic29sdXRlKEEpIH1dKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICBleHRlbmRlZC5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy98IEEgOiBJbnRlZ2VyICAgfCBBLmFicygpIDogSW50ZWdlciAgIHxcbiAgICAgICAgICogICAgICAvLys9PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgIC8vfCAtMTAgICAgICAgICAgIHwgMTAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvL3wgLTUgICAgICAgICAgICB8IDUgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy98IDAgICAgICAgICAgICAgfCAwICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vfCA1ICAgICAgICAgICAgIHwgNSAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvL3wgMTAgICAgICAgICAgICB8IDEwICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcnxGdW5jdGlvbnxBdHRyaWJ1dGV9IHBhcmFtIFRoZSBudW1iZXIgdG8gYWJzb2x1Y2l6ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgQWJzb2x1dGUgZnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAocGFyYW0pIHtcblxuICAgICAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG5cbiAgICAgICAgICAgIHRoaXMudHlwZShUTnVtZXJpYyk7XG5cbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdBYnNvbHV0ZSc7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge051bWJlcn0gVGhlIHJlc3VsdFxuICAgICAgICAgKlxuICAgICAgICAgKiBHZXRzIHRoZSBmdW5jdGlvbiByZXN1bHRcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMF0pKTtcblxuICAgICAgICB9XG5cbiAgICB9KTtcblxuQWJzb2x1dGUubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvbnVtZXJpYycpKTtcbkFic29sdXRlLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL2NvbXBhcmFibGUnKSk7XG5BYnNvbHV0ZS5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9zaXplLWNvbXBhcmFibGUnKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQWJzb2x1dGU7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIFROdW1lcmljID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9OdW1lcmljLmpzJyk7XG52YXIgdmFsdWUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvdmFsdWUnKTtcblxudmFyIEZDZWlsID0gRnVuY3Rpb24uZXh0ZW5kKFxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIEZ1bmN0aW9ucy5OdW1lcmljLkNlaWxcbiAgICAgICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogRnVuY3Rpb24gdGhhdCByb3VuZHMgYSBudW1iZXIgdXB3YXJkc1xuICAgICAgICAgKlxuICAgICAgICAgKiBFeGFtcGxlIHdpdGggRXh0ZW5kIG9wZXJhdG9yIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgcmVsYXRpb24gPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICB7IEEgOiAge3R5cGUgOiBhZmZpbml0eS5JbnRlZ2VyfSB9LFxuICAgICAgICAgKiAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICBbMS4wMV0sIFstMi44NV0sIFszXSwgWzMuMTJdLCBbMTAuMl1dXG4gICAgICAgICAqICAgICAgXSlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgQSA9IHJlbGF0aW9uLmdldCgnQScpO1xuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbeyBcIkEuY2VpbCgpXCIgOiBBLmNlaWwoKSB9XSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gb3JcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSByZWxhdGlvbi5leHRlbmQoW3sgXCJBLmNlaWwoKVwiIDogbmV3IGFmZmluaXR5LkNlaWwoQSkgfV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy98IEEgOiBJbnRlZ2VyICAgfCBBLmNlaWwoKSA6IEludGVnZXIgICB8XG4gICAgICAgICAqICAgICAgLy8rPT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAgLy98IDEuMDEgICAgICAgICAgfCAyICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy98IC0yLjg1ICAgICAgICAgfCAtMiAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy98IDMgICAgICAgICAgICAgfCAzICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy98IDMuMTIgICAgICAgICAgfCA0ICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy98IDEwLjIgICAgICAgICAgfCAxMSAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcblxuICAgICAgICAgICAgdGhpcy50eXBlKFROdW1lcmljKTtcblxuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ0NlaWwnO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGZ1bmN0aW9uIHJldHVybiB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbCh2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMF0pKTtcblxuICAgICAgICB9XG5cbiAgICB9KTtcblxuRkNlaWwubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvbnVtZXJpYycpKTtcbkZDZWlsLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL2NvbXBhcmFibGUnKSk7XG5GQ2VpbC5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9zaXplLWNvbXBhcmFibGUnKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRkNlaWw7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIE51bWVyaWMgPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL051bWVyaWMuanMnKTtcbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy92YWx1ZScpO1xuXG52YXIgQ29zaW5lID0gRnVuY3Rpb24uZXh0ZW5kKFxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIEZ1bmN0aW9ucy5OdW1lcmljLkNvc2luZVxuICAgICAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNvc2luZSBvZiBhIG51bWJlclxuICAgICAgICAgKlxuICAgICAgICAgKiBFeGFtcGxlIHdpdGggRXh0ZW5kIG9wZXJhdG9yIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgcmVsYXRpb24gPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICB7IEEgOiAge3R5cGUgOiBhZmZpbml0eS5JbnRlZ2VyfSB9LFxuICAgICAgICAgKiAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICBbMF0sIFtNYXRoLlBJLzJdLCBbTWF0aC5QSV0sIFszKk1hdGguUEkvMl0sIFsyKk1hdGguUEldXG4gICAgICAgICAqICAgICAgXSlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgQSA9IHJlbGF0aW9uLmdldCgnQScpO1xuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbeyBcImNvcyhBKVwiIDogQS5jb3MoKSB9XSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gb3JcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSByZWxhdGlvbi5leHRlbmQoW3sgXCJjb3MoQSlcIiA6IG5ldyBhZmZpbml0eS5Db3NpbmUoQSkgfV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gVGhlIGZvbGxvd2luZyByZXN1bHQgc2hvd3MgYSBidWcsIGJ1dCBpdCdzIG5vdCBhZmZpbml0eSdzIGZhdWx0LlxuICAgICAgICAgKiAgICAgIC8vIER1ZSB0byBhIGJ1ZyBpbiBWOFxuICAgICAgICAgKiAgICAgIC8vIChzZWUgdGhpcyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI0NDU1Nzc1L3doeS1kb2VzLW5vZGUtbm90LWV2YWx1YXRlLW1hdGgtdGFubWF0aC1waS0yLXRvLWluZmluaXR5LWJ1dC1jaHJvbWUtdjgtZG9lcylcbiAgICAgICAgICogICAgICAvLyBNYXRoLnRhbihNYXRoLlBJLzIpIHdvbid0IGV2YWx1YXRlIHRvIEluZmluaXR5LlxuICAgICAgICAgKiAgICAgIC8vIE1hdGgudGFuKE1hdGguUEkpIHdvbid0IGV2YWx1YXRlIHRvIDAuXG4gICAgICAgICAqICAgICAgLy8gQW5kIHNvIG9uLiBUaGlzIGlzIGR1ZSB0byBNYXRoLmNvcyhNYXRoLlBJLzIpIG5vdCBldmFsdWF0aW5nIHRvIDAuXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gVGhpcyB3aWxsIGJlIGZpeGVkIGluIG5vZGUgdjAuMTEuIGFzIEkgdGVzdGVkIHRoZSB2MC4xMS4xNC1wcmUgdmVyc2lvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy98IEEgOiBJbnRlZ2VyICAgfCBjb3MoQSkgOiBOdW1lcmljICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vKz09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgICAvL3wgMCAgICAgICAgICAgICB8IDEgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vfCBQSS8yICAgICAgICAgIHwgNi4xMjMwMzE3NjkxMTE4ODZlLTE3ICAgIHxcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy98IM+AICAgICAgICAgICAgIHwgLTEgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy98IDPPgC8yICAgICAgICAgIHwgLTEuODM2OTA5NTMwNzMzNTY2ZS0xNiAgIHxcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy98IDLPgCAgICAgICAgICAgIHwgMSAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcblxuICAgICAgICAgICAgdGhpcy50eXBlKE51bWVyaWMpO1xuXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSAnQ29zJztcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBmdW5jdGlvbiByZXN1bHRcbiAgICAgICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNvcyh2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMF0pKTtcblxuICAgICAgICB9XG5cbiAgICB9KTtcblxuQ29zaW5lLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL251bWVyaWMnKSk7XG5Db3NpbmUubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvY29tcGFyYWJsZScpKTtcbkNvc2luZS5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9zaXplLWNvbXBhcmFibGUnKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29zaW5lOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24uanMnKTtcbnZhciBUTnVtZXJpYyA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvTnVtZXJpYy5qcycpO1xudmFyIHZhbHVlID0gcmVxdWlyZSgnLi8uLi8uLi9oZWxwZXJzL3ZhbHVlJyk7XG5cbnZhciBGRGl2aXNpb24gPSBGdW5jdGlvbi5leHRlbmQoXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLk51bWVyaWMuRGl2aXNpb25cbiAgICAgICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogRnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSByZXN1bHQgb2YgYSBkaXZpc2lvbiBiZXR3ZWVuIHR3byBudW1iZXJzXG4gICAgICAgICAqXG4gICAgICAgICAqIEV4YW1wbGUgd2l0aCBFeHRlbmQgb3BlcmF0b3IgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgIHsgQSA6ICB7dHlwZSA6IGFmZmluaXR5LkludGVnZXJ9IH0sXG4gICAgICAgICAqICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgIFstMl0sIFstMV0sIFswXSwgWzFdLCBbMl1dXG4gICAgICAgICAqICAgICAgXSlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgcmVsYXRpb24yID0gcmVsYXRpb24uZXh0ZW5kKFt7QiA6IHJlbGF0aW9uLmdldCgnQScpfV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBwcm9kdWN0ID0gcmVsYXRpb24yLnByb2plY3QoWydBJ10pLnByb2R1Y3QocmVsYXRpb24yLmdldCgnQicpKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgQSA9IHByb2R1Y3QuZ2V0KCdBJyk7XG4gICAgICAgICAqICAgICAgdmFyIEIgPSBwcm9kdWN0LmdldCgnQicpO1xuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IHByb2R1Y3QuZXh0ZW5kKFt7XCJBIC8gQlwiIDogQS5kaXYoQil9XSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gb3IgZXF1aXZhbGVudFxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIG5ldyBhZmZpbml0eS5FeHRlbmQocHJvZHVjdCwgW3sgXCJBIC8gQlwiIDogbmV3IGFmZmluaXR5LkRpdmlzaW9uKEEsIEIpIH1dKVxuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gKFN0YW5kYXJkIGJlaGF2aW91ciBvZiBKYXZhU2NyaXB0KVxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgQSA6IEludGVnZXIgICB8IEIgOiBJbnRlZ2VyICAgfCBBIC8gQiA6IE51bWVyaWMgfFxuICAgICAgICAgKiAgICAgIC8vICs9PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgIC8vIHwgLTIgICAgICAgICAgICB8IC0yICAgICAgICAgICAgfCAxICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgLTIgICAgICAgICAgICB8IC0xICAgICAgICAgICAgfCAyICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgLTIgICAgICAgICAgICB8IDAgICAgICAgICAgICAgfCAtSW5maW5pdHkgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgLTIgICAgICAgICAgICB8IDEgICAgICAgICAgICAgfCAtMiAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgLTIgICAgICAgICAgICB8IDIgICAgICAgICAgICAgfCAtMSAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgLTEgICAgICAgICAgICB8IC0yICAgICAgICAgICAgfCAwLjUgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgLTEgICAgICAgICAgICB8IC0xICAgICAgICAgICAgfCAxICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgLTEgICAgICAgICAgICB8IDAgICAgICAgICAgICAgfCAtSW5maW5pdHkgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgLTEgICAgICAgICAgICB8IDEgICAgICAgICAgICAgfCAtMSAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgLTEgICAgICAgICAgICB8IDIgICAgICAgICAgICAgfCAtMC41ICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgMCAgICAgICAgICAgICB8IC0yICAgICAgICAgICAgfCAwICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgMCAgICAgICAgICAgICB8IC0xICAgICAgICAgICAgfCAwICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgMCAgICAgICAgICAgICB8IDAgICAgICAgICAgICAgfCBOYU4gICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgMCAgICAgICAgICAgICB8IDEgICAgICAgICAgICAgfCAwICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgMCAgICAgICAgICAgICB8IDIgICAgICAgICAgICAgfCAwICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgMSAgICAgICAgICAgICB8IC0yICAgICAgICAgICAgfCAtMC41ICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgMSAgICAgICAgICAgICB8IC0xICAgICAgICAgICAgfCAtMSAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgMSAgICAgICAgICAgICB8IDAgICAgICAgICAgICAgfCBJbmZpbml0eSAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgMSAgICAgICAgICAgICB8IDEgICAgICAgICAgICAgfCAxICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgMSAgICAgICAgICAgICB8IDIgICAgICAgICAgICAgfCAwLjUgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgMiAgICAgICAgICAgICB8IC0yICAgICAgICAgICAgfCAtMSAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgMiAgICAgICAgICAgICB8IC0xICAgICAgICAgICAgfCAtMiAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgMiAgICAgICAgICAgICB8IDAgICAgICAgICAgICAgfCBJbmZpbml0eSAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgMiAgICAgICAgICAgICB8IDEgICAgICAgICAgICAgfCAyICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgMiAgICAgICAgICAgICB8IDIgICAgICAgICAgICAgfCAxICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG5cbiAgICAgICAgICAgIHRoaXMudHlwZShUTnVtZXJpYyk7XG5cbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdEaXZpc2lvbic7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZnVuY3Rpb24gcmVzdWx0XG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUodGhpcy5wYXJhbWV0ZXJzWzBdKS92YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMV0pO1xuXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG5GRGl2aXNpb24ubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvbnVtZXJpYycpKTtcbkZEaXZpc2lvbi5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9jb21wYXJhYmxlJykpO1xuRkRpdmlzaW9uLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL3NpemUtY29tcGFyYWJsZScpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGRGl2aXNpb247IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIFROdW1lcmljID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9OdW1lcmljLmpzJyk7XG52YXIgdmFsdWUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvdmFsdWUnKTtcblxudmFyIEZFeHAgPSBGdW5jdGlvbi5leHRlbmQoXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLk51bWVyaWMuRXhwb25lbnRpYWxcbiAgICAgICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogUmV0dXJucyB0aGUgZXhwb25lbnRpYWwgb2YgYSBudW1iZXIgKGVeeClcbiAgICAgICAgICpcbiAgICAgICAgICogRXhhbXBsZSA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb24gPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW3sgQSA6IHt0eXBlIDogYWZmaW5pdHkuSW50ZWdlcn0gfV0sW1stMl0sIFstMV0sWzBdLFsxXSxbMl1dKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbeyBcIkEuZXhwKClcIiA6IHJlbGF0aW9uLmdldCgnQScpLmV4cCgpfV0pXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBvciBlcXVpdmFsZW50XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgZXh0ZW5kZWQgPSByZWxhdGlvbi5leHRlbmQoW3sgXCJBLmV4cCgpXCIgOiBuZXcgYWZmaW5pdHkuRXhwKEEpfV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgZXh0ZW5kZWQucHJpbnQoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IEEgOiBJbnRlZ2VyICAgfCBBLmV4cCgpIDogTnVtZXJpYyAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKz09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgIC8vIHwgLTIgICAgICAgICAgICB8IDAuMTM1MzM1MjgzMjM2NjEyNyAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAtMSAgICAgICAgICAgIHwgMC4zNjc4Nzk0NDExNzE0NDIzMyAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDAgICAgICAgICAgICAgfCAxICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMSAgICAgICAgICAgICB8IDIuNzE4MjgxODI4NDU5MDQ1ICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAyICAgICAgICAgICAgIHwgNy4zODkwNTYwOTg5MzA2NSAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcblxuICAgICAgICAgICAgdGhpcy50eXBlKFROdW1lcmljKTtcblxuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ0V4cG9uZW50JztcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBmdW5jdGlvbiByZXN1bHRcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBNYXRoLmV4cCh2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMF0pKTtcblxuICAgICAgICB9XG5cbiAgICB9KTtcblxuRkV4cC5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9udW1lcmljJykpO1xuRkV4cC5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9jb21wYXJhYmxlJykpO1xuRkV4cC5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9zaXplLWNvbXBhcmFibGUnKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRkV4cDsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uLmpzJyk7XG52YXIgVE51bWVyaWMgPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL051bWVyaWMuanMnKTtcbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy92YWx1ZScpO1xuXG52YXIgRmxvb3IgPSBGdW5jdGlvbi5leHRlbmQoXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLk51bWVyaWMuRmxvb3JcbiAgICAgICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogRnVuY3Rpb24gdGhhdCByb3VuZHMgYSBudW1iZXIgZG93bndhcmRzXG4gICAgICAgICAqXG4gICAgICAgICAqIEV4YW1wbGUgd2l0aCBFeHRlbmQgb3BlcmF0b3IgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgIHsgQSA6ICB7dHlwZSA6IGFmZmluaXR5LkludGVnZXJ9IH0sXG4gICAgICAgICAqICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgIFsxLjAxXSwgWy0yLjg1XSwgWzNdLCBbMy4xMl0sIFsxMC4yXV1cbiAgICAgICAgICogICAgICBdKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBBID0gcmVsYXRpb24uZ2V0KCdBJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKFt7IFwiQS5mbG9vcigpXCIgOiBBLkZsb29yKCkgfV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vIG9yXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKFt7IFwiQS5mbG9vcigpXCIgOiBuZXcgYWZmaW5pdHkuZmxvb3IoQSkgfV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vfCBBIDogSW50ZWdlciAgIHwgQS5mbG9vcigpIDogSW50ZWdlciAgIHxcbiAgICAgICAgICogICAgICAvLys9PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAgLy98IDEuMDEgICAgICAgICAgfCAxICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvL3wgLTIuODUgICAgICAgICB8IC0zICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vfCAzICAgICAgICAgICAgIHwgMyAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy98IDMuMTIgICAgICAgICAgfCAzICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvL3wgMTAuMiAgICAgICAgICB8IDEwICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG5cbiAgICAgICAgICAgIHRoaXMudHlwZShUTnVtZXJpYyk7XG5cbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdGbG9vcic7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZnVuY3Rpb24gcmV0dXJuIHZhbHVlXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMF0pKTtcblxuICAgICAgICB9XG5cbiAgICB9KTtcblxuRmxvb3IubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvbnVtZXJpYycpKTtcbkZsb29yLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL2NvbXBhcmFibGUnKSk7XG5GbG9vci5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9zaXplLWNvbXBhcmFibGUnKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmxvb3I7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIFROdW1lcmljID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9OdW1lcmljLmpzJyk7XG52YXIgdmFsdWUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvdmFsdWUnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnLi8uLi8uLi9oZWxwZXJzL3R5cGUnKTtcblxudmFyIEZNaW51cyA9IEZ1bmN0aW9uLmV4dGVuZChcbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuTnVtZXJpYy5NaW51c1xuICAgICAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBTdWJ0cmFjdHMgdHdvIG51bWJlcnNcbiAgICAgICAgICpcbiAgICAgICAgICogRXhhbXBsZSA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb24gPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge0EgOiB7dHlwZSA6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtCIDoge3R5cGUgOiBhZmZpbml0eS5JbnRlZ2VyfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbMSwgMl0sXG4gICAgICAgICAqICAgICAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAqICAgICAgICAgICAgICBbMTAsIDFdXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIEEgPSByZWxhdGlvbi5nZXQoJ0EnKTtcbiAgICAgICAgICogICAgIHZhciBCID0gcmVsYXRpb24uZ2V0KCdCJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgZXh0ZW5kZWQgPSByZWxhdGlvbi5leHRlbmQoW3sgXCJBIC0gQlwiIDogQS5taW51cyhCKX1dKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gb3IgZXF1aXZhbGVudFxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKFt7XCJBIC0gQlwiIDogbmV3IGFmZmluaXR5Lk1pbnVzKEEsIEIpfV0pXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBleHRlbmRlZC5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgQSA6IEludGVnZXIgICB8IEIgOiBJbnRlZ2VyICAgfCBBIC0gQiA6IEludGVnZXIgICB8XG4gICAgICAgICAqICAgICAvLyArPT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgLy8gfCAxICAgICAgICAgICAgIHwgMiAgICAgICAgICAgICB8IC0xICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDAgICAgICAgICAgICAgfCAwICAgICAgICAgICAgIHwgMCAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMTAgICAgICAgICAgICB8IDEgICAgICAgICAgICAgfCA5ICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG5cbiAgICAgICAgICAgIHRoaXMudHlwZSh0eXBlKHRoaXMucGFyYW1ldGVyc1swXSkpO1xuXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSAnTWludXMnO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGZ1bmN0aW9uIHJldHVybiB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZSgpLmNvZXJjZSh2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMF0pLXZhbHVlKHRoaXMucGFyYW1ldGVyc1sxXSkpO1xuXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG5GTWludXMubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvbnVtZXJpYycpKTtcbkZNaW51cy5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9jb21wYXJhYmxlJykpO1xuRk1pbnVzLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL3NpemUtY29tcGFyYWJsZScpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGTWludXM7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIFROdW1lcmljID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9OdW1lcmljLmpzJyk7XG52YXIgdmFsdWUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvdmFsdWUnKTtcblxudmFyIEZNb2R1bG8gPSBGdW5jdGlvbi5leHRlbmQoXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLk51bWVyaWMuTW9kdWxvXG4gICAgICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEdldHMgdGhlIG1vZHVsbyBvZiB0d28gbnVtYmVyc1xuICAgICAgICAgKlxuICAgICAgICAgKiBFeGFtcGxlIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7QSA6IHt0eXBlIDogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICAgICAge0IgOiB7dHlwZSA6IGFmZmluaXR5LkludGVnZXJ9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsxLCAyXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsxMCwgMV0sXG4gICAgICAgICAqICAgICAgICAgICAgICBbMTAsIDJdXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIEEgPSByZWxhdGlvbi5nZXQoJ0EnKTtcbiAgICAgICAgICogICAgIHZhciBCID0gcmVsYXRpb24uZ2V0KCdCJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgZXh0ZW5kZWQgPSByZWxhdGlvbi5leHRlbmQoW3tcIkEgJSBCXCIgOiBBLm1vZChCKX1dKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG9yIGVxdWl2YWxlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbe1wiQSAlIEJcIiA6IG5ldyBhZmZpbml0eS5Nb2R1bG8oQSwgQil9XSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBleHRlbmRlZC5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IEEgOiBJbnRlZ2VyICAgfCBCIDogSW50ZWdlciAgIHwgQSAlIEIgOiBOdW1lcmljICAgIHxcbiAgICAgICAgICogICAgIC8vICs9PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgLy8gfCAxICAgICAgICAgICAgIHwgMiAgICAgICAgICAgICB8IDEgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMCAgICAgICAgICAgICB8IDAgICAgICAgICAgICAgfCBOYU4gICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDEwICAgICAgICAgICAgfCAxICAgICAgICAgICAgIHwgMCAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAxMCAgICAgICAgICAgIHwgMiAgICAgICAgICAgICB8IDAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuXG4gICAgICAgICAgICB0aGlzLnR5cGUoVE51bWVyaWMpO1xuXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSAnTW9kdWxvJztcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBmdW5jdGlvbiByZXR1cm4gdmFsdWVcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlIDogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUodGhpcy5wYXJhbWV0ZXJzWzBdKSV2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMV0pO1xuXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG5GTW9kdWxvLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL251bWVyaWMnKSk7XG5GTW9kdWxvLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL2NvbXBhcmFibGUnKSk7XG5GTW9kdWxvLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL3NpemUtY29tcGFyYWJsZScpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGTW9kdWxvOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24uanMnKTtcbnZhciBUTnVtZXJpYyA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvTnVtZXJpYy5qcycpO1xudmFyIHZhbHVlID0gcmVxdWlyZSgnLi8uLi8uLi9oZWxwZXJzL3ZhbHVlJyk7XG5cbnZhciBGTXVsdGlwbGljYXRpb24gPSBGdW5jdGlvbi5leHRlbmQoXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLk51bWVyaWMuTXVsdGlwbGljYXRpb25cbiAgICAgICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogTXVsdGlwbGllcyB0d28gbnVtYmVyc1xuICAgICAgICAgKlxuICAgICAgICAgKiBleGFtcGxlIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgIHsgQSA6IHsgdHlwZSA6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgICAgICAgeyBCIDogeyB0eXBlIDogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgIFsxLCAtMV0sXG4gICAgICAgICAqICAgICAgICAgIFstMSwgMV0sXG4gICAgICAgICAqICAgICAgICAgIFswLCAxMF0sXG4gICAgICAgICAqICAgICAgICAgIFsxLCAxMF0sXG4gICAgICAgICAqICAgICAgICAgIFsyLCAtMTBdLFxuICAgICAgICAgKiAgICAgXSlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBBID0gcmVsYXRpb24uZ2V0KCdBJylcbiAgICAgICAgICogICAgIHZhciBCID0gcmVsYXRpb24uZ2V0KCdCJylcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbeyBcIkEgeCBCXCIgOiBBLnRpbWVzKEIpfV0pXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBvclxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKFt7IFwiQSB4IEJcIiA6IG5ldyBhZmZpbml0eS5NdWx0aXBsaWNhdGlvbihBLCBCKX1dKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgZXh0ZW5kZWQucHJpbnQoKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IEEgOiBJbnRlZ2VyICAgfCBCIDogSW50ZWdlciAgIHwgQSB4IEIgOiBOdW1lcmljIHxcbiAgICAgICAgICogICAgIC8vICs9PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgLy8gfCAxICAgICAgICAgICAgIHwgLTEgICAgICAgICAgICB8IC0xICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgLTEgICAgICAgICAgICB8IDEgICAgICAgICAgICAgfCAtMSAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDAgICAgICAgICAgICAgfCAxMCAgICAgICAgICAgIHwgMCAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAxICAgICAgICAgICAgIHwgMTAgICAgICAgICAgICB8IDEwICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMiAgICAgICAgICAgICB8IC0xMCAgICAgICAgICAgfCAtMjAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcblxuICAgICAgICAgICAgdGhpcy50eXBlKFROdW1lcmljKTtcblxuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ011bHRpcGxpY2F0aW9uJztcblxuICAgICAgICB9LFxuXG4gICAgICAgIHZhbHVlIDogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUodGhpcy5wYXJhbWV0ZXJzWzBdKSp2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMV0pO1xuXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG5GTXVsdGlwbGljYXRpb24ubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvbnVtZXJpYycpKTtcbkZNdWx0aXBsaWNhdGlvbi5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9jb21wYXJhYmxlJykpO1xuRk11bHRpcGxpY2F0aW9uLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL3NpemUtY29tcGFyYWJsZScpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGTXVsdGlwbGljYXRpb247IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIFROdW1lcmljID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9OdW1lcmljLmpzJyk7XG52YXIgdmFsdWUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvdmFsdWUnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnLi8uLi8uLi9oZWxwZXJzL3R5cGUnKTtcblxudmFyIFBsdXMgPSBGdW5jdGlvbi5leHRlbmQoXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLk51bWVyaWMuUGx1c1xuICAgICAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBBZGRzIHR3byBudW1iZXJzXG4gICAgICAgICAqXG4gICAgICAgICAqIGV4YW1wbGUgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgeyBBIDogeyB0eXBlIDogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICB7IEIgOiB7IHR5cGUgOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgWzEsIC0xXSxcbiAgICAgICAgICogICAgICAgICAgWy0xLCAxXSxcbiAgICAgICAgICogICAgICAgICAgWzAsIDEwXSxcbiAgICAgICAgICogICAgICAgICAgWzEsIDEwXSxcbiAgICAgICAgICogICAgICAgICAgWzIsIC0xMF0sXG4gICAgICAgICAqICAgICBdKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIEEgPSByZWxhdGlvbi5nZXQoJ0EnKVxuICAgICAgICAgKiAgICAgdmFyIEIgPSByZWxhdGlvbi5nZXQoJ0InKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKFt7IFwiQSArIEJcIiA6IEEucGx1cyhCKX1dKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gb3JcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbeyBcIkEgKyBCXCIgOiBuZXcgYWZmaW5pdHkuUGx1cyhBLCBCKX1dKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgZXh0ZW5kZWQucHJpbnQoKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IEEgOiBJbnRlZ2VyICAgfCBCIDogSW50ZWdlciAgIHwgQSArIEIgOiBOdW1lcmljIHxcbiAgICAgICAgICogICAgIC8vICs9PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgLy8gfCAxICAgICAgICAgICAgIHwgLTEgICAgICAgICAgICB8IDAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgLTEgICAgICAgICAgICB8IDEgICAgICAgICAgICAgfCAwICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDAgICAgICAgICAgICAgfCAxMCAgICAgICAgICAgIHwgMTAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAxICAgICAgICAgICAgIHwgMTAgICAgICAgICAgICB8IDExICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMiAgICAgICAgICAgICB8IC0xMCAgICAgICAgICAgfCAtMTggICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcblxuICAgICAgICAgICAgdGhpcy50eXBlKHRoaXMucGFyYW1ldGVyc1swXSk7XG5cbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdQbHVzJztcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBmdW5jdGlvbiByZXR1cm4gdmFsdWVcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUoKS5jb2VyY2UodmFsdWUodGhpcy5wYXJhbWV0ZXJzWzBdKSt2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMV0pKTtcblxuICAgICAgICB9XG5cbiAgICB9KTtcblxuUGx1cy5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9udW1lcmljJykpO1xuUGx1cy5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9jb21wYXJhYmxlJykpO1xuUGx1cy5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9zaXplLWNvbXBhcmFibGUnKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGx1czsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uLmpzJyk7XG52YXIgVE51bWVyaWMgPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL051bWVyaWMuanMnKTtcbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy92YWx1ZScpO1xuXG52YXIgRlBvdyA9IEZ1bmN0aW9uLmV4dGVuZChcbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuTnVtZXJpYy5Qb3dlclxuICAgICAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbnVtYmVyIHRvIHRoZSBwb3dlciBvZiBhbm90aGVyIG51bWJlclxuICAgICAgICAgKlxuICAgICAgICAgKiBleGFtcGxlIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgIHsgQSA6IHsgdHlwZSA6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgICAgICAgeyBCIDogeyB0eXBlIDogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgIFsxLCAtMV0sXG4gICAgICAgICAqICAgICAgICAgIFstMSwgMV0sXG4gICAgICAgICAqICAgICAgICAgIFswLCAxMF0sXG4gICAgICAgICAqICAgICAgICAgIFsxLCAxMF0sXG4gICAgICAgICAqICAgICAgICAgIFsyLCAtMTBdLFxuICAgICAgICAgKiAgICAgXSlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBBID0gcmVsYXRpb24uZ2V0KCdBJylcbiAgICAgICAgICogICAgIHZhciBCID0gcmVsYXRpb24uZ2V0KCdCJylcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbeyBcIkEgXiBCXCIgOiBBLnBvdyhCKX1dKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gb3JcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbeyBcIkEgXiBCXCIgOiBuZXcgYWZmaW5pdHkuUG93KEEsIEIpfV0pXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBleHRlbmRlZC5wcmludCgpXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgQSA6IEludGVnZXIgICB8IEIgOiBJbnRlZ2VyICAgfCBBIF4gQiA6IE51bWVyaWMgfFxuICAgICAgICAgKiAgICAgLy8gKz09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAvLyB8IDEgICAgICAgICAgICAgfCAtMSAgICAgICAgICAgIHwgMSAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAtMSAgICAgICAgICAgIHwgMSAgICAgICAgICAgICB8IC0xICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMCAgICAgICAgICAgICB8IDEwICAgICAgICAgICAgfCAwICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDEgICAgICAgICAgICAgfCAxMCAgICAgICAgICAgIHwgMSAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAyICAgICAgICAgICAgIHwgLTEwICAgICAgICAgICB8IDAuMDAwOTc2NTYyNSAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuXG4gICAgICAgICAgICB0aGlzLnR5cGUoVE51bWVyaWMpO1xuXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSAnUG93ZXInO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGZ1bmN0aW9uJ3MgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KHZhbHVlKHRoaXMucGFyYW1ldGVyc1swXSksdmFsdWUodGhpcy5wYXJhbWV0ZXJzWzFdKSk7XG5cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbkZQb3cubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvbnVtZXJpYycpKTtcbkZQb3cubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvY29tcGFyYWJsZScpKTtcbkZQb3cubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvc2l6ZS1jb21wYXJhYmxlJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZQb3c7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIFROdW1lcmljID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9OdW1lcmljLmpzJyk7XG52YXIgdmFsdWUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvdmFsdWUnKTtcblxudmFyIFJvdW5kID0gRnVuY3Rpb24uZXh0ZW5kKFxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIEZ1bmN0aW9ucy5OdW1lcmljLlJvdW5kXG4gICAgICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIFJvdW5kcyBhIG51bWJlciB0byBpdHMgY2xvc2VzdCB3aG9sZSBudW1iZXJcbiAgICAgICAgICpcbiAgICAgICAgICogZXhhbXBsZSA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb24gPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICB7IEEgOiB7IHR5cGUgOiBhZmZpbml0eS5JbnRlZ2VyfX1cbiAgICAgICAgICogICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICBbLTEwXSxbLTVdLFstMl0sWy0xXSxbMF0sWzFdLFsyXSxbNV0sWzEwXVxuICAgICAgICAgKiAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgQSA9IHJlbGF0aW9uLmdldCgnQScpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKFt7XCJBLnNxcnQoKVwiIDogQS5zcXJ0KCl9LCB7XCJBLnNxcnQoKS5yb3VuZCgpXCIgOiBBLnNxcnQoKS5yb3VuZCgpfV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gb3JcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbXG4gICAgICAgICAqICAgICAgICAge1wiQS5zcXJ0KClcIiAgICAgICAgIDogbmV3IGFmZmluaXR5LlNxdWFyZVJvb3QoQSl9LFxuICAgICAgICAgKiAgICAgICAgIHtcIkEuc3FydCgpLnJvdW5kKClcIiA6IG5ldyBhZmZpbml0eS5Sb3VuZChuZXcgYWZmaW5pdHkuU3F1YXJlUm9vdChBKSl9XG4gICAgICAgICAqICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBBIDogSW50ZWdlciAgIHwgQS5zcXJ0KCkgOiBOdW1lcmljICAgfCBBLnNxcnQoKS5yb3VuZCgpIDogTnVtZXJpYyAgIHxcbiAgICAgICAgICogICAgIC8vICs9PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAvLyB8IC0xMCAgICAgICAgICAgfCBOYU4gICAgICAgICAgICAgICAgICB8IE5hTiAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgLTUgICAgICAgICAgICB8IE5hTiAgICAgICAgICAgICAgICAgIHwgTmFOICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAtMiAgICAgICAgICAgIHwgTmFOICAgICAgICAgICAgICAgICAgfCBOYU4gICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IC0xICAgICAgICAgICAgfCBOYU4gICAgICAgICAgICAgICAgICB8IE5hTiAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMCAgICAgICAgICAgICB8IDAgICAgICAgICAgICAgICAgICAgIHwgMCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAxICAgICAgICAgICAgIHwgMSAgICAgICAgICAgICAgICAgICAgfCAxICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDIgICAgICAgICAgICAgfCAxLjQxNDIxMzU2MjM3MzA5NTEgICB8IDEgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgNSAgICAgICAgICAgICB8IDIuMjM2MDY3OTc3NDk5NzkgICAgIHwgMiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG5cbiAgICAgICAgICAgIHRoaXMudHlwZShUTnVtZXJpYyk7XG5cbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdSb3VuZCc7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZnVuY3Rpb24ncyByZXR1cm4gdmFsdWVcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlKHRoaXMucGFyYW1ldGVyc1swXSkpO1xuXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG5Sb3VuZC5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9udW1lcmljJykpO1xuUm91bmQubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvY29tcGFyYWJsZScpKTtcblJvdW5kLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL3NpemUtY29tcGFyYWJsZScpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3VuZDsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uLmpzJyk7XG52YXIgVE51bWVyaWMgPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL051bWVyaWMuanMnKTtcbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy92YWx1ZScpO1xuXG52YXIgU2luZSA9IEZ1bmN0aW9uLmV4dGVuZChcbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuTnVtZXJpYy5TaW5lXG4gICAgICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgc2luZSBvZiBhIG51bWJlclxuICAgICAgICAgKlxuICAgICAgICAgKiBFeGFtcGxlIHdpdGggRXh0ZW5kIG9wZXJhdG9yIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgcmVsYXRpb24gPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICB7IEEgOiAge3R5cGUgOiBhZmZpbml0eS5JbnRlZ2VyfSB9LFxuICAgICAgICAgKiAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICBbMF0sIFtNYXRoLlBJLzJdLCBbTWF0aC5QSV0sIFszKk1hdGguUEkvMl0sIFsyKk1hdGguUEldXG4gICAgICAgICAqICAgICAgXSlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgQSA9IHJlbGF0aW9uLmdldCgnQScpO1xuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbeyBcInNpbihBKVwiIDogQS5zaW4oKSB9XSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gb3JcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSByZWxhdGlvbi5leHRlbmQoW3sgXCJzaW4oQSlcIiA6IG5ldyBhZmZpbml0eS5TaW5lKEEpIH1dKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICBleHRlbmRlZC5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy98IEEgOiBJbnRlZ2VyICAgfCBzaW4oQSkgOiBOdW1lcmljIHxcbiAgICAgICAgICogICAgICAvLys9PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgIC8vfCAwICAgICAgICAgICAgIHwgMCAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvL3wgUEkvMiAgICAgICAgICB8IDEgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy98IM+AICAgICAgICAgICAgIHwgMCAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvL3wgM8+ALzIgICAgICAgICAgfCAxICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vfCAyz4AgICAgICAgICAgICB8IDAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcblxuICAgICAgICAgICAgdGhpcy50eXBlKFROdW1lcmljKTtcblxuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ1NpbmUnO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGZ1bmN0aW9uIHJldHVybiB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIE1hdGguc2luKHZhbHVlKHRoaXMucGFyYW1ldGVyc1swXSkpO1xuXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG5TaW5lLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL251bWVyaWMnKSk7XG5TaW5lLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL2NvbXBhcmFibGUnKSk7XG5TaW5lLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL3NpemUtY29tcGFyYWJsZScpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaW5lOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24uanMnKTtcbnZhciBUTnVtZXJpYyA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvTnVtZXJpYy5qcycpO1xudmFyIHZhbHVlID0gcmVxdWlyZSgnLi8uLi8uLi9oZWxwZXJzL3ZhbHVlJyk7XG5cbnZhciBGU3F1YXJlUm9vdCA9IEZ1bmN0aW9uLmV4dGVuZChcbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuTnVtZXJpYy5TcXVhcmVSb290XG4gICAgICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHNxdWFyZSByb290IG9mIGEgbnVtYmVyXG4gICAgICAgICAqXG4gICAgICAgICAqIGV4YW1wbGUgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgeyBBIDogeyB0eXBlIDogYWZmaW5pdHkuSW50ZWdlcn19XG4gICAgICAgICAqICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgWy0xMF0sWy01XSxbLTJdLFstMV0sWzBdLFsxXSxbMl0sWzVdLFsxMF1cbiAgICAgICAgICogICAgIF0pXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgQSA9IHJlbGF0aW9uLmdldCgnQScpXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgZXh0ZW5kZWQgPSByZWxhdGlvbi5leHRlbmQoW3tcIkEuc3FydCgpXCIgOiBBLnNxcnQoKX1dKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG9yXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgZXh0ZW5kZWQgPSByZWxhdGlvbi5leHRlbmQoW3sgXCJBLnNxcnQoKVwiIDogbmV3IGFmZmluaXR5LlNxcnQoQSl9XSlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IEEgOiBJbnRlZ2VyICAgfCBBLnNxcnQoKSA6IE51bWVyaWMgICB8XG4gICAgICAgICAqICAgICAvLyArPT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAvLyB8IC0xMCAgICAgICAgICAgfCBOYU4gICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IC01ICAgICAgICAgICAgfCBOYU4gICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IC0yICAgICAgICAgICAgfCBOYU4gICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IC0xICAgICAgICAgICAgfCBOYU4gICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDAgICAgICAgICAgICAgfCAwICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDEgICAgICAgICAgICAgfCAxICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDIgICAgICAgICAgICAgfCAxLjQxNDIxMzU2MjM3MzA5NTEgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDUgICAgICAgICAgICAgfCAyLjIzNjA2Nzk3NzQ5OTc5ICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcblxuICAgICAgICAgICAgdGhpcy50eXBlKFROdW1lcmljKTtcblxuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ1NxdWFyZSBSb290JztcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBmdW5jdGlvbiByZXN1bHRcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQodmFsdWUodGhpcy5wYXJhbWV0ZXJzWzBdKSk7XG5cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbkZTcXVhcmVSb290Lm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL251bWVyaWMnKSk7XG5GU3F1YXJlUm9vdC5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9jb21wYXJhYmxlJykpO1xuRlNxdWFyZVJvb3QubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvc2l6ZS1jb21wYXJhYmxlJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZTcXVhcmVSb290OyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24uanMnKTtcbnZhciBUTnVtZXJpYyA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvTnVtZXJpYy5qcycpO1xudmFyIHZhbHVlID0gcmVxdWlyZSgnLi8uLi8uLi9oZWxwZXJzL3ZhbHVlJyk7XG5cbnZhciBUYW5nZW50ID0gRnVuY3Rpb24uZXh0ZW5kKFxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIEZ1bmN0aW9ucy5OdW1lcmljLlRhbmdlbnRcbiAgICAgICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogRnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBUYW5nZW50IG9mIGEgbnVtYmVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEV4YW1wbGUgd2l0aCBFeHRlbmQgb3BlcmF0b3IgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgIHsgQSA6ICB7dHlwZSA6IGFmZmluaXR5LkludGVnZXJ9IH0sXG4gICAgICAgICAqICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgIFswXSwgW01hdGguUEkvMl0sIFtNYXRoLlBJXSwgWzMqTWF0aC5QSS8yXSwgWzIqTWF0aC5QSV1cbiAgICAgICAgICogICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgQSA9IHJlbGF0aW9uLmdldCgnQScpO1xuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbeyBcInRhbihBKVwiIDogQS50YW4oKSB9XSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gb3JcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSByZWxhdGlvbi5leHRlbmQoW3sgXCJ0YW4oQSlcIiA6IG5ldyBhZmZpbml0eS5UYW5nZW50KEEpIH1dKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICBleHRlbmRlZC5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgcmVzdWx0IHNob3dzIGEgYnVnLCBidXQgaXQncyBub3QgYWZmaW5pdHkncyBmYXVsdC5cbiAgICAgICAgICogICAgICAvLyBEdWUgdG8gYSBidWcgaW4gVjhcbiAgICAgICAgICogICAgICAvLyAoc2VlIHRoaXMgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNDQ1NTc3NS93aHktZG9lcy1ub2RlLW5vdC1ldmFsdWF0ZS1tYXRoLXRhbm1hdGgtcGktMi10by1pbmZpbml0eS1idXQtY2hyb21lLXY4LWRvZXMpXG4gICAgICAgICAqICAgICAgLy8gTWF0aC50YW4oTWF0aC5QSS8yKSB3b24ndCBldmFsdWF0ZSB0byBJbmZpbml0eS5cbiAgICAgICAgICogICAgICAvLyBNYXRoLnRhbihNYXRoLlBJKSB3b24ndCBldmFsdWF0ZSB0byAwLlxuICAgICAgICAgKiAgICAgIC8vIEFuZCBzbyBvbi4gVGhpcyBpcyBkdWUgdG8gTWF0aC5jb3MoTWF0aC5QSS8yKSBub3QgZXZhbHVhdGluZyB0byAwLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vIFRoaXMgd2lsbCBiZSBmaXhlZCBpbiBub2RlIHYwLjExLiBhcyBJIHRlc3RlZCB0aGUgdjAuMTEuMTQtcHJlIHZlcnNpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvL3wgQSA6IEludGVnZXIgICB8IHRhbihBKSA6IE51bWVyaWMgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vKz09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAgLy98IDAgICAgICAgICAgICAgfCAwICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vfCBQSS8yICAgICAgICAgIHwgMTYzMzE3Nzg3MjgzODM4NDQgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvL3wgz4AgICAgICAgICAgICAgfCAtMS4yMjQ2MDYzNTM4MjIzNzczZS0xNiAgIHxcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vfCAzz4AvMiAgICAgICAgICB8IDU0NDM5MjYyNDI3OTQ2MTUgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy98IDLPgCAgICAgICAgICAgIHwgLTIuNDQ5MjEyNzA3NjQ0NzU0NWUtMTYgICB8XG4gICAgICAgICAqICAgICAgLy8rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuXG4gICAgICAgICAgICB0aGlzLnR5cGUoVE51bWVyaWMpO1xuXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSAnVGFuZ2VudCc7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZnVuY3Rpb24gcmV0dXJuIHZhbHVlXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gTWF0aC50YW4odmFsdWUodGhpcy5wYXJhbWV0ZXJzWzBdKSk7XG5cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cblRhbmdlbnQubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvbnVtZXJpYycpKTtcblRhbmdlbnQubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvY29tcGFyYWJsZScpKTtcblRhbmdlbnQubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvc2l6ZS1jb21wYXJhYmxlJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRhbmdlbnQ7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIFRJbnRlZ2VyID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9JbnRlZ2VyLmpzJyk7XG52YXIgdmFsdWUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvdmFsdWUnKTtcblxudmFyIExlbmd0aCA9IEZ1bmN0aW9uLmV4dGVuZCh7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLlN0cmluZy5MZW5ndGhcbiAgICAgKlxuICAgICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiBhIHN0cmluZ1xuICAgICAqXG4gICAgICogRXhhbXBsZSB3aXRoIEV4dGVuc2lvbiBvcGVyYXRvciA6XG4gICAgICpcbiAgICAgKiAgICAgdmFyIGFmZmluaXR5ID0gcmVxdWlyZSgnLi9pbmRleC5qcycpO1xuICAgICAqXG4gICAgICogICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICogICAgICAgICAgeyBuYW1lIDogeyB0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgKiAgICAgXSxbXG4gICAgICogICAgICAgICAgWydKb2huIERvZSddLCBbJ01hcmsgQ2xpbnRvbiddLCBbJ0JvIFZyaWwnXVxuICAgICAqICAgICBdKTtcbiAgICAgKlxuICAgICAqICAgICB2YXIgbmFtZSA9IHJlbGF0aW9uLmdldCgnbmFtZScpO1xuICAgICAqXG4gICAgICogICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbe1wibmFtZS5sZW5ndGgoKVwiIDogbmFtZS5sZW5ndGgoKX1dKTtcbiAgICAgKlxuICAgICAqICAgICAvLyBvclxuICAgICAqXG4gICAgICogICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbXG4gICAgICogICAgICAgICB7XCJuYW1lLmxlbmd0aCgpXCIgOiBuZXcgYWZmaW5pdHkuTGVuZ3RoKG5hbWUpfVxuICAgICAqICAgICBdKTtcbiAgICAgKlxuICAgICAqICAgICBleHRlbmRlZC5wcmludCgpO1xuICAgICAqXG4gICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAqICAgICAvLyB8IG5hbWUgOiBTdHJpbmcgICB8IG5hbWUubGVuZ3RoKCkgOiBJbnRlZ2VyIHxcbiAgICAgKiAgICAgLy8gKz09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09PT0rXG4gICAgICogICAgIC8vIHwgSm9obiBEb2UgICAgICAgIHwgOCAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKiAgICAgLy8gfCBNYXJrIENsaW50b24gICAgfCAxMiAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAqICAgICAvLyB8IEJvIFZyaWwgICAgICAgICB8IDcgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuXG4gICAgICAgIHRoaXMudHlwZShUSW50ZWdlcik7XG5cbiAgICAgICAgdGhpcy5uYW1lID0gJ0xlbmd0aCc7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZnVuY3Rpb24gcmV0dXJuIHZhbHVlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHJldHVybiB2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMF0pLmxlbmd0aDtcblxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGVuZ3RoOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24uanMnKTtcbnZhciBUU3RyaW5nID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9TdHJpbmcuanMnKTtcbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy92YWx1ZScpO1xuXG52YXIgTGVuZ3RoID0gRnVuY3Rpb24uZXh0ZW5kKHtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuU3RyaW5nLkxvd2VyY2FzZVxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgbG93ZXJjYXNlIHZlcnNpb24gb2YgYSBzdHJpbmdcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgd2l0aCBFeHRlbnNpb24gb3BlcmF0b3IgOlxuICAgICAqXG4gICAgICogICAgIHZhciBhZmZpbml0eSA9IHJlcXVpcmUoJy4vaW5kZXguanMnKTtcbiAgICAgKlxuICAgICAqICAgICB2YXIgcmVsYXRpb24gPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAqICAgICAgICAgIHsgbmFtZSA6IHsgdHlwZSA6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICogICAgIF0sW1xuICAgICAqICAgICAgICAgIFsnSm9obiBEb2UnXSwgWydNYXJrIENsaW50b24nXSwgWydCbyBWcmlsJ11cbiAgICAgKiAgICAgXSk7XG4gICAgICpcbiAgICAgKiAgICAgdmFyIG5hbWUgPSByZWxhdGlvbi5nZXQoJ25hbWUnKTtcbiAgICAgKlxuICAgICAqICAgICB2YXIgZXh0ZW5kZWQgPSByZWxhdGlvbi5leHRlbmQoW3tcIm5hbWUubG93ZXJjYXNlKClcIiA6IG5hbWUubG93ZXJjYXNlKCl9XSk7XG4gICAgICpcbiAgICAgKiAgICAgLy8gb3JcbiAgICAgKlxuICAgICAqICAgICB2YXIgZXh0ZW5kZWQgPSByZWxhdGlvbi5leHRlbmQoW1xuICAgICAqICAgICAgICAgeyBcIm5hbWUubG93ZXJjYXNlKClcIiA6IG5ldyBhZmZpbml0eS5Mb3dlcmNhc2UobmFtZSkgfVxuICAgICAqICAgICBdKVxuICAgICAqXG4gICAgICogICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICpcbiAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKiAgICAgLy8gfCBuYW1lIDogU3RyaW5nICAgfCBuYW1lLmxvd2VyY2FzZSgpIDogU3RyaW5nIHxcbiAgICAgKiAgICAgLy8gKz09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgKiAgICAgLy8gfCBKb2huIERvZSAgICAgICAgfCBqb2huIGRvZSAgICAgICAgICAgICAgICAgIHxcbiAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKiAgICAgLy8gfCBNYXJrIENsaW50b24gICAgfCBtYXJrIGNsaW50b24gICAgICAgICAgICAgIHxcbiAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKiAgICAgLy8gfCBCbyBWcmlsICAgICAgICAgfCBibyB2cmlsICAgICAgICAgICAgICAgICAgIHxcbiAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuXG4gICAgICAgIHRoaXMudHlwZShUU3RyaW5nKTtcblxuICAgICAgICB0aGlzLm5hbWUgPSAnTG93ZXJjYXNlJztcblxuICAgIH0sXG5cbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHJldHVybiB2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMF0pLnRvTG93ZXJDYXNlKCk7XG5cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExlbmd0aDsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uLmpzJyk7XG52YXIgVFN0cmluZyA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvU3RyaW5nLmpzJyk7XG52YXIgdmFsdWUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvdmFsdWUnKTtcblxudmFyIFVwcGVyY2FzZSA9IEZ1bmN0aW9uLmV4dGVuZCh7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLlN0cmluZy5TdWJzdHJpbmdcbiAgICAgKlxuICAgICAqIFJldHVybnMgYSBzdWJzdHJpbmcgZnJvbSBhIHN0cmluZ1xuICAgICAqXG4gICAgICogRXhhbXBsZSB3aXRoIEV4dGVuc2lvbiBvcGVyYXRvciA6XG4gICAgICpcbiAgICAgKiAgICAgdmFyIGFmZmluaXR5ID0gcmVxdWlyZSgnLi9pbmRleC5qcycpO1xuICAgICAqXG4gICAgICogICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICogICAgICAgICAgeyBuYW1lIDogeyB0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgKiAgICAgXSxbXG4gICAgICogICAgICAgICAgWydKb2huIERvZSddLCBbJ01hcmsgQ2xpbnRvbiddLCBbJ0JvIFZyaWwnXVxuICAgICAqICAgICBdKTtcbiAgICAgKlxuICAgICAqICAgICB2YXIgbmFtZSA9IHJlbGF0aW9uLmdldCgnbmFtZScpO1xuICAgICAqXG4gICAgICogICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbe1wibmFtZS5zdWJzdHIoMCw1KVwiIDogbmFtZS5zdWJzdHIoMCwgNSl9XSk7XG4gICAgICpcbiAgICAgKiAgICAgLy9vclxuICAgICAqXG4gICAgICogICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbXG4gICAgICogICAgICAgICB7IFwibmFtZS5zdWJzdHIoMCw1KVwiIDogbmV3IGFmZmluaXR5LlN1YnN0cmluZyhuYW1lLCAwLCA1KSB9XG4gICAgICogICAgIF0pO1xuICAgICAqXG4gICAgICogICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICpcbiAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKiAgICAgLy8gfCBuYW1lIDogU3RyaW5nICAgfCBuYW1lLnN1YnN0cigwLDUpIDogU3RyaW5nIHxcbiAgICAgKiAgICAgLy8gKz09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgKiAgICAgLy8gfCBKb2huIERvZSAgICAgICAgfCBKb2huICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKiAgICAgLy8gfCBNYXJrIENsaW50b24gICAgfCBNYXJrICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKiAgICAgLy8gfCBCbyBWcmlsICAgICAgICAgfCBCbyBWciAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuXG4gICAgICAgIHRoaXMudHlwZShUU3RyaW5nKTtcblxuICAgICAgICB0aGlzLm5hbWUgPSAnU3Vic3RyaW5nJztcblxuICAgIH0sXG5cbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciBzdGFydCA9IHZhbHVlKHRoaXMucGFyYW1ldGVyc1sxXSk7XG4gICAgICAgIHZhciBsZW5ndGggPSB2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMl0pO1xuICAgICAgICByZXR1cm4gdmFsdWUodGhpcy5wYXJhbWV0ZXJzWzBdKS5zdWJzdHIoc3RhcnQsIGxlbmd0aCk7XG5cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVwcGVyY2FzZTsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uLmpzJyk7XG52YXIgVFN0cmluZyA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvU3RyaW5nLmpzJyk7XG52YXIgdmFsdWUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvdmFsdWUnKTtcblxudmFyIFRlc3QgPSBGdW5jdGlvbi5leHRlbmQoe1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIEZ1bmN0aW9ucy5TdHJpbmcuVGVzdFxuICAgICAqXG4gICAgICogVGVzdHMgYSByZWdleCBvbiBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEV4YW1wbGUgd2l0aCBFeHRlbnNpb24gb3BlcmF0b3IgOlxuICAgICAqXG4gICAgICogICAgIHZhciBhZmZpbml0eSA9IHJlcXVpcmUoJy4vaW5kZXguanMnKTtcbiAgICAgKlxuICAgICAqICAgICB2YXIgcmVsYXRpb24gPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAqICAgICAgICAgIHsgbmFtZSA6IHsgdHlwZSA6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICogICAgIF0sW1xuICAgICAqICAgICAgICAgIFsnSm9obiBEb2UnXSwgWydNYXJrIENsaW50b24nXSwgWydCbyBWcmlsJ11cbiAgICAgKiAgICAgXSk7XG4gICAgICpcbiAgICAgKiAgICAgdmFyIG5hbWUgPSByZWxhdGlvbi5nZXQoJ25hbWUnKTtcbiAgICAgKlxuICAgICAqICAgICB2YXIgZXh0ZW5kZWQgPSByZWxhdGlvbi5leHRlbmQoW3sgXCJuYW1lLnRlc3QoL0RvZS8pXCIgOiBuYW1lLnRlc3QoL0RvZS8pfV0pO1xuICAgICAqXG4gICAgICogICAgIC8vIG9yXG4gICAgICpcbiAgICAgKiAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKFtcbiAgICAgKiAgICAgICAgIHsgXCJuYW1lLnRlc3QoL0RvZS8pXCIgOiBuZXcgYWZmaW5pdHkuVGVzdChuYW1lLCAvRG9lLykgfVxuICAgICAqICAgICBdKVxuICAgICAqXG4gICAgICogICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICpcbiAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICogICAgIC8vIHwgbmFtZSA6IFN0cmluZyAgIHwgbmFtZS50ZXN0KC9Eb2UvKSA6IEJvb2xlYW4gfFxuICAgICAqICAgICAvLyArPT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgKiAgICAgLy8gfCBKb2huIERvZSAgICAgICAgfCB0cnVlICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAqICAgICAvLyB8IE1hcmsgQ2xpbnRvbiAgICB8IGZhbHNlICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICogICAgIC8vIHwgQm8gVnJpbCAgICAgICAgIHwgZmFsc2UgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuXG4gICAgICAgIHRoaXMudHlwZShUU3RyaW5nKTtcblxuICAgICAgICB0aGlzLm5hbWUgPSAnVGVzdCc7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZnVuY3Rpb24gcmV0dXJuIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB2YXIgcmVnZXggPSB2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMV0pO1xuICAgICAgICByZXR1cm4gcmVnZXgudGVzdCh2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMF0pKTtcblxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGVzdDsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uLmpzJyk7XG52YXIgVFN0cmluZyA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvU3RyaW5nLmpzJyk7XG52YXIgdmFsdWUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvdmFsdWUnKTtcblxudmFyIFVwcGVyY2FzZSA9IEZ1bmN0aW9uLmV4dGVuZCh7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLlN0cmluZy5VcHBlcmNhc2VcbiAgICAgKlxuICAgICAqIFJldHVybnMgdGhlIHVwcGVyY2FzZSB2ZXJzaW9uIG9mIGEgc3RyaW5nXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIHdpdGggRXh0ZW5zaW9uIG9wZXJhdG9yIDpcbiAgICAgKlxuICAgICAqICAgICB2YXIgYWZmaW5pdHkgPSByZXF1aXJlKCcuL2luZGV4LmpzJyk7XG4gICAgICpcbiAgICAgKiAgICAgdmFyIHJlbGF0aW9uID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgKiAgICAgICAgICB7IHVwY3MgOiB7IHR5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAqICAgICBdLFtcbiAgICAgKiAgICAgICAgICBbJ0pvaG4gRG9lJ10sIFsnTWFyayBDbGludG9uJ10sIFsnQm8gVnJpbCddXG4gICAgICogICAgIF0pO1xuICAgICAqXG4gICAgICogICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbe1wibmFtZS51cHBlcmNhc2UoKVwiIDogcmVsYXRpb24uZ2V0KCduYW1lJykudXBwZXJjYXNlKCl9XSk7XG4gICAgICpcbiAgICAgKiAgICAgLy8gb3JcbiAgICAgKlxuICAgICAqICAgICB2YXIgZXh0ZW5kZWQgPSByZWxhdGlvbi5leHRlbmQoW1xuICAgICAqICAgICAgICAgeyBcIm5hbWUudXBwZXJjYXNlKClcIiA6IG5ldyBhZmZpbml0eS5VcHBlcmNhc2UobmFtZSkgfVxuICAgICAqICAgICBdKVxuICAgICAqXG4gICAgICogICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICpcbiAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKiAgICAgLy8gfCBuYW1lIDogU3RyaW5nICAgfCBuYW1lLnVwcGVyY2FzZSgpIDogU3RyaW5nIHxcbiAgICAgKiAgICAgLy8gKz09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgKiAgICAgLy8gfCBKb2huIERvZSAgICAgICAgfCBKT0hOIERPRSAgICAgICAgICAgICAgICAgIHxcbiAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKiAgICAgLy8gfCBNYXJrIENsaW50b24gICAgfCBNQVJLIENMSU5UT04gICAgICAgICAgICAgIHxcbiAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKiAgICAgLy8gfCBCbyBWcmlsICAgICAgICAgfCBCTyBWUklMICAgICAgICAgICAgICAgICAgIHxcbiAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuXG4gICAgICAgIHRoaXMudHlwZShUU3RyaW5nKTtcblxuICAgICAgICB0aGlzLm5hbWUgPSAnVXBwZXJjYXNlJztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmdW5jdGlvbiByZXR1cm4gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlKHRoaXMucGFyYW1ldGVyc1swXSkudG9VcHBlckNhc2UoKTtcblxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVXBwZXJjYXNlO1xuXG5cbiIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24uanMnKTtcbnZhciBUeXBlID0gcmVxdWlyZSgnLi8uLi8uLi9UeXBlLmpzJyk7XG52YXIgVEJvb2xlYW4gPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL0Jvb2xlYW4uanMnKTtcblxudmFyIFR1cGxlQXR0cmlidXRlID0gRnVuY3Rpb24uZXh0ZW5kKHtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuVHVwbGUuQXR0cmlidXRlVmFsdWVcbiAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAqXG4gICAgICogV2hlbiBidWlsZGluZyBhIHByZWRpY2F0ZSwgeW91IHBhc3MgdGhlIEhlYWRlciBBdHRyaWJ1dGVzIGRpcmVjdGx5IGxpa2UgdGhpcyA6XG4gICAgICpcbiAgICAgKiAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKHJlbGF0aW9uLmdldCgnYXR0cmlidXRlMScpLnBsdXMocmVsYXRpb24uZ2V0KCdhdHRyaWJ1dGUyJykpKTtcbiAgICAgKlxuICAgICAqIEluIHRoZSBkb2N1bWVudGF0aW9uIGZvciBSZWxhdGlvbiNnZXQsIGl0IGlzIHNwZWNpZmllZCB0aGF0IGl0IHJldHVybnMgYW4gQXR0cmlidXRlLlxuICAgICAqXG4gICAgICogVGhvdWdoLCB3aGVuIGJ1aWxkaW5nIHByZWRpY2F0ZXMgZm9yIHJlc3RyaWN0aW9uIG9yIGV4dGVuc2lvbiBvcGVyYXRvcnMsIHdlIGNvbnZlcnQgdGhlIHBhc3NlZCBBdHRyaWJ1dGVzXG4gICAgICogaW50byBhIGZ1bmN0aW9uIFR1cGxlQXR0cmlidXRlLiBTbyB0aGlzIGlzIHRoZSBzYW1lIGFzIHRoZSBhYm92ZSA6XG4gICAgICpcbiAgICAgKiAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKG5ldyBhZmZpbml0eS5UdXBsZUF0dHJpYnV0ZSgnYXR0cmlidXRlMScpLnBsdXMobmV3IGFmZmluaXR5LlR1cGxlQXR0cmlidXRlKCdhdHRyaWJ1dGUyJykpKTtcbiAgICAgKlxuICAgICAqIERpcmVjdGx5IHBhc3NpbmcgdGhlIEhlYWRlciBBdHRyaWJ1dGUgaXMganVzdCBzb21lIG5pY2Ugc3VnYXIuXG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcblxuICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIHRoaXMuYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG5cbiAgICAgICAgdGhpcy5uYW1lID0gJ1R1cGxlQXR0cmlidXRlJztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmdW5jdGlvbiByZXR1cm4gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciB0dXBsZSA9IHRoaXMucGFyYW1ldGVyc1swXTtcblxuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHRoaXMuYXR0cmlidXRlTmFtZTtcblxuICAgICAgICBpZighdHVwbGUuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSBcIicrYXR0cmlidXRlTmFtZSsnXCIgZG9lcyBub3QgZXhpc3QgaW4gVHVwbGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0dXBsZS5nZXQoYXR0cmlidXRlTmFtZSk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBhIHR1cGxlIHRvIHRoZSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB0dXBsZVxuICAgICAqL1xuICAgIGFzc2lnblR1cGxlIDogZnVuY3Rpb24odHVwbGUpe1xuXG4gICAgICAgIHRoaXMucGFyYW1ldGVyc1swXSA9IHR1cGxlO1xuXG4gICAgfVxuXG59LHtcblxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUdXBsZUF0dHJpYnV0ZTsiLCJ2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuXG52YXIgY2xvbmUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuXG4gICAgZGVidWcuY2xvbmUudHJhY2UoJyNjbG9uZScpO1xuXG4gICAgaWYgKGVsZW1lbnQuY2xvbmUgJiYgXy5pc0Z1bmN0aW9uKGVsZW1lbnQuY2xvbmUpKSB7XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuY2xvbmUoKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgcmV0dXJuIF8uY2xvbmVEZWVwKGVsZW1lbnQpO1xuXG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lOyIsInZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG52YXIgY29lcmNlID0gZnVuY3Rpb24gKHR5cGUsIHZhbHVlKSB7XG4gICAgZGVidWcuY29lcmNlLnRyYWNlKCcjY29lcmNlJyk7XG4gICAgaWYodmFsdWUgaW5zdGFuY2VvZiB0eXBlKXtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSBpZiAodHlwZSAmJiBfLmlzRnVuY3Rpb24odHlwZS5jb2VyY2UpKSB7XG4gICAgICAgIHJldHVybiB0eXBlLmNvZXJjZS5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyAodHlwZS5wcm90b3R5cGUuY29uc3RydWN0b3IuYmluZC5hcHBseSh0eXBlLCAoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gY29lcmNlOyIsInZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vdmFsdWUnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uL0Z1bmN0aW9uJyk7XG52YXIgVHlwZSA9IHJlcXVpcmUoJy4vLi4vVHlwZScpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuXG52YXIgY29tcGFyZSA9IGZ1bmN0aW9uICh0eXBlLCB2YWx1ZTEsIHZhbHVlMikge1xuXG4gICAgZGVidWcuY29tcGFyZS50cmFjZSgnI2NvbXBhcmUnKTtcblxuICAgIC8vIEdldCB0aGUgZnVuY3Rpb24gcmV0dXJuIHZhbHVlcyBpZiBhcHBsaWNhYmxlXG5cbiAgICB2YWx1ZTEgPSB2YWx1ZSh2YWx1ZTEpO1xuICAgIHZhbHVlMiA9IHZhbHVlKHZhbHVlMik7XG5cblxuICAgIC8vIEFjY2VzcyB0aGUgdHlwZSdzIGVxdWFsIGZ1bmN0aW9uXG5cbiAgICBpZih2YWx1ZTEgaW5zdGFuY2VvZiBUeXBlKXtcbiAgICAgICAgcmV0dXJuIHZhbHVlMS5jb25zdHJ1Y3Rvci5jb21wYXJlKHZhbHVlMSwgdmFsdWUyKTtcbiAgICB9XG5cbiAgICBpZih2YWx1ZTIgaW5zdGFuY2VvZiBUeXBlKXtcbiAgICAgICAgcmV0dXJuIHZhbHVlMi5jb25zdHJ1Y3Rvci5jb21wYXJlKHZhbHVlMSwgdmFsdWUyKTtcbiAgICB9XG5cbiAgICBpZih2YWx1ZTEgaW5zdGFuY2VvZiBEYXRlKXtcbiAgICAgICAgdmFsdWUxID0gdmFsdWUxLmdldFRpbWUoKTtcbiAgICB9XG5cbiAgICBpZih2YWx1ZTIgaW5zdGFuY2VvZiBEYXRlKXtcbiAgICAgICAgdmFsdWUyID0gdmFsdWUyLmdldFRpbWUoKTtcbiAgICB9XG5cblxuICAgIGlmKHZhbHVlMSA9PT0gdmFsdWUyKXtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmICh2YWx1ZTEgPiB2YWx1ZTIpe1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlMiA+IHZhbHVlMSl7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlOyIsIlxudmFyIGxvZzRqcztcblxudHJ5IHtcbiAgICBsb2c0anMgPSByZXF1aXJlKFwibG9nNGpzXCIpO1xuXG4gICAgbG9nNGpzLmNvbmZpZ3VyZSh7XG4gICAgICAgIGFwcGVuZGVyczogW1xuICAgICAgICAgICAgeyB0eXBlOiAnY29uc29sZScgfVxuICAgICAgICBdLFxuICAgICAgICByZXBsYWNlQ29uc29sZTogZmFsc2VcbiAgICB9KTtcblxuICAgIGxvZzRqcy5zZXRHbG9iYWxMb2dMZXZlbChsb2c0anMubGV2ZWxzLldBUk4pO1xuXG59IGNhdGNoKGUpIHtcbiAgICBsb2c0anMgPSB7fTtcblxuICAgIHZhciBsb2dnZXIgPSBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLnRyYWNlID0gdGhpcy53YXJuID0gdGhpcy5kZWJ1ZyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbG9nNGpzLmdldExvZ2dlciA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBuZXcgbG9nZ2VyKCk7XG4gICAgfTtcbn1cblxudmFyIFNldCA9IG1vZHVsZS5leHBvcnRzLnNldCA9IGxvZzRqcy5nZXRMb2dnZXIoJ1NldCcpO1xudmFyIFJlbGF0aW9uID0gbW9kdWxlLmV4cG9ydHMucmVsYXRpb24gPSBsb2c0anMuZ2V0TG9nZ2VyKCdSZWxhdGlvbicpO1xudmFyIEhlYWRlciA9IG1vZHVsZS5leHBvcnRzLmhlYWRlciA9IGxvZzRqcy5nZXRMb2dnZXIoJ0hlYWRlcicpO1xuXG52YXIgQ29tcG9zZSA9IG1vZHVsZS5leHBvcnRzLmNvbXBvc2UgPSBsb2c0anMuZ2V0TG9nZ2VyKCdDb21wb3NlJyk7XG52YXIgRGlmZmVyZW5jZSA9IG1vZHVsZS5leHBvcnRzLmRpZmZlcmVuY2UgPSBsb2c0anMuZ2V0TG9nZ2VyKCdEaWZmZXJlbmNlJyk7XG52YXIgRXh0ZW5kID0gbW9kdWxlLmV4cG9ydHMuZXh0ZW5kID0gbG9nNGpzLmdldExvZ2dlcignRXh0ZW5kJyk7XG52YXIgR3JvdXAgPSBtb2R1bGUuZXhwb3J0cy5ncm91cCA9IGxvZzRqcy5nZXRMb2dnZXIoJ0dyb3VwJyk7XG52YXIgSW50ZXJzZWN0aW9uID0gbW9kdWxlLmV4cG9ydHMuaW50ZXJzZWN0aW9uID0gbG9nNGpzLmdldExvZ2dlcignSW50ZXJzZWN0aW9uJyk7XG52YXIgSm9pbiA9IG1vZHVsZS5leHBvcnRzLmpvaW4gPSBsb2c0anMuZ2V0TG9nZ2VyKCdKb2luJyk7XG52YXIgUHJvZHVjdCA9IG1vZHVsZS5leHBvcnRzLnByb2R1Y3QgPSBsb2c0anMuZ2V0TG9nZ2VyKCdQcm9kdWN0Jyk7XG52YXIgUHJvamVjdGlvbiA9IG1vZHVsZS5leHBvcnRzLnByb2plY3Rpb24gPSBsb2c0anMuZ2V0TG9nZ2VyKCdQcm9qZWN0aW9uJyk7XG52YXIgUmVuYW1lID0gbW9kdWxlLmV4cG9ydHMucmVuYW1lID0gbG9nNGpzLmdldExvZ2dlcignUmVuYW1lJyk7XG52YXIgUmVzdHJpY3Rpb24gPSBtb2R1bGUuZXhwb3J0cy5yZXN0cmljdGlvbiA9IGxvZzRqcy5nZXRMb2dnZXIoJ1Jlc3RyaWN0aW9uJyk7XG52YXIgU2VtaUpvaW4gPSBtb2R1bGUuZXhwb3J0cy5zZW1pSm9pbiA9IGxvZzRqcy5nZXRMb2dnZXIoJ1NlbWlKb2luJyk7XG52YXIgU2VtaURpZmZlcmVuY2UgPSBtb2R1bGUuZXhwb3J0cy5zZW1pRGlmZmVyZW5jZSA9IGxvZzRqcy5nZXRMb2dnZXIoJ1NlbWlEaWZmZXJlbmNlJyk7XG52YXIgVW5ncm91cCA9IG1vZHVsZS5leHBvcnRzLnVuZ3JvdXAgPSBsb2c0anMuZ2V0TG9nZ2VyKCdVbmdyb3VwJyk7XG52YXIgVW5pb24gPSBtb2R1bGUuZXhwb3J0cy51bmlvbiA9IGxvZzRqcy5nZXRMb2dnZXIoJ1VuaW9uJyk7XG52YXIgVW53cmFwID0gbW9kdWxlLmV4cG9ydHMudW53cmFwID0gbG9nNGpzLmdldExvZ2dlcignVW53cmFwJyk7XG52YXIgV3JhcCA9IG1vZHVsZS5leHBvcnRzLndyYXAgPSBsb2c0anMuZ2V0TG9nZ2VyKCdXcmFwJyk7XG52YXIgVGFibGVEdW1wID0gbW9kdWxlLmV4cG9ydHMucmVsZHVtcCA9IGxvZzRqcy5nZXRMb2dnZXIoJ1RhYmxlRHVtcCcpO1xudmFyIFRlc3QgPSBtb2R1bGUuZXhwb3J0cy50ZXN0ID0gbG9nNGpzLmdldExvZ2dlcignVGVzdCcpO1xuXG52YXIgSW5kZXggPSBtb2R1bGUuZXhwb3J0cy5pbmRleCA9IGxvZzRqcy5nZXRMb2dnZXIoJ0luZGV4Jyk7XG52YXIgS2V5ID0gbW9kdWxlLmV4cG9ydHMua2V5ID0gbG9nNGpzLmdldExvZ2dlcignS2V5Jyk7XG52YXIgRm9yZWlnbktleSA9IG1vZHVsZS5leHBvcnRzLmZvcmVpZ25LZXkgPSBsb2c0anMuZ2V0TG9nZ2VyKCdGb3JlaWduS2V5Jyk7XG5cblxudmFyIENsb25lID0gbW9kdWxlLmV4cG9ydHMuY2xvbmUgPSBsb2c0anMuZ2V0TG9nZ2VyKCdDbG9uZScpO1xudmFyIFR5cGUgPSBtb2R1bGUuZXhwb3J0cy50eXBlID0gbG9nNGpzLmdldExvZ2dlcignVHlwZScpO1xudmFyIENvZXJjZSA9IG1vZHVsZS5leHBvcnRzLmNvZXJjZSA9IGxvZzRqcy5nZXRMb2dnZXIoJ0NvZXJjZScpO1xudmFyIENvbXBhcmUgPSBtb2R1bGUuZXhwb3J0cy5jb21wYXJlID0gbG9nNGpzLmdldExvZ2dlcignQ29tcGFyZScpO1xudmFyIFZhbHVlID0gbW9kdWxlLmV4cG9ydHMudmFsdWUgPSBsb2c0anMuZ2V0TG9nZ2VyKCdWYWx1ZScpO1xudmFyIEVxdWFsID0gbW9kdWxlLmV4cG9ydHMuZXF1YWwgPSBsb2c0anMuZ2V0TG9nZ2VyKCdFcXVhbCcpO1xuXG5cbiIsInZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vdmFsdWUnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uL0Z1bmN0aW9uJyk7XG52YXIgVHlwZSA9IHJlcXVpcmUoJy4vLi4vVHlwZScpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuXG52YXIgZXF1YWwgPSBmdW5jdGlvbiAodHlwZSwgdmFsdWUxLCB2YWx1ZTIpIHtcblxuICAgIGRlYnVnLmVxdWFsLnRyYWNlKCcjZXF1YWwnKTtcblxuICAgIC8vIEdldCB0aGUgZnVuY3Rpb24gcmV0dXJuIHZhbHVlcyBpZiBhcHBsaWNhYmxlXG5cbiAgICB2YWx1ZTEgPSB2YWx1ZSh2YWx1ZTEpO1xuICAgIHZhbHVlMiA9IHZhbHVlKHZhbHVlMik7XG5cbiAgICBpZihfLmlzVW5kZWZpbmVkKHZhbHVlMSkgJiYgXy5pc1VuZGVmaW5lZCh2YWx1ZTIpKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChfLmlzVW5kZWZpbmVkKHZhbHVlMSkgfHwgXy5pc1VuZGVmaW5lZCh2YWx1ZTIpKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoXy5pc051bGwodmFsdWUxKSAmJiBfLmlzTnVsbCh2YWx1ZTIpKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChfLmlzTnVsbCh2YWx1ZTEpIHx8IF8uaXNOdWxsKHZhbHVlMikpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG5cbiAgICAvLyBBY2Nlc3MgdGhlIHR5cGUncyBlcXVhbCBmdW5jdGlvblxuXG4gICAgaWYodmFsdWUxLmNvbnN0cnVjdG9yICYmIHZhbHVlMS5jb25zdHJ1Y3Rvci5lcXVhbCl7XG4gICAgICAgIHJldHVybiB2YWx1ZTEuY29uc3RydWN0b3IuZXF1YWwodmFsdWUxLCB2YWx1ZTIpO1xuICAgIH1cblxuICAgIGlmKHZhbHVlMi5jb25zdHJ1Y3RvciAmJiB2YWx1ZTIuY29uc3RydWN0b3IuZXF1YWwpe1xuICAgICAgICByZXR1cm4gdmFsdWUyLmNvbnN0cnVjdG9yLmVxdWFsKHZhbHVlMSwgdmFsdWUyKTtcbiAgICB9XG5cblxuICAgIC8vIEZhbGxiYWNrIG9uIGdvb2Qnb2wgbG9kYXNoXG5cbiAgICByZXR1cm4gXy5pc0VxdWFsKHZhbHVlMSwgdmFsdWUyKTtcblxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsOyIsInZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vdmFsdWUnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uL0Z1bmN0aW9uJyk7XG52YXIgQXR0cmlidXRlID0gcmVxdWlyZSgnLi8uLi9BdHRyaWJ1dGUnKTtcbnZhciBUeXBlID0gcmVxdWlyZSgnLi8uLi9UeXBlJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5cbnZhciBUQm9vbGVhbiA9IHJlcXVpcmUoJy4vLi4vdHlwZXMvQm9vbGVhbicpO1xudmFyIFRTdHJpbmcgPSByZXF1aXJlKCcuLy4uL3R5cGVzL1N0cmluZycpO1xudmFyIFREYXRlID0gcmVxdWlyZSgnLi8uLi90eXBlcy9EYXRlJyk7XG52YXIgVEludGVnZXIgPSByZXF1aXJlKCcuLy4uL3R5cGVzL0ludGVnZXInKTtcbnZhciBUTnVtZXJpYyA9IHJlcXVpcmUoJy4vLi4vdHlwZXMvTnVtZXJpYycpO1xudmFyIFRGbG9hdCA9IHJlcXVpcmUoJy4vLi4vdHlwZXMvRmxvYXQnKTtcblxuXG52YXIgdHlwZSA9IGZ1bmN0aW9uKHRoYW5nKXtcblxuICAgIGRlYnVnLnR5cGUudHJhY2UoJyN0eXBlJyk7XG5cbiAgICBpZih0aGFuZyBpbnN0YW5jZW9mIEF0dHJpYnV0ZSl7XG4gICAgICAgIHJldHVybiB0aGFuZy50eXBlO1xuICAgIH1cblxuICAgIGlmKHRoYW5nIGluc3RhbmNlb2YgVHlwZSl7XG4gICAgICAgIHJldHVybiB0aGFuZy5jb25zdHJ1Y3RvcjtcbiAgICB9XG5cbiAgICBpZih0aGFuZyBpbnN0YW5jZW9mIEZ1bmN0aW9uKXtcbiAgICAgICAgcmV0dXJuIHRoYW5nLnR5cGUoKTtcbiAgICB9XG5cbiAgICBpZihfLmlzQm9vbGVhbih0aGFuZykpe1xuICAgICAgICByZXR1cm4gVEJvb2xlYW47XG4gICAgfVxuXG4gICAgaWYoXy5pc051bWJlcih0aGFuZykpe1xuICAgICAgICByZXR1cm4gVE51bWVyaWM7XG4gICAgfVxuXG4gICAgaWYoXy5pc0RhdGUodGhhbmcpKXtcbiAgICAgICAgcmV0dXJuIFREYXRlO1xuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlO1xuXG4iLCJcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbnZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vRnVuY3Rpb24nKTtcblxudmFyIHZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICBkZWJ1Zy52YWx1ZS50cmFjZSgnI3ZhbHVlJyk7XG5cbiAgICBpZih2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKXtcblxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnZhbHVlKCk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdmFsdWU7IiwiLyoqXG4gKiBAY2xhc3MgTWl4aW5zLkNvbXBhcmFibGVcbiAqL1xuXG5cbi8qKlxuICogQG1lbWJlciBNaXhpbnMuQ29tcGFyYWJsZVxuICovXG5tb2R1bGUuZXhwb3J0cy5lcXVhbHMgPSBmdW5jdGlvbiAoYXR0cikge1xuXG4gICAgdmFyIEVxdWFsID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvY29tcGFyYWJsZS9FcXVhbC5qcycpO1xuXG4gICAgaWYgKHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKG5ldyBFcXVhbCh0aGlzLCBhdHRyKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBFcXVhbCh0aGlzLCBhdHRyKTtcblxufTtcblxuLyoqXG4gKiBAbWVtYmVyIE1peGlucy5Db21wYXJhYmxlXG4gKi9cbm1vZHVsZS5leHBvcnRzLmVxID0gZnVuY3Rpb24oYXR0cil7XG4gICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzLmVxdWFscy5jYWxsKHRoaXMsIGF0dHIpO1xufTsiLCIvKipcbiAqIEBjbGFzcyBNaXhpbnMuQ2hhaW5hYmxlXG4gKi9cblxuLyoqXG4gKiBAbWVtYmVyIE1peGlucy5DaGFpbmFibGVcbiAqL1xubW9kdWxlLmV4cG9ydHMuYW5kID0gZnVuY3Rpb24gKHBhcmFtKSB7XG5cbiAgICB2YXIgQW5kID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvY29ubmVjdGl2ZS9BbmQuanMnKTtcblxuICAgIGlmICh0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZShuZXcgQW5kKHRoaXMsIHBhcmFtKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBBbmQodGhpcywgcGFyYW0pO1xuXG59O1xuXG4vKipcbiAqIEBtZW1iZXIgTWl4aW5zLkNoYWluYWJsZVxuICovXG5tb2R1bGUuZXhwb3J0cy5vciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBPciA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL2Nvbm5lY3RpdmUvT3IuanMnKTtcblxuICAgIGlmICh0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZShuZXcgT3IodGhpcykpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgT3IodGhpcyk7XG5cbn07IiwibW9kdWxlLmV4cG9ydHMuZGF5T2ZNb250aCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBEYXlPZk1vbnRoID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvZGF0ZS9EYXlPZk1vbnRoLmpzJyk7XG5cbiAgICBpZiAodGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUobmV3IERheU9mTW9udGgodGhpcykpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGF5T2ZNb250aCh0aGlzKTtcblxufTtcblxubW9kdWxlLmV4cG9ydHMuZGF5T2ZXZWVrID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIERheU9mV2VlayA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL2RhdGUvRGF5T2ZXZWVrLmpzJyk7XG5cbiAgICBpZiAodGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUobmV3IERheU9mV2Vlayh0aGlzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEYXlPZldlZWsodGhpcyk7XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzLmRheU9mWWVhciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBEYXlPZlllYXIgPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9kYXRlL0RheU9mWWVhci5qcycpO1xuXG4gICAgaWYgKHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKG5ldyBEYXlPZlllYXIodGhpcykpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGF5T2ZZZWFyKHRoaXMpO1xuXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLm1vbnRoID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIE1vbnRoID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvZGF0ZS9Nb250aC5qcycpO1xuXG4gICAgaWYgKHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKG5ldyBNb250aCh0aGlzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBNb250aCh0aGlzKTtcblxufTtcblxubW9kdWxlLmV4cG9ydHMudHMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgVGltZXN0YW1wID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvZGF0ZS9UaW1lc3RhbXAuanMnKTtcblxuICAgIGlmICh0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZShuZXcgVGltZXN0YW1wKHRoaXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCh0aGlzKTtcblxufTtcblxubW9kdWxlLmV4cG9ydHMud2Vla09mWWVhciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBXZWVrT2ZZZWFyID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvZGF0ZS9XZWVrT2ZZZWFyLmpzJyk7XG5cbiAgICBpZiAodGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUobmV3IFdlZWtPZlllYXIodGhpcykpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgV2Vla09mWWVhcih0aGlzKTtcblxufTtcblxubW9kdWxlLmV4cG9ydHMueWVhciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBZZWFyID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvZGF0ZS9ZZWFyLmpzJyk7XG5cbiAgICBpZiAodGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUobmV3IFllYXIodGhpcykpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgWWVhcih0aGlzKTtcblxufTtcblxubW9kdWxlLmV4cG9ydHMuaG91cnMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgSG91cnMgPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9kYXRlL0hvdXJzLmpzJyk7XG5cbiAgICBpZiAodGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUobmV3IEhvdXJzKHRoaXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEhvdXJzKHRoaXMpO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5taW51dGVzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIE1pbnV0ZXMgPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9kYXRlL01pbnV0ZXMuanMnKTtcblxuICAgIGlmICh0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZShuZXcgTWludXRlcyh0aGlzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBNaW51dGVzKHRoaXMpO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5zZWNvbmRzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIFNlY29uZHMgPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9kYXRlL1NlY29uZHMuanMnKTtcblxuICAgIGlmICh0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZShuZXcgU2Vjb25kcyh0aGlzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTZWNvbmRzKHRoaXMpO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5taWxsaXNlY29uZHMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgTWlsbGlzZWNvbmRzID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvZGF0ZS9NaWxsaXNlY29uZHMuanMnKTtcblxuICAgIGlmICh0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZShuZXcgTWlsbGlzZWNvbmRzKHRoaXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE1pbGxpc2Vjb25kcyh0aGlzKTtcblxufTsiLCIvKipcbiAqIEBjbGFzcyBNaXhpbnMuTmVnYXRhYmxlXG4gKi9cblxuLyoqXG4gKiBAbWVtYmVyIE1peGlucy5OZWdhdGFibGVcbiAqL1xubW9kdWxlLmV4cG9ydHMubm90ID0gZnVuY3Rpb24gKGF0dHIpIHtcblxuICAgIHRoaXMuX25lZ2F0ZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuXG59OyIsIm1vZHVsZS5leHBvcnRzLmFicyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgQWJzb2x1dGUgPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9udW1lcmljL0Fic29sdXRlLmpzJyk7XG4gICAgaWYgKHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKG5ldyBBYnNvbHV0ZSh0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQWJzb2x1dGUodGhpcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5jZWlsID0gZnVuY3Rpb24gKGF0dHIpIHtcbiAgICB2YXIgQ2VpbCA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL251bWVyaWMvQ2VpbC5qcycpO1xuICAgIGlmICh0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZShuZXcgQ2VpbCh0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ2VpbCh0aGlzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmZsb29yID0gZnVuY3Rpb24gKGF0dHIpIHtcbiAgICB2YXIgRmxvb3IgPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9udW1lcmljL0Zsb29yLmpzJyk7XG4gICAgaWYgKHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKG5ldyBDZWlsKHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGbG9vcih0aGlzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmNvcyA9IGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgdmFyIENvcyA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL251bWVyaWMvQ29zaW5lLmpzJyk7XG4gICAgaWYgKHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKG5ldyBDb3ModGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IENvcyh0aGlzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmRpdiA9IGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgdmFyIERpdmlzaW9uID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvbnVtZXJpYy9EaXZpc2lvbi5qcycpO1xuICAgIGlmICh0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZShuZXcgRGl2aXNpb24odGhpcywgYXR0cikpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERpdmlzaW9uKHRoaXMsIGF0dHIpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cy5leHAgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIEV4cCA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL251bWVyaWMvRXhwb25lbnRpYWwuanMnKTtcbiAgICBpZiAodGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUobmV3IEV4cCh0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXhwKHRoaXMpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cy5taW51cyA9IGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgdmFyIE1pbnVzID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvbnVtZXJpYy9NaW51cy5qcycpO1xuICAgIGlmICh0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZShuZXcgTWludXModGhpcywgYXR0cikpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE1pbnVzKHRoaXMsIGF0dHIpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cy5tb2QgPSBmdW5jdGlvbiAoYXR0cikge1xuICAgIHZhciBNb2R1bG8gPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9udW1lcmljL01vZHVsby5qcycpO1xuICAgIGlmICh0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZShuZXcgTW9kdWxvKHRoaXMsIGF0dHIpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNb2R1bG8odGhpcywgYXR0cik7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLnRpbWVzID0gZnVuY3Rpb24gKGF0dHIpIHtcbiAgICB2YXIgTXVsdGlwbGljYXRpb24gPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9udW1lcmljL011bHRpcGxpY2F0aW9uLmpzJyk7XG4gICAgaWYgKHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKG5ldyBNdWx0aXBsaWNhdGlvbih0aGlzLCBhdHRyKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTXVsdGlwbGljYXRpb24odGhpcywgYXR0cik7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLnBsdXMgPSBmdW5jdGlvbiAoYXR0cikge1xuICAgIHZhciBQbHVzID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvbnVtZXJpYy9QbHVzLmpzJyk7XG4gICAgaWYgKHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKG5ldyBQbHVzKHRoaXMsIGF0dHIpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQbHVzKHRoaXMsIGF0dHIpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cy5wb3cgPSBmdW5jdGlvbiAoYXR0cikge1xuICAgIHZhciBQb3cgPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9udW1lcmljL1Bvd2VyLmpzJyk7XG4gICAgaWYgKHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKG5ldyBQb3codGhpcywgYXR0cikpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFBvdyh0aGlzLCBhdHRyKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMucm91bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIFJvdW5kID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvbnVtZXJpYy9Sb3VuZC5qcycpO1xuICAgIGlmICh0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZShuZXcgUm91bmQodGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJvdW5kKHRoaXMpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cy5zaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIFNpbiA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL251bWVyaWMvU2luZS5qcycpO1xuICAgIGlmICh0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZShuZXcgU2luKHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTaW4odGhpcyk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLnNxcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIFNxcnQgPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9udW1lcmljL1NxdWFyZVJvb3QuanMnKTtcbiAgICBpZiAodGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUobmV3IFNxcnQodGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFNxcnQodGhpcyk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLnRhbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgVGFuID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvbnVtZXJpYy9UYW5nZW50LmpzJyk7XG4gICAgaWYgKHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKG5ldyBUYW4odGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRhbih0aGlzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmF2ZyA9IGZ1bmN0aW9uKCl7XG5cbiAgICB2YXIgQXZlcmFnZSA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL2FnZ3JlZ2F0ZS9BdmVyYWdlLmpzJyk7XG4gICAgcmV0dXJuIG5ldyBBdmVyYWdlKHRoaXMpO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5zdGFuZGFyZERldmlhdGlvbiA9IGZ1bmN0aW9uKCl7XG5cbiAgICB2YXIgU3RhbmRhcmREZXZpYXRpb24gPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9hZ2dyZWdhdGUvU3RhbmRhcmREZXZpYXRpb24uanMnKTtcbiAgICByZXR1cm4gbmV3IFN0YW5kYXJkRGV2aWF0aW9uKHRoaXMpO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5zdW0gPSBmdW5jdGlvbigpe1xuXG4gICAgdmFyIFN1bSA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL2FnZ3JlZ2F0ZS9TdW0uanMnKTtcbiAgICByZXR1cm4gbmV3IFN1bSh0aGlzKTtcblxufTtcblxubW9kdWxlLmV4cG9ydHMudmFyaWFuY2UgPSBmdW5jdGlvbigpe1xuXG4gICAgdmFyIFZhcmlhbmNlID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvYWdncmVnYXRlL1ZhcmlhbmNlLmpzJyk7XG4gICAgcmV0dXJuIG5ldyBWYXJpYW5jZSh0aGlzKTtcblxufTtcblxuIiwiLyoqXG4gKiBAY2xhc3MgTWl4aW5zLlNpemVDb21wYXJhYmxlXG4gKi9cblxuLyoqXG4gKiBAbWVtYmVyIE1peGlucy5TaXplQ29tcGFyYWJsZVxuICovXG5tb2R1bGUuZXhwb3J0cy5ndCA9IGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgdmFyIEdyZWF0ZXJUaGFuID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvY29tcGFyYWJsZS9HcmVhdGVyVGhhbi5qcycpO1xuICAgIHJldHVybiBuZXcgR3JlYXRlclRoYW4odGhpcywgYXR0cik7XG59O1xuXG4vKipcbiAqIEBtZW1iZXIgTWl4aW5zLlNpemVDb21wYXJhYmxlXG4gKi9cbm1vZHVsZS5leHBvcnRzLmd0ZSA9IGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgdmFyIEdyZWF0ZXJUaGFuRXF1YWwgPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9jb21wYXJhYmxlL0dyZWF0ZXJUaGFuRXF1YWwuanMnKTtcbiAgICByZXR1cm4gbmV3IEdyZWF0ZXJUaGFuRXF1YWwodGhpcywgYXR0cik7XG59O1xuXG4vKipcbiAqIEBtZW1iZXIgTWl4aW5zLlNpemVDb21wYXJhYmxlXG4gKi9cbm1vZHVsZS5leHBvcnRzLnN0ID0gZnVuY3Rpb24gKGF0dHIpIHtcbiAgICB2YXIgU21hbGxlclRoYW4gPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9jb21wYXJhYmxlL1NtYWxsZXJUaGFuLmpzJyk7XG4gICAgcmV0dXJuIG5ldyBTbWFsbGVyVGhhbih0aGlzLCBhdHRyKTtcbn07XG5cbi8qKlxuICogQG1lbWJlciBNaXhpbnMuU2l6ZUNvbXBhcmFibGVcbiAqL1xubW9kdWxlLmV4cG9ydHMuc3RlID0gZnVuY3Rpb24gKGF0dHIpIHtcbiAgICB2YXIgU21hbGxlclRoYW5FcXVhbCA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL2NvbXBhcmFibGUvU21hbGxlclRoYW5FcXVhbC5qcycpO1xuICAgIHJldHVybiBuZXcgU21hbGxlclRoYW5FcXVhbCh0aGlzLCBhdHRyKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLm1heCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIE1heGltdW0gPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9hZ2dyZWdhdGUvTWF4aW11bScpO1xuXG4gICAgcmV0dXJuIG5ldyBNYXhpbXVtKHRoaXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMubWluID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgTWluaW11bSA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL2FnZ3JlZ2F0ZS9NaW5pbXVtJyk7XG5cbiAgICByZXR1cm4gbmV3IE1pbmltdW0odGhpcyk7XG59OyIsIlxuXG5tb2R1bGUuZXhwb3J0cy5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIExlbmd0aCA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL3N0cmluZy9MZW5ndGguanMnKTtcbiAgICBpZiAodGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUobmV3IExlbmd0aCh0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGVuZ3RoKHRoaXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMubG93ZXJjYXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBMb3dlcmNhc2UgPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9zdHJpbmcvTG93ZXJjYXNlLmpzJyk7XG4gICAgaWYgKHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKG5ldyBMb3dlcmNhc2UodGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IExvd2VyY2FzZSh0aGlzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnRlc3QgPSBmdW5jdGlvbiAocmVnZXgpIHtcbiAgICB2YXIgVGVzdCA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL3N0cmluZy9UZXN0LmpzJyk7XG4gICAgaWYgKHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKG5ldyBUZXN0KHRoaXMsIHJlZ2V4KSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGVzdCh0aGlzLCByZWdleCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5zdWJzdHIgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbikge1xuICAgIHZhciBTdWJzdHJpbmcgPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9zdHJpbmcvU3Vic3RyaW5nLmpzJyk7XG4gICAgaWYgKHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKG5ldyBTdWJzdHJpbmcodGhpcywgaW5kZXgsIGxlbikpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN1YnN0cmluZyh0aGlzLCBpbmRleCwgbGVuKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnVwcGVyY2FzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgVXBwZXJjYXNlID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvc3RyaW5nL1VwcGVyY2FzZS5qcycpO1xuICAgIGlmICh0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZShuZXcgVXBwZXJjYXNlKHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVcHBlcmNhc2UodGhpcyk7XG59OyIsInZhciBUeXBlID0gcmVxdWlyZSgnLi8uLi9UeXBlJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG52YXIgVEJvb2xlYW4gPSBUeXBlLmV4dGVuZCgvKipcbiAqIEBjbGFzcyBUeXBlcy5Cb29sZWFuXG4gKiBAZXh0ZW5kcyBUeXBlXG4gKlxuICogUmVwcmVzZW50cyBhIEJvb2xlYW4gVHlwZVxuICpcbiAqIFRoaXMgY2xhc3Mgc2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQuIEl0IGlzIG9ubHkgdXNlZCB0byBkZWZpbmVcbiAqIHJlbGF0aW9uIGhlYWRlciBhdHRyaWJ1dGUgdHlwZXMgb3IgZnVuY3Rpb24gcmV0dXJuIHR5cGVzLlxuICpcbiAqL3tcblxuXG5cbn0sIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxUeXBlcy5Cb29sZWFufSBib29sZWFuMVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxUeXBlcy5Cb29sZWFufSBib29sZWFuMlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKlxuICAgICAqIE1ldGhvZCB0byBjaGVjayBpZiB0d28gYm9vbGVhbiBvYmplY3QgYXJlIGVxdWFsXG4gICAgICpcbiAgICAgKi9cbiAgICBlcXVhbDogZnVuY3Rpb24gKGJvb2xlYW4xLCBib29sZWFuMikge1xuXG4gICAgICAgIHJldHVybiBib29sZWFuMSA9PT0gYm9vbGVhbjI7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFyaWFibGUgdG8gY29lcmNlIHRvIEJvb2xlYW4gdHlwZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjb2VyY2UgOiBmdW5jdGlvbih2YWx1ZSl7XG5cbiAgICAgICAgdmFyIGxvd2VyQ2FzZVZhbHVlO1xuXG4gICAgICAgIGlmKF8uaXNCb29sZWFuKHZhbHVlKSl7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDApe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAxKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcodmFsdWUpKXtcblxuICAgICAgICAgICAgbG93ZXJDYXNlVmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZihsb3dlckNhc2VWYWx1ZSA9PT0gJ3RydWUnIHx8IGxvd2VyQ2FzZVZhbHVlID09PSAndCcpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGxvd2VyQ2FzZVZhbHVlID09PSAnZmFsc2UnIHx8IGxvd2VyQ2FzZVZhbHVlID09PSAnZicpe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICpcbiAgICAgKiBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIEJvb2xlYW4gdHlwZVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnQm9vbGVhbidcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBib29sZWFuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgYSBib29sZWFuXG4gICAgICovXG4gICAgdmFsdWUgOiBmdW5jdGlvbihib29sZWFuKXtcblxuICAgICAgICByZXR1cm4gYm9vbGVhbjtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNaXhpbnMgZm9yIEJvb2xlYW5zXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHBheWxvYWQgOiBbXG4gICAgICAgIHJlcXVpcmUoJy4vLi4vbWl4aW5zL2NvbXBhcmFibGUnKSxcbiAgICAgICAgcmVxdWlyZSgnLi8uLi9taXhpbnMvY29ubmVjdGFibGUnKSxcbiAgICAgICAgcmVxdWlyZSgnLi8uLi9taXhpbnMvbm90JylcbiAgICBdLFxuXG4gICAgdHlwZSA6ICdCb29sZWFuJ1xuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUQm9vbGVhbjtcblxuIiwidmFyIE9iamVjdCA9IHJlcXVpcmUoJy4vT2JqZWN0Jyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG52YXIgRGF0ZSA9IE9iamVjdC5leHRlbmQoe1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIFR5cGVzLkRhdGVcbiAgICAgKiBAZXh0ZW5kcyBUeXBlXG4gICAgICpcbiAgICAgKiBSZXByZXNlbnRzIGEgRGF0ZSB0eXBlLlxuICAgICAqXG4gICAgICogU2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQuIE9ubHkgdXNlZCB0byByZXByZXNlbnRcbiAgICAgKiByZWxhdGlvbiBoZWFkZXIgYXR0cmlidXRlIHR5cGVzIG9yIGZ1bmN0aW9uIHJldHVybiB0eXBlcy5cbiAgICAgKi9cblxufSwge1xuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIG1ldGhvZCBmb3IgRGF0ZXMuXG4gICAgICogQHBhcmFtIHtEYXRlfFR5cGVzLkRhdGV9IGRhdGVcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBzZXJpYWxpemUgOiBmdW5jdGlvbihkYXRlKXtcblxuICAgICAgICByZXR1cm4gZGF0ZS5nZXRUaW1lKCk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29lcmNlcyBhbiBhcmJpdHJhcnkgb2JqZWN0IGludG8gYSBkYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfERhdGV8VHlwZXMuRGF0ZX0gdmFsdWVcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybnMge0RhdGV9XG4gICAgICovXG4gICAgY29lcmNlIDogZnVuY3Rpb24odmFsdWUpe1xuXG4gICAgICAgIGlmKF8uaXNTdHJpbmcodmFsdWUpKXtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pc051bWJlcih2YWx1ZSkpe1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICByZXN1bHQuc2V0VGltZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2UgaWYoXy5pc0RhdGUodmFsdWUpKXtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHR3byBkYXRlcyBhcmUgZXF1YWxcbiAgICAgKiBAcGFyYW0ge0RhdGV8VHlwZXMuRGF0ZX0gZGF0ZTFcbiAgICAgKiBAcGFyYW0ge0RhdGV8VHlwZXMuRGF0ZX0gZGF0ZTJcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZXF1YWw6IGZ1bmN0aW9uIChkYXRlMSwgZGF0ZTIpIHtcblxuICAgICAgICByZXR1cm4gZGF0ZTEgPT09IGRhdGUyO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgRGF0ZSB0eXBlXG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdEYXRlJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiBhIGRhdGVcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIGRhdGVcbiAgICAgKiBAcmV0dXJucyB7RGF0ZX1cbiAgICAgKi9cbiAgICB2YWx1ZSA6IGZ1bmN0aW9uKGRhdGUpe1xuXG4gICAgICAgIHJldHVybiBkYXRlO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1peGlucyBmb3IgZGF0ZXNcbiAgICAgKi9cbiAgICBwYXlsb2FkIDogW1xuICAgICAgICByZXF1aXJlKCcuLy4uL21peGlucy9jb21wYXJhYmxlJyksXG4gICAgICAgIHJlcXVpcmUoJy4vLi4vbWl4aW5zL3NpemUtY29tcGFyYWJsZScpLFxuICAgICAgICByZXF1aXJlKCcuLy4uL21peGlucy9ub3QnKSxcbiAgICAgICAgcmVxdWlyZSgnLi8uLi9taXhpbnMvZGF0ZScpXG4gICAgXSxcblxuICAgIHR5cGUgOiAnRGF0ZSdcblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0ZTtcblxuIiwidmFyIE51bWVyaWMgPSByZXF1aXJlKCcuL051bWVyaWMuanMnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbnZhciBGbG9hdCA9IE51bWVyaWMuZXh0ZW5kKHtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBUeXBlcy5GbG9hdFxuICAgICAqIEBleHRlbmRzIFR5cGVzLk51bWVyaWNcbiAgICAgKlxuICAgICAqIFJlcHJlc2VudHMgYSBGbG9hdCB0eXBlLlxuICAgICAqXG4gICAgICogVGhpcyBjbGFzcyBzaG91bGQgbm90IGJlIGluc3RhbnRpYXRlZC4gSXQgaXMgb25seSB1c2VkXG4gICAgICogdG8gcmVwcmVzZW50IHJlbGF0aW9uIGhlYWRlciBhdHRyaWJ1dGUgdHlwZXMgb3IgZnVuY3Rpb24gcmV0dXJuIHR5cGVzLlxuICAgICAqL1xuXG59LCB7XG5cbiAgICAvKipcbiAgICAgKiBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIEZsb2F0IHR5cGVcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0Zsb2F0J1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIENvZXJjZXMgYW4gYXJiaXRyYXJ5IHZhbHVlIHRvIEZsb2F0IHR5cGVcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGNvZXJjZSA6IGZ1bmN0aW9uKHZhbHVlKXtcblxuICAgICAgICBpZiAoXy5pc051bWJlcih2YWx1ZSkgfHwgXy5pc1N0cmluZyh2YWx1ZSkpe1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgcHJpbWl0aXZlIDogdHJ1ZSxcblxuICAgIHR5cGUgOiAnRmxvYXQnXG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZsb2F0O1xuXG4iLCJ2YXIgVE51bWVyaWMgPSByZXF1aXJlKCcuL051bWVyaWMuanMnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbnZhciBJbnRlZ2VyID0gVE51bWVyaWMuZXh0ZW5kKHtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBUeXBlcy5JbnRlZ2VyXG4gICAgICogQGV4dGVuZHMgVHlwZXMuTnVtZXJpY1xuICAgICAqXG4gICAgICogUmVwcmVzZW50cyBhbiBJbnRlZ2VyIHR5cGUuXG4gICAgICpcbiAgICAgKiBUaGlzIGNsYXNzIHNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkLiBJdCBpcyBvbmx5IHVzZWRcbiAgICAgKiB0byByZXByZXNlbnQgcmVsYXRpb24gaGVhZGVyIGF0dHJpYnV0ZSB0eXBlcyBvciBmdW5jdGlvbiByZXR1cm4gdHlwZXMuXG4gICAgICovXG5cbn0sIHtcblxuICAgIC8qKlxuICAgICAqIENvZXJjZXMgYW4gYXJiaXRyYXJ5IHZhbHVlIHRvIEludGVnZXIgdHlwZVxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgY29lcmNlIDogZnVuY3Rpb24odmFsdWUpe1xuXG4gICAgICAgIGlmIChfLmlzTnVtYmVyKHZhbHVlKSB8fCBfLmlzU3RyaW5nKHZhbHVlKSl7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBJbnRlZ2VyIFR5cGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnSW50ZWdlcidcbiAgICB9LFxuXG4gICAgcHJpbWl0aXZlIDogdHJ1ZSxcblxuICAgIHR5cGUgOiAnSW50ZWdlcidcblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZWdlcjtcblxuIiwidmFyIFR5cGUgPSByZXF1aXJlKCcuLy4uL1R5cGUnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbnZhciBOdW1lcmljID0gVHlwZS5leHRlbmQoe1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIFR5cGVzLk51bWVyaWNcbiAgICAgKlxuICAgICAqIFJlcHJlc2VudHMgYSBOdW1lcmljIHR5cGUuXG4gICAgICpcbiAgICAgKiBUaGlzIGNsYXNzIHNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkLiBJdCBpcyBvbmx5IHVzZWRcbiAgICAgKiB0byByZXByZXNlbnQgcmVsYXRpb24gaGVhZGVyIGF0dHJpYnV0ZSB0eXBlcyBvciBmdW5jdGlvbiByZXR1cm4gdHlwZXMuXG4gICAgICovXG5cbn0sIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqXG4gICAgICogQ29lcmNlcyBhbiBhcmJpdHJhcnkgdmFsdWUgdG8gdHlwZSBmbG9hdFxuICAgICAqXG4gICAgICovXG4gICAgY29lcmNlIDogZnVuY3Rpb24odmFsdWUpe1xuXG4gICAgICAgIGlmKF8uaXNOdW1iZXIodmFsdWUpKXtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKHZhbHVlKSl7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNaXhpbnMgZm9yIE51bWVyaWMgdHlwZXNcbiAgICAgKi9cbiAgICBwYXlsb2FkIDogW1xuICAgICAgICByZXF1aXJlKCcuLy4uL21peGlucy9jb21wYXJhYmxlJyksXG4gICAgICAgIHJlcXVpcmUoJy4vLi4vbWl4aW5zL3NpemUtY29tcGFyYWJsZScpLFxuICAgICAgICByZXF1aXJlKCcuLy4uL21peGlucy9udW1lcmljJyksXG4gICAgICAgIHJlcXVpcmUoJy4vLi4vbWl4aW5zL2Nvbm5lY3RhYmxlJyksXG4gICAgICAgIHJlcXVpcmUoJy4vLi4vbWl4aW5zL25vdCcpXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBOdW1lcmljIG9iamVjdFxuICAgICAqIEBwYXJhbSBudW1lcmljXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgdmFsdWUgOiBmdW5jdGlvbihudW1lcmljKXtcblxuICAgICAgICByZXR1cm4gbnVtZXJpYztcblxuICAgIH0sXG5cbiAgICBlcXVhbDogZnVuY3Rpb24gKG51bWVyaWMxLCBudW1lcmljMikge1xuXG4gICAgICAgIHJldHVybiAobnVtZXJpYzEgPT09IG51bWVyaWMyKTtcblxuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ051bWVyaWMnXG4gICAgfSxcblxuICAgIHByaW1pdGl2ZSA6IHRydWUsXG5cbiAgICB0eXBlIDogJ051bWVyaWMnXG5cbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTnVtZXJpYztcblxuIiwidmFyIFR5cGUgPSByZXF1aXJlKCcuLy4uL1R5cGUnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbnZhciBUT2JqZWN0ID0gVHlwZS5leHRlbmQoe1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIFR5cGVzLk9iamVjdFxuICAgICAqIEBleHRlbmRzIFR5cGVcbiAgICAgKlxuICAgICAqIFJlcHJlc2VudHMgYW4gT2JqZWN0IFR5cGUuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG5ldyBPYmplY3QgaW5zdGFuY2VzXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICovXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgICAgIFR5cGUuYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG5cbiAgICAgICAgaWYoXy5pc09iamVjdCh2YWx1ZSkpe1xuICAgICAgICAgICAgXy5leHRlbmQodGhpcywgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5uYW1lID0gJ09iamVjdCc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBPYmplY3QgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgcmV0dXJuICdPYmplY3QnO1xuXG4gICAgfVxuXG59LCB7XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gY29lcmNlIGFuIGFyYml0cmFyeSB2YWx1ZSBpbnRvIGFuIE9iamVjdCBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgY29lcmNlIDogZnVuY3Rpb24odmFsdWUpe1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNaXhpbnMgZm9yIE9iamVjdCB0eXBlXG4gICAgICovXG4gICAgcGF5bG9hZCA6IFtcbiAgICAgICAgcmVxdWlyZSgnLi8uLi9taXhpbnMvY29tcGFyYWJsZScpLFxuICAgICAgICByZXF1aXJlKCcuLy4uL21peGlucy9jb25uZWN0YWJsZScpLFxuICAgICAgICByZXF1aXJlKCcuLy4uL21peGlucy9ub3QnKVxuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHZhbHVlIDogZnVuY3Rpb24ob2JqZWN0KXtcblxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIGZvciBlcXVhbGl0eSBiZXR3ZWVuIHR3byBvYmplY3RzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSBvYmplY3QxXG4gICAgICogQHBhcmFtIG9iamVjdDJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBlcXVhbDogZnVuY3Rpb24gKG9iamVjdDEsIG9iamVjdDIpIHtcblxuICAgICAgICByZXR1cm4gXy5pc0VxdWFsKG9iamVjdDEsIG9iamVjdDIpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBvYmplY3RcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHJldHVybiAnT2JqZWN0J1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9iamVjdCBpcyBub3QgYSBwcmltaXRpdmUgdHlwZVxuICAgICAqL1xuICAgIHByaW1pdGl2ZSA6IGZhbHNlLFxuXG4gICAgdHlwZSA6ICdPYmplY3QnXG5cbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gVE9iamVjdDtcblxuIiwidmFyIFR5cGUgPSByZXF1aXJlKCcuLy4uL1R5cGUnKTtcbnZhciBUQm9vbGVhbiA9IHJlcXVpcmUoJy4vQm9vbGVhbicpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxudmFyIFN0cmluZyA9IFR5cGUuZXh0ZW5kKHtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBUeXBlcy5TdHJpbmdcbiAgICAgKiBAZXh0ZW5kcyBUeXBlXG4gICAgICpcbiAgICAgKiBSZXByZXNlbnRzIGEgU3RyaW5nIEF0dHJpYnV0ZSBUeXBlLlxuICAgICAqXG4gICAgICogU2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQuIEl0IGlzIG9ubHlcbiAgICAgKiB1c2VkIHRvIHJlcHJlc2VudCByZWxhdGlvbiBoZWFkZXIgYXR0cmlidXRlIHR5cGVzIG9yIGZ1bmN0aW9uIHJldHVybiB0eXBlcy5cbiAgICAgKlxuICAgICAqL1xuXG59LCB7XG5cbiAgICBjb2VyY2UgOiBmdW5jdGlvbih2YWx1ZSl7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1peGlucyBmb3IgU3RyaW5nIHR5cGVzXG4gICAgICovXG4gICAgcGF5bG9hZCA6IFtcbiAgICAgICAgcmVxdWlyZSgnLi8uLi9taXhpbnMvY29tcGFyYWJsZScpLFxuICAgICAgICByZXF1aXJlKCcuLy4uL21peGlucy9zaXplLWNvbXBhcmFibGUnKSxcbiAgICAgICAgcmVxdWlyZSgnLi8uLi9taXhpbnMvY29ubmVjdGFibGUnKSxcbiAgICAgICAgcmVxdWlyZSgnLi8uLi9taXhpbnMvbm90JyksXG4gICAgICAgIHJlcXVpcmUoJy4vLi4vbWl4aW5zL3N0cmluZycpLFxuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgZm9yIGVxdWFsaXR5IGJldHdlZW4gdHdvIHN0cmluZ3NcbiAgICAgKiBAcGFyYW0gc3RyMVxuICAgICAqIEBwYXJhbSBzdHIyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZXF1YWw6IGZ1bmN0aW9uIChzdHIxLCBzdHIyKSB7XG5cbiAgICAgICAgcmV0dXJuIHN0cjIgPT09IHN0cjE7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgU3RyaW5nIFR5cGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnU3RyaW5nJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdHJpbmcgaXMgYSBwcmltaXRpdmVcbiAgICAgKi9cbiAgICBwcmltaXRpdmUgOiB0cnVlLFxuXG4gICAgdHlwZSA6ICdUU3RyaW5nJ1xuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdHJpbmc7XG5cbiIsInZhciBUeXBlID0gcmVxdWlyZSgnLi8uLi9UeXBlJyk7XG52YXIgVEJvb2xlYW4gPSByZXF1aXJlKCcuL0Jvb2xlYW4nKTtcblxudmFyIFRUeXBlID0gVHlwZS5leHRlbmQoe1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIFR5cGVzLlR5cGVcbiAgICAgKiBAZXh0ZW5kcyBUeXBlXG4gICAgICpcbiAgICAgKiBSZXByZXNlbnRzIGEgVHlwZSBBdHRyaWJ1dGUgdHlwZS5cbiAgICAgKlxuICAgICAqIFNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkLiBJdCBpcyBvbmx5XG4gICAgICogdXNlZCB0byByZXByZXNlbnQgcmVsYXRpb24gaGVhZGVyIGF0dHJpYnV0ZSB0eXBlcyBvciBmdW5jdGlvbiByZXR1cm4gdHlwZXMuXG4gICAgICpcbiAgICAgKi9cblxufSwge1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdHdvIFR5cGVzIGFyZSBlcXVhbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHR5cGUxXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHlwZTJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBlcXVhbDogZnVuY3Rpb24gKHR5cGUxLCB0eXBlMikge1xuXG4gICAgICAgIHJldHVybiAodHlwZTEgPT09IHR5cGUyKTtcblxuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1R5cGUnXG4gICAgfSxcblxuICAgIHR5cGUgOiAnVHlwZSdcblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVFR5cGU7XG5cbiIsIi8qKlxuICogQGNsYXNzIEFmZmluaXR5XG4gKiBAdHlwZSB7T2JqZWN0fSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xudmFyIGFmZmluaXR5ID0ge307XG5cbi8vcmVnaW9uIFR5cGVzXG5cbi8qKlxuICogQG1lbWJlciBBZmZpbml0eVxuICogQHR5cGUge0luZGV4fVxuICovXG5hZmZpbml0eS5JbmRleCA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvSW5kZXguanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7VHlwZXMuVHlwZX0gIFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5UeXBlID0gcmVxdWlyZSgnLi9hZmZpbml0eS90eXBlcy9UeXBlLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge1NldH0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LlNldCA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvU2V0LmpzJyk7XG5cbi8qKlxuICogQHR5cGUge1JlbGF0aW9ufSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuUmVsYXRpb24gPSByZXF1aXJlKCcuL2FmZmluaXR5L1JlbGF0aW9uLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge1R1cGxlfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuVHVwbGUgPSByZXF1aXJlKCcuL2FmZmluaXR5L1R1cGxlLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge0hlYWRlcn0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LkhlYWRlciA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvSGVhZGVyLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge0F0dHJpYnV0ZX0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LkF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvQXR0cmlidXRlLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge1R5cGVzLk9iamVjdH0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5Lk9iamVjdCA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvdHlwZXMvT2JqZWN0Jyk7XG5cbi8qKlxuICogQHR5cGUge1R5cGVzLkludGVnZXJ9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5JbnRlZ2VyID0gcmVxdWlyZSgnLi9hZmZpbml0eS90eXBlcy9JbnRlZ2VyJyk7XG5cbi8qKlxuICogQHR5cGUge1R5cGVzLkZsb2F0fSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuRmxvYXQgPSByZXF1aXJlKCcuL2FmZmluaXR5L3R5cGVzL0Zsb2F0Jyk7XG5cbi8qKlxuICogQHR5cGUge1R5cGVzLlN0cmluZ30gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LlN0cmluZyA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvdHlwZXMvU3RyaW5nJyk7XG5cbi8qKlxuICogQHR5cGUge1R5cGVzLkJvb2xlYW59IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5Cb29sZWFuID0gcmVxdWlyZSgnLi9hZmZpbml0eS90eXBlcy9Cb29sZWFuJyk7XG5cbi8qKlxuICogQHR5cGUge1R5cGVzLkRhdGV9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5EYXRlID0gcmVxdWlyZSgnLi9hZmZpbml0eS90eXBlcy9EYXRlJyk7XG4vL2VuZHJlZ2lvblxuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbn0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LkZ1bmN0aW9uID0gcmVxdWlyZSgnLi9hZmZpbml0eS9GdW5jdGlvbi5qcycpO1xuXG4vL3JlZ2lvbiBDb25uZWN0aXZlIEZ1bmN0aW9uc1xuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuQ29ubmVjdGl2ZS5BbmR9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5BbmQgPSByZXF1aXJlKCcuL2FmZmluaXR5L2Z1bmN0aW9ucy9jb25uZWN0aXZlL0FuZC5qcycpO1xuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuQ29ubmVjdGl2ZS5Pcn0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5Lk9yID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvY29ubmVjdGl2ZS9Pci5qcycpO1xuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuQ29ubmVjdGl2ZS5Ob3R9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5Ob3QgPSByZXF1aXJlKCcuL2FmZmluaXR5L2Z1bmN0aW9ucy9jb25uZWN0aXZlL05vdC5qcycpO1xuLy9lbmRyZWdpb25cblxuLy9yZWdpb24gQ29tcGFyYXRpdmUgRnVuY3Rpb25zXG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5Db21wYXJhYmxlLkVxdWFsfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuRXF1YWwgPSByZXF1aXJlKCcuL2FmZmluaXR5L2Z1bmN0aW9ucy9jb21wYXJhYmxlL0VxdWFsLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5Db21wYXJhYmxlLkVxdWFsfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuZXEgPSBmdW5jdGlvbihhdHRyMSwgYXR0cjIpe1xuICAgIHJldHVybiBuZXcgYWZmaW5pdHkuRXF1YWwoYXR0cjEsIGF0dHIyKTtcbn07XG5cblxuLyoqXG4gKiBAdHlwZSB7RnVuY3Rpb25zLkNvbXBhcmFibGUuR3JlYXRlclRoYW59IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5HcmVhdGVyVGhhbiA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL2NvbXBhcmFibGUvR3JlYXRlclRoYW4uanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7RnVuY3Rpb25zLkNvbXBhcmFibGUuR3JlYXRlclRoYW59IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5ndCA9IGZ1bmN0aW9uKGF0dHIxLCBhdHRyMil7XG4gICAgcmV0dXJuIG5ldyBhZmZpbml0eS5HcmVhdGVyVGhhbihhdHRyMSwgYXR0cjIpO1xufTtcblxuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuQ29tcGFyYWJsZS5HcmVhdGVyVGhhbkVxdWFsfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuR3JlYXRlclRoYW5FcXVhbCA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL2NvbXBhcmFibGUvR3JlYXRlclRoYW5FcXVhbC5qcycpO1xuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuQ29tcGFyYWJsZS5HcmVhdGVyVGhhbkVxdWFsfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuZ3RlID0gZnVuY3Rpb24oYXR0cjEsIGF0dHIyKXtcbiAgICByZXR1cm4gbmV3IGFmZmluaXR5LkdyZWF0ZXJUaGFuRXF1YWwoYXR0cjEsIGF0dHIyKTtcbn07XG5cblxuLyoqXG4gKiBAdHlwZSB7RnVuY3Rpb25zLkNvbXBhcmFibGUuU21hbGxlclRoYW59IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5TbWFsbGVyVGhhbiA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL2NvbXBhcmFibGUvU21hbGxlclRoYW4uanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7RnVuY3Rpb25zLkNvbXBhcmFibGUuU21hbGxlclRoYW59IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5zdCA9IGZ1bmN0aW9uKGF0dHIxLCBhdHRyMil7XG4gICAgcmV0dXJuIG5ldyBhZmZpbml0eS5TbWFsbGVyVGhhbihhdHRyMSwgYXR0cjIpO1xufTtcblxuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuQ29tcGFyYWJsZS5TbWFsbGVyVGhhbkVxdWFsfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuU21hbGxlclRoYW5FcXVhbCA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL2NvbXBhcmFibGUvU21hbGxlclRoYW5FcXVhbC5qcycpO1xuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuQ29tcGFyYWJsZS5TbWFsbGVyVGhhbkVxdWFsfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuc3RlID0gZnVuY3Rpb24oYXR0cjEsIGF0dHIyKXtcbiAgICByZXR1cm4gbmV3IGFmZmluaXR5LlNtYWxsZXJUaGFuRXF1YWwoYXR0cjEsIGF0dHIyKTtcbn07XG5cbi8vZW5kcmVnaW9uXG5cbi8vcmVnaW9uIE51bWVyaWMgRnVuY3Rpb25zXG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5OdW1lcmljLkFic29sdXRlfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuQWJzb2x1dGUgPSByZXF1aXJlKCcuL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL0Fic29sdXRlLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5OdW1lcmljLkNlaWx9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5DZWlsID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvbnVtZXJpYy9DZWlsLmpzJyk7XG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuTnVtZXJpYy5Db3NpbmV9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5Db3NpbmUgPSByZXF1aXJlKCcuL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL0Nvc2luZS5qcycpO1xuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuTnVtZXJpYy5EaXZpc2lvbn0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LkRpdmlzaW9uID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvbnVtZXJpYy9EaXZpc2lvbi5qcycpO1xuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuTnVtZXJpYy5FeHBvbmVudGlhbH0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LkV4cG9uZW50aWFsID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvbnVtZXJpYy9FeHBvbmVudGlhbC5qcycpO1xuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuTnVtZXJpYy5GbG9vcn0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LkZsb29yID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvbnVtZXJpYy9GbG9vci5qcycpO1xuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuTnVtZXJpYy5NaW51c30gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5Lk1pbnVzID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvbnVtZXJpYy9NaW51cy5qcycpO1xuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuTnVtZXJpYy5Nb2R1bG99IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5Nb2R1bG8gPSByZXF1aXJlKCcuL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL01vZHVsby5qcycpO1xuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuTnVtZXJpYy5NdWx0aXBsaWNhdGlvbn0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5Lk11bHRpcGxpY2F0aW9uID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvbnVtZXJpYy9NdWx0aXBsaWNhdGlvbi5qcycpO1xuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuTnVtZXJpYy5QbHVzfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuUGx1cyA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL251bWVyaWMvUGx1cy5qcycpO1xuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuTnVtZXJpYy5Qb3dlcn0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LlBvd2VyID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvbnVtZXJpYy9Qb3dlci5qcycpO1xuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuTnVtZXJpYy5Sb3VuZH0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LlJvdW5kID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvbnVtZXJpYy9Sb3VuZC5qcycpO1xuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuTnVtZXJpYy5TaW5lfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuU2luZSA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL251bWVyaWMvU2luZS5qcycpO1xuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuTnVtZXJpYy5TcXVhcmVSb290fSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuU3F1YXJlUm9vdCA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL251bWVyaWMvU3F1YXJlUm9vdC5qcycpO1xuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuTnVtZXJpYy5UYW5nZW50fSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuVGFuZ2VudCA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL251bWVyaWMvVGFuZ2VudC5qcycpO1xuXG4vKipcbiAqIEBwYXJhbSBhdHRyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb25zLk51bWVyaWMuQWJzb2x1dGV9XG4gKi9cbmFmZmluaXR5LmFicyA9IGZ1bmN0aW9uKGF0dHIpe1xuICAgIHJldHVybiBuZXcgYWZmaW5pdHkuQWJzb2x1dGUoYXR0cik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSBhdHRyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb25zLk51bWVyaWMuQ2VpbH1cbiAqL1xuYWZmaW5pdHkuY2VpbCA9IGZ1bmN0aW9uKGF0dHIpe1xuICAgIHJldHVybiBuZXcgYWZmaW5pdHkuQ2VpbChhdHRyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIGF0dHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnMuTnVtZXJpYy5GbG9vcn1cbiAqL1xuYWZmaW5pdHkuZmxvb3IgPSBmdW5jdGlvbihhdHRyKXtcbiAgICByZXR1cm4gbmV3IGFmZmluaXR5LkZsb29yKGF0dHIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gYXR0clxuICogQHJldHVybnMge0Z1bmN0aW9ucy5OdW1lcmljLkNvc2luZX1cbiAqL1xuYWZmaW5pdHkuY29zID0gZnVuY3Rpb24oYXR0cil7XG4gICAgcmV0dXJuIG5ldyBhZmZpbml0eS5Db3NpbmUoYXR0cik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSBhdHRyMVxuICogQHBhcmFtIGF0dHIyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb25zLk51bWVyaWMuRGl2aXNpb259XG4gKi9cbmFmZmluaXR5LmRpdiA9IGZ1bmN0aW9uKGF0dHIxLCBhdHRyMil7XG4gICAgcmV0dXJuIG5ldyBhZmZpbml0eS5EaXZpc2lvbihhdHRyMSwgYXR0cjIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gYXR0clxuICogQHJldHVybnMge0Z1bmN0aW9ucy5OdW1lcmljLkV4cG9uZW50aWFsfVxuICovXG5hZmZpbml0eS5leHAgPSBmdW5jdGlvbihhdHRyKXtcbiAgICByZXR1cm4gbmV3IGFmZmluaXR5LkV4cG9uZW50aWFsKGF0dHIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gYXR0cjFcbiAqIEBwYXJhbSBhdHRyMlxuICogQHJldHVybnMge0Z1bmN0aW9ucy5OdW1lcmljLk1pbnVzfVxuICovXG5hZmZpbml0eS5taW51cyA9IGZ1bmN0aW9uKGF0dHIxLCBhdHRyMil7XG4gICAgcmV0dXJuIG5ldyBhZmZpbml0eS5NaW51cyhhdHRyMSwgYXR0cjIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gYXR0cjFcbiAqIEBwYXJhbSBhdHRyMlxuICogQHJldHVybnMge0Z1bmN0aW9ucy5OdW1lcmljLk1vZHVsb31cbiAqL1xuYWZmaW5pdHkubW9kID0gZnVuY3Rpb24oYXR0cjEsIGF0dHIyKXtcbiAgICByZXR1cm4gbmV3IGFmZmluaXR5Lk1vZHVsbyhhdHRyMSwgYXR0cjIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gYXR0cjFcbiAqIEBwYXJhbSBhdHRyMlxuICogQHJldHVybnMge0Z1bmN0aW9ucy5OdW1lcmljLk11bHRpcGxpY2F0aW9ufVxuICovXG5hZmZpbml0eS50aW1lcyA9IGZ1bmN0aW9uKGF0dHIxLCBhdHRyMil7XG4gICAgcmV0dXJuIG5ldyBhZmZpbml0eS5NdWx0aXBsaWNhdGlvbihhdHRyMSwgYXR0cjIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gYXR0cjFcbiAqIEBwYXJhbSBhdHRyMlxuICogQHJldHVybnMge0Z1bmN0aW9ucy5OdW1lcmljLlBsdXN9XG4gKi9cbmFmZmluaXR5LnBsdXMgPSBmdW5jdGlvbihhdHRyMSwgYXR0cjIpe1xuICAgIHJldHVybiBuZXcgYWZmaW5pdHkuUGx1cyhhdHRyMSwgYXR0cjIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gYXR0cjFcbiAqIEBwYXJhbSBhdHRyMlxuICogQHJldHVybnMge0Z1bmN0aW9ucy5OdW1lcmljLlBvd2VyfVxuICovXG5hZmZpbml0eS5wb3cgPSBmdW5jdGlvbihhdHRyMSwgYXR0cjIpe1xuICAgIHJldHVybiBuZXcgYWZmaW5pdHkuUG93ZXIoYXR0cjEsIGF0dHIyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIGF0dHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnMuTnVtZXJpYy5Sb3VuZH1cbiAqL1xuYWZmaW5pdHkucm91bmQgPSBmdW5jdGlvbihhdHRyKXtcbiAgICByZXR1cm4gbmV3IGFmZmluaXR5LlJvdW5kKGF0dHIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gYXR0clxuICogQHJldHVybnMge0Z1bmN0aW9ucy5OdW1lcmljLlNpbmV9XG4gKi9cbmFmZmluaXR5LnNpbiA9IGZ1bmN0aW9uKGF0dHIpe1xuICAgIHJldHVybiBuZXcgYWZmaW5pdHkuU2luZShhdHRyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIGF0dHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnMuTnVtZXJpYy5TcXVhcmVSb290fVxuICovXG5hZmZpbml0eS5zcXJ0ID0gZnVuY3Rpb24oYXR0cil7XG4gICAgcmV0dXJuIG5ldyBhZmZpbml0eS5TcXVhcmVSb290KGF0dHIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gYXR0clxuICogQHJldHVybnMge0Z1bmN0aW9ucy5OdW1lcmljLlRhbmdlbnR9XG4gKi9cbmFmZmluaXR5LnRhbiA9IGZ1bmN0aW9uKGF0dHIpe1xuICAgIHJldHVybiBuZXcgYWZmaW5pdHkuVGFuZ2VudChhdHRyKTtcbn07XG4vL2VuZHJlZ2lvblxuXG4vL3JlZ2lvbiBTdHJpbmcgRnVuY3Rpb25zXG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5TdHJpbmcuTGVuZ3RofSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuTGVuZ3RoID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvc3RyaW5nL0xlbmd0aC5qcycpO1xuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuU3RyaW5nLkxvd2VyY2FzZX0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5Lkxvd2VyY2FzZSA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL3N0cmluZy9Mb3dlcmNhc2UuanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7RnVuY3Rpb25zLlN0cmluZy5UZXN0fSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuVGVzdCA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL3N0cmluZy9UZXN0LmpzJyk7XG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5TdHJpbmcuU3Vic3RyaW5nfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuU3Vic3RyaW5nID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvc3RyaW5nL1N1YnN0cmluZy5qcycpO1xuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuU3RyaW5nLlVwcGVyY2FzZX0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LlVwcGVyY2FzZSA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL3N0cmluZy9VcHBlcmNhc2UuanMnKTtcblxuLyoqXG4gKiBAcGFyYW0gYXR0clxuICogQHJldHVybnMge0Z1bmN0aW9ucy5TdHJpbmcuTGVuZ3RofVxuICovXG5hZmZpbml0eS5sZW5ndGggPSBmdW5jdGlvbihhdHRyKXtcbiAgICByZXR1cm4gbmV3IGFmZmluaXR5Lkxlbmd0aChhdHRyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIGF0dHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnMuU3RyaW5nLkxvd2VyY2FzZX1cbiAqL1xuYWZmaW5pdHkubG93ZXJjYXNlID0gZnVuY3Rpb24oYXR0cil7XG4gICAgcmV0dXJuIG5ldyBhZmZpbml0eS5Mb3dlcmNhc2UoYXR0cik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSBhdHRyXG4gKiBAcGFyYW0gcmVnZXhcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnMuU3RyaW5nLlRlc3R9XG4gKi9cbmFmZmluaXR5LnRlc3QgPSBmdW5jdGlvbihhdHRyLCByZWdleCl7XG4gICAgcmV0dXJuIG5ldyBhZmZpbml0eS5UZXN0KGF0dHIsIHJlZ2V4KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIGF0dHJcbiAqIEBwYXJhbSBzdGFydFxuICogQHBhcmFtIGxlbmd0aFxuICogQHJldHVybnMge0Z1bmN0aW9ucy5TdHJpbmcuU3Vic3RyaW5nfVxuICovXG5hZmZpbml0eS5zdWJzdHIgPSBmdW5jdGlvbihhdHRyLCBzdGFydCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gbmV3IGFmZmluaXR5Lkxlbmd0aChhdHRyLCBzdGFydCwgbGVuZ3RoKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIGF0dHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnMuU3RyaW5nLlVwcGVyY2FzZX1cbiAqL1xuYWZmaW5pdHkudXBwZXJjYXNlID0gZnVuY3Rpb24oYXR0cil7XG4gICAgcmV0dXJuIG5ldyBhZmZpbml0eS5MZW5ndGgoYXR0cik7XG59O1xuLy9lbmRyZWdpb25cblxuLy9yZWdpb24gVHVwbGUgRnVuY3Rpb25zXG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5UdXBsZS5BdHRyaWJ1dGVWYWx1ZX0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LlR1cGxlVmFsdWUgPSByZXF1aXJlKCcuL2FmZmluaXR5L2Z1bmN0aW9ucy90dXBsZS9BdHRyaWJ1dGUuanMnKTtcblxuLyoqXG4gKiBAcGFyYW0gcmVsYXRpb25cbiAqIEBwYXJhbSBhdHRyaWJ1dGVOYW1lXG4gKiBAcmV0dXJucyB7RnVuY3Rpb25zLlR1cGxlLkF0dHJpYnV0ZVZhbHVlfVxuICovXG5hZmZpbml0eS52YWx1ZSA9IGZ1bmN0aW9uKHJlbGF0aW9uLCBhdHRyaWJ1dGVOYW1lKXtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IGFmZmluaXR5LlR1cGxlVmFsdWUoYXR0cmlidXRlTmFtZSk7XG4gICAgcmVzdWx0LnR5cGUocmVsYXRpb24uaGVhZGVyKCkuZ2V0KGF0dHJpYnV0ZU5hbWUpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbi8vZW5kcmVnaW9uXG5cbi8vcmVnaW9uIERhdGUgRnVuY3Rpb25zXG5cbmFmZmluaXR5LkRheU9mTW9udGggPSByZXF1aXJlKCcuL2FmZmluaXR5L2Z1bmN0aW9ucy9kYXRlL0RheU9mTW9udGguanMnKTtcbmFmZmluaXR5LkRheU9mTW9udGggPSByZXF1aXJlKCcuL2FmZmluaXR5L2Z1bmN0aW9ucy9kYXRlL0RheU9mTW9udGguanMnKTtcbmFmZmluaXR5LkRheU9mV2VlayA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL2RhdGUvRGF5T2ZXZWVrLmpzJyk7XG5hZmZpbml0eS5EYXlPZlllYXIgPSByZXF1aXJlKCcuL2FmZmluaXR5L2Z1bmN0aW9ucy9kYXRlL0RheU9mWWVhci5qcycpO1xuYWZmaW5pdHkuSG91cnMgPSByZXF1aXJlKCcuL2FmZmluaXR5L2Z1bmN0aW9ucy9kYXRlL0hvdXJzLmpzJyk7XG5hZmZpbml0eS5NaWxsaXNlY29uZHMgPSByZXF1aXJlKCcuL2FmZmluaXR5L2Z1bmN0aW9ucy9kYXRlL01pbGxpc2Vjb25kcy5qcycpO1xuYWZmaW5pdHkuTWludXRlcyA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL2RhdGUvTWludXRlcy5qcycpO1xuYWZmaW5pdHkuTW9udGggPSByZXF1aXJlKCcuL2FmZmluaXR5L2Z1bmN0aW9ucy9kYXRlL01vbnRoLmpzJyk7XG5hZmZpbml0eS5TZWNvbmRzID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvZGF0ZS9TZWNvbmRzLmpzJyk7XG5hZmZpbml0eS5UaW1lc3RhbXAgPSByZXF1aXJlKCcuL2FmZmluaXR5L2Z1bmN0aW9ucy9kYXRlL1RpbWVzdGFtcC5qcycpO1xuYWZmaW5pdHkuV2Vla09mWWVhciA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL2RhdGUvV2Vla09mWWVhci5qcycpO1xuYWZmaW5pdHkuWWVhciA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL2RhdGUvWWVhci5qcycpO1xuLy9lbmRyZWdpb25cblxuYWZmaW5pdHkuY291bnQgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBuZXcgKHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL2FnZ3JlZ2F0ZS9Db3VudC5qcycpKTtcbn07XG5cbi8vcmVnaW9uIFJlbGF0aW9uYWwgT3BlcmF0b3JzXG5cbi8qKlxuICogQHR5cGUge09wZXJhdG9ycy5Db21wb3NpdGlvbn0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LkNvbXBvc2l0aW9uID0gcmVxdWlyZSgnLi9hZmZpbml0eS9hbGdlYnJhL0NvbXBvc2l0aW9uLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge09wZXJhdG9ycy5EaWZmZXJlbmNlfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuRGlmZmVyZW5jZSA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvYWxnZWJyYS9EaWZmZXJlbmNlLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge09wZXJhdG9ycy5FeHRlbnNpb259IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5FeHRlbnNpb24gPSByZXF1aXJlKCcuL2FmZmluaXR5L2FsZ2VicmEvRXh0ZW5zaW9uLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge09wZXJhdG9ycy5Hcm91cH0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5Lkdyb3VwID0gcmVxdWlyZSgnLi9hZmZpbml0eS9hbGdlYnJhL0dyb3VwLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge09wZXJhdG9ycy5JbnRlcnNlY3Rpb259IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5JbnRlcnNlY3Rpb24gPSByZXF1aXJlKCcuL2FmZmluaXR5L2FsZ2VicmEvSW50ZXJzZWN0aW9uLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge09wZXJhdG9ycy5Kb2lufSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuSm9pbiA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvYWxnZWJyYS9Kb2luLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge09wZXJhdG9ycy5Qcm9kdWN0fSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuUHJvZHVjdCA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvYWxnZWJyYS9Qcm9kdWN0LmpzJyk7XG5cbi8qKlxuICogQHR5cGUge09wZXJhdG9ycy5Qcm9qZWN0aW9ufSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuUHJvamVjdGlvbiA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvYWxnZWJyYS9Qcm9qZWN0aW9uLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge09wZXJhdG9ycy5SZW5hbWV9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5SZW5hbWUgPSByZXF1aXJlKCcuL2FmZmluaXR5L2FsZ2VicmEvUmVuYW1lLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge09wZXJhdG9ycy5SZXN0cmljdGlvbn0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LlJlc3RyaWN0aW9uID0gcmVxdWlyZSgnLi9hZmZpbml0eS9hbGdlYnJhL1Jlc3RyaWN0aW9uLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge09wZXJhdG9ycy5TZW1pRGlmZmVyZW5jZX0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LlNlbWlEaWZmZXJlbmNlID0gcmVxdWlyZSgnLi9hZmZpbml0eS9hbGdlYnJhL1NlbWlkaWZmZXJlbmNlLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge09wZXJhdG9ycy5TZW1pSm9pbn0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LlNlbWlKb2luID0gcmVxdWlyZSgnLi9hZmZpbml0eS9hbGdlYnJhL1NlbWlqb2luLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge09wZXJhdG9ycy5Vbmdyb3VwfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuVW5ncm91cCA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvYWxnZWJyYS9Vbmdyb3VwLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge09wZXJhdG9ycy5Vbmlvbn0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LlVuaW9uID0gcmVxdWlyZSgnLi9hZmZpbml0eS9hbGdlYnJhL1VuaW9uLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge09wZXJhdG9ycy5VbndyYXB9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5VbndyYXAgPSByZXF1aXJlKCcuL2FmZmluaXR5L2FsZ2VicmEvVW53cmFwLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge09wZXJhdG9ycy5XcmFwfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuV3JhcCA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvYWxnZWJyYS9XcmFwLmpzJyk7XG4vL2VuZHJlZ2lvblxuXG4vL3JlZ2lvbiBDb25zdGFudHNcblxuLyoqXG4gKiBAdHlwZSB7UmVsYXRpb259IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5UQUJMRV9EVU0gPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW10pO1xuXG4vKipcbiAqIEB0eXBlIHtSZWxhdGlvbn0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LlRBQkxFX0RFRSA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXSwgW1xuICAgIFtdXG5dKTtcbi8vZW5kcmVnaW9uXG5cbm1vZHVsZS5leHBvcnRzID0gYWZmaW5pdHk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgRXZlbnRFbWl0dGVyIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEV2ZW50IGhhbmRsZXIgdG8gYmUgY2FsbGVkLlxuICogQHBhcmFtIHtNaXhlZH0gY29udGV4dCBDb250ZXh0IGZvciBmdW5jdGlvbiBleGVjdXRpb24uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSBlbWl0IG9uY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFRShmbiwgY29udGV4dCwgb25jZSkge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMub25jZSA9IG9uY2UgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogTWluaW1hbCBFdmVudEVtaXR0ZXIgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcbiAqIEV2ZW50RW1pdHRlciBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7IC8qIE5vdGhpbmcgdG8gc2V0ICovIH1cblxuLyoqXG4gKiBIb2xkcyB0aGUgYXNzaWduZWQgRXZlbnRFbWl0dGVycyBieSBuYW1lLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5cbi8qKlxuICogUmV0dXJuIGEgbGlzdCBvZiBhc3NpZ25lZCBldmVudCBsaXN0ZW5lcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBldmVudHMgdGhhdCBzaG91bGQgYmUgbGlzdGVkLlxuICogQHJldHVybnMge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1tldmVudF0pIHJldHVybiBbXTtcbiAgaWYgKHRoaXMuX2V2ZW50c1tldmVudF0uZm4pIHJldHVybiBbdGhpcy5fZXZlbnRzW2V2ZW50XS5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9ldmVudHNbZXZlbnRdLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IHRoaXMuX2V2ZW50c1tldmVudF1baV0uZm47XG4gIH1cblxuICByZXR1cm4gZWU7XG59O1xuXG4vKipcbiAqIEVtaXQgYW4gZXZlbnQgdG8gYWxsIHJlZ2lzdGVyZWQgZXZlbnQgbGlzdGVuZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSW5kaWNhdGlvbiBpZiB3ZSd2ZSBlbWl0dGVkIGFuIGV2ZW50LlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbZXZlbnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldmVudF1cbiAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGFyZ3NcbiAgICAsIGk7XG5cbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB0cnVlKTtcblxuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIG5ldyBFdmVudExpc3RlbmVyIGZvciB0aGUgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IE5hbWUgb2YgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtGdW5jdG9ufSBmbiBDYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7TWl4ZWR9IGNvbnRleHQgVGhlIGNvbnRleHQgb2YgdGhlIGZ1bmN0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgdGhpcyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHt9O1xuICBpZiAoIXRoaXMuX2V2ZW50c1tldmVudF0pIHRoaXMuX2V2ZW50c1tldmVudF0gPSBsaXN0ZW5lcjtcbiAgZWxzZSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHNbZXZlbnRdLmZuKSB0aGlzLl9ldmVudHNbZXZlbnRdLnB1c2gobGlzdGVuZXIpO1xuICAgIGVsc2UgdGhpcy5fZXZlbnRzW2V2ZW50XSA9IFtcbiAgICAgIHRoaXMuX2V2ZW50c1tldmVudF0sIGxpc3RlbmVyXG4gICAgXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gRXZlbnRMaXN0ZW5lciB0aGF0J3Mgb25seSBjYWxsZWQgb25jZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgTmFtZSBvZiB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBDYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7TWl4ZWR9IGNvbnRleHQgVGhlIGNvbnRleHQgb2YgdGhlIGZ1bmN0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IHRoaXMsIHRydWUpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTtcbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZlbnRdKSB0aGlzLl9ldmVudHNbZXZlbnRdID0gbGlzdGVuZXI7XG4gIGVsc2Uge1xuICAgIGlmICghdGhpcy5fZXZlbnRzW2V2ZW50XS5mbikgdGhpcy5fZXZlbnRzW2V2ZW50XS5wdXNoKGxpc3RlbmVyKTtcbiAgICBlbHNlIHRoaXMuX2V2ZW50c1tldmVudF0gPSBbXG4gICAgICB0aGlzLl9ldmVudHNbZXZlbnRdLCBsaXN0ZW5lclxuICAgIF07XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IHdlIHdhbnQgdG8gcmVtb3ZlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIHRoYXQgd2UgbmVlZCB0byBmaW5kLlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uY2UgbGlzdGVuZXJzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgb25jZSkge1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW2V2ZW50XSkgcmV0dXJuIHRoaXM7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldmVudF1cbiAgICAsIGV2ZW50cyA9IFtdO1xuXG4gIGlmIChmbikge1xuICAgIGlmIChsaXN0ZW5lcnMuZm4gJiYgKGxpc3RlbmVycy5mbiAhPT0gZm4gfHwgKG9uY2UgJiYgIWxpc3RlbmVycy5vbmNlKSkpIHtcbiAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVycyk7XG4gICAgfVxuICAgIGlmICghbGlzdGVuZXJzLmZuKSBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLmZuICE9PSBmbiB8fCAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy9cbiAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAvL1xuICBpZiAoZXZlbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2V2ZW50c1tldmVudF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzIG9yIG9ubHkgdGhlIGxpc3RlbmVycyBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IHdhbnQgdG8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiB0aGlzO1xuXG4gIGlmIChldmVudCkgZGVsZXRlIHRoaXMuX2V2ZW50c1tldmVudF07XG4gIGVsc2UgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIFRoaXMgZnVuY3Rpb24gZG9lc24ndCBhcHBseSBhbnltb3JlLlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlcjIgPSBFdmVudEVtaXR0ZXI7XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyMyA9IEV2ZW50RW1pdHRlcjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogTG8tRGFzaCAyLjQuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cDovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIC1vIC4vZGlzdC9sb2Rhc2guanNgXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDEzIFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjUuMiA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTMgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cDovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuOyhmdW5jdGlvbigpIHtcblxuICAvKiogVXNlZCBhcyBhIHNhZmUgcmVmZXJlbmNlIGZvciBgdW5kZWZpbmVkYCBpbiBwcmUgRVM1IGVudmlyb25tZW50cyAqL1xuICB2YXIgdW5kZWZpbmVkO1xuXG4gIC8qKiBVc2VkIHRvIHBvb2wgYXJyYXlzIGFuZCBvYmplY3RzIHVzZWQgaW50ZXJuYWxseSAqL1xuICB2YXIgYXJyYXlQb29sID0gW10sXG4gICAgICBvYmplY3RQb29sID0gW107XG5cbiAgLyoqIFVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcyAqL1xuICB2YXIgaWRDb3VudGVyID0gMDtcblxuICAvKiogVXNlZCB0byBwcmVmaXgga2V5cyB0byBhdm9pZCBpc3N1ZXMgd2l0aCBgX19wcm90b19fYCBhbmQgcHJvcGVydGllcyBvbiBgT2JqZWN0LnByb3RvdHlwZWAgKi9cbiAgdmFyIGtleVByZWZpeCA9ICtuZXcgRGF0ZSArICcnO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzaXplIHdoZW4gb3B0aW1pemF0aW9ucyBhcmUgZW5hYmxlZCBmb3IgbGFyZ2UgYXJyYXlzICovXG4gIHZhciBsYXJnZUFycmF5U2l6ZSA9IDc1O1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBtYXggc2l6ZSBvZiB0aGUgYGFycmF5UG9vbGAgYW5kIGBvYmplY3RQb29sYCAqL1xuICB2YXIgbWF4UG9vbFNpemUgPSA0MDtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgYW5kIHRlc3Qgd2hpdGVzcGFjZSAqL1xuICB2YXIgd2hpdGVzcGFjZSA9IChcbiAgICAvLyB3aGl0ZXNwYWNlXG4gICAgJyBcXHRcXHgwQlxcZlxceEEwXFx1ZmVmZicgK1xuXG4gICAgLy8gbGluZSB0ZXJtaW5hdG9yc1xuICAgICdcXG5cXHJcXHUyMDI4XFx1MjAyOScgK1xuXG4gICAgLy8gdW5pY29kZSBjYXRlZ29yeSBcIlpzXCIgc3BhY2Ugc2VwYXJhdG9yc1xuICAgICdcXHUxNjgwXFx1MTgwZVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwJ1xuICApO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGVtcHR5IHN0cmluZyBsaXRlcmFscyBpbiBjb21waWxlZCB0ZW1wbGF0ZSBzb3VyY2UgKi9cbiAgdmFyIHJlRW1wdHlTdHJpbmdMZWFkaW5nID0gL1xcYl9fcCBcXCs9ICcnOy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ01pZGRsZSA9IC9cXGIoX19wIFxcKz0pICcnIFxcKy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXCguKj9cXCl8XFxiX190XFwpKSBcXCtcXG4nJzsvZztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBFUzYgdGVtcGxhdGUgZGVsaW1pdGVyc1xuICAgKiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1saXRlcmFscy1zdHJpbmctbGl0ZXJhbHNcbiAgICovXG4gIHZhciByZUVzVGVtcGxhdGUgPSAvXFwkXFx7KFteXFxcXH1dKig/OlxcXFwuW15cXFxcfV0qKSopXFx9L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggcmVnZXhwIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzICovXG4gIHZhciByZUZsYWdzID0gL1xcdyokLztcblxuICAvKiogVXNlZCB0byBkZXRlY3RlZCBuYW1lZCBmdW5jdGlvbnMgKi9cbiAgdmFyIHJlRnVuY05hbWUgPSAvXlxccypmdW5jdGlvblsgXFxuXFxyXFx0XStcXHcvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIFwiaW50ZXJwb2xhdGVcIiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzICovXG4gIHZhciByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyB3aGl0ZXNwYWNlIGFuZCB6ZXJvcyB0byBiZSByZW1vdmVkICovXG4gIHZhciByZUxlYWRpbmdTcGFjZXNBbmRaZXJvcyA9IFJlZ0V4cCgnXlsnICsgd2hpdGVzcGFjZSArICddKjArKD89LiQpJyk7XG5cbiAgLyoqIFVzZWQgdG8gZW5zdXJlIGNhcHR1cmluZyBvcmRlciBvZiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzICovXG4gIHZhciByZU5vTWF0Y2ggPSAvKCReKS87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGZ1bmN0aW9ucyBjb250YWluaW5nIGEgYHRoaXNgIHJlZmVyZW5jZSAqL1xuICB2YXIgcmVUaGlzID0gL1xcYnRoaXNcXGIvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscyAqL1xuICB2YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHRcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG5cbiAgLyoqIFVzZWQgdG8gYXNzaWduIGRlZmF1bHQgYGNvbnRleHRgIG9iamVjdCBwcm9wZXJ0aWVzICovXG4gIHZhciBjb250ZXh0UHJvcHMgPSBbXG4gICAgJ0FycmF5JywgJ0Jvb2xlYW4nLCAnRGF0ZScsICdGdW5jdGlvbicsICdNYXRoJywgJ051bWJlcicsICdPYmplY3QnLFxuICAgICdSZWdFeHAnLCAnU3RyaW5nJywgJ18nLCAnYXR0YWNoRXZlbnQnLCAnY2xlYXJUaW1lb3V0JywgJ2lzRmluaXRlJywgJ2lzTmFOJyxcbiAgICAncGFyc2VJbnQnLCAnc2V0VGltZW91dCdcbiAgXTtcblxuICAvKiogVXNlZCB0byBtYWtlIHRlbXBsYXRlIHNvdXJjZVVSTHMgZWFzaWVyIHRvIGlkZW50aWZ5ICovXG4gIHZhciB0ZW1wbGF0ZUNvdW50ZXIgPSAwO1xuXG4gIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgc2hvcnRjdXRzICovXG4gIHZhciBhcmdzQ2xhc3MgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICAgIGFycmF5Q2xhc3MgPSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgYm9vbENsYXNzID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgICAgZGF0ZUNsYXNzID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgICAgZnVuY0NsYXNzID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICAgIG51bWJlckNsYXNzID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgICBvYmplY3RDbGFzcyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgICAgcmVnZXhwQ2xhc3MgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICAgIHN0cmluZ0NsYXNzID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgb2JqZWN0IGNsYXNzaWZpY2F0aW9ucyB0aGF0IGBfLmNsb25lYCBzdXBwb3J0cyAqL1xuICB2YXIgY2xvbmVhYmxlQ2xhc3NlcyA9IHt9O1xuICBjbG9uZWFibGVDbGFzc2VzW2Z1bmNDbGFzc10gPSBmYWxzZTtcbiAgY2xvbmVhYmxlQ2xhc3Nlc1thcmdzQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1thcnJheUNsYXNzXSA9XG4gIGNsb25lYWJsZUNsYXNzZXNbYm9vbENsYXNzXSA9IGNsb25lYWJsZUNsYXNzZXNbZGF0ZUNsYXNzXSA9XG4gIGNsb25lYWJsZUNsYXNzZXNbbnVtYmVyQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tvYmplY3RDbGFzc10gPVxuICBjbG9uZWFibGVDbGFzc2VzW3JlZ2V4cENsYXNzXSA9IGNsb25lYWJsZUNsYXNzZXNbc3RyaW5nQ2xhc3NdID0gdHJ1ZTtcblxuICAvKiogVXNlZCBhcyBhbiBpbnRlcm5hbCBgXy5kZWJvdW5jZWAgb3B0aW9ucyBvYmplY3QgKi9cbiAgdmFyIGRlYm91bmNlT3B0aW9ucyA9IHtcbiAgICAnbGVhZGluZyc6IGZhbHNlLFxuICAgICdtYXhXYWl0JzogMCxcbiAgICAndHJhaWxpbmcnOiBmYWxzZVxuICB9O1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciBgX19iaW5kRGF0YV9fYCAqL1xuICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICAnY29uZmlndXJhYmxlJzogZmFsc2UsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBudWxsLFxuICAgICd3cml0YWJsZSc6IGZhbHNlXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHZhbHVlcyBhcmUgb2YgdGhlIGxhbmd1YWdlIHR5cGUgT2JqZWN0ICovXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICAnYm9vbGVhbic6IGZhbHNlLFxuICAgICdmdW5jdGlvbic6IHRydWUsXG4gICAgJ29iamVjdCc6IHRydWUsXG4gICAgJ251bWJlcic6IGZhbHNlLFxuICAgICdzdHJpbmcnOiBmYWxzZSxcbiAgICAndW5kZWZpbmVkJzogZmFsc2VcbiAgfTtcblxuICAvKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscyAqL1xuICB2YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICBcIidcIjogXCInXCIsXG4gICAgJ1xcbic6ICduJyxcbiAgICAnXFxyJzogJ3InLFxuICAgICdcXHQnOiAndCcsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0ICovXG4gIHZhciByb290ID0gKG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdykgfHwgdGhpcztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgICovXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgICovXG4gIHZhciBmcmVlTW9kdWxlID0gb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4gIC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AgKi9cbiAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMgJiYgZnJlZUV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSBhbmQgdXNlIGl0IGFzIGByb290YCAqL1xuICB2YXIgZnJlZUdsb2JhbCA9IG9iamVjdFR5cGVzW3R5cGVvZiBnbG9iYWxdICYmIGdsb2JhbDtcbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSkge1xuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYmluYXJ5IHNlYXJjaGVzXG4gICAqIG9yIGBmcm9tSW5kZXhgIGNvbnN0cmFpbnRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlIG9yIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHZhciBpbmRleCA9IChmcm9tSW5kZXggfHwgMCkgLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogQW4gaW1wbGVtZW50YXRpb24gb2YgYF8uY29udGFpbnNgIGZvciBjYWNoZSBvYmplY3RzIHRoYXQgbWltaWNzIHRoZSByZXR1cm5cbiAgICogc2lnbmF0dXJlIG9mIGBfLmluZGV4T2ZgIGJ5IHJldHVybmluZyBgMGAgaWYgdGhlIHZhbHVlIGlzIGZvdW5kLCBlbHNlIGAtMWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYDBgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGNhY2hlSW5kZXhPZihjYWNoZSwgdmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBjYWNoZSA9IGNhY2hlLmNhY2hlO1xuXG4gICAgaWYgKHR5cGUgPT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjYWNoZVt2YWx1ZV0gPyAwIDogLTE7XG4gICAgfVxuICAgIGlmICh0eXBlICE9ICdudW1iZXInICYmIHR5cGUgIT0gJ3N0cmluZycpIHtcbiAgICAgIHR5cGUgPSAnb2JqZWN0JztcbiAgICB9XG4gICAgdmFyIGtleSA9IHR5cGUgPT0gJ251bWJlcicgPyB2YWx1ZSA6IGtleVByZWZpeCArIHZhbHVlO1xuICAgIGNhY2hlID0gKGNhY2hlID0gY2FjaGVbdHlwZV0pICYmIGNhY2hlW2tleV07XG5cbiAgICByZXR1cm4gdHlwZSA9PSAnb2JqZWN0J1xuICAgICAgPyAoY2FjaGUgJiYgYmFzZUluZGV4T2YoY2FjaGUsIHZhbHVlKSA+IC0xID8gMCA6IC0xKVxuICAgICAgOiAoY2FjaGUgPyAwIDogLTEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBnaXZlbiB2YWx1ZSB0byB0aGUgY29ycmVzcG9uZGluZyBjYWNoZSBvYmplY3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFkZCB0byB0aGUgY2FjaGUuXG4gICAqL1xuICBmdW5jdGlvbiBjYWNoZVB1c2godmFsdWUpIHtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlLFxuICAgICAgICB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gICAgaWYgKHR5cGUgPT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgIGNhY2hlW3ZhbHVlXSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlICE9ICdudW1iZXInICYmIHR5cGUgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHlwZSA9ICdvYmplY3QnO1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHR5cGUgPT0gJ251bWJlcicgPyB2YWx1ZSA6IGtleVByZWZpeCArIHZhbHVlLFxuICAgICAgICAgIHR5cGVDYWNoZSA9IGNhY2hlW3R5cGVdIHx8IChjYWNoZVt0eXBlXSA9IHt9KTtcblxuICAgICAgaWYgKHR5cGUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgKHR5cGVDYWNoZVtrZXldIHx8ICh0eXBlQ2FjaGVba2V5XSA9IFtdKSkucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlQ2FjaGVba2V5XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8ubWF4YCBhbmQgYF8ubWluYCBhcyB0aGUgZGVmYXVsdCBjYWxsYmFjayB3aGVuIGEgZ2l2ZW5cbiAgICogY29sbGVjdGlvbiBpcyBhIHN0cmluZyB2YWx1ZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSBjaGFyYWN0ZXIgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29kZSB1bml0IG9mIGdpdmVuIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJBdENhbGxiYWNrKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgc29ydEJ5YCB0byBjb21wYXJlIHRyYW5zZm9ybWVkIGBjb2xsZWN0aW9uYCBlbGVtZW50cywgc3RhYmxlIHNvcnRpbmdcbiAgICogdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gY29tcGFyZSB0byBgYmAuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29tcGFyZSB0byBgYWAuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIG9mIGAxYCBvciBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyhhLCBiKSB7XG4gICAgdmFyIGFjID0gYS5jcml0ZXJpYSxcbiAgICAgICAgYmMgPSBiLmNyaXRlcmlhLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhYy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYWNbaW5kZXhdLFxuICAgICAgICAgIG90aGVyID0gYmNbaW5kZXhdO1xuXG4gICAgICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgICAgIGlmICh2YWx1ZSA+IG90aGVyIHx8IHR5cGVvZiB2YWx1ZSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA8IG90aGVyIHx8IHR5cGVvZiBvdGhlciA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBGaXhlcyBhbiBgQXJyYXkjc29ydGAgYnVnIGluIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgYXBwbGljYXRpb25zXG4gICAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcmV0dXJuIHRoZSBzYW1lIHZhbHVlIGZvclxuICAgIC8vIGBhYCBhbmQgYGJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAgIC8vXG4gICAgLy8gVGhpcyBhbHNvIGVuc3VyZXMgYSBzdGFibGUgc29ydCBpbiBWOCBhbmQgb3RoZXIgZW5naW5lcy5cbiAgICAvLyBTZWUgaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTBcbiAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNhY2hlIG9iamVjdCB0byBvcHRpbWl6ZSBsaW5lYXIgc2VhcmNoZXMgb2YgbGFyZ2UgYXJyYXlzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEByZXR1cm5zIHtudWxsfE9iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgb2JqZWN0IG9yIGBudWxsYCBpZiBjYWNoaW5nIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUNhY2hlKGFycmF5KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgZmlyc3QgPSBhcnJheVswXSxcbiAgICAgICAgbWlkID0gYXJyYXlbKGxlbmd0aCAvIDIpIHwgMF0sXG4gICAgICAgIGxhc3QgPSBhcnJheVtsZW5ndGggLSAxXTtcblxuICAgIGlmIChmaXJzdCAmJiB0eXBlb2YgZmlyc3QgPT0gJ29iamVjdCcgJiZcbiAgICAgICAgbWlkICYmIHR5cGVvZiBtaWQgPT0gJ29iamVjdCcgJiYgbGFzdCAmJiB0eXBlb2YgbGFzdCA9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgY2FjaGUgPSBnZXRPYmplY3QoKTtcbiAgICBjYWNoZVsnZmFsc2UnXSA9IGNhY2hlWydudWxsJ10gPSBjYWNoZVsndHJ1ZSddID0gY2FjaGVbJ3VuZGVmaW5lZCddID0gZmFsc2U7XG5cbiAgICB2YXIgcmVzdWx0ID0gZ2V0T2JqZWN0KCk7XG4gICAgcmVzdWx0LmFycmF5ID0gYXJyYXk7XG4gICAgcmVzdWx0LmNhY2hlID0gY2FjaGU7XG4gICAgcmVzdWx0LnB1c2ggPSBjYWNoZVB1c2g7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaW5kZXhdKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGB0ZW1wbGF0ZWAgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZFxuICAgKiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaCBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIobWF0Y2gpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgc3RyaW5nRXNjYXBlc1ttYXRjaF07XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbiBhcnJheSBmcm9tIHRoZSBhcnJheSBwb29sIG9yIGNyZWF0ZXMgYSBuZXcgb25lIGlmIHRoZSBwb29sIGlzIGVtcHR5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBhcnJheSBmcm9tIHRoZSBwb29sLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0QXJyYXkoKSB7XG4gICAgcmV0dXJuIGFycmF5UG9vbC5wb3AoKSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIG9iamVjdCBmcm9tIHRoZSBvYmplY3QgcG9vbCBvciBjcmVhdGVzIGEgbmV3IG9uZSBpZiB0aGUgcG9vbCBpcyBlbXB0eS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIG9iamVjdCBmcm9tIHRoZSBwb29sLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0T2JqZWN0KCkge1xuICAgIHJldHVybiBvYmplY3RQb29sLnBvcCgpIHx8IHtcbiAgICAgICdhcnJheSc6IG51bGwsXG4gICAgICAnY2FjaGUnOiBudWxsLFxuICAgICAgJ2NyaXRlcmlhJzogbnVsbCxcbiAgICAgICdmYWxzZSc6IGZhbHNlLFxuICAgICAgJ2luZGV4JzogMCxcbiAgICAgICdudWxsJzogZmFsc2UsXG4gICAgICAnbnVtYmVyJzogbnVsbCxcbiAgICAgICdvYmplY3QnOiBudWxsLFxuICAgICAgJ3B1c2gnOiBudWxsLFxuICAgICAgJ3N0cmluZyc6IG51bGwsXG4gICAgICAndHJ1ZSc6IGZhbHNlLFxuICAgICAgJ3VuZGVmaW5lZCc6IGZhbHNlLFxuICAgICAgJ3ZhbHVlJzogbnVsbFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgdGhlIGdpdmVuIGFycmF5IGJhY2sgdG8gdGhlIGFycmF5IHBvb2wuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIHJlbGVhc2UuXG4gICAqL1xuICBmdW5jdGlvbiByZWxlYXNlQXJyYXkoYXJyYXkpIHtcbiAgICBhcnJheS5sZW5ndGggPSAwO1xuICAgIGlmIChhcnJheVBvb2wubGVuZ3RoIDwgbWF4UG9vbFNpemUpIHtcbiAgICAgIGFycmF5UG9vbC5wdXNoKGFycmF5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgdGhlIGdpdmVuIG9iamVjdCBiYWNrIHRvIHRoZSBvYmplY3QgcG9vbC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcmVsZWFzZS5cbiAgICovXG4gIGZ1bmN0aW9uIHJlbGVhc2VPYmplY3Qob2JqZWN0KSB7XG4gICAgdmFyIGNhY2hlID0gb2JqZWN0LmNhY2hlO1xuICAgIGlmIChjYWNoZSkge1xuICAgICAgcmVsZWFzZU9iamVjdChjYWNoZSk7XG4gICAgfVxuICAgIG9iamVjdC5hcnJheSA9IG9iamVjdC5jYWNoZSA9IG9iamVjdC5jcml0ZXJpYSA9IG9iamVjdC5vYmplY3QgPSBvYmplY3QubnVtYmVyID0gb2JqZWN0LnN0cmluZyA9IG9iamVjdC52YWx1ZSA9IG51bGw7XG4gICAgaWYgKG9iamVjdFBvb2wubGVuZ3RoIDwgbWF4UG9vbFNpemUpIHtcbiAgICAgIG9iamVjdFBvb2wucHVzaChvYmplY3QpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTbGljZXMgdGhlIGBjb2xsZWN0aW9uYCBmcm9tIHRoZSBgc3RhcnRgIGluZGV4IHVwIHRvLCBidXQgbm90IGluY2x1ZGluZyxcbiAgICogdGhlIGBlbmRgIGluZGV4LlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgaW5zdGVhZCBvZiBgQXJyYXkjc2xpY2VgIHRvIHN1cHBvcnQgbm9kZSBsaXN0c1xuICAgKiBpbiBJRSA8IDkgYW5kIHRvIGVuc3VyZSBkZW5zZSBhcnJheXMgYXJlIHJldHVybmVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2xpY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBpbmRleC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBzbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgIHN0YXJ0IHx8IChzdGFydCA9IDApO1xuICAgIGlmICh0eXBlb2YgZW5kID09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbmQgPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgfVxuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBlbmQgLSBzdGFydCB8fCAwLFxuICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGggPCAwID8gMCA6IGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgbG9kYXNoYCBmdW5jdGlvbiB1c2luZyB0aGUgZ2l2ZW4gY29udGV4dCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHQ9cm9vdF0gVGhlIGNvbnRleHQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQpIHtcbiAgICAvLyBBdm9pZCBpc3N1ZXMgd2l0aCBzb21lIEVTMyBlbnZpcm9ubWVudHMgdGhhdCBhdHRlbXB0IHRvIHVzZSB2YWx1ZXMsIG5hbWVkXG4gICAgLy8gYWZ0ZXIgYnVpbHQtaW4gY29uc3RydWN0b3JzIGxpa2UgYE9iamVjdGAsIGZvciB0aGUgY3JlYXRpb24gb2YgbGl0ZXJhbHMuXG4gICAgLy8gRVM1IGNsZWFycyB0aGlzIHVwIGJ5IHN0YXRpbmcgdGhhdCBsaXRlcmFscyBtdXN0IHVzZSBidWlsdC1pbiBjb25zdHJ1Y3RvcnMuXG4gICAgLy8gU2VlIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTEuMS41LlxuICAgIGNvbnRleHQgPSBjb250ZXh0ID8gXy5kZWZhdWx0cyhyb290Lk9iamVjdCgpLCBjb250ZXh0LCBfLnBpY2socm9vdCwgY29udGV4dFByb3BzKSkgOiByb290O1xuXG4gICAgLyoqIE5hdGl2ZSBjb25zdHJ1Y3RvciByZWZlcmVuY2VzICovXG4gICAgdmFyIEFycmF5ID0gY29udGV4dC5BcnJheSxcbiAgICAgICAgQm9vbGVhbiA9IGNvbnRleHQuQm9vbGVhbixcbiAgICAgICAgRGF0ZSA9IGNvbnRleHQuRGF0ZSxcbiAgICAgICAgRnVuY3Rpb24gPSBjb250ZXh0LkZ1bmN0aW9uLFxuICAgICAgICBNYXRoID0gY29udGV4dC5NYXRoLFxuICAgICAgICBOdW1iZXIgPSBjb250ZXh0Lk51bWJlcixcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dC5PYmplY3QsXG4gICAgICAgIFJlZ0V4cCA9IGNvbnRleHQuUmVnRXhwLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0LlN0cmluZyxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dC5UeXBlRXJyb3I7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBgQXJyYXlgIG1ldGhvZCByZWZlcmVuY2VzLlxuICAgICAqXG4gICAgICogTm9ybWFsbHkgYEFycmF5LnByb3RvdHlwZWAgd291bGQgc3VmZmljZSwgaG93ZXZlciwgdXNpbmcgYW4gYXJyYXkgbGl0ZXJhbFxuICAgICAqIGF2b2lkcyBpc3N1ZXMgaW4gTmFyd2hhbC5cbiAgICAgKi9cbiAgICB2YXIgYXJyYXlSZWYgPSBbXTtcblxuICAgIC8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgKi9cbiAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgYF9gIHJlZmVyZW5jZSBpbiBgbm9Db25mbGljdGAgKi9cbiAgICB2YXIgb2xkRGFzaCA9IGNvbnRleHQuXztcblxuICAgIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGludGVybmFsIFtbQ2xhc3NdXSBvZiB2YWx1ZXMgKi9cbiAgICB2YXIgdG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUgKi9cbiAgICB2YXIgcmVOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgICAgIFN0cmluZyh0b1N0cmluZylcbiAgICAgICAgLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJylcbiAgICAgICAgLnJlcGxhY2UoL3RvU3RyaW5nfCBmb3IgW15cXF1dKy9nLCAnLio/JykgKyAnJCdcbiAgICApO1xuXG4gICAgLyoqIE5hdGl2ZSBtZXRob2Qgc2hvcnRjdXRzICovXG4gICAgdmFyIGNlaWwgPSBNYXRoLmNlaWwsXG4gICAgICAgIGNsZWFyVGltZW91dCA9IGNvbnRleHQuY2xlYXJUaW1lb3V0LFxuICAgICAgICBmbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICAgIGZuVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICAgIGdldFByb3RvdHlwZU9mID0gaXNOYXRpdmUoZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YpICYmIGdldFByb3RvdHlwZU9mLFxuICAgICAgICBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5LFxuICAgICAgICBwdXNoID0gYXJyYXlSZWYucHVzaCxcbiAgICAgICAgc2V0VGltZW91dCA9IGNvbnRleHQuc2V0VGltZW91dCxcbiAgICAgICAgc3BsaWNlID0gYXJyYXlSZWYuc3BsaWNlLFxuICAgICAgICB1bnNoaWZ0ID0gYXJyYXlSZWYudW5zaGlmdDtcblxuICAgIC8qKiBVc2VkIHRvIHNldCBtZXRhIGRhdGEgb24gZnVuY3Rpb25zICovXG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gSUUgOCBvbmx5IGFjY2VwdHMgRE9NIGVsZW1lbnRzXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbyA9IHt9LFxuICAgICAgICAgICAgZnVuYyA9IGlzTmF0aXZlKGZ1bmMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkpICYmIGZ1bmMsXG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jKG8sIG8sIG8pICYmIGZ1bmM7XG4gICAgICB9IGNhdGNoKGUpIHsgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KCkpO1xuXG4gICAgLyogTmF0aXZlIG1ldGhvZCBzaG9ydGN1dHMgZm9yIG1ldGhvZHMgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMgKi9cbiAgICB2YXIgbmF0aXZlQ3JlYXRlID0gaXNOYXRpdmUobmF0aXZlQ3JlYXRlID0gT2JqZWN0LmNyZWF0ZSkgJiYgbmF0aXZlQ3JlYXRlLFxuICAgICAgICBuYXRpdmVJc0FycmF5ID0gaXNOYXRpdmUobmF0aXZlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkpICYmIG5hdGl2ZUlzQXJyYXksXG4gICAgICAgIG5hdGl2ZUlzRmluaXRlID0gY29udGV4dC5pc0Zpbml0ZSxcbiAgICAgICAgbmF0aXZlSXNOYU4gPSBjb250ZXh0LmlzTmFOLFxuICAgICAgICBuYXRpdmVLZXlzID0gaXNOYXRpdmUobmF0aXZlS2V5cyA9IE9iamVjdC5rZXlzKSAmJiBuYXRpdmVLZXlzLFxuICAgICAgICBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICAgICAgbmF0aXZlTWluID0gTWF0aC5taW4sXG4gICAgICAgIG5hdGl2ZVBhcnNlSW50ID0gY29udGV4dC5wYXJzZUludCxcbiAgICAgICAgbmF0aXZlUmFuZG9tID0gTWF0aC5yYW5kb207XG5cbiAgICAvKiogVXNlZCB0byBsb29rdXAgYSBidWlsdC1pbiBjb25zdHJ1Y3RvciBieSBbW0NsYXNzXV0gKi9cbiAgICB2YXIgY3RvckJ5Q2xhc3MgPSB7fTtcbiAgICBjdG9yQnlDbGFzc1thcnJheUNsYXNzXSA9IEFycmF5O1xuICAgIGN0b3JCeUNsYXNzW2Jvb2xDbGFzc10gPSBCb29sZWFuO1xuICAgIGN0b3JCeUNsYXNzW2RhdGVDbGFzc10gPSBEYXRlO1xuICAgIGN0b3JCeUNsYXNzW2Z1bmNDbGFzc10gPSBGdW5jdGlvbjtcbiAgICBjdG9yQnlDbGFzc1tvYmplY3RDbGFzc10gPSBPYmplY3Q7XG4gICAgY3RvckJ5Q2xhc3NbbnVtYmVyQ2xhc3NdID0gTnVtYmVyO1xuICAgIGN0b3JCeUNsYXNzW3JlZ2V4cENsYXNzXSA9IFJlZ0V4cDtcbiAgICBjdG9yQnlDbGFzc1tzdHJpbmdDbGFzc10gPSBTdHJpbmc7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3Qgd2hpY2ggd3JhcHMgdGhlIGdpdmVuIHZhbHVlIHRvIGVuYWJsZSBpbnR1aXRpdmVcbiAgICAgKiBtZXRob2QgY2hhaW5pbmcuXG4gICAgICpcbiAgICAgKiBJbiBhZGRpdGlvbiB0byBMby1EYXNoIG1ldGhvZHMsIHdyYXBwZXJzIGFsc28gaGF2ZSB0aGUgZm9sbG93aW5nIGBBcnJheWAgbWV0aG9kczpcbiAgICAgKiBgY29uY2F0YCwgYGpvaW5gLCBgcG9wYCwgYHB1c2hgLCBgcmV2ZXJzZWAsIGBzaGlmdGAsIGBzbGljZWAsIGBzb3J0YCwgYHNwbGljZWAsXG4gICAgICogYW5kIGB1bnNoaWZ0YFxuICAgICAqXG4gICAgICogQ2hhaW5pbmcgaXMgc3VwcG9ydGVkIGluIGN1c3RvbSBidWlsZHMgYXMgbG9uZyBhcyB0aGUgYHZhbHVlYCBtZXRob2QgaXNcbiAgICAgKiBpbXBsaWNpdGx5IG9yIGV4cGxpY2l0bHkgaW5jbHVkZWQgaW4gdGhlIGJ1aWxkLlxuICAgICAqXG4gICAgICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIGZ1bmN0aW9ucyBhcmU6XG4gICAgICogYGFmdGVyYCwgYGFzc2lnbmAsIGBiaW5kYCwgYGJpbmRBbGxgLCBgYmluZEtleWAsIGBjaGFpbmAsIGBjb21wYWN0YCxcbiAgICAgKiBgY29tcG9zZWAsIGBjb25jYXRgLCBgY291bnRCeWAsIGBjcmVhdGVgLCBgY3JlYXRlQ2FsbGJhY2tgLCBgY3VycnlgLFxuICAgICAqIGBkZWJvdW5jZWAsIGBkZWZhdWx0c2AsIGBkZWZlcmAsIGBkZWxheWAsIGBkaWZmZXJlbmNlYCwgYGZpbHRlcmAsIGBmbGF0dGVuYCxcbiAgICAgKiBgZm9yRWFjaGAsIGBmb3JFYWNoUmlnaHRgLCBgZm9ySW5gLCBgZm9ySW5SaWdodGAsIGBmb3JPd25gLCBgZm9yT3duUmlnaHRgLFxuICAgICAqIGBmdW5jdGlvbnNgLCBgZ3JvdXBCeWAsIGBpbmRleEJ5YCwgYGluaXRpYWxgLCBgaW50ZXJzZWN0aW9uYCwgYGludmVydGAsXG4gICAgICogYGludm9rZWAsIGBrZXlzYCwgYG1hcGAsIGBtYXhgLCBgbWVtb2l6ZWAsIGBtZXJnZWAsIGBtaW5gLCBgb2JqZWN0YCwgYG9taXRgLFxuICAgICAqIGBvbmNlYCwgYHBhaXJzYCwgYHBhcnRpYWxgLCBgcGFydGlhbFJpZ2h0YCwgYHBpY2tgLCBgcGx1Y2tgLCBgcHVsbGAsIGBwdXNoYCxcbiAgICAgKiBgcmFuZ2VgLCBgcmVqZWN0YCwgYHJlbW92ZWAsIGByZXN0YCwgYHJldmVyc2VgLCBgc2h1ZmZsZWAsIGBzbGljZWAsIGBzb3J0YCxcbiAgICAgKiBgc29ydEJ5YCwgYHNwbGljZWAsIGB0YXBgLCBgdGhyb3R0bGVgLCBgdGltZXNgLCBgdG9BcnJheWAsIGB0cmFuc2Zvcm1gLFxuICAgICAqIGB1bmlvbmAsIGB1bmlxYCwgYHVuc2hpZnRgLCBgdW56aXBgLCBgdmFsdWVzYCwgYHdoZXJlYCwgYHdpdGhvdXRgLCBgd3JhcGAsXG4gICAgICogYW5kIGB6aXBgXG4gICAgICpcbiAgICAgKiBUaGUgbm9uLWNoYWluYWJsZSB3cmFwcGVyIGZ1bmN0aW9ucyBhcmU6XG4gICAgICogYGNsb25lYCwgYGNsb25lRGVlcGAsIGBjb250YWluc2AsIGBlc2NhcGVgLCBgZXZlcnlgLCBgZmluZGAsIGBmaW5kSW5kZXhgLFxuICAgICAqIGBmaW5kS2V5YCwgYGZpbmRMYXN0YCwgYGZpbmRMYXN0SW5kZXhgLCBgZmluZExhc3RLZXlgLCBgaGFzYCwgYGlkZW50aXR5YCxcbiAgICAgKiBgaW5kZXhPZmAsIGBpc0FyZ3VtZW50c2AsIGBpc0FycmF5YCwgYGlzQm9vbGVhbmAsIGBpc0RhdGVgLCBgaXNFbGVtZW50YCxcbiAgICAgKiBgaXNFbXB0eWAsIGBpc0VxdWFsYCwgYGlzRmluaXRlYCwgYGlzRnVuY3Rpb25gLCBgaXNOYU5gLCBgaXNOdWxsYCwgYGlzTnVtYmVyYCxcbiAgICAgKiBgaXNPYmplY3RgLCBgaXNQbGFpbk9iamVjdGAsIGBpc1JlZ0V4cGAsIGBpc1N0cmluZ2AsIGBpc1VuZGVmaW5lZGAsIGBqb2luYCxcbiAgICAgKiBgbGFzdEluZGV4T2ZgLCBgbWl4aW5gLCBgbm9Db25mbGljdGAsIGBwYXJzZUludGAsIGBwb3BgLCBgcmFuZG9tYCwgYHJlZHVjZWAsXG4gICAgICogYHJlZHVjZVJpZ2h0YCwgYHJlc3VsdGAsIGBzaGlmdGAsIGBzaXplYCwgYHNvbWVgLCBgc29ydGVkSW5kZXhgLCBgcnVuSW5Db250ZXh0YCxcbiAgICAgKiBgdGVtcGxhdGVgLCBgdW5lc2NhcGVgLCBgdW5pcXVlSWRgLCBhbmQgYHZhbHVlYFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgZnVuY3Rpb25zIGBmaXJzdGAgYW5kIGBsYXN0YCByZXR1cm4gd3JhcHBlZCB2YWx1ZXMgd2hlbiBgbmAgaXNcbiAgICAgKiBwcm92aWRlZCwgb3RoZXJ3aXNlIHRoZXkgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBFeHBsaWNpdCBjaGFpbmluZyBjYW4gYmUgZW5hYmxlZCBieSB1c2luZyB0aGUgYF8uY2hhaW5gIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBuYW1lIF9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDIsIDNdKTtcbiAgICAgKlxuICAgICAqIC8vIHJldHVybnMgYW4gdW53cmFwcGVkIHZhbHVlXG4gICAgICogd3JhcHBlZC5yZWR1Y2UoZnVuY3Rpb24oc3VtLCBudW0pIHtcbiAgICAgKiAgIHJldHVybiBzdW0gKyBudW07XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogLy8gcmV0dXJucyBhIHdyYXBwZWQgdmFsdWVcbiAgICAgKiB2YXIgc3F1YXJlcyA9IHdyYXBwZWQubWFwKGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSAqIG51bTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMudmFsdWUoKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZGFzaCh2YWx1ZSkge1xuICAgICAgLy8gZG9uJ3Qgd3JhcCBpZiBhbHJlYWR5IHdyYXBwZWQsIGV2ZW4gaWYgd3JhcHBlZCBieSBhIGRpZmZlcmVudCBgbG9kYXNoYCBjb25zdHJ1Y3RvclxuICAgICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgIWlzQXJyYXkodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdfX3dyYXBwZWRfXycpKVxuICAgICAgID8gdmFsdWVcbiAgICAgICA6IG5ldyBsb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGZhc3QgcGF0aCBmb3IgY3JlYXRpbmcgYGxvZGFzaGAgd3JhcHBlciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjaGFpbkFsbCBBIGZsYWcgdG8gZW5hYmxlIGNoYWluaW5nIGZvciBhbGwgbWV0aG9kc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2Rhc2hXcmFwcGVyKHZhbHVlLCBjaGFpbkFsbCkge1xuICAgICAgdGhpcy5fX2NoYWluX18gPSAhIWNoYWluQWxsO1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgIH1cbiAgICAvLyBlbnN1cmUgYG5ldyBsb2Rhc2hXcmFwcGVyYCBpcyBhbiBpbnN0YW5jZSBvZiBgbG9kYXNoYFxuICAgIGxvZGFzaFdyYXBwZXIucHJvdG90eXBlID0gbG9kYXNoLnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCB1c2VkIHRvIGZsYWcgZW52aXJvbm1lbnRzIGZlYXR1cmVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICovXG4gICAgdmFyIHN1cHBvcnQgPSBsb2Rhc2guc3VwcG9ydCA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIGZ1bmN0aW9ucyBjYW4gYmUgZGVjb21waWxlZCBieSBgRnVuY3Rpb24jdG9TdHJpbmdgXG4gICAgICogKGFsbCBidXQgUFMzIGFuZCBvbGRlciBPcGVyYSBtb2JpbGUgYnJvd3NlcnMgJiBhdm9pZGVkIGluIFdpbmRvd3MgOCBhcHBzKS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICovXG4gICAgc3VwcG9ydC5mdW5jRGVjb21wID0gIWlzTmF0aXZlKGNvbnRleHQuV2luUlRFcnJvcikgJiYgcmVUaGlzLnRlc3QocnVuSW5Db250ZXh0KTtcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiBgRnVuY3Rpb24jbmFtZWAgaXMgc3VwcG9ydGVkIChhbGwgYnV0IElFKS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICovXG4gICAgc3VwcG9ydC5mdW5jTmFtZXMgPSB0eXBlb2YgRnVuY3Rpb24ubmFtZSA9PSAnc3RyaW5nJztcblxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzIHVzZWQgYnkgTG8tRGFzaCBhcmUgc2ltaWxhciB0byB0aG9zZSBpblxuICAgICAqIGVtYmVkZGVkIFJ1YnkgKEVSQikuIENoYW5nZSB0aGUgZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZVxuICAgICAqIGRlbGltaXRlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSBSZWdFeHBcbiAgICAgICAqL1xuICAgICAgJ2VzY2FwZSc6IC88JS0oW1xcc1xcU10rPyklPi9nLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnZXZhbHVhdGUnOiAvPCUoW1xcc1xcU10rPyklPi9nLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgICAqL1xuICAgICAgJ3ZhcmlhYmxlJzogJycsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBpbXBvcnQgdmFyaWFibGVzIGludG8gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAgICovXG4gICAgICAnaW1wb3J0cyc6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNcbiAgICAgICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgICdfJzogbG9kYXNoXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYmluZGAgdGhhdCBjcmVhdGVzIHRoZSBib3VuZCBmdW5jdGlvbiBhbmRcbiAgICAgKiBzZXRzIGl0cyBtZXRhIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGJpbmREYXRhIFRoZSBiaW5kIGRhdGEgYXJyYXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUJpbmQoYmluZERhdGEpIHtcbiAgICAgIHZhciBmdW5jID0gYmluZERhdGFbMF0sXG4gICAgICAgICAgcGFydGlhbEFyZ3MgPSBiaW5kRGF0YVsyXSxcbiAgICAgICAgICB0aGlzQXJnID0gYmluZERhdGFbNF07XG5cbiAgICAgIGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgICAgICAvLyBgRnVuY3Rpb24jYmluZGAgc3BlY1xuICAgICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjMuNC41XG4gICAgICAgIGlmIChwYXJ0aWFsQXJncykge1xuICAgICAgICAgIC8vIGF2b2lkIGBhcmd1bWVudHNgIG9iamVjdCBkZW9wdGltaXphdGlvbnMgYnkgdXNpbmcgYHNsaWNlYCBpbnN0ZWFkXG4gICAgICAgICAgLy8gb2YgYEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsYCBhbmQgbm90IGFzc2lnbmluZyBgYXJndW1lbnRzYCB0byBhXG4gICAgICAgICAgLy8gdmFyaWFibGUgYXMgYSB0ZXJuYXJ5IGV4cHJlc3Npb25cbiAgICAgICAgICB2YXIgYXJncyA9IHNsaWNlKHBhcnRpYWxBcmdzKTtcbiAgICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWltaWMgdGhlIGNvbnN0cnVjdG9yJ3MgYHJldHVybmAgYmVoYXZpb3JcbiAgICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3gxMy4yLjJcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgIC8vIGVuc3VyZSBgbmV3IGJvdW5kYCBpcyBhbiBpbnN0YW5jZSBvZiBgZnVuY2BcbiAgICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKGZ1bmMucHJvdG90eXBlKSxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQmluZGluZywgYXJncyB8fCBhcmd1bWVudHMpO1xuICAgICAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogdGhpc0JpbmRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyB8fCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgc2V0QmluZERhdGEoYm91bmQsIGJpbmREYXRhKTtcbiAgICAgIHJldHVybiBib3VuZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgd2l0aG91dCBhcmd1bWVudCBqdWdnbGluZyBvciBzdXBwb3J0XG4gICAgICogZm9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXA9ZmFsc2VdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgY2xvbmVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCBjYWxsYmFjaywgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2sodmFsdWUpO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGluc3BlY3QgW1tDbGFzc11dXG4gICAgICB2YXIgaXNPYmogPSBpc09iamVjdCh2YWx1ZSk7XG4gICAgICBpZiAoaXNPYmopIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgICBpZiAoIWNsb25lYWJsZUNsYXNzZXNbY2xhc3NOYW1lXSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3RvciA9IGN0b3JCeUNsYXNzW2NsYXNzTmFtZV07XG4gICAgICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgY2FzZSBib29sQ2xhc3M6XG4gICAgICAgICAgY2FzZSBkYXRlQ2xhc3M6XG4gICAgICAgICAgICByZXR1cm4gbmV3IGN0b3IoK3ZhbHVlKTtcblxuICAgICAgICAgIGNhc2UgbnVtYmVyQ2xhc3M6XG4gICAgICAgICAgY2FzZSBzdHJpbmdDbGFzczpcbiAgICAgICAgICAgIHJldHVybiBuZXcgY3Rvcih2YWx1ZSk7XG5cbiAgICAgICAgICBjYXNlIHJlZ2V4cENsYXNzOlxuICAgICAgICAgICAgcmVzdWx0ID0gY3Rvcih2YWx1ZS5zb3VyY2UsIHJlRmxhZ3MuZXhlYyh2YWx1ZSkpO1xuICAgICAgICAgICAgcmVzdWx0Lmxhc3RJbmRleCA9IHZhbHVlLmxhc3RJbmRleDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICAvLyBjaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGNvcnJlc3BvbmRpbmcgY2xvbmVcbiAgICAgICAgdmFyIGluaXRlZFN0YWNrID0gIXN0YWNrQTtcbiAgICAgICAgc3RhY2tBIHx8IChzdGFja0EgPSBnZXRBcnJheSgpKTtcbiAgICAgICAgc3RhY2tCIHx8IChzdGFja0IgPSBnZXRBcnJheSgpKTtcblxuICAgICAgICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2tCW2xlbmd0aF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGlzQXJyID8gY3Rvcih2YWx1ZS5sZW5ndGgpIDoge307XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gaXNBcnIgPyBzbGljZSh2YWx1ZSkgOiBhc3NpZ24oe30sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIGFkZCBhcnJheSBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2BcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2luZGV4JykpIHtcbiAgICAgICAgICByZXN1bHQuaW5kZXggPSB2YWx1ZS5pbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2lucHV0JykpIHtcbiAgICAgICAgICByZXN1bHQuaW5wdXQgPSB2YWx1ZS5pbnB1dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZXhpdCBmb3Igc2hhbGxvdyBjbG9uZVxuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIC8vIGFkZCB0aGUgc291cmNlIHZhbHVlIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0c1xuICAgICAgLy8gYW5kIGFzc29jaWF0ZSBpdCB3aXRoIGl0cyBjbG9uZVxuICAgICAgc3RhY2tBLnB1c2godmFsdWUpO1xuICAgICAgc3RhY2tCLnB1c2gocmVzdWx0KTtcblxuICAgICAgLy8gcmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKVxuICAgICAgKGlzQXJyID8gZm9yRWFjaCA6IGZvck93bikodmFsdWUsIGZ1bmN0aW9uKG9ialZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBiYXNlQ2xvbmUob2JqVmFsdWUsIGlzRGVlcCwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaW5pdGVkU3RhY2spIHtcbiAgICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQSk7XG4gICAgICAgIHJlbGVhc2VBcnJheShzdGFja0IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gICAgICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KHByb3RvdHlwZSkgPyBuYXRpdmVDcmVhdGUocHJvdG90eXBlKSA6IHt9O1xuICAgIH1cbiAgICAvLyBmYWxsYmFjayBmb3IgYnJvd3NlcnMgd2l0aG91dCBgT2JqZWN0LmNyZWF0ZWBcbiAgICBpZiAoIW5hdGl2ZUNyZWF0ZSkge1xuICAgICAgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gT2JqZWN0KCkge31cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgICAgICAgIGlmIChpc09iamVjdChwcm90b3R5cGUpKSB7XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBPYmplY3Q7XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBjb250ZXh0Lk9iamVjdCgpO1xuICAgICAgICB9O1xuICAgICAgfSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVDYWxsYmFja2Agd2l0aG91dCBzdXBwb3J0IGZvciBjcmVhdGluZ1xuICAgICAqIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcmdDb3VudF0gVGhlIG51bWJlciBvZiBhcmd1bWVudHMgdGhlIGNhbGxiYWNrIGFjY2VwdHMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGEgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNyZWF0ZUNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gaWRlbnRpdHk7XG4gICAgICB9XG4gICAgICAvLyBleGl0IGVhcmx5IGZvciBubyBgdGhpc0FyZ2Agb3IgYWxyZWFkeSBib3VuZCBieSBgRnVuY3Rpb24jYmluZGBcbiAgICAgIGlmICh0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJyB8fCAhKCdwcm90b3R5cGUnIGluIGZ1bmMpKSB7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgfVxuICAgICAgdmFyIGJpbmREYXRhID0gZnVuYy5fX2JpbmREYXRhX187XG4gICAgICBpZiAodHlwZW9mIGJpbmREYXRhID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChzdXBwb3J0LmZ1bmNOYW1lcykge1xuICAgICAgICAgIGJpbmREYXRhID0gIWZ1bmMubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBiaW5kRGF0YSA9IGJpbmREYXRhIHx8ICFzdXBwb3J0LmZ1bmNEZWNvbXA7XG4gICAgICAgIGlmICghYmluZERhdGEpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gZm5Ub1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgICAgICAgIGlmICghc3VwcG9ydC5mdW5jTmFtZXMpIHtcbiAgICAgICAgICAgIGJpbmREYXRhID0gIXJlRnVuY05hbWUudGVzdChzb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWJpbmREYXRhKSB7XG4gICAgICAgICAgICAvLyBjaGVja3MgaWYgYGZ1bmNgIHJlZmVyZW5jZXMgdGhlIGB0aGlzYCBrZXl3b3JkIGFuZCBzdG9yZXMgdGhlIHJlc3VsdFxuICAgICAgICAgICAgYmluZERhdGEgPSByZVRoaXMudGVzdChzb3VyY2UpO1xuICAgICAgICAgICAgc2V0QmluZERhdGEoZnVuYywgYmluZERhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZXhpdCBlYXJseSBpZiB0aGVyZSBhcmUgbm8gYHRoaXNgIHJlZmVyZW5jZXMgb3IgYGZ1bmNgIGlzIGJvdW5kXG4gICAgICBpZiAoYmluZERhdGEgPT09IGZhbHNlIHx8IChiaW5kRGF0YSAhPT0gdHJ1ZSAmJiBiaW5kRGF0YVsxXSAmIDEpKSB7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChhcmdDb3VudCkge1xuICAgICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhLCBiKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiaW5kKGZ1bmMsIHRoaXNBcmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBjcmVhdGVXcmFwcGVyYCB0aGF0IGNyZWF0ZXMgdGhlIHdyYXBwZXIgYW5kXG4gICAgICogc2V0cyBpdHMgbWV0YSBkYXRhLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBiaW5kRGF0YSBUaGUgYmluZCBkYXRhIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDcmVhdGVXcmFwcGVyKGJpbmREYXRhKSB7XG4gICAgICB2YXIgZnVuYyA9IGJpbmREYXRhWzBdLFxuICAgICAgICAgIGJpdG1hc2sgPSBiaW5kRGF0YVsxXSxcbiAgICAgICAgICBwYXJ0aWFsQXJncyA9IGJpbmREYXRhWzJdLFxuICAgICAgICAgIHBhcnRpYWxSaWdodEFyZ3MgPSBiaW5kRGF0YVszXSxcbiAgICAgICAgICB0aGlzQXJnID0gYmluZERhdGFbNF0sXG4gICAgICAgICAgYXJpdHkgPSBiaW5kRGF0YVs1XTtcblxuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiAxLFxuICAgICAgICAgIGlzQmluZEtleSA9IGJpdG1hc2sgJiAyLFxuICAgICAgICAgIGlzQ3VycnkgPSBiaXRtYXNrICYgNCxcbiAgICAgICAgICBpc0N1cnJ5Qm91bmQgPSBiaXRtYXNrICYgOCxcbiAgICAgICAgICBrZXkgPSBmdW5jO1xuXG4gICAgICBmdW5jdGlvbiBib3VuZCgpIHtcbiAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gaXNCaW5kID8gdGhpc0FyZyA6IHRoaXM7XG4gICAgICAgIGlmIChwYXJ0aWFsQXJncykge1xuICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UocGFydGlhbEFyZ3MpO1xuICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbFJpZ2h0QXJncyB8fCBpc0N1cnJ5KSB7XG4gICAgICAgICAgYXJncyB8fCAoYXJncyA9IHNsaWNlKGFyZ3VtZW50cykpO1xuICAgICAgICAgIGlmIChwYXJ0aWFsUmlnaHRBcmdzKSB7XG4gICAgICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIHBhcnRpYWxSaWdodEFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNDdXJyeSAmJiBhcmdzLmxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgICBiaXRtYXNrIHw9IDE2ICYgfjMyO1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VDcmVhdGVXcmFwcGVyKFtmdW5jLCAoaXNDdXJyeUJvdW5kID8gYml0bWFzayA6IGJpdG1hc2sgJiB+MyksIGFyZ3MsIG51bGwsIHRoaXNBcmcsIGFyaXR5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFyZ3MgfHwgKGFyZ3MgPSBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoaXNCaW5kS2V5KSB7XG4gICAgICAgICAgZnVuYyA9IHRoaXNCaW5kaW5nW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgIHRoaXNCaW5kaW5nID0gYmFzZUNyZWF0ZShmdW5jLnByb3RvdHlwZSk7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgICAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogdGhpc0JpbmRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgc2V0QmluZERhdGEoYm91bmQsIGJpbmREYXRhKTtcbiAgICAgIHJldHVybiBib3VuZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5kaWZmZXJlbmNlYCB0aGF0IGFjY2VwdHMgYSBzaW5nbGUgYXJyYXlcbiAgICAgKiBvZiB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIGFycmF5IG9mIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgaXNMYXJnZSA9IGxlbmd0aCA+PSBsYXJnZUFycmF5U2l6ZSAmJiBpbmRleE9mID09PSBiYXNlSW5kZXhPZixcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgaWYgKGlzTGFyZ2UpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gY3JlYXRlQ2FjaGUodmFsdWVzKTtcbiAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgaW5kZXhPZiA9IGNhY2hlSW5kZXhPZjtcbiAgICAgICAgICB2YWx1ZXMgPSBjYWNoZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc0xhcmdlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKGluZGV4T2YodmFsdWVzLCB2YWx1ZSkgPCAwKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgICByZWxlYXNlT2JqZWN0KHZhbHVlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIG9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NoYWxsb3c9ZmFsc2VdIEEgZmxhZyB0byByZXN0cmljdCBmbGF0dGVuaW5nIHRvIGEgc2luZ2xlIGxldmVsLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0PWZhbHNlXSBBIGZsYWcgdG8gcmVzdHJpY3QgZmxhdHRlbmluZyB0byBhcnJheXMgYW5kIGBhcmd1bWVudHNgIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHN0YXJ0IGZyb20uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgaXNTaGFsbG93LCBpc1N0cmljdCwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgaW5kZXggPSAoZnJvbUluZGV4IHx8IDApIC0gMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT0gJ251bWJlcidcbiAgICAgICAgICAgICYmIChpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgICAgLy8gcmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKVxuICAgICAgICAgIGlmICghaXNTaGFsbG93KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VGbGF0dGVuKHZhbHVlLCBpc1NoYWxsb3csIGlzU3RyaWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHZhbEluZGV4ID0gLTEsXG4gICAgICAgICAgICAgIHZhbExlbmd0aCA9IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgICAgICAgcmVzSW5kZXggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICAgICAgcmVzdWx0Lmxlbmd0aCArPSB2YWxMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKCsrdmFsSW5kZXggPCB2YWxMZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlW3ZhbEluZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgLCB3aXRob3V0IHN1cHBvcnQgZm9yIGB0aGlzQXJnYCBiaW5kaW5nLFxuICAgICAqIHRoYXQgYWxsb3dzIHBhcnRpYWwgXCJfLndoZXJlXCIgc3R5bGUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gYSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IGIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2lzV2hlcmU9ZmFsc2VdIEEgZmxhZyB0byBpbmRpY2F0ZSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBgYWAgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBUcmFja3MgdHJhdmVyc2VkIGBiYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWwoYSwgYiwgY2FsbGJhY2ssIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICAvLyB1c2VkIHRvIGluZGljYXRlIHRoYXQgd2hlbiBjb21wYXJpbmcgb2JqZWN0cywgYGFgIGhhcyBhdCBsZWFzdCB0aGUgcHJvcGVydGllcyBvZiBgYmBcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2soYSwgYik7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBleGl0IGVhcmx5IGZvciBpZGVudGljYWwgdmFsdWVzXG4gICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAvLyB0cmVhdCBgKzBgIHZzLiBgLTBgIGFzIG5vdCBlcXVhbFxuICAgICAgICByZXR1cm4gYSAhPT0gMCB8fCAoMSAvIGEgPT0gMSAvIGIpO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgYSxcbiAgICAgICAgICBvdGhlclR5cGUgPSB0eXBlb2YgYjtcblxuICAgICAgLy8gZXhpdCBlYXJseSBmb3IgdW5saWtlIHByaW1pdGl2ZSB2YWx1ZXNcbiAgICAgIGlmIChhID09PSBhICYmXG4gICAgICAgICAgIShhICYmIG9iamVjdFR5cGVzW3R5cGVdKSAmJlxuICAgICAgICAgICEoYiAmJiBvYmplY3RUeXBlc1tvdGhlclR5cGVdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBleGl0IGVhcmx5IGZvciBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGF2b2lkaW5nIEVTMydzIEZ1bmN0aW9uI2NhbGwgYmVoYXZpb3JcbiAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMy40LjRcbiAgICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhID09PSBiO1xuICAgICAgfVxuICAgICAgLy8gY29tcGFyZSBbW0NsYXNzXV0gbmFtZXNcbiAgICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpLFxuICAgICAgICAgIG90aGVyQ2xhc3MgPSB0b1N0cmluZy5jYWxsKGIpO1xuXG4gICAgICBpZiAoY2xhc3NOYW1lID09IGFyZ3NDbGFzcykge1xuICAgICAgICBjbGFzc05hbWUgPSBvYmplY3RDbGFzcztcbiAgICAgIH1cbiAgICAgIGlmIChvdGhlckNsYXNzID09IGFyZ3NDbGFzcykge1xuICAgICAgICBvdGhlckNsYXNzID0gb2JqZWN0Q2xhc3M7XG4gICAgICB9XG4gICAgICBpZiAoY2xhc3NOYW1lICE9IG90aGVyQ2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgICAgY2FzZSBib29sQ2xhc3M6XG4gICAgICAgIGNhc2UgZGF0ZUNsYXNzOlxuICAgICAgICAgIC8vIGNvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtYmVycywgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzIGFuZCBib29sZWFuc1xuICAgICAgICAgIC8vIHRvIGAxYCBvciBgMGAgdHJlYXRpbmcgaW52YWxpZCBkYXRlcyBjb2VyY2VkIHRvIGBOYU5gIGFzIG5vdCBlcXVhbFxuICAgICAgICAgIHJldHVybiArYSA9PSArYjtcblxuICAgICAgICBjYXNlIG51bWJlckNsYXNzOlxuICAgICAgICAgIC8vIHRyZWF0IGBOYU5gIHZzLiBgTmFOYCBhcyBlcXVhbFxuICAgICAgICAgIHJldHVybiAoYSAhPSArYSlcbiAgICAgICAgICAgID8gYiAhPSArYlxuICAgICAgICAgICAgLy8gYnV0IHRyZWF0IGArMGAgdnMuIGAtMGAgYXMgbm90IGVxdWFsXG4gICAgICAgICAgICA6IChhID09IDAgPyAoMSAvIGEgPT0gMSAvIGIpIDogYSA9PSArYik7XG5cbiAgICAgICAgY2FzZSByZWdleHBDbGFzczpcbiAgICAgICAgY2FzZSBzdHJpbmdDbGFzczpcbiAgICAgICAgICAvLyBjb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIChodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEwLjYuNClcbiAgICAgICAgICAvLyB0cmVhdCBzdHJpbmcgcHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3QgaW5zdGFuY2VzIGFzIGVxdWFsXG4gICAgICAgICAgcmV0dXJuIGEgPT0gU3RyaW5nKGIpO1xuICAgICAgfVxuICAgICAgdmFyIGlzQXJyID0gY2xhc3NOYW1lID09IGFycmF5Q2xhc3M7XG4gICAgICBpZiAoIWlzQXJyKSB7XG4gICAgICAgIC8vIHVud3JhcCBhbnkgYGxvZGFzaGAgd3JhcHBlZCB2YWx1ZXNcbiAgICAgICAgdmFyIGFXcmFwcGVkID0gaGFzT3duUHJvcGVydHkuY2FsbChhLCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgICAgIGJXcmFwcGVkID0gaGFzT3duUHJvcGVydHkuY2FsbChiLCAnX193cmFwcGVkX18nKTtcblxuICAgICAgICBpZiAoYVdyYXBwZWQgfHwgYldyYXBwZWQpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZUlzRXF1YWwoYVdyYXBwZWQgPyBhLl9fd3JhcHBlZF9fIDogYSwgYldyYXBwZWQgPyBiLl9fd3JhcHBlZF9fIDogYiwgY2FsbGJhY2ssIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBleGl0IGZvciBmdW5jdGlvbnMgYW5kIERPTSBub2Rlc1xuICAgICAgICBpZiAoY2xhc3NOYW1lICE9IG9iamVjdENsYXNzKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGluIG9sZGVyIHZlcnNpb25zIG9mIE9wZXJhLCBgYXJndW1lbnRzYCBvYmplY3RzIGhhdmUgYEFycmF5YCBjb25zdHJ1Y3RvcnNcbiAgICAgICAgdmFyIGN0b3JBID0gYS5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIGN0b3JCID0gYi5jb25zdHJ1Y3RvcjtcblxuICAgICAgICAvLyBub24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbFxuICAgICAgICBpZiAoY3RvckEgIT0gY3RvckIgJiZcbiAgICAgICAgICAgICAgIShpc0Z1bmN0aW9uKGN0b3JBKSAmJiBjdG9yQSBpbnN0YW5jZW9mIGN0b3JBICYmIGlzRnVuY3Rpb24oY3RvckIpICYmIGN0b3JCIGluc3RhbmNlb2YgY3RvckIpICYmXG4gICAgICAgICAgICAgICgnY29uc3RydWN0b3InIGluIGEgJiYgJ2NvbnN0cnVjdG9yJyBpbiBiKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBhc3N1bWUgY3ljbGljIHN0cnVjdHVyZXMgYXJlIGVxdWFsXG4gICAgICAvLyB0aGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMVxuICAgICAgLy8gc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYCAoaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4xMi4zKVxuICAgICAgdmFyIGluaXRlZFN0YWNrID0gIXN0YWNrQTtcbiAgICAgIHN0YWNrQSB8fCAoc3RhY2tBID0gZ2V0QXJyYXkoKSk7XG4gICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IGdldEFycmF5KCkpO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gYSkge1xuICAgICAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXSA9PSBiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgc2l6ZSA9IDA7XG4gICAgICByZXN1bHQgPSB0cnVlO1xuXG4gICAgICAvLyBhZGQgYGFgIGFuZCBgYmAgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzXG4gICAgICBzdGFja0EucHVzaChhKTtcbiAgICAgIHN0YWNrQi5wdXNoKGIpO1xuXG4gICAgICAvLyByZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgLy8gY29tcGFyZSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnlcbiAgICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICAgIHNpemUgPSBiLmxlbmd0aDtcbiAgICAgICAgcmVzdWx0ID0gc2l6ZSA9PSBsZW5ndGg7XG5cbiAgICAgICAgaWYgKHJlc3VsdCB8fCBpc1doZXJlKSB7XG4gICAgICAgICAgLy8gZGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllc1xuICAgICAgICAgIHdoaWxlIChzaXplLS0pIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGxlbmd0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGJbc2l6ZV07XG5cbiAgICAgICAgICAgIGlmIChpc1doZXJlKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKChyZXN1bHQgPSBiYXNlSXNFcXVhbChhW2luZGV4XSwgdmFsdWUsIGNhbGxiYWNrLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQikpKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIShyZXN1bHQgPSBiYXNlSXNFcXVhbChhW3NpemVdLCB2YWx1ZSwgY2FsbGJhY2ssIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gZGVlcCBjb21wYXJlIG9iamVjdHMgdXNpbmcgYGZvckluYCwgaW5zdGVhZCBvZiBgZm9yT3duYCwgdG8gYXZvaWQgYE9iamVjdC5rZXlzYFxuICAgICAgICAvLyB3aGljaCwgaW4gdGhpcyBjYXNlLCBpcyBtb3JlIGNvc3RseVxuICAgICAgICBmb3JJbihiLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBiKSB7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYiwga2V5KSkge1xuICAgICAgICAgICAgLy8gY291bnQgdGhlIG51bWJlciBvZiBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgICAgLy8gZGVlcCBjb21wYXJlIGVhY2ggcHJvcGVydHkgdmFsdWUuXG4gICAgICAgICAgICByZXR1cm4gKHJlc3VsdCA9IGhhc093blByb3BlcnR5LmNhbGwoYSwga2V5KSAmJiBiYXNlSXNFcXVhbChhW2tleV0sIHZhbHVlLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyZXN1bHQgJiYgIWlzV2hlcmUpIHtcbiAgICAgICAgICAvLyBlbnN1cmUgYm90aCBvYmplY3RzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXNcbiAgICAgICAgICBmb3JJbihhLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBhKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhLCBrZXkpKSB7XG4gICAgICAgICAgICAgIC8vIGBzaXplYCB3aWxsIGJlIGAtMWAgaWYgYGFgIGhhcyBtb3JlIHByb3BlcnRpZXMgdGhhbiBgYmBcbiAgICAgICAgICAgICAgcmV0dXJuIChyZXN1bHQgPSAtLXNpemUgPiAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YWNrQS5wb3AoKTtcbiAgICAgIHN0YWNrQi5wb3AoKTtcblxuICAgICAgaWYgKGluaXRlZFN0YWNrKSB7XG4gICAgICAgIHJlbGVhc2VBcnJheShzdGFja0EpO1xuICAgICAgICByZWxlYXNlQXJyYXkoc3RhY2tCKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgYXJndW1lbnQganVnZ2xpbmcgb3Igc3VwcG9ydFxuICAgICAqIGZvciBgdGhpc0FyZ2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdpbmcgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgdmFsdWVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIGNhbGxiYWNrLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgKGlzQXJyYXkoc291cmNlKSA/IGZvckVhY2ggOiBmb3JPd24pKHNvdXJjZSwgZnVuY3Rpb24oc291cmNlLCBrZXkpIHtcbiAgICAgICAgdmFyIGZvdW5kLFxuICAgICAgICAgICAgaXNBcnIsXG4gICAgICAgICAgICByZXN1bHQgPSBzb3VyY2UsXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgIGlmIChzb3VyY2UgJiYgKChpc0FyciA9IGlzQXJyYXkoc291cmNlKSkgfHwgaXNQbGFpbk9iamVjdChzb3VyY2UpKSkge1xuICAgICAgICAgIC8vIGF2b2lkIG1lcmdpbmcgcHJldmlvdXNseSBtZXJnZWQgY3ljbGljIHNvdXJjZXNcbiAgICAgICAgICB2YXIgc3RhY2tMZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChzdGFja0xlbmd0aC0tKSB7XG4gICAgICAgICAgICBpZiAoKGZvdW5kID0gc3RhY2tBW3N0YWNrTGVuZ3RoXSA9PSBzb3VyY2UpKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gc3RhY2tCW3N0YWNrTGVuZ3RoXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgIHZhciBpc1NoYWxsb3c7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2sodmFsdWUsIHNvdXJjZSk7XG4gICAgICAgICAgICAgIGlmICgoaXNTaGFsbG93ID0gdHlwZW9mIHJlc3VsdCAhPSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1NoYWxsb3cpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBpc0FyclxuICAgICAgICAgICAgICAgID8gKGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXSlcbiAgICAgICAgICAgICAgICA6IChpc1BsYWluT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDoge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWRkIGBzb3VyY2VgIGFuZCBhc3NvY2lhdGVkIGB2YWx1ZWAgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzXG4gICAgICAgICAgICBzdGFja0EucHVzaChzb3VyY2UpO1xuICAgICAgICAgICAgc3RhY2tCLnB1c2godmFsdWUpO1xuXG4gICAgICAgICAgICAvLyByZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKVxuICAgICAgICAgICAgaWYgKCFpc1NoYWxsb3cpIHtcbiAgICAgICAgICAgICAgYmFzZU1lcmdlKHZhbHVlLCBzb3VyY2UsIGNhbGxiYWNrLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2sodmFsdWUsIHNvdXJjZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICByZXN1bHQgPSBzb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmRvbWAgd2l0aG91dCBhcmd1bWVudCBqdWdnbGluZyBvciBzdXBwb3J0XG4gICAgICogZm9yIHJldHVybmluZyBmbG9hdGluZy1wb2ludCBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBhIHJhbmRvbSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmRvbShtaW4sIG1heCkge1xuICAgICAgcmV0dXJuIG1pbiArIGZsb29yKG5hdGl2ZVJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgKiBvciBgdGhpc0FyZ2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTb3J0ZWQ9ZmFsc2VdIEEgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IGBhcnJheWAgaXMgc29ydGVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIGR1cGxpY2F0ZS12YWx1ZS1mcmVlIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpc1NvcnRlZCwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB2YXIgaXNMYXJnZSA9ICFpc1NvcnRlZCAmJiBsZW5ndGggPj0gbGFyZ2VBcnJheVNpemUgJiYgaW5kZXhPZiA9PT0gYmFzZUluZGV4T2YsXG4gICAgICAgICAgc2VlbiA9IChjYWxsYmFjayB8fCBpc0xhcmdlKSA/IGdldEFycmF5KCkgOiByZXN1bHQ7XG5cbiAgICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IGNyZWF0ZUNhY2hlKHNlZW4pO1xuICAgICAgICBpbmRleE9mID0gY2FjaGVJbmRleE9mO1xuICAgICAgICBzZWVuID0gY2FjaGU7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGNhbGxiYWNrID8gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBhcnJheSkgOiB2YWx1ZTtcblxuICAgICAgICBpZiAoaXNTb3J0ZWRcbiAgICAgICAgICAgICAgPyAhaW5kZXggfHwgc2VlbltzZWVuLmxlbmd0aCAtIDFdICE9PSBjb21wdXRlZFxuICAgICAgICAgICAgICA6IGluZGV4T2Yoc2VlbiwgY29tcHV0ZWQpIDwgMFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrIHx8IGlzTGFyZ2UpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzTGFyZ2UpIHtcbiAgICAgICAgcmVsZWFzZUFycmF5KHNlZW4uYXJyYXkpO1xuICAgICAgICByZWxlYXNlT2JqZWN0KHNlZW4pO1xuICAgICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgICByZWxlYXNlQXJyYXkoc2Vlbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFnZ3JlZ2F0ZXMgYSBjb2xsZWN0aW9uLCBjcmVhdGluZyBhbiBvYmplY3QgY29tcG9zZWRcbiAgICAgKiBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgICogdGhyb3VnaCBhIGNhbGxiYWNrLiBUaGUgZ2l2ZW4gYHNldHRlcmAgZnVuY3Rpb24gc2V0cyB0aGUga2V5cyBhbmQgdmFsdWVzXG4gICAgICogb2YgdGhlIGNvbXBvc2VkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBzZXR0ZXIgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWdncmVnYXRvciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBZ2dyZWdhdG9yKHNldHRlcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICAgIHNldHRlcihyZXN1bHQsIHZhbHVlLCBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIHNldHRlcihyZXN1bHQsIHZhbHVlLCBjYWxsYmFjayh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSwgY29sbGVjdGlvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBlaXRoZXIgY3VycmllcyBvciBpbnZva2VzIGBmdW5jYFxuICAgICAqIHdpdGggYW4gb3B0aW9uYWwgYHRoaXNgIGJpbmRpbmcgYW5kIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHJlZmVyZW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBtZXRob2QgZmxhZ3MgdG8gY29tcG9zZS5cbiAgICAgKiAgVGhlIGJpdG1hc2sgbWF5IGJlIGNvbXBvc2VkIG9mIHRoZSBmb2xsb3dpbmcgZmxhZ3M6XG4gICAgICogIDEgLSBgXy5iaW5kYFxuICAgICAqICAyIC0gYF8uYmluZEtleWBcbiAgICAgKiAgNCAtIGBfLmN1cnJ5YFxuICAgICAqICA4IC0gYF8uY3VycnlgIChib3VuZClcbiAgICAgKiAgMTYgLSBgXy5wYXJ0aWFsYFxuICAgICAqICAzMiAtIGBfLnBhcnRpYWxSaWdodGBcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbEFyZ3NdIEFuIGFycmF5IG9mIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlXG4gICAgICogIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxSaWdodEFyZ3NdIEFuIGFycmF5IG9mIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2VcbiAgICAgKiAgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlV3JhcHBlcihmdW5jLCBiaXRtYXNrLCBwYXJ0aWFsQXJncywgcGFydGlhbFJpZ2h0QXJncywgdGhpc0FyZywgYXJpdHkpIHtcbiAgICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgMSxcbiAgICAgICAgICBpc0JpbmRLZXkgPSBiaXRtYXNrICYgMixcbiAgICAgICAgICBpc0N1cnJ5ID0gYml0bWFzayAmIDQsXG4gICAgICAgICAgaXNDdXJyeUJvdW5kID0gYml0bWFzayAmIDgsXG4gICAgICAgICAgaXNQYXJ0aWFsID0gYml0bWFzayAmIDE2LFxuICAgICAgICAgIGlzUGFydGlhbFJpZ2h0ID0gYml0bWFzayAmIDMyO1xuXG4gICAgICBpZiAoIWlzQmluZEtleSAmJiAhaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKGlzUGFydGlhbCAmJiAhcGFydGlhbEFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfjE2O1xuICAgICAgICBpc1BhcnRpYWwgPSBwYXJ0aWFsQXJncyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzUGFydGlhbFJpZ2h0ICYmICFwYXJ0aWFsUmlnaHRBcmdzLmxlbmd0aCkge1xuICAgICAgICBiaXRtYXNrICY9IH4zMjtcbiAgICAgICAgaXNQYXJ0aWFsUmlnaHQgPSBwYXJ0aWFsUmlnaHRBcmdzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgYmluZERhdGEgPSBmdW5jICYmIGZ1bmMuX19iaW5kRGF0YV9fO1xuICAgICAgaWYgKGJpbmREYXRhICYmIGJpbmREYXRhICE9PSB0cnVlKSB7XG4gICAgICAgIC8vIGNsb25lIGBiaW5kRGF0YWBcbiAgICAgICAgYmluZERhdGEgPSBzbGljZShiaW5kRGF0YSk7XG4gICAgICAgIGlmIChiaW5kRGF0YVsyXSkge1xuICAgICAgICAgIGJpbmREYXRhWzJdID0gc2xpY2UoYmluZERhdGFbMl0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaW5kRGF0YVszXSkge1xuICAgICAgICAgIGJpbmREYXRhWzNdID0gc2xpY2UoYmluZERhdGFbM10pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBgdGhpc0JpbmRpbmdgIGlzIG5vdCBwcmV2aW91c2x5IGJvdW5kXG4gICAgICAgIGlmIChpc0JpbmQgJiYgIShiaW5kRGF0YVsxXSAmIDEpKSB7XG4gICAgICAgICAgYmluZERhdGFbNF0gPSB0aGlzQXJnO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBpZiBwcmV2aW91c2x5IGJvdW5kIGJ1dCBub3QgY3VycmVudGx5IChzdWJzZXF1ZW50IGN1cnJpZWQgZnVuY3Rpb25zKVxuICAgICAgICBpZiAoIWlzQmluZCAmJiBiaW5kRGF0YVsxXSAmIDEpIHtcbiAgICAgICAgICBiaXRtYXNrIHw9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGN1cnJpZWQgYXJpdHkgaWYgbm90IHlldCBzZXRcbiAgICAgICAgaWYgKGlzQ3VycnkgJiYgIShiaW5kRGF0YVsxXSAmIDQpKSB7XG4gICAgICAgICAgYmluZERhdGFbNV0gPSBhcml0eTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBlbmQgcGFydGlhbCBsZWZ0IGFyZ3VtZW50c1xuICAgICAgICBpZiAoaXNQYXJ0aWFsKSB7XG4gICAgICAgICAgcHVzaC5hcHBseShiaW5kRGF0YVsyXSB8fCAoYmluZERhdGFbMl0gPSBbXSksIHBhcnRpYWxBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBlbmQgcGFydGlhbCByaWdodCBhcmd1bWVudHNcbiAgICAgICAgaWYgKGlzUGFydGlhbFJpZ2h0KSB7XG4gICAgICAgICAgdW5zaGlmdC5hcHBseShiaW5kRGF0YVszXSB8fCAoYmluZERhdGFbM10gPSBbXSksIHBhcnRpYWxSaWdodEFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIGZsYWdzXG4gICAgICAgIGJpbmREYXRhWzFdIHw9IGJpdG1hc2s7XG4gICAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyLmFwcGx5KG51bGwsIGJpbmREYXRhKTtcbiAgICAgIH1cbiAgICAgIC8vIGZhc3QgcGF0aCBmb3IgYF8uYmluZGBcbiAgICAgIHZhciBjcmVhdGVyID0gKGJpdG1hc2sgPT0gMSB8fCBiaXRtYXNrID09PSAxNykgPyBiYXNlQmluZCA6IGJhc2VDcmVhdGVXcmFwcGVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZXIoW2Z1bmMsIGJpdG1hc2ssIHBhcnRpYWxBcmdzLCBwYXJ0aWFsUmlnaHRBcmdzLCB0aGlzQXJnLCBhcml0eV0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYGVzY2FwZWAgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaCBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZUh0bWxDaGFyKG1hdGNoKSB7XG4gICAgICByZXR1cm4gaHRtbEVzY2FwZXNbbWF0Y2hdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFwcHJvcHJpYXRlIFwiaW5kZXhPZlwiIGZ1bmN0aW9uLiBJZiB0aGUgYF8uaW5kZXhPZmAgbWV0aG9kIGlzXG4gICAgICogY3VzdG9taXplZCwgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgY3VzdG9tIG1ldGhvZCwgb3RoZXJ3aXNlIGl0IHJldHVybnNcbiAgICAgKiB0aGUgYGJhc2VJbmRleE9mYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBcImluZGV4T2ZcIiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRJbmRleE9mKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IChyZXN1bHQgPSBsb2Rhc2guaW5kZXhPZikgPT09IGluZGV4T2YgPyBiYXNlSW5kZXhPZiA6IHJlc3VsdDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgJiYgcmVOYXRpdmUudGVzdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBgdGhpc2AgYmluZGluZyBkYXRhIG9uIGEgZ2l2ZW4gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHNldCBkYXRhIG9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlIFRoZSBkYXRhIGFycmF5IHRvIHNldC5cbiAgICAgKi9cbiAgICB2YXIgc2V0QmluZERhdGEgPSAhZGVmaW5lUHJvcGVydHkgPyBub29wIDogZnVuY3Rpb24oZnVuYywgdmFsdWUpIHtcbiAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGRlZmluZVByb3BlcnR5KGZ1bmMsICdfX2JpbmREYXRhX18nLCBkZXNjcmlwdG9yKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiBvZiBgaXNQbGFpbk9iamVjdGAgd2hpY2ggY2hlY2tzIGlmIGEgZ2l2ZW4gdmFsdWVcbiAgICAgKiBpcyBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IsIGFzc3VtaW5nIG9iamVjdHMgY3JlYXRlZFxuICAgICAqIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3RvciBoYXZlIG5vIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYW5kIHRoYXRcbiAgICAgKiB0aGVyZSBhcmUgbm8gYE9iamVjdC5wcm90b3R5cGVgIGV4dGVuc2lvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hpbUlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgIHZhciBjdG9yLFxuICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgLy8gYXZvaWQgbm9uIE9iamVjdCBvYmplY3RzLCBgYXJndW1lbnRzYCBvYmplY3RzLCBhbmQgRE9NIGVsZW1lbnRzXG4gICAgICBpZiAoISh2YWx1ZSAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBvYmplY3RDbGFzcykgfHxcbiAgICAgICAgICAoY3RvciA9IHZhbHVlLmNvbnN0cnVjdG9yLCBpc0Z1bmN0aW9uKGN0b3IpICYmICEoY3RvciBpbnN0YW5jZW9mIGN0b3IpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBJbiBtb3N0IGVudmlyb25tZW50cyBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcyBhcmUgaXRlcmF0ZWQgYmVmb3JlXG4gICAgICAvLyBpdHMgaW5oZXJpdGVkIHByb3BlcnRpZXMuIElmIHRoZSBsYXN0IGl0ZXJhdGVkIHByb3BlcnR5IGlzIGFuIG9iamVjdCdzXG4gICAgICAvLyBvd24gcHJvcGVydHkgdGhlbiB0aGVyZSBhcmUgbm8gaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgIGZvckluKHZhbHVlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHR5cGVvZiByZXN1bHQgPT0gJ3VuZGVmaW5lZCcgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGB1bmVzY2FwZWAgdG8gY29udmVydCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaCBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gdW5lc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmVzY2FwZUh0bWxDaGFyKG1hdGNoKSB7XG4gICAgICByZXR1cm4gaHRtbFVuZXNjYXBlc1ttYXRjaF07XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogKGZ1bmN0aW9uKCkgeyByZXR1cm4gXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpOyB9KSgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09ICdudW1iZXInICYmXG4gICAgICAgIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFyZ3NDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogKGZ1bmN0aW9uKCkgeyByZXR1cm4gXy5pc0FycmF5KGFyZ3VtZW50cyk7IH0pKCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICB2YXIgaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgICAgICB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzIHx8IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIG9mIGBPYmplY3Qua2V5c2Agd2hpY2ggcHJvZHVjZXMgYW4gYXJyYXkgb2YgdGhlXG4gICAgICogZ2l2ZW4gb2JqZWN0J3Mgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIHZhciBzaGltS2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIGluZGV4LCBpdGVyYWJsZSA9IG9iamVjdCwgcmVzdWx0ID0gW107XG4gICAgICBpZiAoIWl0ZXJhYmxlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgaWYgKCEob2JqZWN0VHlwZXNbdHlwZW9mIG9iamVjdF0pKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICBmb3IgKGluZGV4IGluIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoaXRlcmFibGUsIGluZGV4KSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGNvbXBvc2VkIG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5rZXlzKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0pO1xuICAgICAqIC8vID0+IFsnb25lJywgJ3R3bycsICd0aHJlZSddIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqL1xuICAgIHZhciBrZXlzID0gIW5hdGl2ZUtleXMgPyBzaGltS2V5cyA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXM6XG4gICAgICpcbiAgICAgKiBUaG91Z2ggdGhlIGA+YCBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZSBgPmAgYW5kIGAvYFxuICAgICAqIGRvbid0IHJlcXVpcmUgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmcgdW5sZXNzIHRoZXkncmUgcGFydFxuICAgICAqIG9mIGEgdGFnIG9yIGFuIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgKiBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcyAodW5kZXIgXCJzZW1pLXJlbGF0ZWQgZnVuIGZhY3RcIilcbiAgICAgKi9cbiAgICB2YXIgaHRtbEVzY2FwZXMgPSB7XG4gICAgICAnJic6ICcmYW1wOycsXG4gICAgICAnPCc6ICcmbHQ7JyxcbiAgICAgICc+JzogJyZndDsnLFxuICAgICAgJ1wiJzogJyZxdW90OycsXG4gICAgICBcIidcIjogJyYjMzk7J1xuICAgIH07XG5cbiAgICAvKiogVXNlZCB0byBjb252ZXJ0IEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycyAqL1xuICAgIHZhciBodG1sVW5lc2NhcGVzID0gaW52ZXJ0KGh0bWxFc2NhcGVzKTtcblxuICAgIC8qKiBVc2VkIHRvIG1hdGNoIEhUTUwgZW50aXRpZXMgYW5kIEhUTUwgY2hhcmFjdGVycyAqL1xuICAgIHZhciByZUVzY2FwZWRIdG1sID0gUmVnRXhwKCcoJyArIGtleXMoaHRtbFVuZXNjYXBlcykuam9pbignfCcpICsgJyknLCAnZycpLFxuICAgICAgICByZVVuZXNjYXBlZEh0bWwgPSBSZWdFeHAoJ1snICsga2V5cyhodG1sRXNjYXBlcykuam9pbignJykgKyAnXScsICdnJyk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICAgICAqIG9iamVjdC4gU3Vic2VxdWVudCBzb3VyY2VzIHdpbGwgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzXG4gICAgICogc291cmNlcy4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIHRvIHByb2R1Y2UgdGhlXG4gICAgICogYXNzaWduZWQgdmFsdWVzLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdHdvXG4gICAgICogYXJndW1lbnRzOyAob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGFsaWFzIGV4dGVuZFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICduYW1lJzogJ2ZyZWQnIH0sIHsgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnLCAnZW1wbG95ZXInOiAnc2xhdGUnIH1cbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICogICByZXR1cm4gdHlwZW9mIGEgPT0gJ3VuZGVmaW5lZCcgPyBiIDogYTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICduYW1lJzogJ2Jhcm5leScgfTtcbiAgICAgKiBkZWZhdWx0cyhvYmplY3QsIHsgJ25hbWUnOiAnZnJlZCcsICdlbXBsb3llcic6ICdzbGF0ZScgfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnZW1wbG95ZXInOiAnc2xhdGUnIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduID0gZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIGd1YXJkKSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gb2JqZWN0LCByZXN1bHQgPSBpdGVyYWJsZTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBhcmdzSW5kZXggPSAwLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSB0eXBlb2YgZ3VhcmQgPT0gJ251bWJlcicgPyAyIDogYXJncy5sZW5ndGg7XG4gICAgICBpZiAoYXJnc0xlbmd0aCA+IDMgJiYgdHlwZW9mIGFyZ3NbYXJnc0xlbmd0aCAtIDJdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYmFzZUNyZWF0ZUNhbGxiYWNrKGFyZ3NbLS1hcmdzTGVuZ3RoIC0gMV0sIGFyZ3NbYXJnc0xlbmd0aC0tXSwgMik7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3NMZW5ndGggPiAyICYmIHR5cGVvZiBhcmdzW2FyZ3NMZW5ndGggLSAxXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gYXJnc1stLWFyZ3NMZW5ndGhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICBpdGVyYWJsZSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgICAgaWYgKGl0ZXJhYmxlICYmIG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0pIHtcbiAgICAgICAgdmFyIG93bkluZGV4ID0gLTEsXG4gICAgICAgICAgICBvd25Qcm9wcyA9IG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0gJiYga2V5cyhpdGVyYWJsZSksXG4gICAgICAgICAgICBsZW5ndGggPSBvd25Qcm9wcyA/IG93blByb3BzLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgd2hpbGUgKCsrb3duSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpbmRleCA9IG93blByb3BzW293bkluZGV4XTtcbiAgICAgICAgICByZXN1bHRbaW5kZXhdID0gY2FsbGJhY2sgPyBjYWxsYmFjayhyZXN1bHRbaW5kZXhdLCBpdGVyYWJsZVtpbmRleF0pIDogaXRlcmFibGVbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB2YWx1ZWAuIElmIGBpc0RlZXBgIGlzIGB0cnVlYCBuZXN0ZWQgb2JqZWN0cyB3aWxsIGFsc29cbiAgICAgKiBiZSBjbG9uZWQsIG90aGVyd2lzZSB0aGV5IHdpbGwgYmUgYXNzaWduZWQgYnkgcmVmZXJlbmNlLiBJZiBhIGNhbGxiYWNrXG4gICAgICogaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWVzLiBJZiB0aGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB1bmRlZmluZWRgIGNsb25pbmcgd2lsbCBiZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC5cbiAgICAgKiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXA9ZmFsc2VdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShjaGFyYWN0ZXJzKTtcbiAgICAgKiBzaGFsbG93WzBdID09PSBjaGFyYWN0ZXJzWzBdO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZShjaGFyYWN0ZXJzLCB0cnVlKTtcbiAgICAgKiBkZWVwWzBdID09PSBjaGFyYWN0ZXJzWzBdO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLm1peGluKHtcbiAgICAgKiAgICdjbG9uZSc6IF8ucGFydGlhbFJpZ2h0KF8uY2xvbmUsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICAgIHJldHVybiBfLmlzRWxlbWVudCh2YWx1ZSkgPyB2YWx1ZS5jbG9uZU5vZGUoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAqICAgfSlcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHZhciBjbG9uZSA9IF8uY2xvbmUoZG9jdW1lbnQuYm9keSk7XG4gICAgICogY2xvbmUuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lKHZhbHVlLCBpc0RlZXAsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAvLyBhbGxvd3Mgd29ya2luZyB3aXRoIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzIHdpdGhvdXQgdXNpbmcgdGhlaXIgYGluZGV4YFxuICAgICAgLy8gYW5kIGBjb2xsZWN0aW9uYCBhcmd1bWVudHMgZm9yIGBpc0RlZXBgIGFuZCBgY2FsbGJhY2tgXG4gICAgICBpZiAodHlwZW9mIGlzRGVlcCAhPSAnYm9vbGVhbicgJiYgaXNEZWVwICE9IG51bGwpIHtcbiAgICAgICAgdGhpc0FyZyA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayA9IGlzRGVlcDtcbiAgICAgICAgaXNEZWVwID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBpc0RlZXAsIHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nICYmIGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWVwIGNsb25lIG9mIGB2YWx1ZWAuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZVxuICAgICAqIGV4ZWN1dGVkIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZXMuIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGB1bmRlZmluZWRgXG4gICAgICogY2xvbmluZyB3aWxsIGJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZSBzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobS4gRnVuY3Rpb25zXG4gICAgICogYW5kIERPTSBub2RlcyBhcmUgKipub3QqKiBjbG9uZWQuIFRoZSBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhbmRcbiAgICAgKiBvYmplY3RzIGNyZWF0ZWQgYnkgY29uc3RydWN0b3JzIG90aGVyIHRoYW4gYE9iamVjdGAgYXJlIGNsb25lZCB0byBwbGFpbiBgT2JqZWN0YCBvYmplY3RzLlxuICAgICAqIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmZyYXN0cnVjdHVyZS5odG1sI2ludGVybmFsLXN0cnVjdHVyZWQtY2xvbmluZy1hbGdvcml0aG0uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKGNoYXJhY3RlcnMpO1xuICAgICAqIGRlZXBbMF0gPT09IGNoYXJhY3RlcnNbMF07XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIHZhciB2aWV3ID0ge1xuICAgICAqICAgJ2xhYmVsJzogJ2RvY3MnLFxuICAgICAqICAgJ25vZGUnOiBlbGVtZW50XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjbG9uZSA9IF8uY2xvbmVEZWVwKHZpZXcsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gXy5pc0VsZW1lbnQodmFsdWUpID8gdmFsdWUuY2xvbmVOb2RlKHRydWUpIDogdW5kZWZpbmVkO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY2xvbmUubm9kZSA9PSB2aWV3Lm5vZGU7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURlZXAodmFsdWUsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCB0cnVlLCB0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJyAmJiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGdpdmVuIGBwcm90b3R5cGVgIG9iamVjdC4gSWYgYVxuICAgICAqIGBwcm9wZXJ0aWVzYCBvYmplY3QgaXMgcHJvdmlkZWQgaXRzIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIGFzc2lnbmVkXG4gICAgICogdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gVGhlIHByb3BlcnRpZXMgdG8gYXNzaWduIHRvIHRoZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBDaXJjbGUoKSB7XG4gICAgICogICBTaGFwZS5jYWxsKHRoaXMpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIENpcmNsZS5wcm90b3R5cGUgPSBfLmNyZWF0ZShTaGFwZS5wcm90b3R5cGUsIHsgJ2NvbnN0cnVjdG9yJzogQ2lyY2xlIH0pO1xuICAgICAqXG4gICAgICogdmFyIGNpcmNsZSA9IG5ldyBDaXJjbGU7XG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgQ2lyY2xlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIFNoYXBlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXMgPyBhc3NpZ24ocmVzdWx0LCBwcm9wZXJ0aWVzKSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAgICAgKiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC4gT25jZSBhXG4gICAgICogcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIGRlZmF1bHRzIG9mIHRoZSBzYW1lIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gQWxsb3dzIHdvcmtpbmcgd2l0aCBgXy5yZWR1Y2VgIHdpdGhvdXQgdXNpbmcgaXRzXG4gICAgICogIGBrZXlgIGFuZCBgb2JqZWN0YCBhcmd1bWVudHMgYXMgc291cmNlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICduYW1lJzogJ2Jhcm5leScgfTtcbiAgICAgKiBfLmRlZmF1bHRzKG9iamVjdCwgeyAnbmFtZSc6ICdmcmVkJywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdlbXBsb3llcic6ICdzbGF0ZScgfVxuICAgICAqL1xuICAgIHZhciBkZWZhdWx0cyA9IGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBndWFyZCkge1xuICAgICAgdmFyIGluZGV4LCBpdGVyYWJsZSA9IG9iamVjdCwgcmVzdWx0ID0gaXRlcmFibGU7XG4gICAgICBpZiAoIWl0ZXJhYmxlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgYXJnc0luZGV4ID0gMCxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gdHlwZW9mIGd1YXJkID09ICdudW1iZXInID8gMiA6IGFyZ3MubGVuZ3RoO1xuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICBpdGVyYWJsZSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgICAgaWYgKGl0ZXJhYmxlICYmIG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0pIHtcbiAgICAgICAgdmFyIG93bkluZGV4ID0gLTEsXG4gICAgICAgICAgICBvd25Qcm9wcyA9IG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0gJiYga2V5cyhpdGVyYWJsZSksXG4gICAgICAgICAgICBsZW5ndGggPSBvd25Qcm9wcyA/IG93blByb3BzLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgd2hpbGUgKCsrb3duSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpbmRleCA9IG93blByb3BzW293bkluZGV4XTtcbiAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdFtpbmRleF0gPT0gJ3VuZGVmaW5lZCcpIHJlc3VsdFtpbmRleF0gPSBpdGVyYWJsZVtpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRJbmRleGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUga2V5IG9mIHRoZVxuICAgICAqIGZpcnN0IGVsZW1lbnQgdGhhdCBwYXNzZXMgdGhlIGNhbGxiYWNrIGNoZWNrLCBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlclxuICAgICAqICBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvXG4gICAgICogIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSB7XG4gICAgICogICAnYmFybmV5JzogeyAgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICAnZnJlZCc6IHsgICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdibG9ja2VkJzogZmFsc2UgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRLZXkoY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA8IDQwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdiYXJuZXknIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kS2V5KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDEgfSk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRLZXkoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kS2V5KG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBmb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kS2V5YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyXG4gICAgICogIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG9cbiAgICAgKiAgY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiB7ICAnYWdlJzogMzYsICdibG9ja2VkJzogdHJ1ZSB9LFxuICAgICAqICAgJ2ZyZWQnOiB7ICAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEtleShjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gcmV0dXJucyBgcGViYmxlc2AsIGFzc3VtaW5nIGBfLmZpbmRLZXlgIHJldHVybnMgYGJhcm5leWBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RLZXkoY2hhcmFjdGVycywgeyAnYWdlJzogNDAgfSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0S2V5KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RLZXkob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGZvck93blJpZ2h0KG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCxcbiAgICAgKiBleGVjdXRpbmcgdGhlIGNhbGxiYWNrIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBDYWxsYmFja3MgbWF5IGV4aXRcbiAgICAgKiBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogU2hhcGUucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICB0aGlzLnggKz0geDtcbiAgICAgKiAgIHRoaXMueSArPSB5O1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZvckluKG5ldyBTaGFwZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICd4JywgJ3knLCBhbmQgJ21vdmUnIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqL1xuICAgIHZhciBmb3JJbiA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gY29sbGVjdGlvbiwgcmVzdWx0ID0gaXRlcmFibGU7XG4gICAgICBpZiAoIWl0ZXJhYmxlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgaWYgKCFvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdKSByZXR1cm4gcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayAmJiB0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrIDogYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgZm9yIChpbmRleCBpbiBpdGVyYWJsZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjayhpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKSA9PT0gZmFsc2UpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JJbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIFNoYXBlLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAqICAgdGhpcy54ICs9IHg7XG4gICAgICogICB0aGlzLnkgKz0geTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5mb3JJblJpZ2h0KG5ldyBTaGFwZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdtb3ZlJywgJ3knLCBhbmQgJ3gnIGFzc3VtaW5nIGBfLmZvckluIGAgbG9ncyAneCcsICd5JywgYW5kICdtb3ZlJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckluUmlnaHQob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHBhaXJzID0gW107XG5cbiAgICAgIGZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICBwYWlycy5wdXNoKGtleSwgdmFsdWUpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBwYWlycy5sZW5ndGg7XG4gICAgICBjYWxsYmFjayA9IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHBhaXJzW2xlbmd0aC0tXSwgcGFpcnNbbGVuZ3RoXSwgb2JqZWN0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0LCBleGVjdXRpbmcgdGhlIGNhbGxiYWNrXG4gICAgICogZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBrZXksIG9iamVjdCkuIENhbGxiYWNrcyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnlcbiAgICAgKiBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mb3JPd24oeyAnMCc6ICd6ZXJvJywgJzEnOiAnb25lJywgJ2xlbmd0aCc6IDIgfSwgZnVuY3Rpb24obnVtLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnMCcsICcxJywgYW5kICdsZW5ndGgnIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqL1xuICAgIHZhciBmb3JPd24gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4LCBpdGVyYWJsZSA9IGNvbGxlY3Rpb24sIHJlc3VsdCA9IGl0ZXJhYmxlO1xuICAgICAgaWYgKCFpdGVyYWJsZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGlmICghb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgJiYgdHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFjayA6IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIHZhciBvd25JbmRleCA9IC0xLFxuICAgICAgICAgICAgb3duUHJvcHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdICYmIGtleXMoaXRlcmFibGUpLFxuICAgICAgICAgICAgbGVuZ3RoID0gb3duUHJvcHMgPyBvd25Qcm9wcy5sZW5ndGggOiAwO1xuXG4gICAgICAgIHdoaWxlICgrK293bkluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaW5kZXggPSBvd25Qcm9wc1tvd25JbmRleF07XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pID09PSBmYWxzZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvck93bmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvck93blJpZ2h0KHsgJzAnOiAnemVybycsICcxJzogJ29uZScsICdsZW5ndGgnOiAyIH0sIGZ1bmN0aW9uKG51bSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ2xlbmd0aCcsICcxJywgYW5kICcwJyBhc3N1bWluZyBgXy5mb3JPd25gIGxvZ3MgJzAnLCAnMScsIGFuZCAnbGVuZ3RoJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93blJpZ2h0KG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIGNhbGxiYWNrID0gYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKG9iamVjdFtrZXldLCBrZXksIG9iamVjdCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNvcnRlZCBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBvZiBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLFxuICAgICAqIG93biBhbmQgaW5oZXJpdGVkLCBvZiBgb2JqZWN0YCB0aGF0IGhhdmUgZnVuY3Rpb24gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIG1ldGhvZHNcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyB0aGF0IGhhdmUgZnVuY3Rpb24gdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9ucyhfKTtcbiAgICAgKiAvLyA9PiBbJ2FsbCcsICdhbnknLCAnYmluZCcsICdiaW5kQWxsJywgJ2Nsb25lJywgJ2NvbXBhY3QnLCAnY29tcG9zZScsIC4uLl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbnMob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0LnNvcnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBuYW1lIGV4aXN0cyBhcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCxcbiAgICAgKiBpbnN0ZWFkIG9mIGFuIGluaGVyaXRlZCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGtleSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmhhcyh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgJ2InKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzKG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID8gaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgaW52ZXJ0ZWQga2V5cyBhbmQgdmFsdWVzIG9mIHRoZSBnaXZlbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3JlYXRlZCBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0KHsgJ2ZpcnN0JzogJ2ZyZWQnLCAnc2Vjb25kJzogJ2Jhcm5leScgfSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6ICdmaXJzdCcsICdiYXJuZXknOiAnc2Vjb25kJyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52ZXJ0KG9iamVjdCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICByZXN1bHRbb2JqZWN0W2tleV1dID0ga2V5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJvb2xlYW4gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIGJvb2xlYW4gdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4obnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHxcbiAgICAgICAgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IGJvb2xDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGRhdGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIGRhdGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUobmV3IERhdGUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZGF0ZUNsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMSB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBlbXB0eS4gQXJyYXlzLCBzdHJpbmdzLCBvciBgYXJndW1lbnRzYCBvYmplY3RzIHdpdGggYVxuICAgICAqIGxlbmd0aCBvZiBgMGAgYW5kIG9iamVjdHMgd2l0aCBubyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSBjb25zaWRlcmVkXG4gICAgICogXCJlbXB0eVwiLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoJycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKHZhbHVlKSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cbiAgICAgIGlmICgoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MgfHwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8IGNsYXNzTmFtZSA9PSBhcmdzQ2xhc3MgKSB8fFxuICAgICAgICAgIChjbGFzc05hbWUgPT0gb2JqZWN0Q2xhc3MgJiYgdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBpc0Z1bmN0aW9uKHZhbHVlLnNwbGljZSkpKSB7XG4gICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZm9yT3duKHZhbHVlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChyZXN1bHQgPSBmYWxzZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICAgICAqIGVxdWl2YWxlbnQgdG8gZWFjaCBvdGhlci4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkXG4gICAgICogdG8gY29tcGFyZSB2YWx1ZXMuIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGB1bmRlZmluZWRgIGNvbXBhcmlzb25zIHdpbGxcbiAgICAgKiBiZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czsgKGEsIGIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IGEgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBiIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICduYW1lJzogJ2ZyZWQnIH07XG4gICAgICogdmFyIGNvcHkgPSB7ICduYW1lJzogJ2ZyZWQnIH07XG4gICAgICpcbiAgICAgKiBvYmplY3QgPT0gY29weTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0VxdWFsKG9iamVjdCwgY29weSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIHdvcmRzID0gWydoZWxsbycsICdnb29kYnllJ107XG4gICAgICogdmFyIG90aGVyV29yZHMgPSBbJ2hpJywgJ2dvb2RieWUnXTtcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbCh3b3Jkcywgb3RoZXJXb3JkcywgZnVuY3Rpb24oYSwgYikge1xuICAgICAqICAgdmFyIHJlR3JlZXQgPSAvXig/OmhlbGxvfGhpKSQvaSxcbiAgICAgKiAgICAgICBhR3JlZXQgPSBfLmlzU3RyaW5nKGEpICYmIHJlR3JlZXQudGVzdChhKSxcbiAgICAgKiAgICAgICBiR3JlZXQgPSBfLmlzU3RyaW5nKGIpICYmIHJlR3JlZXQudGVzdChiKTtcbiAgICAgKlxuICAgICAqICAgcmV0dXJuIChhR3JlZXQgfHwgYkdyZWV0KSA/IChhR3JlZXQgPT0gYkdyZWV0KSA6IHVuZGVmaW5lZDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcXVhbChhLCBiLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsKGEsIGIsIHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nICYmIGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzLCBvciBjYW4gYmUgY29lcmNlZCB0bywgYSBmaW5pdGUgbnVtYmVyLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBpcyBub3QgdGhlIHNhbWUgYXMgbmF0aXZlIGBpc0Zpbml0ZWAgd2hpY2ggd2lsbCByZXR1cm4gdHJ1ZSBmb3JcbiAgICAgKiBib29sZWFucyBhbmQgZW1wdHkgc3RyaW5ncy4gU2VlIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMS4yLjUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBmaW5pdGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgtMTAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKCcxMCcpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUodHJ1ZSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoJycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRmluaXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gbmF0aXZlSXNGaW5pdGUodmFsdWUpICYmICFuYXRpdmVJc05hTihwYXJzZUZsb2F0KHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKF8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIGxhbmd1YWdlIHR5cGUgb2YgT2JqZWN0LlxuICAgICAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3Qoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHRoZSB2YWx1ZSBpcyB0aGUgRUNNQVNjcmlwdCBsYW5ndWFnZSB0eXBlIG9mIE9iamVjdFxuICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3g4XG4gICAgICAvLyBhbmQgYXZvaWQgYSBWOCBidWdcbiAgICAgIC8vIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTFcbiAgICAgIHJldHVybiAhISh2YWx1ZSAmJiBvYmplY3RUeXBlc1t0eXBlb2YgdmFsdWVdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgTmFOYC5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgaXMgbm90IHRoZSBzYW1lIGFzIG5hdGl2ZSBgaXNOYU5gIHdoaWNoIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3JcbiAgICAgKiBgdW5kZWZpbmVkYCBhbmQgb3RoZXIgbm9uLW51bWVyaWMgdmFsdWVzLiBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4xLjIuNC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4oTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKG5ldyBOdW1iZXIoTmFOKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuICAgICAgLy8gYE5hTmAgYXMgYSBwcmltaXRpdmUgaXMgdGhlIG9ubHkgdmFsdWUgdGhhdCBpcyBub3QgZXF1YWwgdG8gaXRzZWxmXG4gICAgICAvLyAocGVyZm9ybSB0aGUgW1tDbGFzc11dIGNoZWNrIGZpcnN0IHRvIGF2b2lkIGVycm9ycyB3aXRoIHNvbWUgaG9zdCBvYmplY3RzIGluIElFKVxuICAgICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSAhPSArdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYG51bGxgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG51bWJlci5cbiAgICAgKlxuICAgICAqIE5vdGU6IGBOYU5gIGlzIGNvbnNpZGVyZWQgYSBudW1iZXIuIFNlZSBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDguNS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoOC40ICogNSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8XG4gICAgICAgIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBudW1iZXJDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KG5ldyBTaGFwZSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgdmFyIGlzUGxhaW5PYmplY3QgPSAhZ2V0UHJvdG90eXBlT2YgPyBzaGltSXNQbGFpbk9iamVjdCA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoISh2YWx1ZSAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBvYmplY3RDbGFzcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mLFxuICAgICAgICAgIG9ialByb3RvID0gaXNOYXRpdmUodmFsdWVPZikgJiYgKG9ialByb3RvID0gZ2V0UHJvdG90eXBlT2YodmFsdWVPZikpICYmIGdldFByb3RvdHlwZU9mKG9ialByb3RvKTtcblxuICAgICAgcmV0dXJuIG9ialByb3RvXG4gICAgICAgID8gKHZhbHVlID09IG9ialByb3RvIHx8IGdldFByb3RvdHlwZU9mKHZhbHVlKSA9PSBvYmpQcm90bylcbiAgICAgICAgOiBzaGltSXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcmVndWxhciBleHByZXNzaW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgvZnJlZC8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1JlZ0V4cCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSByZWdleHBDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcbiAgICAgICAgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN0cmluZ0NsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAndW5kZWZpbmVkJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgYG9iamVjdGAgYW5kIHZhbHVlcyBnZW5lcmF0ZWQgYnlcbiAgICAgKiBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGUgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhyb3VnaCB0aGUgY2FsbGJhY2suXG4gICAgICogVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHZhbHVlcyBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGBjYWxsYmFja2AgZXhlY3V0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcFZhbHVlcyh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDN9ICwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gKiAzOyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMywgJ2InOiA2LCAnYyc6IDkgfVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSB7XG4gICAgICogICAnZnJlZCc6IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwVmFsdWVzKGNoYXJhY3RlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwVmFsdWVzKG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgZm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBtZXJnZXMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiB0aGUgc291cmNlIG9iamVjdChzKSwgdGhhdFxuICAgICAqIGRvbid0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgaW50byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LiBTdWJzZXF1ZW50IHNvdXJjZXNcbiAgICAgKiB3aWxsIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLiBJZiBhIGNhbGxiYWNrIGlzXG4gICAgICogcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCB0byBwcm9kdWNlIHRoZSBtZXJnZWQgdmFsdWVzIG9mIHRoZSBkZXN0aW5hdGlvblxuICAgICAqIGFuZCBzb3VyY2UgcHJvcGVydGllcy4gSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGAgbWVyZ2luZyB3aWxsXG4gICAgICogYmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM7IChvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2luZyBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG5hbWVzID0ge1xuICAgICAqICAgJ2NoYXJhY3RlcnMnOiBbXG4gICAgICogICAgIHsgJ25hbWUnOiAnYmFybmV5JyB9LFxuICAgICAqICAgICB7ICduYW1lJzogJ2ZyZWQnIH1cbiAgICAgKiAgIF1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGFnZXMgPSB7XG4gICAgICogICAnY2hhcmFjdGVycyc6IFtcbiAgICAgKiAgICAgeyAnYWdlJzogMzYgfSxcbiAgICAgKiAgICAgeyAnYWdlJzogNDAgfVxuICAgICAqICAgXVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlKG5hbWVzLCBhZ2VzKTtcbiAgICAgKiAvLyA9PiB7ICdjaGFyYWN0ZXJzJzogW3sgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sIHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9XSB9XG4gICAgICpcbiAgICAgKiB2YXIgZm9vZCA9IHtcbiAgICAgKiAgICdmcnVpdHMnOiBbJ2FwcGxlJ10sXG4gICAgICogICAndmVnZXRhYmxlcyc6IFsnYmVldCddXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBvdGhlckZvb2QgPSB7XG4gICAgICogICAnZnJ1aXRzJzogWydiYW5hbmEnXSxcbiAgICAgKiAgICd2ZWdldGFibGVzJzogWydjYXJyb3QnXVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlKGZvb2QsIG90aGVyRm9vZCwgZnVuY3Rpb24oYSwgYikge1xuICAgICAqICAgcmV0dXJuIF8uaXNBcnJheShhKSA/IGEuY29uY2F0KGIpIDogdW5kZWZpbmVkO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2ZydWl0cyc6IFsnYXBwbGUnLCAnYmFuYW5hJ10sICd2ZWdldGFibGVzJzogWydiZWV0JywgJ2NhcnJvdF0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlKG9iamVjdCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgbGVuZ3RoID0gMjtcblxuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG4gICAgICAvLyBhbGxvd3Mgd29ya2luZyB3aXRoIGBfLnJlZHVjZWAgYW5kIGBfLnJlZHVjZVJpZ2h0YCB3aXRob3V0IHVzaW5nXG4gICAgICAvLyB0aGVpciBgaW5kZXhgIGFuZCBgY29sbGVjdGlvbmAgYXJndW1lbnRzXG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMl0gIT0gJ251bWJlcicpIHtcbiAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoID4gMyAmJiB0eXBlb2YgYXJnc1tsZW5ndGggLSAyXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGJhc2VDcmVhdGVDYWxsYmFjayhhcmdzWy0tbGVuZ3RoIC0gMV0sIGFyZ3NbbGVuZ3RoLS1dLCAyKTtcbiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiB0eXBlb2YgYXJnc1tsZW5ndGggLSAxXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gYXJnc1stLWxlbmd0aF07XG4gICAgICB9XG4gICAgICB2YXIgc291cmNlcyA9IHNsaWNlKGFyZ3VtZW50cywgMSwgbGVuZ3RoKSxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIHN0YWNrQSA9IGdldEFycmF5KCksXG4gICAgICAgICAgc3RhY2tCID0gZ2V0QXJyYXkoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlc1tpbmRleF0sIGNhbGxiYWNrLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICB9XG4gICAgICByZWxlYXNlQXJyYXkoc3RhY2tBKTtcbiAgICAgIHJlbGVhc2VBcnJheShzdGFja0IpO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgb2JqZWN0YCBleGNsdWRpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAqIFByb3BlcnR5IG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzIG9mXG4gICAgICogcHJvcGVydHkgbmFtZXMuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCBmb3IgZWFjaFxuICAgICAqIHByb3BlcnR5IG9mIGBvYmplY3RgIG9taXR0aW5nIHRoZSBwcm9wZXJ0aWVzIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5XG4gICAgICogZm9yLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258Li4uc3RyaW5nfHN0cmluZ1tdfSBbY2FsbGJhY2tdIFRoZSBwcm9wZXJ0aWVzIHRvIG9taXQgb3IgdGhlXG4gICAgICogIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdpdGhvdXQgdGhlIG9taXR0ZWQgcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5vbWl0KHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9LCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJyB9XG4gICAgICpcbiAgICAgKiBfLm9taXQoeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9taXQob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IFtdO1xuICAgICAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICBwcm9wcy5wdXNoKGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9wcyA9IGJhc2VEaWZmZXJlbmNlKHByb3BzLCBiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIGZhbHNlLCAxKSk7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgICBpZiAoIWNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHR3byBkaW1lbnNpb25hbCBhcnJheSBvZiBhbiBvYmplY3QncyBrZXktdmFsdWUgcGFpcnMsXG4gICAgICogaS5lLiBgW1trZXkxLCB2YWx1ZTFdLCBba2V5MiwgdmFsdWUyXV1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgbmV3IGFycmF5IG9mIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWlycyh7ICdiYXJuZXknOiAzNiwgJ2ZyZWQnOiA0MCB9KTtcbiAgICAgKiAvLyA9PiBbWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQwXV0gKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFpcnMob2JqZWN0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IFtrZXksIG9iamVjdFtrZXldXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYG9iamVjdGAgY29tcG9zZWQgb2YgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAqIFByb3BlcnR5IG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzIG9mXG4gICAgICogcHJvcGVydHkgbmFtZXMuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCBmb3IgZWFjaFxuICAgICAqIHByb3BlcnR5IG9mIGBvYmplY3RgIHBpY2tpbmcgdGhlIHByb3BlcnRpZXMgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXlcbiAgICAgKiBmb3IuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnwuLi5zdHJpbmd8c3RyaW5nW119IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXJcbiAgICAgKiAgaXRlcmF0aW9uIG9yIHByb3BlcnR5IG5hbWVzIHRvIHBpY2ssIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIHByb3BlcnR5XG4gICAgICogIG5hbWVzIG9yIGFycmF5cyBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGljayh7ICduYW1lJzogJ2ZyZWQnLCAnX3VzZXJpZCc6ICdmcmVkMScgfSwgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnIH1cbiAgICAgKlxuICAgICAqIF8ucGljayh7ICduYW1lJzogJ2ZyZWQnLCAnX3VzZXJpZCc6ICdmcmVkMScgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgcmV0dXJuIGtleS5jaGFyQXQoMCkgIT0gJ18nO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBpY2sob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgcHJvcHMgPSBiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIGZhbHNlLCAxKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGlzT2JqZWN0KG9iamVjdCkgPyBwcm9wcy5sZW5ndGggOiAwO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBgXy5yZWR1Y2VgIHRoaXMgbWV0aG9kIHRyYW5zZm9ybXMgYG9iamVjdGAgdG8gYSBuZXdcbiAgICAgKiBgYWNjdW11bGF0b3JgIG9iamVjdCB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgZWFjaCBvZiBpdHMgb3duXG4gICAgICogZW51bWVyYWJsZSBwcm9wZXJ0aWVzIHRocm91Z2ggYSBjYWxsYmFjaywgd2l0aCBlYWNoIGNhbGxiYWNrIGV4ZWN1dGlvblxuICAgICAqIHBvdGVudGlhbGx5IG11dGF0aW5nIHRoZSBgYWNjdW11bGF0b3JgIG9iamVjdC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvXG4gICAgICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM7IChhY2N1bXVsYXRvciwgdmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKiBDYWxsYmFja3MgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBjdXN0b20gYWNjdW11bGF0b3IgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc3F1YXJlcyA9IF8udHJhbnNmb3JtKFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMF0sIGZ1bmN0aW9uKHJlc3VsdCwgbnVtKSB7XG4gICAgICogICBudW0gKj0gbnVtO1xuICAgICAqICAgaWYgKG51bSAlIDIpIHtcbiAgICAgKiAgICAgcmV0dXJuIHJlc3VsdC5wdXNoKG51bSkgPCAzO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxLCA5LCAyNV1cbiAgICAgKlxuICAgICAqIHZhciBtYXBwZWQgPSBfLnRyYW5zZm9ybSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgZnVuY3Rpb24ocmVzdWx0LCBudW0sIGtleSkge1xuICAgICAqICAgcmVzdWx0W2tleV0gPSBudW0gKiAzO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAzLCAnYic6IDYsICdjJzogOSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKG9iamVjdCwgY2FsbGJhY2ssIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iamVjdCk7XG4gICAgICBpZiAoYWNjdW11bGF0b3IgPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjdG9yID0gb2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgICAgcHJvdG8gPSBjdG9yICYmIGN0b3IucHJvdG90eXBlO1xuXG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBiYXNlQ3JlYXRlKHByb3RvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCA0KTtcbiAgICAgICAgKGlzQXJyID8gZm9yRWFjaCA6IGZvck93bikob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBvYmplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGNvbXBvc2VkIG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXSAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IG9iamVjdFtwcm9wc1tpbmRleF1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgZnJvbSB0aGUgc3BlY2lmaWVkIGluZGV4ZXMsIG9yIGtleXMsIG9mIHRoZVxuICAgICAqIGBjb2xsZWN0aW9uYC4gSW5kZXhlcyBtYXkgYmUgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzIG9yIGFzIGFycmF5c1xuICAgICAqIG9mIGluZGV4ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXXxzdHJpbmd8c3RyaW5nW10pfSBbaW5kZXhdIFRoZSBpbmRleGVzIG9mIGBjb2xsZWN0aW9uYFxuICAgICAqICAgdG8gcmV0cmlldmUsIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGluZGV4ZXMgb3IgYXJyYXlzIG9mIGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGVsZW1lbnRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlXG4gICAgICogIHByb3ZpZGVkIGluZGV4ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYXQoWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSwgWzAsIDIsIDRdKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYycsICdlJ11cbiAgICAgKlxuICAgICAqIF8uYXQoWydmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJ10sIDAsIDIpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdChjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0gYmFzZUZsYXR0ZW4oYXJncywgdHJ1ZSwgZmFsc2UsIDEpLFxuICAgICAgICAgIGxlbmd0aCA9IChhcmdzWzJdICYmIGFyZ3NbMl1bYXJnc1sxXV0gPT09IGNvbGxlY3Rpb24pID8gMSA6IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBjb2xsZWN0aW9uW3Byb3BzW2luZGV4XV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGdpdmVuIHZhbHVlIGlzIHByZXNlbnQgaW4gYSBjb2xsZWN0aW9uIHVzaW5nIHN0cmljdCBlcXVhbGl0eVxuICAgICAqIGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0IGlzIHVzZWQgYXMgdGhlXG4gICAgICogb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBpbmNsdWRlXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gY2hlY2sgZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB0YXJnZXRgIGVsZW1lbnQgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb250YWlucyhbMSwgMiwgM10sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uY29udGFpbnMoWzEsIDIsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5jb250YWlucyh7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfSwgJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmNvbnRhaW5zKCdwZWJibGVzJywgJ2ViJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnRhaW5zKGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgIGZyb21JbmRleCA9IChmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KDAsIGxlbmd0aCArIGZyb21JbmRleCkgOiBmcm9tSW5kZXgpIHx8IDA7XG4gICAgICBpZiAoaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgICByZXN1bHQgPSBpbmRleE9mKGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4KSA+IC0xO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHJlc3VsdCA9IChpc1N0cmluZyhjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24uaW5kZXhPZih0YXJnZXQsIGZyb21JbmRleCkgOiBpbmRleE9mKGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4KSkgPiAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmICgrK2luZGV4ID49IGZyb21JbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuICEocmVzdWx0ID0gdmFsdWUgPT09IHRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJvdWdoIHRoZSBjYWxsYmFjay4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVcbiAgICAgKiBvZiBlYWNoIGtleSBpcyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBrZXkgd2FzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjay5cbiAgICAgKiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbNC4zLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gTWF0aC5mbG9vcihudW0pOyB9KTtcbiAgICAgKiAvLyA9PiB7ICc0JzogMSwgJzYnOiAyIH1cbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbNC4zLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gdGhpcy5mbG9vcihudW0pOyB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogMSwgJzYnOiAyIH1cbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiAyLCAnNSc6IDEgfVxuICAgICAqL1xuICAgIHZhciBjb3VudEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSA/IHJlc3VsdFtrZXldKysgOiByZXN1bHRba2V5XSA9IDEpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBjYWxsYmFjayByZXR1cm5zIHRydWV5IHZhbHVlIGZvciAqKmFsbCoqIGVsZW1lbnRzIG9mXG4gICAgICogYSBjb2xsZWN0aW9uLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGFsbFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3NlZCB0aGUgY2FsbGJhY2sgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ldmVyeShbdHJ1ZSwgMSwgbnVsbCwgJ3llcyddKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmV2ZXJ5KGNoYXJhY3RlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmV2ZXJ5KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmICghKHJlc3VsdCA9ICEhY2FsbGJhY2soY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJldHVybiAocmVzdWx0ID0gISFjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYSBjb2xsZWN0aW9uLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gICAgICogdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkgZm9yLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHNlbGVjdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgdGhhdCBwYXNzZWQgdGhlIGNhbGxiYWNrIGNoZWNrLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZXZlbnMgPSBfLmZpbHRlcihbMSwgMiwgMywgNCwgNSwgNl0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICUgMiA9PSAwOyB9KTtcbiAgICAgKiAvLyA9PiBbMiwgNCwgNl1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbHRlcihjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maWx0ZXIoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYSBjb2xsZWN0aW9uLCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdFxuICAgICAqIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5IGZvci4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBkZXRlY3QsIGZpbmRXaGVyZVxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdibG9ja2VkJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmQoY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA8IDQwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZChjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAxIH0pO1xuICAgICAqIC8vID0+ICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmQoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0KFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtICUgMiA9PSAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGZvckVhY2hSaWdodChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGEgY29sbGVjdGlvbiwgZXhlY3V0aW5nIHRoZSBjYWxsYmFjayBmb3IgZWFjaFxuICAgICAqIGVsZW1lbnQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLiBDYWxsYmFja3MgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5XG4gICAgICogZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIE5vdGU6IEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIGBsZW5ndGhgIHByb3BlcnR5XG4gICAgICogYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIGBfLmZvckluYCBvciBgXy5mb3JPd25gXG4gICAgICogbWF5IGJlIHVzZWQgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZWFjaFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkuZm9yRWFjaChmdW5jdGlvbihudW0pIHsgY29uc29sZS5sb2cobnVtKTsgfSkuam9pbignLCcpO1xuICAgICAqIC8vID0+IGxvZ3MgZWFjaCBudW1iZXIgYW5kIHJldHVybnMgJzEsMiwzJ1xuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0sIGZ1bmN0aW9uKG51bSkgeyBjb25zb2xlLmxvZyhudW0pOyB9KTtcbiAgICAgKiAvLyA9PiBsb2dzIGVhY2ggbnVtYmVyIGFuZCByZXR1cm5zIHRoZSBvYmplY3QgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayAmJiB0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrIDogYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKGNvbGxlY3Rpb25baW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckVhY2hgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZWFjaFJpZ2h0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fHN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS5mb3JFYWNoUmlnaHQoZnVuY3Rpb24obnVtKSB7IGNvbnNvbGUubG9nKG51bSk7IH0pLmpvaW4oJywnKTtcbiAgICAgKiAvLyA9PiBsb2dzIGVhY2ggbnVtYmVyIGZyb20gcmlnaHQgdG8gbGVmdCBhbmQgcmV0dXJucyAnMywyLDEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaFJpZ2h0KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgJiYgdHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFjayA6IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2soY29sbGVjdGlvbltsZW5ndGhdLCBsZW5ndGgsIGNvbGxlY3Rpb24pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHJvcHMgPSBrZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAga2V5ID0gcHJvcHMgPyBwcm9wc1stLWxlbmd0aF0gOiAtLWxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY29sbGVjdGlvbltrZXldLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBhIGNvbGxlY3Rpb24gdGhyb3VnaCB0aGUgY2FsbGJhY2suIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlXG4gICAgICogb2YgZWFjaCBrZXkgaXMgYW4gYXJyYXkgb2YgdGhlIGVsZW1lbnRzIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuXG4gICAgICogVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNC4yLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gTWF0aC5mbG9vcihudW0pOyB9KTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi40XSB9XG4gICAgICpcbiAgICAgKiBfLmdyb3VwQnkoWzQuMiwgNi4xLCA2LjRdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIHRoaXMuZmxvb3IobnVtKTsgfSwgTWF0aCk7XG4gICAgICogLy8gPT4geyAnNCc6IFs0LjJdLCAnNic6IFs2LjEsIDYuNF0gfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ncm91cEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IFsnb25lJywgJ3R3byddLCAnNSc6IFsndGhyZWUnXSB9XG4gICAgICovXG4gICAgdmFyIGdyb3VwQnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpID8gcmVzdWx0W2tleV0gOiByZXN1bHRba2V5XSA9IFtdKS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiB0aGUgY29sbGVjdGlvbiB0aHJvdWdoIHRoZSBnaXZlbiBjYWxsYmFjay4gVGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiB2YWx1ZSBvZiBlYWNoIGtleSBpcyB0aGUgbGFzdCBlbGVtZW50IHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuXG4gICAgICogVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIga2V5cyA9IFtcbiAgICAgKiAgIHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LFxuICAgICAqICAgeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmluZGV4Qnkoa2V5cywgJ2RpcicpO1xuICAgICAqIC8vID0+IHsgJ2xlZnQnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ3JpZ2h0JzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICpcbiAgICAgKiBfLmluZGV4Qnkoa2V5cywgZnVuY3Rpb24oa2V5KSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGtleS5jb2RlKTsgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAnZCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqXG4gICAgICogXy5pbmRleEJ5KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGtleSkgeyB0aGlzLmZyb21DaGFyQ29kZShrZXkuY29kZSk7IH0sIFN0cmluZyk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAnZCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqL1xuICAgIHZhciBpbmRleEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBtZXRob2QgbmFtZWQgYnkgYG1ldGhvZE5hbWVgIG9uIGVhY2ggZWxlbWVudCBpbiB0aGUgYGNvbGxlY3Rpb25gXG4gICAgICogcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggaW52b2tlZCBtZXRob2QuIEFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgICogd2lsbCBiZSBwcm92aWRlZCB0byBlYWNoIGludm9rZWQgbWV0aG9kLiBJZiBgbWV0aG9kTmFtZWAgaXMgYSBmdW5jdGlvbiBpdFxuICAgICAqIHdpbGwgYmUgaW52b2tlZCBmb3IsIGFuZCBgdGhpc2AgYm91bmQgdG8sIGVhY2ggZWxlbWVudCBpbiB0aGUgYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGludm9rZSBvclxuICAgICAqICB0aGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggaW52b2tlZCBtZXRob2QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW52b2tlKFtbNSwgMSwgN10sIFszLCAyLCAxXV0sICdzb3J0Jyk7XG4gICAgICogLy8gPT4gW1sxLCA1LCA3XSwgWzEsIDIsIDNdXVxuICAgICAqXG4gICAgICogXy5pbnZva2UoWzEyMywgNDU2XSwgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgJycpO1xuICAgICAqIC8vID0+IFtbJzEnLCAnMicsICczJ10sIFsnNCcsICc1JywgJzYnXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZva2UoY29sbGVjdGlvbiwgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDIpLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNGdW5jID0gdHlwZW9mIG1ldGhvZE5hbWUgPT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgPyBsZW5ndGggOiAwKTtcblxuICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSAoaXNGdW5jID8gbWV0aG9kTmFtZSA6IHZhbHVlW21ldGhvZE5hbWVdKS5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAgKiB0aHJvdWdoIHRoZSBjYWxsYmFjay4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBjb2xsZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGBjYWxsYmFja2AgZXhlY3V0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcChbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICogMzsgfSk7XG4gICAgICogLy8gPT4gWzMsIDYsIDldXG4gICAgICpcbiAgICAgKiBfLm1hcCh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9LCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAqIDM7IH0pO1xuICAgICAqIC8vID0+IFszLCA2LCA5XSAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXAoY2hhcmFjdGVycywgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXN1bHRbKytpbmRleF0gPSBjYWxsYmFjayh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBhIGNvbGxlY3Rpb24uIElmIHRoZSBjb2xsZWN0aW9uIGlzIGVtcHR5IG9yXG4gICAgICogZmFsc2V5IGAtSW5maW5pdHlgIGlzIHJldHVybmVkLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWRcbiAgICAgKiBmb3IgZWFjaCB2YWx1ZSBpbiB0aGUgY29sbGVjdGlvbiB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoIHRoZSB2YWx1ZVxuICAgICAqIGlzIHJhbmtlZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1heChbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXgoY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7IHJldHVybiBjaHIuYWdlOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWF4KGNoYXJhY3RlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXgoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBjb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgICByZXN1bHQgPSBjb21wdXRlZDtcblxuICAgICAgLy8gYWxsb3dzIHdvcmtpbmcgd2l0aCBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgIHdpdGhvdXQgdXNpbmdcbiAgICAgIC8vIHRoZWlyIGBpbmRleGAgYXJndW1lbnQgYXMgYSBjYWxsYmFja1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nICYmIHRoaXNBcmcgJiYgdGhpc0FyZ1tjYWxsYmFja10gPT09IGNvbGxlY3Rpb24pIHtcbiAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrID09IG51bGwgJiYgaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgaWYgKHZhbHVlID4gcmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrID0gKGNhbGxiYWNrID09IG51bGwgJiYgaXNTdHJpbmcoY29sbGVjdGlvbikpXG4gICAgICAgICAgPyBjaGFyQXRDYWxsYmFja1xuICAgICAgICAgIDogbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICBpZiAoY3VycmVudCA+IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICBjb21wdXRlZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIG1pbmltdW0gdmFsdWUgb2YgYSBjb2xsZWN0aW9uLiBJZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eSBvclxuICAgICAqIGZhbHNleSBgSW5maW5pdHlgIGlzIHJldHVybmVkLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWRcbiAgICAgKiBmb3IgZWFjaCB2YWx1ZSBpbiB0aGUgY29sbGVjdGlvbiB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoIHRoZSB2YWx1ZVxuICAgICAqIGlzIHJhbmtlZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1pbihbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5taW4oY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7IHJldHVybiBjaHIuYWdlOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9O1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5taW4oY2hhcmFjdGVycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH07XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSBJbmZpbml0eSxcbiAgICAgICAgICByZXN1bHQgPSBjb21wdXRlZDtcblxuICAgICAgLy8gYWxsb3dzIHdvcmtpbmcgd2l0aCBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgIHdpdGhvdXQgdXNpbmdcbiAgICAgIC8vIHRoZWlyIGBpbmRleGAgYXJndW1lbnQgYXMgYSBjYWxsYmFja1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nICYmIHRoaXNBcmcgJiYgdGhpc0FyZ1tjYWxsYmFja10gPT09IGNvbGxlY3Rpb24pIHtcbiAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrID09IG51bGwgJiYgaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgaWYgKHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrID0gKGNhbGxiYWNrID09IG51bGwgJiYgaXNTdHJpbmcoY29sbGVjdGlvbikpXG4gICAgICAgICAgPyBjaGFyQXRDYWxsYmFja1xuICAgICAgICAgIDogbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICBpZiAoY3VycmVudCA8IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICBjb21wdXRlZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHZhbHVlIG9mIGEgc3BlY2lmaWVkIHByb3BlcnR5IGZyb20gYWxsIGVsZW1lbnRzIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gcGx1Y2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnBsdWNrKGNoYXJhY3RlcnMsICduYW1lJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgdmFyIHBsdWNrID0gbWFwO1xuXG4gICAgLyoqXG4gICAgICogUmVkdWNlcyBhIGNvbGxlY3Rpb24gdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgaW4gdGhlIGNvbGxlY3Rpb24gdGhyb3VnaCB0aGUgY2FsbGJhY2ssIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGNhbGxiYWNrIGV4ZWN1dGlvbiBjb25zdW1lcyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cyBleGVjdXRpb24uIElmXG4gICAgICogYGFjY3VtdWxhdG9yYCBpcyBub3QgcHJvdmlkZWQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGNvbGxlY3Rpb24gd2lsbCBiZVxuICAgICAqIHVzZWQgYXMgdGhlIGluaXRpYWwgYGFjY3VtdWxhdG9yYCB2YWx1ZS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYFxuICAgICAqIGFuZCBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM7IChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZm9sZGwsIGluamVjdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIEluaXRpYWwgdmFsdWUgb2YgdGhlIGFjY3VtdWxhdG9yLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHN1bSA9IF8ucmVkdWNlKFsxLCAyLCAzXSwgZnVuY3Rpb24oc3VtLCBudW0pIHtcbiAgICAgKiAgIHJldHVybiBzdW0gKyBudW07XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogdmFyIG1hcHBlZCA9IF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCBmdW5jdGlvbihyZXN1bHQsIG51bSwga2V5KSB7XG4gICAgICogICByZXN1bHRba2V5XSA9IG51bSAqIDM7XG4gICAgICogICByZXR1cm4gcmVzdWx0O1xuICAgICAqIH0sIHt9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMywgJ2InOiA2LCAnYyc6IDkgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBjYWxsYmFjaywgYWNjdW11bGF0b3IsIHRoaXNBcmcpIHtcbiAgICAgIGlmICghY29sbGVjdGlvbikgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgICAgdmFyIG5vYWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCA0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChub2FjY3VtKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBjb2xsZWN0aW9uWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBjYWxsYmFjayhhY2N1bXVsYXRvciwgY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gbm9hY2N1bVxuICAgICAgICAgICAgPyAobm9hY2N1bSA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgICAgICAgIDogY2FsbGJhY2soYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5yZWR1Y2VgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZm9sZHJcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBJbml0aWFsIHZhbHVlIG9mIHRoZSBhY2N1bXVsYXRvci5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBsaXN0ID0gW1swLCAxXSwgWzIsIDNdLCBbNCwgNV1dO1xuICAgICAqIHZhciBmbGF0ID0gXy5yZWR1Y2VSaWdodChsaXN0LCBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhLmNvbmNhdChiKTsgfSwgW10pO1xuICAgICAqIC8vID0+IFs0LCA1LCAyLCAzLCAwLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCBhY2N1bXVsYXRvciwgdGhpc0FyZykge1xuICAgICAgdmFyIG5vYWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCA0KTtcbiAgICAgIGZvckVhY2hSaWdodChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBub2FjY3VtXG4gICAgICAgICAgPyAobm9hY2N1bSA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgICAgICA6IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmZpbHRlcmAgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZWxlbWVudHMgb2YgYVxuICAgICAqIGNvbGxlY3Rpb24gdGhhdCB0aGUgY2FsbGJhY2sgZG9lcyAqKm5vdCoqIHJldHVybiB0cnVleSBmb3IuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgdGhhdCBmYWlsZWQgdGhlIGNhbGxiYWNrIGNoZWNrLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2RkcyA9IF8ucmVqZWN0KFsxLCAyLCAzLCA0LCA1LCA2XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gJSAyID09IDA7IH0pO1xuICAgICAqIC8vID0+IFsxLCAzLCA1XVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVqZWN0KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH1dXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnJlamVjdChjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWplY3QoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHJldHVybiBmaWx0ZXIoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAhY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIHJhbmRvbSBlbGVtZW50IG9yIGBuYCByYW5kb20gZWxlbWVudHMgZnJvbSBhIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbl0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEFsbG93cyB3b3JraW5nIHdpdGggZnVuY3Rpb25zIGxpa2UgYF8ubWFwYFxuICAgICAqICB3aXRob3V0IHVzaW5nIHRoZWlyIGBpbmRleGAgYXJndW1lbnRzIGFzIGBuYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBzYW1wbGUocykgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSwgMik7XG4gICAgICogLy8gPT4gWzMsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FtcGxlKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiAmJiB0eXBlb2YgY29sbGVjdGlvbi5sZW5ndGggIT0gJ251bWJlcicpIHtcbiAgICAgICAgY29sbGVjdGlvbiA9IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uW2Jhc2VSYW5kb20oMCwgY29sbGVjdGlvbi5sZW5ndGggLSAxKV0gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gc2h1ZmZsZShjb2xsZWN0aW9uKTtcbiAgICAgIHJlc3VsdC5sZW5ndGggPSBuYXRpdmVNaW4obmF0aXZlTWF4KDAsIG4pLCByZXN1bHQubGVuZ3RoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBzaHVmZmxlZCB2YWx1ZXMsIHVzaW5nIGEgdmVyc2lvbiBvZiB0aGUgRmlzaGVyLVlhdGVzXG4gICAgICogc2h1ZmZsZS4gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyLVlhdGVzX3NodWZmbGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgc2h1ZmZsZWQgY29sbGVjdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaHVmZmxlKFsxLCAyLCAzLCA0LCA1LCA2XSk7XG4gICAgICogLy8gPT4gWzQsIDEsIDYsIDMsIDUsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgPyBsZW5ndGggOiAwKTtcblxuICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgcmFuZCA9IGJhc2VSYW5kb20oMCwgKytpbmRleCk7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSByZXN1bHRbcmFuZF07XG4gICAgICAgIHJlc3VsdFtyYW5kXSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNpemUgb2YgdGhlIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgYGNvbGxlY3Rpb24ubGVuZ3RoYCBmb3IgYXJyYXlzXG4gICAgICogYW5kIGFycmF5LWxpa2Ugb2JqZWN0cyBvciB0aGUgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgZm9yIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGBjb2xsZWN0aW9uLmxlbmd0aGAgb3IgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2l6ZShbMSwgMl0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc2l6ZSh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnNpemUoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiA3XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcbiAgICAgIHJldHVybiB0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInID8gbGVuZ3RoIDoga2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjYWxsYmFjayByZXR1cm5zIGEgdHJ1ZXkgdmFsdWUgZm9yICoqYW55KiogZWxlbWVudCBvZiBhXG4gICAgICogY29sbGVjdGlvbi4gVGhlIGZ1bmN0aW9uIHJldHVybnMgYXMgc29vbiBhcyBpdCBmaW5kcyBhIHBhc3NpbmcgdmFsdWUgYW5kXG4gICAgICogZG9lcyBub3QgaXRlcmF0ZSBvdmVyIHRoZSBlbnRpcmUgY29sbGVjdGlvbi4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvXG4gICAgICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBhbnlcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlZCB0aGUgY2FsbGJhY2sgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb21lKFtudWxsLCAwLCAneWVzJywgZmFsc2VdLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb21lKGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb21lKGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDEgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb21lKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmICgocmVzdWx0ID0gY2FsbGJhY2soY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJldHVybiAhKHJlc3VsdCA9IGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzLCBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSByZXN1bHRzIG9mXG4gICAgICogcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uIHRocm91Z2ggdGhlIGNhbGxiYWNrLiBUaGlzIG1ldGhvZFxuICAgICAqIHBlcmZvcm1zIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHdpbGwgcHJlc2VydmUgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXJcbiAgICAgKiBvZiBlcXVhbCBlbGVtZW50cy4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY29sbGVjdGlvblxuICAgICAqIHdpbGwgYmUgc29ydGVkIGJ5IGVhY2ggcHJvcGVydHkgdmFsdWUuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2Ygc29ydGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeShbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gTWF0aC5zaW4obnVtKTsgfSk7XG4gICAgICogLy8gPT4gWzMsIDEsIDJdXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeShbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gdGhpcy5zaW4obnVtKTsgfSwgTWF0aCk7XG4gICAgICogLy8gPT4gWzMsIDEsIDJdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYWdlJzogMjYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiAzMCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwKF8uc29ydEJ5KGNoYXJhY3RlcnMsICdhZ2UnKSwgXy52YWx1ZXMpO1xuICAgICAqIC8vID0+IFtbJ2Jhcm5leScsIDI2XSwgWydmcmVkJywgMzBdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgNDBdXVxuICAgICAqXG4gICAgICogLy8gc29ydGluZyBieSBtdWx0aXBsZSBwcm9wZXJ0aWVzXG4gICAgICogXy5tYXAoXy5zb3J0QnkoY2hhcmFjdGVycywgWyduYW1lJywgJ2FnZSddKSwgXy52YWx1ZXMpO1xuICAgICAqIC8vID0gPiBbWydiYXJuZXknLCAyNl0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCAzMF0sIFsnZnJlZCcsIDQwXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0QnkoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzQXJyID0gaXNBcnJheShjYWxsYmFjayksXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheSh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInID8gbGVuZ3RoIDogMCk7XG5cbiAgICAgIGlmICghaXNBcnIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgfVxuICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSByZXN1bHRbKytpbmRleF0gPSBnZXRPYmplY3QoKTtcbiAgICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgICAgb2JqZWN0LmNyaXRlcmlhID0gbWFwKGNhbGxiYWNrLCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIChvYmplY3QuY3JpdGVyaWEgPSBnZXRBcnJheSgpKVswXSA9IGNhbGxiYWNrKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdC5pbmRleCA9IGluZGV4O1xuICAgICAgICBvYmplY3QudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuICAgICAgcmVzdWx0LnNvcnQoY29tcGFyZUFzY2VuZGluZyk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IHJlc3VsdFtsZW5ndGhdO1xuICAgICAgICByZXN1bHRbbGVuZ3RoXSA9IG9iamVjdC52YWx1ZTtcbiAgICAgICAgaWYgKCFpc0Fycikge1xuICAgICAgICAgIHJlbGVhc2VBcnJheShvYmplY3QuY3JpdGVyaWEpO1xuICAgICAgICB9XG4gICAgICAgIHJlbGVhc2VPYmplY3Qob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGBjb2xsZWN0aW9uYCB0byBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGNvbnZlcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogKGZ1bmN0aW9uKCkgeyByZXR1cm4gXy50b0FycmF5KGFyZ3VtZW50cykuc2xpY2UoMSk7IH0pKDEsIDIsIDMsIDQpO1xuICAgICAqIC8vID0+IFsyLCAzLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvQXJyYXkoY29sbGVjdGlvbikge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gJiYgdHlwZW9mIGNvbGxlY3Rpb24ubGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBzbGljZShjb2xsZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gb2YgZWFjaCBlbGVtZW50IGluIGEgYGNvbGxlY3Rpb25gIHRvIHRoZSBnaXZlblxuICAgICAqIGBwcm9wZXJ0aWVzYCBvYmplY3QsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHMgdGhhdCBoYXZlIGVxdWl2YWxlbnRcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBnaXZlbiBwcm9wZXJ0aWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAncGV0cyc6IFsnaG9wcHknXSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAsICdwZXRzJzogWydiYWJ5IHB1c3MnLCAnZGlubyddIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy53aGVyZShjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdwZXRzJzogWydob3BweSddIH1dXG4gICAgICpcbiAgICAgKiBfLndoZXJlKGNoYXJhY3RlcnMsIHsgJ3BldHMnOiBbJ2Rpbm8nXSB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwLCAncGV0cyc6IFsnYmFieSBwdXNzJywgJ2Rpbm8nXSB9XVxuICAgICAqL1xuICAgIHZhciB3aGVyZSA9IGZpbHRlcjtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBmYWxzZXkgdmFsdWVzIHJlbW92ZWQuIFRoZSB2YWx1ZXMgYGZhbHNlYCwgYG51bGxgLFxuICAgICAqIGAwYCwgYFwiXCJgLCBgdW5kZWZpbmVkYCwgYW5kIGBOYU5gIGFyZSBhbGwgZmFsc2V5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY29tcGFjdChbMCwgMSwgZmFsc2UsIDIsICcnLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFjdChhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgdmFsdWVzIG9mIHRoZSBwcm92aWRlZCBhcnJheXMgdXNpbmcgc3RyaWN0XG4gICAgICogZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSBhcnJheXMgb2YgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlKFsxLCAyLCAzLCA0LCA1XSwgWzUsIDIsIDEwXSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlmZmVyZW5jZShhcnJheSkge1xuICAgICAgcmV0dXJuIGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgdGhhdCBwYXNzZXMgdGhlIGNhbGxiYWNrIGNoZWNrLCBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZEluZGV4KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPCAyMDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRJbmRleChjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRJbmRleChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRJbmRleGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiB0cnVlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEluZGV4KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPiAzMDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEluZGV4KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KSkge1xuICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmaXJzdCBlbGVtZW50IG9yIGZpcnN0IGBuYCBlbGVtZW50cyBvZiBhbiBhcnJheS4gSWYgYSBjYWxsYmFja1xuICAgICAqIGlzIHByb3ZpZGVkIGVsZW1lbnRzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5IGFyZSByZXR1cm5lZCBhcyBsb25nXG4gICAgICogYXMgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgaGVhZCwgdGFrZVxuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8bnVtYmVyfHN0cmluZ30gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBlbGVtZW50IG9yIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmV0dXJuLiBJZiBhIHByb3BlcnR5IG5hbWUgb3JcbiAgICAgKiAgb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIlxuICAgICAqICBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50KHMpIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmlyc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmZpcnN0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLmZpcnN0KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtIDwgMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2Jsb2NrZWQnOiBmYWxzZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ25hJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmlyc3QoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYmxvY2tlZCc6IHRydWUsICdlbXBsb3llcic6ICdzbGF0ZScgfV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5maXJzdChjaGFyYWN0ZXJzLCB7ICdlbXBsb3llcic6ICdzbGF0ZScgfSksICduYW1lJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlyc3QoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbiA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdudW1iZXInICYmIGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gY2FsbGJhY2s7XG4gICAgICAgIGlmIChuID09IG51bGwgfHwgdGhpc0FyZykge1xuICAgICAgICAgIHJldHVybiBhcnJheSA/IGFycmF5WzBdIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xpY2UoYXJyYXksIDAsIG5hdGl2ZU1pbihuYXRpdmVNYXgoMCwgbiksIGxlbmd0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW5zIGEgbmVzdGVkIGFycmF5ICh0aGUgbmVzdGluZyBjYW4gYmUgdG8gYW55IGRlcHRoKS4gSWYgYGlzU2hhbGxvd2BcbiAgICAgKiBpcyB0cnVleSwgdGhlIGFycmF5IHdpbGwgb25seSBiZSBmbGF0dGVuZWQgYSBzaW5nbGUgbGV2ZWwuIElmIGEgY2FsbGJhY2tcbiAgICAgKiBpcyBwcm92aWRlZCBlYWNoIGVsZW1lbnQgb2YgdGhlIGFycmF5IGlzIHBhc3NlZCB0aHJvdWdoIHRoZSBjYWxsYmFjayBiZWZvcmVcbiAgICAgKiBmbGF0dGVuaW5nLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU2hhbGxvdz1mYWxzZV0gQSBmbGFnIHRvIHJlc3RyaWN0IGZsYXR0ZW5pbmcgdG8gYSBzaW5nbGUgbGV2ZWwuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyXSwgWzMsIFtbNF1dXV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XTtcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbihbMSwgWzJdLCBbMywgW1s0XV1dXSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFtbNF1dXTtcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzAsICdwZXRzJzogWydob3BweSddIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ3BldHMnOiBbJ2JhYnkgcHVzcycsICdkaW5vJ10gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZsYXR0ZW4oY2hhcmFjdGVycywgJ3BldHMnKTtcbiAgICAgKiAvLyA9PiBbJ2hvcHB5JywgJ2JhYnkgcHVzcycsICdkaW5vJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuKGFycmF5LCBpc1NoYWxsb3csIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAvLyBqdWdnbGUgYXJndW1lbnRzXG4gICAgICBpZiAodHlwZW9mIGlzU2hhbGxvdyAhPSAnYm9vbGVhbicgJiYgaXNTaGFsbG93ICE9IG51bGwpIHtcbiAgICAgICAgdGhpc0FyZyA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayA9ICh0eXBlb2YgaXNTaGFsbG93ICE9ICdmdW5jdGlvbicgJiYgdGhpc0FyZyAmJiB0aGlzQXJnW2lzU2hhbGxvd10gPT09IGFycmF5KSA/IG51bGwgOiBpc1NoYWxsb3c7XG4gICAgICAgIGlzU2hhbGxvdyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgYXJyYXkgPSBtYXAoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihhcnJheSwgaXNTaGFsbG93KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIHVzaW5nXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC4gSWYgdGhlIGFycmF5IGlzIGFscmVhZHkgc29ydGVkXG4gICAgICogcHJvdmlkaW5nIGB0cnVlYCBmb3IgYGZyb21JbmRleGAgd2lsbCBydW4gYSBmYXN0ZXIgYmluYXJ5IHNlYXJjaC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtib29sZWFufG51bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20gb3IgYHRydWVgXG4gICAgICogIHRvIHBlcmZvcm0gYSBiaW5hcnkgc2VhcmNoIG9uIGEgc29ydGVkIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlIG9yIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIsIDMpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMSwgMiwgMiwgMywgM10sIDIsIHRydWUpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICBpZiAodHlwZW9mIGZyb21JbmRleCA9PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgICBmcm9tSW5kZXggPSAoZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heCgwLCBsZW5ndGggKyBmcm9tSW5kZXgpIDogZnJvbUluZGV4IHx8IDApO1xuICAgICAgfSBlbHNlIGlmIChmcm9tSW5kZXgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gc29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2luZGV4XSA9PT0gdmFsdWUgPyBpbmRleCA6IC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGxhc3QgZWxlbWVudCBvciBsYXN0IGBuYCBlbGVtZW50cyBvZiBhbiBhcnJheS4gSWYgYVxuICAgICAqIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGVsZW1lbnRzIGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5IGFyZSBleGNsdWRlZCBmcm9tXG4gICAgICogdGhlIHJlc3VsdCBhcyBsb25nIGFzIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmRcbiAgICAgKiB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxudW1iZXJ8c3RyaW5nfSBbY2FsbGJhY2s9MV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgZWxlbWVudCBvciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGV4Y2x1ZGUuIElmIGEgcHJvcGVydHkgbmFtZSBvclxuICAgICAqICBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiXG4gICAgICogIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLmluaXRpYWwoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSA+IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdibG9ja2VkJzogZmFsc2UsICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICduYScgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmluaXRpYWwoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiBmYWxzZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmluaXRpYWwoY2hhcmFjdGVycywgeyAnZW1wbG95ZXInOiAnbmEnIH0pLCAnbmFtZScpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRpYWwoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbiA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdudW1iZXInICYmIGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIHdoaWxlIChpbmRleC0tICYmIGNhbGxiYWNrKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IChjYWxsYmFjayA9PSBudWxsIHx8IHRoaXNBcmcpID8gMSA6IGNhbGxiYWNrIHx8IG47XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xpY2UoYXJyYXksIDAsIG5hdGl2ZU1pbihuYXRpdmVNYXgoMCwgbGVuZ3RoIC0gbiksIGxlbmd0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyBwcmVzZW50IGluIGFsbCBwcm92aWRlZCBhcnJheXMgdXNpbmdcbiAgICAgKiBzdHJpY3QgZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheV0gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBzaGFyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbihbMSwgMiwgM10sIFs1LCAyLCAxLCA0XSwgWzIsIDFdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgIGNhY2hlcyA9IGdldEFycmF5KCksXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICB0cnVzdEluZGV4T2YgPSBpbmRleE9mID09PSBiYXNlSW5kZXhPZixcbiAgICAgICAgICBzZWVuID0gZ2V0QXJyYXkoKTtcblxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbYXJnc0luZGV4XTtcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkge1xuICAgICAgICAgIGFyZ3MucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgY2FjaGVzLnB1c2godHJ1c3RJbmRleE9mICYmIHZhbHVlLmxlbmd0aCA+PSBsYXJnZUFycmF5U2l6ZSAmJlxuICAgICAgICAgICAgY3JlYXRlQ2FjaGUoYXJnc0luZGV4ID8gYXJnc1thcmdzSW5kZXhdIDogc2VlbikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgYXJyYXkgPSBhcmdzWzBdLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IGNhY2hlc1swXTtcbiAgICAgICAgdmFsdWUgPSBhcnJheVtpbmRleF07XG5cbiAgICAgICAgaWYgKChjYWNoZSA/IGNhY2hlSW5kZXhPZihjYWNoZSwgdmFsdWUpIDogaW5kZXhPZihzZWVuLCB2YWx1ZSkpIDwgMCkge1xuICAgICAgICAgIGFyZ3NJbmRleCA9IGFyZ3NMZW5ndGg7XG4gICAgICAgICAgKGNhY2hlIHx8IHNlZW4pLnB1c2godmFsdWUpO1xuICAgICAgICAgIHdoaWxlICgtLWFyZ3NJbmRleCkge1xuICAgICAgICAgICAgY2FjaGUgPSBjYWNoZXNbYXJnc0luZGV4XTtcbiAgICAgICAgICAgIGlmICgoY2FjaGUgPyBjYWNoZUluZGV4T2YoY2FjaGUsIHZhbHVlKSA6IGluZGV4T2YoYXJnc1thcmdzSW5kZXhdLCB2YWx1ZSkpIDwgMCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoYXJnc0xlbmd0aC0tKSB7XG4gICAgICAgIGNhY2hlID0gY2FjaGVzW2FyZ3NMZW5ndGhdO1xuICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICByZWxlYXNlT2JqZWN0KGNhY2hlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVsZWFzZUFycmF5KGNhY2hlcyk7XG4gICAgICByZWxlYXNlQXJyYXkoc2Vlbik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvciBsYXN0IGBuYCBlbGVtZW50cyBvZiBhbiBhcnJheS4gSWYgYSBjYWxsYmFjayBpc1xuICAgICAqIHByb3ZpZGVkIGVsZW1lbnRzIGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5IGFyZSByZXR1cm5lZCBhcyBsb25nIGFzIHRoZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fG51bWJlcnxzdHJpbmd9IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgZWxlbWVudCBvciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJldHVybi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yXG4gICAgICogIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCJcbiAgICAgKiAgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50KHMpIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtID4gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiBmYWxzZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ25hJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5sYXN0KGNoYXJhY3RlcnMsICdibG9ja2VkJyksICduYW1lJyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5sYXN0KGNoYXJhY3RlcnMsIHsgJ2VtcGxveWVyJzogJ25hJyB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAnZW1wbG95ZXInOiAnbmEnIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBuID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ251bWJlcicgJiYgY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaW5kZXggPSBsZW5ndGg7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgd2hpbGUgKGluZGV4LS0gJiYgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gY2FsbGJhY2s7XG4gICAgICAgIGlmIChuID09IG51bGwgfHwgdGhpc0FyZykge1xuICAgICAgICAgIHJldHVybiBhcnJheSA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xpY2UoYXJyYXksIG5hdGl2ZU1heCgwLCBsZW5ndGggLSBuKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIHVzaW5nIHN0cmljdFxuICAgICAqIGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0IGlzIHVzZWRcbiAgICAgKiBhcyB0aGUgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1hcnJheS5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlIG9yIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDMsIDEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAzLCAxLCAyLCAzXSwgMiwgMyk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgaW5kZXggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAodHlwZW9mIGZyb21JbmRleCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpbmRleCA9IChmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KDAsIGluZGV4ICsgZnJvbUluZGV4KSA6IG5hdGl2ZU1pbihmcm9tSW5kZXgsIGluZGV4IC0gMSkpICsgMTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgcHJvdmlkZWQgdmFsdWVzIGZyb20gdGhlIGdpdmVuIGFycmF5IHVzaW5nIHN0cmljdCBlcXVhbGl0eSBmb3JcbiAgICAgKiBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlXSBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDEsIDIsIDNdO1xuICAgICAqIF8ucHVsbChhcnJheSwgMiwgMyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGwoYXJyYXkpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IDAsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgtLSwgMSk7XG4gICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG51bWJlcnMgKHBvc2l0aXZlIGFuZC9vciBuZWdhdGl2ZSkgcHJvZ3Jlc3NpbmcgZnJvbVxuICAgICAqIGBzdGFydGAgdXAgdG8gYnV0IG5vdCBpbmNsdWRpbmcgYGVuZGAuIElmIGBzdGFydGAgaXMgbGVzcyB0aGFuIGBzdG9wYCBhXG4gICAgICogemVyby1sZW5ndGggcmFuZ2UgaXMgY3JlYXRlZCB1bmxlc3MgYSBuZWdhdGl2ZSBgc3RlcGAgaXMgc3BlY2lmaWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgcmFuZ2UgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoNCk7XG4gICAgICogLy8gPT4gWzAsIDEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAyMCwgNSk7XG4gICAgICogLy8gPT4gWzAsIDUsIDEwLCAxNV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgICAgc3RhcnQgPSArc3RhcnQgfHwgMDtcbiAgICAgIHN0ZXAgPSB0eXBlb2Ygc3RlcCA9PSAnbnVtYmVyJyA/IHN0ZXAgOiAoK3N0ZXAgfHwgMSk7XG5cbiAgICAgIGlmIChlbmQgPT0gbnVsbCkge1xuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfVxuICAgICAgLy8gdXNlIGBBcnJheShsZW5ndGgpYCBzbyBlbmdpbmVzIGxpa2UgQ2hha3JhIGFuZCBWOCBhdm9pZCBzbG93ZXIgbW9kZXNcbiAgICAgIC8vIGh0dHA6Ly95b3V0dS5iZS9YQXFJcEdVOFpaayN0PTE3bTI1c1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KDAsIGNlaWwoKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHN0YXJ0O1xuICAgICAgICBzdGFydCArPSBzdGVwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIGFuIGFycmF5IHRoYXQgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkgZm9yXG4gICAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYFxuICAgICAqIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCA0LCA1LCA2XTtcbiAgICAgKiB2YXIgZXZlbnMgPSBfLnJlbW92ZShhcnJheSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gJSAyID09IDA7IH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAzLCA1XVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZXZlbnMpO1xuICAgICAqIC8vID0+IFsyLCA0LCA2XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZShhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGluZGV4LS0sIDEpO1xuICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5pbml0aWFsYCB0aGlzIG1ldGhvZCBnZXRzIGFsbCBidXQgdGhlIGZpcnN0IGVsZW1lbnQgb3JcbiAgICAgKiBmaXJzdCBgbmAgZWxlbWVudHMgb2YgYW4gYXJyYXkuIElmIGEgY2FsbGJhY2sgZnVuY3Rpb24gaXMgcHJvdmlkZWQgZWxlbWVudHNcbiAgICAgKiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheSBhcmUgZXhjbHVkZWQgZnJvbSB0aGUgcmVzdWx0IGFzIGxvbmcgYXMgdGhlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyB0cnVleS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBkcm9wLCB0YWlsXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxudW1iZXJ8c3RyaW5nfSBbY2FsbGJhY2s9MV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgZWxlbWVudCBvciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGV4Y2x1ZGUuIElmIGEgcHJvcGVydHkgbmFtZSBvclxuICAgICAqICBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiXG4gICAgICogIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLnJlc3QoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8ucmVzdChbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSA8IDM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdibG9ja2VkJzogZmFsc2UsICAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICdlbXBsb3llcic6ICduYScgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8ucmVzdChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpLCAnbmFtZScpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVzdChjaGFyYWN0ZXJzLCB7ICdlbXBsb3llcic6ICdzbGF0ZScgfSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgJ2VtcGxveWVyJzogJ25hJyB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3QoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdudW1iZXInICYmIGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG4gPSAwLFxuICAgICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGNhbGxiYWNrKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IChjYWxsYmFjayA9PSBudWxsIHx8IHRoaXNBcmcpID8gMSA6IG5hdGl2ZU1heCgwLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xpY2UoYXJyYXksIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZXMgYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2ggYSB2YWx1ZVxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGEgZ2l2ZW4gc29ydGVkIGFycmF5IGluIG9yZGVyIHRvIG1haW50YWluIHRoZSBzb3J0XG4gICAgICogb3JkZXIgb2YgdGhlIGFycmF5LiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgZm9yXG4gICAgICogYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpciBzb3J0IHJhbmtpbmcuIFRoZVxuICAgICAqIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFsyMCwgMzAsIDUwXSwgNDApO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc29ydGVkSW5kZXgoW3sgJ3gnOiAyMCB9LCB7ICd4JzogMzAgfSwgeyAneCc6IDUwIH1dLCB7ICd4JzogNDAgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiB2YXIgZGljdCA9IHtcbiAgICAgKiAgICd3b3JkVG9OdW1iZXInOiB7ICd0d2VudHknOiAyMCwgJ3RoaXJ0eSc6IDMwLCAnZm91cnR5JzogNDAsICdmaWZ0eSc6IDUwIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbJ3R3ZW50eScsICd0aGlydHknLCAnZmlmdHknXSwgJ2ZvdXJ0eScsIGZ1bmN0aW9uKHdvcmQpIHtcbiAgICAgKiAgIHJldHVybiBkaWN0LndvcmRUb051bWJlclt3b3JkXTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFsndHdlbnR5JywgJ3RoaXJ0eScsICdmaWZ0eSddLCAnZm91cnR5JywgZnVuY3Rpb24od29yZCkge1xuICAgICAqICAgcmV0dXJuIHRoaXMud29yZFRvTnVtYmVyW3dvcmRdO1xuICAgICAqIH0sIGRpY3QpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiBsb3c7XG5cbiAgICAgIC8vIGV4cGxpY2l0bHkgcmVmZXJlbmNlIGBpZGVudGl0eWAgZm9yIGJldHRlciBpbmxpbmluZyBpbiBGaXJlZm94XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAxKSA6IGlkZW50aXR5O1xuICAgICAgdmFsdWUgPSBjYWxsYmFjayh2YWx1ZSk7XG5cbiAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDE7XG4gICAgICAgIChjYWxsYmFjayhhcnJheVttaWRdKSA8IHZhbHVlKVxuICAgICAgICAgID8gbG93ID0gbWlkICsgMVxuICAgICAgICAgIDogaGlnaCA9IG1pZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsb3c7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBvcmRlciwgb2YgdGhlIHByb3ZpZGVkIGFycmF5cyB1c2luZ1xuICAgICAqIHN0cmljdCBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5XSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbihbMSwgMiwgM10sIFs1LCAyLCAxLCA0XSwgWzIsIDFdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNSwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlvbigpIHtcbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZHVwbGljYXRlLXZhbHVlLWZyZWUgdmVyc2lvbiBvZiBhbiBhcnJheSB1c2luZyBzdHJpY3QgZXF1YWxpdHlcbiAgICAgKiBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuIElmIHRoZSBhcnJheSBpcyBzb3J0ZWQsIHByb3ZpZGluZ1xuICAgICAqIGB0cnVlYCBmb3IgYGlzU29ydGVkYCB3aWxsIHVzZSBhIGZhc3RlciBhbGdvcml0aG0uIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWRcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCBpcyBwYXNzZWQgdGhyb3VnaCB0aGUgY2FsbGJhY2sgYmVmb3JlIHVuaXF1ZW5lc3NcbiAgICAgKiBpcyBjb21wdXRlZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyB1bmlxdWVcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTb3J0ZWQ9ZmFsc2VdIEEgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IGBhcnJheWAgaXMgc29ydGVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcShbMSwgMiwgMSwgMywgMV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy51bmlxKFsxLCAxLCAyLCAyLCAzXSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWydBJywgJ2InLCAnQycsICdhJywgJ0InLCAnYyddLCBmdW5jdGlvbihsZXR0ZXIpIHsgcmV0dXJuIGxldHRlci50b0xvd2VyQ2FzZSgpOyB9KTtcbiAgICAgKiAvLyA9PiBbJ0EnLCAnYicsICdDJ11cbiAgICAgKlxuICAgICAqIF8udW5pcShbMSwgMi41LCAzLCAxLjUsIDIsIDMuNV0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gdGhpcy5mbG9vcihudW0pOyB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiBbMSwgMi41LCAzXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy51bmlxKFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxKGFycmF5LCBpc1NvcnRlZCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIC8vIGp1Z2dsZSBhcmd1bWVudHNcbiAgICAgIGlmICh0eXBlb2YgaXNTb3J0ZWQgIT0gJ2Jvb2xlYW4nICYmIGlzU29ydGVkICE9IG51bGwpIHtcbiAgICAgICAgdGhpc0FyZyA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayA9ICh0eXBlb2YgaXNTb3J0ZWQgIT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnICYmIHRoaXNBcmdbaXNTb3J0ZWRdID09PSBhcnJheSkgPyBudWxsIDogaXNTb3J0ZWQ7XG4gICAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYXJyYXksIGlzU29ydGVkLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBleGNsdWRpbmcgYWxsIHByb3ZpZGVkIHZhbHVlcyB1c2luZyBzdHJpY3QgZXF1YWxpdHkgZm9yXG4gICAgICogY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbHRlci5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZV0gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ud2l0aG91dChbMSwgMiwgMSwgMCwgMywgMSwgNF0sIDAsIDEpO1xuICAgICAqIC8vID0+IFsyLCAzLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdpdGhvdXQoYXJyYXkpIHtcbiAgICAgIHJldHVybiBiYXNlRGlmZmVyZW5jZShhcnJheSwgc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBzeW1tZXRyaWMgZGlmZmVyZW5jZSBvZiB0aGUgcHJvdmlkZWQgYXJyYXlzLlxuICAgICAqIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N5bW1ldHJpY19kaWZmZXJlbmNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheV0gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ueG9yKFsxLCAyLCAzXSwgWzUsIDIsIDEsIDRdKTtcbiAgICAgKiAvLyA9PiBbMywgNSwgNF1cbiAgICAgKlxuICAgICAqIF8ueG9yKFsxLCAyLCA1XSwgWzIsIDMsIDVdLCBbMywgNCwgNV0pO1xuICAgICAqIC8vID0+IFsxLCA0LCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHhvcigpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIGlmIChpc0FycmF5KGFycmF5KSB8fCBpc0FyZ3VtZW50cyhhcnJheSkpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0XG4gICAgICAgICAgICA/IGJhc2VVbmlxKGJhc2VEaWZmZXJlbmNlKHJlc3VsdCwgYXJyYXkpLmNvbmNhdChiYXNlRGlmZmVyZW5jZShhcnJheSwgcmVzdWx0KSkpXG4gICAgICAgICAgICA6IGFycmF5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0IHx8IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cywgdGhlIGZpcnN0IG9mIHdoaWNoIGNvbnRhaW5zIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIHRoZSBzZWNvbmQgb2Ygd2hpY2ggY29udGFpbnMgdGhlIHNlY29uZFxuICAgICAqIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyB1bnppcFxuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXldIEFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcChbJ2ZyZWQnLCAnYmFybmV5J10sIFszMCwgNDBdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydmcmVkJywgMzAsIHRydWVdLCBbJ2Jhcm5leScsIDQwLCBmYWxzZV1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwKCkge1xuICAgICAgdmFyIGFycmF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHMgOiBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IG1heChwbHVjayhhcnJheSwgJ2xlbmd0aCcpKSA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gcGx1Y2soYXJyYXksIGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgZnJvbSBhcnJheXMgb2YgYGtleXNgIGFuZCBgdmFsdWVzYC4gUHJvdmlkZVxuICAgICAqIGVpdGhlciBhIHNpbmdsZSB0d28gZGltZW5zaW9uYWwgYXJyYXksIGkuZS4gYFtba2V5MSwgdmFsdWUxXSwgW2tleTIsIHZhbHVlMl1dYFxuICAgICAqIG9yIHR3byBhcnJheXMsIG9uZSBvZiBga2V5c2AgYW5kIG9uZSBvZiBjb3JyZXNwb25kaW5nIGB2YWx1ZXNgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIG9iamVjdFxuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIFRoZSBhcnJheSBvZiBrZXlzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGdpdmVuIGtleXMgYW5kXG4gICAgICogIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcE9iamVjdChbJ2ZyZWQnLCAnYmFybmV5J10sIFszMCwgNDBdKTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogMzAsICdiYXJuZXknOiA0MCB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0KGtleXMsIHZhbHVlcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0ga2V5cyA/IGtleXMubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgaWYgKCF2YWx1ZXMgJiYgbGVuZ3RoICYmICFpc0FycmF5KGtleXNbMF0pKSB7XG4gICAgICAgIHZhbHVlcyA9IFtdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSkge1xuICAgICAgICAgIHJlc3VsdFtrZXlbMF1dID0ga2V5WzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgYGZ1bmNgLCB3aXRoICB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kXG4gICAgICogYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCBvbmx5IGFmdGVyIGJlaW5nIGNhbGxlZCBgbmAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0aGUgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgYmVmb3JlXG4gICAgICogIGBmdW5jYCBpcyBleGVjdXRlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F2ZXMgPSBbJ3Byb2ZpbGUnLCAnc2V0dGluZ3MnXTtcbiAgICAgKlxuICAgICAqIHZhciBkb25lID0gXy5hZnRlcihzYXZlcy5sZW5ndGgsIGZ1bmN0aW9uKCkge1xuICAgICAqICAgY29uc29sZS5sb2coJ0RvbmUgc2F2aW5nIScpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHNhdmVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICogICBhc3luY1NhdmUoeyAndHlwZSc6IHR5cGUsICdjb21wbGV0ZSc6IGRvbmUgfSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnRG9uZSBzYXZpbmchJywgYWZ0ZXIgYWxsIHNhdmVzIGhhdmUgY29tcGxldGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWZ0ZXIobiwgZnVuYykge1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPCAxKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCBwcmVwZW5kcyBhbnkgYWRkaXRpb25hbCBgYmluZGAgYXJndW1lbnRzIHRvIHRob3NlXG4gICAgICogcHJvdmlkZWQgdG8gdGhlIGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBmdW5jdGlvbihncmVldGluZykge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy5uYW1lO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBmdW5jID0gXy5iaW5kKGZ1bmMsIHsgJ25hbWUnOiAnZnJlZCcgfSwgJ2hpJyk7XG4gICAgICogZnVuYygpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmQoZnVuYywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAyXG4gICAgICAgID8gY3JlYXRlV3JhcHBlcihmdW5jLCAxNywgc2xpY2UoYXJndW1lbnRzLCAyKSwgbnVsbCwgdGhpc0FyZylcbiAgICAgICAgOiBjcmVhdGVXcmFwcGVyKGZ1bmMsIDEsIG51bGwsIG51bGwsIHRoaXNBcmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJpbmRzIG1ldGhvZHMgb2YgYW4gb2JqZWN0IHRvIHRoZSBvYmplY3QgaXRzZWxmLCBvdmVyd3JpdGluZyB0aGUgZXhpc3RpbmdcbiAgICAgKiBtZXRob2QuIE1ldGhvZCBuYW1lcyBtYXkgYmUgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzIG9yIGFzIGFycmF5c1xuICAgICAqIG9mIG1ldGhvZCBuYW1lcy4gSWYgbm8gbWV0aG9kIG5hbWVzIGFyZSBwcm92aWRlZCBhbGwgdGhlIGZ1bmN0aW9uIHByb3BlcnRpZXNcbiAgICAgKiBvZiBgb2JqZWN0YCB3aWxsIGJlIGJvdW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiaW5kIGFuZCBhc3NpZ24gdGhlIGJvdW5kIG1ldGhvZHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi5zdHJpbmd9IFttZXRob2ROYW1lXSBUaGUgb2JqZWN0IG1ldGhvZCBuYW1lcyB0b1xuICAgICAqICBiaW5kLCBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBtZXRob2QgbmFtZXMgb3IgYXJyYXlzIG9mIG1ldGhvZCBuYW1lcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdmlldyA9IHtcbiAgICAgKiAgICdsYWJlbCc6ICdkb2NzJyxcbiAgICAgKiAgICdvbkNsaWNrJzogZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nKCdjbGlja2VkICcgKyB0aGlzLmxhYmVsKTsgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmJpbmRBbGwodmlldyk7XG4gICAgICogalF1ZXJ5KCcjZG9jcycpLm9uKCdjbGljaycsIHZpZXcub25DbGljayk7XG4gICAgICogLy8gPT4gbG9ncyAnY2xpY2tlZCBkb2NzJywgd2hlbiB0aGUgYnV0dG9uIGlzIGNsaWNrZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kQWxsKG9iamVjdCkge1xuICAgICAgdmFyIGZ1bmNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIGZhbHNlLCAxKSA6IGZ1bmN0aW9ucyhvYmplY3QpLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZnVuY3MubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gZnVuY3NbaW5kZXhdO1xuICAgICAgICBvYmplY3Rba2V5XSA9IGNyZWF0ZVdyYXBwZXIob2JqZWN0W2tleV0sIDEsIG51bGwsIG51bGwsIG9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgaW52b2tlcyB0aGUgbWV0aG9kIGF0IGBvYmplY3Rba2V5XWBcbiAgICAgKiBhbmQgcHJlcGVuZHMgYW55IGFkZGl0aW9uYWwgYGJpbmRLZXlgIGFyZ3VtZW50cyB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgYm91bmRcbiAgICAgKiBmdW5jdGlvbi4gVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIGBfLmJpbmRgIGJ5IGFsbG93aW5nIGJvdW5kIGZ1bmN0aW9ucyB0b1xuICAgICAqIHJlZmVyZW5jZSBtZXRob2RzIHRoYXQgd2lsbCBiZSByZWRlZmluZWQgb3IgZG9uJ3QgeWV0IGV4aXN0LlxuICAgICAqIFNlZSBodHRwOi8vbWljaGF1eC5jYS9hcnRpY2xlcy9sYXp5LWZ1bmN0aW9uLWRlZmluaXRpb24tcGF0dGVybi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdGhlIG1ldGhvZCBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ25hbWUnOiAnZnJlZCcsXG4gICAgICogICAnZ3JlZXQnOiBmdW5jdGlvbihncmVldGluZykge1xuICAgICAqICAgICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLm5hbWU7XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgJ2hpJyk7XG4gICAgICogZnVuYygpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqXG4gICAgICogb2JqZWN0LmdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICd5YSAnICsgdGhpcy5uYW1lICsgJyEnO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBmdW5jKCk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluZEtleShvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAyXG4gICAgICAgID8gY3JlYXRlV3JhcHBlcihrZXksIDE5LCBzbGljZShhcmd1bWVudHMsIDIpLCBudWxsLCBvYmplY3QpXG4gICAgICAgIDogY3JlYXRlV3JhcHBlcihrZXksIDMsIG51bGwsIG51bGwsIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIHRoZSBwcm92aWRlZCBmdW5jdGlvbnMsXG4gICAgICogd2hlcmUgZWFjaCBmdW5jdGlvbiBjb25zdW1lcyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXG4gICAgICogRm9yIGV4YW1wbGUsIGNvbXBvc2luZyB0aGUgZnVuY3Rpb25zIGBmKClgLCBgZygpYCwgYW5kIGBoKClgIHByb2R1Y2VzIGBmKGcoaCgpKSlgLlxuICAgICAqIEVhY2ggZnVuY3Rpb24gaXMgZXhlY3V0ZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNvbXBvc2VkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IFtmdW5jXSBGdW5jdGlvbnMgdG8gY29tcG9zZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHJlYWxOYW1lTWFwID0ge1xuICAgICAqICAgJ3BlYmJsZXMnOiAncGVuZWxvcGUnXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBmb3JtYXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICogICBuYW1lID0gcmVhbE5hbWVNYXBbbmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBuYW1lO1xuICAgICAqICAgcmV0dXJuIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBncmVldCA9IGZ1bmN0aW9uKGZvcm1hdHRlZCkge1xuICAgICAqICAgcmV0dXJuICdIaXlhICcgKyBmb3JtYXR0ZWQgKyAnISc7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciB3ZWxjb21lID0gXy5jb21wb3NlKGdyZWV0LCBmb3JtYXQpO1xuICAgICAqIHdlbGNvbWUoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnSGl5YSBQZW5lbG9wZSEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgICAgIHZhciBmdW5jcyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBsZW5ndGggPSBmdW5jcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuY3NbbGVuZ3RoXSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgbGVuZ3RoID0gZnVuY3MubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIGFyZ3MgPSBbZnVuY3NbbGVuZ3RoXS5hcHBseSh0aGlzLCBhcmdzKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB3aGljaCBhY2NlcHRzIG9uZSBvciBtb3JlIGFyZ3VtZW50cyBvZiBgZnVuY2AgdGhhdCB3aGVuXG4gICAgICogaW52b2tlZCBlaXRoZXIgZXhlY3V0ZXMgYGZ1bmNgIHJldHVybmluZyBpdHMgcmVzdWx0LCBpZiBhbGwgYGZ1bmNgIGFyZ3VtZW50c1xuICAgICAqIGhhdmUgYmVlbiBwcm92aWRlZCwgb3IgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBvbmUgb3IgbW9yZSBvZiB0aGVcbiAgICAgKiByZW1haW5pbmcgYGZ1bmNgIGFyZ3VtZW50cywgYW5kIHNvIG9uLiBUaGUgYXJpdHkgb2YgYGZ1bmNgIGNhbiBiZSBzcGVjaWZpZWRcbiAgICAgKiBpZiBgZnVuYy5sZW5ndGhgIGlzIG5vdCBzdWZmaWNpZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5KGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGEgKyBiICsgYyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEpKDIpKDMpO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMikoMyk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycnkoZnVuYywgYXJpdHkpIHtcbiAgICAgIGFyaXR5ID0gdHlwZW9mIGFyaXR5ID09ICdudW1iZXInID8gYXJpdHkgOiAoK2FyaXR5IHx8IGZ1bmMubGVuZ3RoKTtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGZ1bmMsIDQsIG51bGwsIG51bGwsIG51bGwsIGFyaXR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGRlbGF5IHRoZSBleGVjdXRpb24gb2YgYGZ1bmNgIHVudGlsIGFmdGVyXG4gICAgICogYHdhaXRgIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSBpdCB3YXMgaW52b2tlZC5cbiAgICAgKiBQcm92aWRlIGFuIG9wdGlvbnMgb2JqZWN0IHRvIGluZGljYXRlIHRoYXQgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uXG4gICAgICogdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBTdWJzZXF1ZW50IGNhbGxzXG4gICAgICogdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBjYWxsLlxuICAgICAqXG4gICAgICogTm90ZTogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCBgZnVuY2Agd2lsbCBiZSBjYWxsZWRcbiAgICAgKiBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIGlzXG4gICAgICogaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV0gU3BlY2lmeSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF0gVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGNhbGxlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdIFNwZWNpZnkgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gYXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eFxuICAgICAqIHZhciBsYXp5TGF5b3V0ID0gXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCk7XG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIGxhenlMYXlvdXQpO1xuICAgICAqXG4gICAgICogLy8gZXhlY3V0ZSBgc2VuZE1haWxgIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHNcbiAgICAgKiBqUXVlcnkoJyNwb3N0Ym94Jykub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gICAgICogICAnbGVhZGluZyc6IHRydWUsXG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gZW5zdXJlIGBiYXRjaExvZ2AgaXMgZXhlY3V0ZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHNcbiAgICAgKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gICAgICogc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHtcbiAgICAgKiAgICdtYXhXYWl0JzogMTAwMFxuICAgICAqIH0sIGZhbHNlKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgYXJncyxcbiAgICAgICAgICBtYXhUaW1lb3V0SWQsXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIHN0YW1wLFxuICAgICAgICAgIHRoaXNBcmcsXG4gICAgICAgICAgdGltZW91dElkLFxuICAgICAgICAgIHRyYWlsaW5nQ2FsbCxcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gMCxcbiAgICAgICAgICBtYXhXYWl0ID0gZmFsc2UsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHdhaXQgPSBuYXRpdmVNYXgoMCwgd2FpdCkgfHwgMDtcbiAgICAgIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZTtcbiAgICAgICAgdHJhaWxpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9IG9wdGlvbnMubGVhZGluZztcbiAgICAgICAgbWF4V2FpdCA9ICdtYXhXYWl0JyBpbiBvcHRpb25zICYmIChuYXRpdmVNYXgod2FpdCwgb3B0aW9ucy5tYXhXYWl0KSB8fCAwKTtcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgZGVsYXllZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3coKSAtIHN0YW1wKTtcbiAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgICAgaWYgKG1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpc0NhbGxlZCA9IHRyYWlsaW5nQ2FsbDtcbiAgICAgICAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKGlzQ2FsbGVkKSB7XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gbm93KCk7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKCF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZGVsYXllZCwgcmVtYWluaW5nKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIG1heERlbGF5ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRyYWlsaW5nIHx8IChtYXhXYWl0ICE9PSB3YWl0KSkge1xuICAgICAgICAgIGxhc3RDYWxsZWQgPSBub3coKTtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3RhbXAgPSBub3coKTtcbiAgICAgICAgdGhpc0FyZyA9IHRoaXM7XG4gICAgICAgIHRyYWlsaW5nQ2FsbCA9IHRyYWlsaW5nICYmICh0aW1lb3V0SWQgfHwgIWxlYWRpbmcpO1xuXG4gICAgICAgIGlmIChtYXhXYWl0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHZhciBsZWFkaW5nQ2FsbCA9IGxlYWRpbmcgJiYgIXRpbWVvdXRJZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIW1heFRpbWVvdXRJZCAmJiAhbGVhZGluZykge1xuICAgICAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVtYWluaW5nID0gbWF4V2FpdCAtIChzdGFtcCAtIGxhc3RDYWxsZWQpLFxuICAgICAgICAgICAgICBpc0NhbGxlZCA9IHJlbWFpbmluZyA8PSAwO1xuXG4gICAgICAgICAgaWYgKGlzQ2FsbGVkKSB7XG4gICAgICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICAgIG1heFRpbWVvdXRJZCA9IGNsZWFyVGltZW91dChtYXhUaW1lb3V0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgbWF4VGltZW91dElkID0gc2V0VGltZW91dChtYXhEZWxheWVkLCByZW1haW5pbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYWxsZWQgJiYgdGltZW91dElkKSB7XG4gICAgICAgICAgdGltZW91dElkID0gY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRpbWVvdXRJZCAmJiB3YWl0ICE9PSBtYXhXYWl0KSB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCB3YWl0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVhZGluZ0NhbGwpIHtcbiAgICAgICAgICBpc0NhbGxlZCA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYWxsZWQgJiYgIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmVycyBleGVjdXRpbmcgdGhlIGBmdW5jYCBmdW5jdGlvbiB1bnRpbCB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhcyBjbGVhcmVkLlxuICAgICAqIEFkZGl0aW9uYWwgYXJndW1lbnRzIHdpbGwgYmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQgaXMgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWZlci5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24odGV4dCkgeyBjb25zb2xlLmxvZyh0ZXh0KTsgfSwgJ2RlZmVycmVkJyk7XG4gICAgICogLy8gbG9ncyAnZGVmZXJyZWQnIGFmdGVyIG9uZSBvciBtb3JlIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmVyKGZ1bmMpIHtcbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGBmdW5jYCBmdW5jdGlvbiBhZnRlciBgd2FpdGAgbWlsbGlzZWNvbmRzLiBBZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgICAqIHdpbGwgYmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQgaXMgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBleGVjdXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlbGF5KGZ1bmN0aW9uKHRleHQpIHsgY29uc29sZS5sb2codGV4dCk7IH0sIDEwMDAsICdsYXRlcicpO1xuICAgICAqIC8vID0+IGxvZ3MgJ2xhdGVyJyBhZnRlciBvbmUgc2Vjb25kXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVsYXkoZnVuYywgd2FpdCkge1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMik7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOyB9LCB3YWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICAgICAqIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0XG4gICAgICogYmFzZWQgb24gdGhlIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZVxuICAgICAqIGZpcnN0IGFyZ3VtZW50IHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBjYWNoZSBrZXkuXG4gICAgICogVGhlIGBmdW5jYCBpcyBleGVjdXRlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICogVGhlIHJlc3VsdCBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBBIGZ1bmN0aW9uIHVzZWQgdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemluZyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZpYm9uYWNjaSA9IF8ubWVtb2l6ZShmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiA8IDIgPyBuIDogZmlib25hY2NpKG4gLSAxKSArIGZpYm9uYWNjaShuIC0gMik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBmaWJvbmFjY2koOSlcbiAgICAgKiAvLyA9PiAzNFxuICAgICAqXG4gICAgICogdmFyIGRhdGEgPSB7XG4gICAgICogICAnZnJlZCc6IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIC8vIG1vZGlmeWluZyB0aGUgcmVzdWx0IGNhY2hlXG4gICAgICogdmFyIGdldCA9IF8ubWVtb2l6ZShmdW5jdGlvbihuYW1lKSB7IHJldHVybiBkYXRhW25hbWVdOyB9LCBfLmlkZW50aXR5KTtcbiAgICAgKiBnZXQoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICpcbiAgICAgKiBnZXQuY2FjaGUucGViYmxlcy5uYW1lID0gJ3BlbmVsb3BlJztcbiAgICAgKiBnZXQoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ3BlbmVsb3BlJywgJ2FnZSc6IDEgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IG1lbW9pemVkLmNhY2hlLFxuICAgICAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDoga2V5UHJlZml4ICsgYXJndW1lbnRzWzBdO1xuXG4gICAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGNhY2hlLCBrZXkpXG4gICAgICAgICAgPyBjYWNoZVtrZXldXG4gICAgICAgICAgOiAoY2FjaGVba2V5XSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICB9XG4gICAgICBtZW1vaXplZC5jYWNoZSA9IHt9O1xuICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHJlc3RyaWN0ZWQgdG8gZXhlY3V0ZSBgZnVuY2Agb25jZS4gUmVwZWF0IGNhbGxzIHRvXG4gICAgICogdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgY2FsbC4gVGhlIGBmdW5jYCBpcyBleGVjdXRlZFxuICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBpbml0aWFsaXplID0gXy5vbmNlKGNyZWF0ZUFwcGxpY2F0aW9uKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIC8vIGBpbml0aWFsaXplYCBleGVjdXRlcyBgY3JlYXRlQXBwbGljYXRpb25gIG9uY2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbmNlKGZ1bmMpIHtcbiAgICAgIHZhciByYW4sXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHJhbikge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmFuID0gdHJ1ZTtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIC8vIGNsZWFyIHRoZSBgZnVuY2AgdmFyaWFibGUgc28gdGhlIGZ1bmN0aW9uIG1heSBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuICAgICAgICBmdW5jID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBpbnZva2VzIGBmdW5jYCB3aXRoIGFueSBhZGRpdGlvbmFsXG4gICAgICogYHBhcnRpYWxgIGFyZ3VtZW50cyBwcmVwZW5kZWQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi4gVGhpc1xuICAgICAqIG1ldGhvZCBpcyBzaW1pbGFyIHRvIGBfLmJpbmRgIGV4Y2VwdCBpdCBkb2VzICoqbm90KiogYWx0ZXIgdGhlIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBuYW1lKSB7IHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7IH07XG4gICAgICogdmFyIGhpID0gXy5wYXJ0aWFsKGdyZWV0LCAnaGknKTtcbiAgICAgKiBoaSgnZnJlZCcpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnRpYWwoZnVuYykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgMTYsIHNsaWNlKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucGFydGlhbGAgZXhjZXB0IHRoYXQgYHBhcnRpYWxgIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBhcHBlbmRlZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0c0RlZXAgPSBfLnBhcnRpYWxSaWdodChfLm1lcmdlLCBfLmRlZmF1bHRzKTtcbiAgICAgKlxuICAgICAqIHZhciBvcHRpb25zID0ge1xuICAgICAqICAgJ3ZhcmlhYmxlJzogJ2RhdGEnLFxuICAgICAqICAgJ2ltcG9ydHMnOiB7ICdqcSc6ICQgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBkZWZhdWx0c0RlZXAob3B0aW9ucywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcbiAgICAgKlxuICAgICAqIG9wdGlvbnMudmFyaWFibGVcbiAgICAgKiAvLyA9PiAnZGF0YSdcbiAgICAgKlxuICAgICAqIG9wdGlvbnMuaW1wb3J0c1xuICAgICAqIC8vID0+IHsgJ18nOiBfLCAnanEnOiAkIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJ0aWFsUmlnaHQoZnVuYykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgMzIsIG51bGwsIHNsaWNlKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGV4ZWN1dGVkLCB3aWxsIG9ubHkgY2FsbCB0aGUgYGZ1bmNgIGZ1bmN0aW9uXG4gICAgICogYXQgbW9zdCBvbmNlIHBlciBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBQcm92aWRlIGFuIG9wdGlvbnMgb2JqZWN0IHRvXG4gICAgICogaW5kaWNhdGUgdGhhdCBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2VcbiAgICAgKiBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsXG4gICAgICogcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGNhbGwuXG4gICAgICpcbiAgICAgKiBOb3RlOiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgIGBmdW5jYCB3aWxsIGJlIGNhbGxlZFxuICAgICAqIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gaXNcbiAgICAgKiBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgZXhlY3V0aW9ucyB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV0gU3BlY2lmeSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdIFNwZWNpZnkgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gYXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZ1xuICAgICAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApO1xuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCB0aHJvdHRsZWQpO1xuICAgICAqXG4gICAgICogLy8gZXhlY3V0ZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzXG4gICAgICogalF1ZXJ5KCcuaW50ZXJhY3RpdmUnKS5vbignY2xpY2snLCBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwge1xuICAgICAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgICAgKiB9KSk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgbGVhZGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cbiAgICAgIGRlYm91bmNlT3B0aW9ucy5sZWFkaW5nID0gbGVhZGluZztcbiAgICAgIGRlYm91bmNlT3B0aW9ucy5tYXhXYWl0ID0gd2FpdDtcbiAgICAgIGRlYm91bmNlT3B0aW9ucy50cmFpbGluZyA9IHRyYWlsaW5nO1xuXG4gICAgICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwgZGVib3VuY2VPcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyBgdmFsdWVgIHRvIHRoZSB3cmFwcGVyIGZ1bmN0aW9uIGFzIGl0c1xuICAgICAqIGZpcnN0IGFyZ3VtZW50LiBBZGRpdGlvbmFsIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZnVuY3Rpb24gYXJlIGFwcGVuZGVkXG4gICAgICogdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIHdyYXBwZXIgZnVuY3Rpb24uIFRoZSB3cmFwcGVyIGlzIGV4ZWN1dGVkIHdpdGhcbiAgICAgKiB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcCA9IF8ud3JhcChfLmVzY2FwZSwgZnVuY3Rpb24oZnVuYywgdGV4dCkge1xuICAgICAqICAgcmV0dXJuICc8cD4nICsgZnVuYyh0ZXh0KSArICc8L3A+JztcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHAoJ0ZyZWQsIFdpbG1hLCAmIFBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnPHA+RnJlZCwgV2lsbWEsICZhbXA7IFBlYmJsZXM8L3A+J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXAodmFsdWUsIHdyYXBwZXIpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKHdyYXBwZXIsIDE2LCBbdmFsdWVdKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgICAqIHZhciBnZXR0ZXIgPSBfLmNvbnN0YW50KG9iamVjdCk7XG4gICAgICogZ2V0dGVyKCkgPT09IG9iamVjdDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIGNhbGxiYWNrIGJvdW5kIHRvIGFuIG9wdGlvbmFsIGB0aGlzQXJnYC4gSWYgYGZ1bmNgIGlzIGEgcHJvcGVydHlcbiAgICAgKiBuYW1lIHRoZSBjcmVhdGVkIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBnaXZlbiBlbGVtZW50LlxuICAgICAqIElmIGBmdW5jYCBpcyBhbiBvYmplY3QgdGhlIGNyZWF0ZWQgY2FsbGJhY2sgd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50c1xuICAgICAqIHRoYXQgY29udGFpbiB0aGUgZXF1aXZhbGVudCBvYmplY3QgcHJvcGVydGllcywgb3RoZXJ3aXNlIGl0IHdpbGwgcmV0dXJuIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcmdDb3VudF0gVGhlIG51bWJlciBvZiBhcmd1bWVudHMgdGhlIGNhbGxiYWNrIGFjY2VwdHMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGEgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gd3JhcCB0byBjcmVhdGUgY3VzdG9tIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgKiBfLmNyZWF0ZUNhbGxiYWNrID0gXy53cmFwKF8uY3JlYXRlQ2FsbGJhY2ssIGZ1bmN0aW9uKGZ1bmMsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICogICB2YXIgbWF0Y2ggPSAvXiguKz8pX18oW2dsXXQpKC4rKSQvLmV4ZWMoY2FsbGJhY2spO1xuICAgICAqICAgcmV0dXJuICFtYXRjaCA/IGZ1bmMoY2FsbGJhY2ssIHRoaXNBcmcpIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICogICAgIHJldHVybiBtYXRjaFsyXSA9PSAnZ3QnID8gb2JqZWN0W21hdGNoWzFdXSA+IG1hdGNoWzNdIDogb2JqZWN0W21hdGNoWzFdXSA8IG1hdGNoWzNdO1xuICAgICAqICAgfTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKGNoYXJhY3RlcnMsICdhZ2VfX2d0MzgnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGZ1bmM7XG4gICAgICBpZiAoZnVuYyA9PSBudWxsIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gYmFzZUNyZWF0ZUNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KTtcbiAgICAgIH1cbiAgICAgIC8vIGhhbmRsZSBcIl8ucGx1Y2tcIiBzdHlsZSBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICBpZiAodHlwZSAhPSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gcHJvcGVydHkoZnVuYyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKGZ1bmMpLFxuICAgICAgICAgIGtleSA9IHByb3BzWzBdLFxuICAgICAgICAgIGEgPSBmdW5jW2tleV07XG5cbiAgICAgIC8vIGhhbmRsZSBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICBpZiAocHJvcHMubGVuZ3RoID09IDEgJiYgYSA9PT0gYSAmJiAhaXNPYmplY3QoYSkpIHtcbiAgICAgICAgLy8gZmFzdCBwYXRoIHRoZSBjb21tb24gY2FzZSBvZiBwcm92aWRpbmcgYW4gb2JqZWN0IHdpdGggYSBzaW5nbGVcbiAgICAgICAgLy8gcHJvcGVydHkgY29udGFpbmluZyBhIHByaW1pdGl2ZSB2YWx1ZVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgdmFyIGIgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICByZXR1cm4gYSA9PT0gYiAmJiAoYSAhPT0gMCB8fCAoMSAvIGEgPT0gMSAvIGIpKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIGlmICghKHJlc3VsdCA9IGJhc2VJc0VxdWFsKG9iamVjdFtwcm9wc1tsZW5ndGhdXSwgZnVuY1twcm9wc1tsZW5ndGhdXSwgbnVsbCwgdHJ1ZSkpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgYCZgLCBgPGAsIGA+YCwgYFwiYCwgYW5kIGAnYCBpbiBgc3RyaW5nYCB0byB0aGVpclxuICAgICAqIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZSgnRnJlZCwgV2lsbWEsICYgUGViYmxlcycpO1xuICAgICAqIC8vID0+ICdGcmVkLCBXaWxtYSwgJmFtcDsgUGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nID09IG51bGwgPyAnJyA6IFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBlc2NhcGVIdG1sQ2hhcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgcHJvdmlkZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICAgKiBfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGZ1bmN0aW9uIHByb3BlcnRpZXMgb2YgYSBzb3VyY2Ugb2JqZWN0IHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogSWYgYG9iamVjdGAgaXMgYSBmdW5jdGlvbiBtZXRob2RzIHdpbGwgYmUgYWRkZWQgdG8gaXRzIHByb3RvdHlwZSBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBbb2JqZWN0PWxvZGFzaF0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIGZ1bmN0aW9ucyB0byBhZGQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGFpbj10cnVlXSBTcGVjaWZ5IHdoZXRoZXIgdGhlIGZ1bmN0aW9ucyBhZGRlZCBhcmUgY2hhaW5hYmxlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICAgICAqICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKS50b0xvd2VyQ2FzZSgpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAnY2FwaXRhbGl6ZSc6IGNhcGl0YWxpemUgfSk7XG4gICAgICogXy5jYXBpdGFsaXplKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICpcbiAgICAgKiBfKCdmcmVkJykuY2FwaXRhbGl6ZSgpLnZhbHVlKCk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ2NhcGl0YWxpemUnOiBjYXBpdGFsaXplIH0sIHsgJ2NoYWluJzogZmFsc2UgfSk7XG4gICAgICogXygnZnJlZCcpLmNhcGl0YWxpemUoKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaXhpbihvYmplY3QsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgdmFyIGNoYWluID0gdHJ1ZSxcbiAgICAgICAgICBtZXRob2ROYW1lcyA9IHNvdXJjZSAmJiBmdW5jdGlvbnMoc291cmNlKTtcblxuICAgICAgaWYgKCFzb3VyY2UgfHwgKCFvcHRpb25zICYmICFtZXRob2ROYW1lcy5sZW5ndGgpKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zID0gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGN0b3IgPSBsb2Rhc2hXcmFwcGVyO1xuICAgICAgICBzb3VyY2UgPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdCA9IGxvZGFzaDtcbiAgICAgICAgbWV0aG9kTmFtZXMgPSBmdW5jdGlvbnMoc291cmNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgICBjaGFpbiA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSAmJiAnY2hhaW4nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgY2hhaW4gPSBvcHRpb25zLmNoYWluO1xuICAgICAgfVxuICAgICAgdmFyIGN0b3IgPSBvYmplY3QsXG4gICAgICAgICAgaXNGdW5jID0gaXNGdW5jdGlvbihjdG9yKTtcblxuICAgICAgZm9yRWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgZnVuYyA9IG9iamVjdFttZXRob2ROYW1lXSA9IHNvdXJjZVttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKGlzRnVuYykge1xuICAgICAgICAgIGN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXyxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgICAgICAgYXJncyA9IFt2YWx1ZV07XG5cbiAgICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KG9iamVjdCwgYXJncyk7XG4gICAgICAgICAgICBpZiAoY2hhaW4gfHwgY2hhaW5BbGwpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSByZXN1bHQgJiYgaXNPYmplY3QocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBjdG9yKHJlc3VsdCk7XG4gICAgICAgICAgICAgIHJlc3VsdC5fX2NoYWluX18gPSBjaGFpbkFsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJ0cyB0aGUgJ18nIHZhcmlhYmxlIHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0b1xuICAgICAqIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbG9kYXNoID0gXy5ub0NvbmZsaWN0KCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgIGNvbnRleHQuXyA9IG9sZERhc2g7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIG5vLW9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICAgKiBfLm5vb3Aob2JqZWN0KSA9PT0gdW5kZWZpbmVkO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub29wKCkge1xuICAgICAgLy8gbm8gb3BlcmF0aW9uIHBlcmZvcm1lZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIFVuaXggZXBvY2hcbiAgICAgKiAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHN0YW1wID0gXy5ub3coKTtcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApOyB9KTtcbiAgICAgKiAvLyA9PiBsb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAgICAgKi9cbiAgICB2YXIgbm93ID0gaXNOYXRpdmUobm93ID0gRGF0ZS5ub3cpICYmIG5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYW4gaW50ZWdlciBvZiB0aGUgc3BlY2lmaWVkIHJhZGl4LlxuICAgICAqIElmIGByYWRpeGAgaXMgYHVuZGVmaW5lZGAgb3IgYDBgIGEgYHJhZGl4YCBvZiBgMTBgIGlzIHVzZWQgdW5sZXNzIHRoZVxuICAgICAqIGB2YWx1ZWAgaXMgYSBoZXhhZGVjaW1hbCwgaW4gd2hpY2ggY2FzZSBhIGByYWRpeGAgb2YgYDE2YCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBtZXRob2QgYXZvaWRzIGRpZmZlcmVuY2VzIGluIG5hdGl2ZSBFUzMgYW5kIEVTNSBgcGFyc2VJbnRgXG4gICAgICogaW1wbGVtZW50YXRpb25zLiBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI0UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0byBwYXJzZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl4XSBUaGUgcmFkaXggdXNlZCB0byBpbnRlcnByZXQgdGhlIHZhbHVlIHRvIHBhcnNlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG5ldyBpbnRlZ2VyIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhcnNlSW50KCcwOCcpO1xuICAgICAqIC8vID0+IDhcbiAgICAgKi9cbiAgICB2YXIgcGFyc2VJbnQgPSBuYXRpdmVQYXJzZUludCh3aGl0ZXNwYWNlICsgJzA4JykgPT0gOCA/IG5hdGl2ZVBhcnNlSW50IDogZnVuY3Rpb24odmFsdWUsIHJhZGl4KSB7XG4gICAgICAvLyBGaXJlZm94IDwgMjEgYW5kIE9wZXJhIDwgMTUgZm9sbG93IHRoZSBFUzMgc3BlY2lmaWVkIGltcGxlbWVudGF0aW9uIG9mIGBwYXJzZUludGBcbiAgICAgIHJldHVybiBuYXRpdmVQYXJzZUludChpc1N0cmluZyh2YWx1ZSkgPyB2YWx1ZS5yZXBsYWNlKHJlTGVhZGluZ1NwYWNlc0FuZFplcm9zLCAnJykgOiB2YWx1ZSwgcmFkaXggfHwgMCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBcIl8ucGx1Y2tcIiBzdHlsZSBmdW5jdGlvbiwgd2hpY2ggcmV0dXJucyB0aGUgYGtleWAgdmFsdWUgb2YgYVxuICAgICAqIGdpdmVuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byByZXRyaWV2ZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgZ2V0TmFtZSA9IF8ucHJvcGVydHkoJ25hbWUnKTtcbiAgICAgKlxuICAgICAqIF8ubWFwKGNoYXJhY3RlcnMsIGdldE5hbWUpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogXy5zb3J0QnkoY2hhcmFjdGVycywgZ2V0TmFtZSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydHkoa2V5KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgIChpbmNsdXNpdmUpLiBJZiBvbmx5IG9uZVxuICAgICAqIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGEgbnVtYmVyIGJldHdlZW4gYDBgIGFuZCB0aGUgZ2l2ZW4gbnVtYmVyIHdpbGwgYmVcbiAgICAgKiByZXR1cm5lZC4gSWYgYGZsb2F0aW5nYCBpcyB0cnVleSBvciBlaXRoZXIgYG1pbmAgb3IgYG1heGAgYXJlIGZsb2F0cyBhXG4gICAgICogZmxvYXRpbmctcG9pbnQgbnVtYmVyIHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZiBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWluPTBdIFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4PTFdIFRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zsb2F0aW5nPWZhbHNlXSBTcGVjaWZ5IHJldHVybmluZyBhIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGEgcmFuZG9tIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMCwgNSk7XG4gICAgICogLy8gPT4gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUpO1xuICAgICAqIC8vID0+IGFsc28gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUsIHRydWUpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMS4yLCA1LjIpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMS4yIGFuZCA1LjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kb20obWluLCBtYXgsIGZsb2F0aW5nKSB7XG4gICAgICB2YXIgbm9NaW4gPSBtaW4gPT0gbnVsbCxcbiAgICAgICAgICBub01heCA9IG1heCA9PSBudWxsO1xuXG4gICAgICBpZiAoZmxvYXRpbmcgPT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIG1pbiA9PSAnYm9vbGVhbicgJiYgbm9NYXgpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IG1pbjtcbiAgICAgICAgICBtaW4gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFub01heCAmJiB0eXBlb2YgbWF4ID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gbWF4O1xuICAgICAgICAgIG5vTWF4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vTWluICYmIG5vTWF4KSB7XG4gICAgICAgIG1heCA9IDE7XG4gICAgICB9XG4gICAgICBtaW4gPSArbWluIHx8IDA7XG4gICAgICBpZiAobm9NYXgpIHtcbiAgICAgICAgbWF4ID0gbWluO1xuICAgICAgICBtaW4gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4ID0gK21heCB8fCAwO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nIHx8IG1pbiAlIDEgfHwgbWF4ICUgMSkge1xuICAgICAgICB2YXIgcmFuZCA9IG5hdGl2ZVJhbmRvbSgpO1xuICAgICAgICByZXR1cm4gbmF0aXZlTWluKG1pbiArIChyYW5kICogKG1heCAtIG1pbiArIHBhcnNlRmxvYXQoJzFlLScgKyAoKHJhbmQgKycnKS5sZW5ndGggLSAxKSkpKSwgbWF4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlUmFuZG9tKG1pbiwgbWF4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgdmFsdWUgb2YgcHJvcGVydHkgYGtleWAgb24gYG9iamVjdGAuIElmIGBrZXlgIGlzIGEgZnVuY3Rpb25cbiAgICAgKiBpdCB3aWxsIGJlIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYG9iamVjdGAgYW5kIGl0cyByZXN1bHQgcmV0dXJuZWQsXG4gICAgICogZWxzZSB0aGUgcHJvcGVydHkgdmFsdWUgaXMgcmV0dXJuZWQuIElmIGBvYmplY3RgIGlzIGZhbHNleSB0aGVuIGB1bmRlZmluZWRgXG4gICAgICogaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gcmVzb2x2ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAnY2hlZXNlJzogJ2NydW1wZXRzJyxcbiAgICAgKiAgICdzdHVmZic6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICByZXR1cm4gJ25vbnNlbnNlJztcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnY2hlZXNlJyk7XG4gICAgICogLy8gPT4gJ2NydW1wZXRzJ1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnc3R1ZmYnKTtcbiAgICAgKiAvLyA9PiAnbm9uc2Vuc2UnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdWx0KG9iamVjdCwga2V5KSB7XG4gICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSkgPyBvYmplY3Rba2V5XSgpIDogdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBtaWNyby10ZW1wbGF0aW5nIG1ldGhvZCB0aGF0IGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlc1xuICAgICAqIHdoaXRlc3BhY2UsIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxuICAgICAqXG4gICAgICogTm90ZTogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkLCBgXy50ZW1wbGF0ZWAgdXRpbGl6ZXMgc291cmNlVVJMcyBmb3IgZWFzaWVyXG4gICAgICogZGVidWdnaW5nLiBTZWUgaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gcHJlY29tcGlsaW5nIHRlbXBsYXRlcyBzZWU6XG4gICAgICogaHR0cDovL2xvZGFzaC5jb20vY3VzdG9tLWJ1aWxkc1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ2hyb21lIGV4dGVuc2lvbiBzYW5kYm94ZXMgc2VlOlxuICAgICAqIGh0dHA6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9zdGFibGUvZXh0ZW5zaW9ucy9zYW5kYm94aW5nRXZhbC5odG1sXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRlbXBsYXRlIHRleHQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGRhdGEgb2JqZWN0IHVzZWQgdG8gcG9wdWxhdGUgdGhlIHRleHQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZV0gVGhlIFwiZXNjYXBlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5ldmFsdWF0ZV0gVGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltcG9ydHNdIEFuIG9iamVjdCB0byBpbXBvcnQgaW50byB0aGUgdGVtcGxhdGUgYXMgbG9jYWwgdmFyaWFibGVzLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5pbnRlcnBvbGF0ZV0gVGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzb3VyY2VVUkxdIFRoZSBzb3VyY2VVUkwgb2YgdGhlIHRlbXBsYXRlJ3MgY29tcGlsZWQgc291cmNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdmFyaWFibGVdIFRoZSBkYXRhIG9iamVjdCB2YXJpYWJsZSBuYW1lLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxzdHJpbmd9IFJldHVybnMgYSBjb21waWxlZCBmdW5jdGlvbiB3aGVuIG5vIGBkYXRhYCBvYmplY3RcbiAgICAgKiAgaXMgZ2l2ZW4sIGVsc2UgaXQgcmV0dXJucyB0aGUgaW50ZXJwb2xhdGVkIHRleHQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyIHRvIGNyZWF0ZSBhIGNvbXBpbGVkIHRlbXBsYXRlXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IG5hbWUgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICduYW1lJzogJ2ZyZWQnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBIVE1MIGluIGRhdGEgcHJvcGVydHkgdmFsdWVzXG4gICAgICogXy50ZW1wbGF0ZSgnPGI+PCUtIHZhbHVlICU+PC9iPicsIHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAgICAgKiAvLyA9PiAnPGI+Jmx0O3NjcmlwdCZndDs8L2I+J1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIgdG8gZ2VuZXJhdGUgSFRNTFxuICAgICAqIHZhciBsaXN0ID0gJzwlIF8uZm9yRWFjaChwZW9wbGUsIGZ1bmN0aW9uKG5hbWUpIHsgJT48bGk+PCUtIG5hbWUgJT48L2xpPjwlIH0pOyAlPic7XG4gICAgICogXy50ZW1wbGF0ZShsaXN0LCB7ICdwZW9wbGUnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgRVM2IGRlbGltaXRlciBhcyBhbiBhbHRlcm5hdGl2ZSB0byB0aGUgZGVmYXVsdCBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyXG4gICAgICogXy50ZW1wbGF0ZSgnaGVsbG8gJHsgbmFtZSB9JywgeyAnbmFtZSc6ICdwZWJibGVzJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gcGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzXG4gICAgICogXy50ZW1wbGF0ZSgnPCUgcHJpbnQoXCJoZWxsbyBcIiArIG5hbWUpOyAlPiEnLCB7ICduYW1lJzogJ2Jhcm5leScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGJhcm5leSEnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhIGN1c3RvbSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXG4gICAgICogXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgICAqICAgJ2ludGVycG9sYXRlJzogL3t7KFtcXHNcXFNdKz8pfX0vZ1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLnRlbXBsYXRlKCdoZWxsbyB7eyBuYW1lIH19IScsIHsgJ25hbWUnOiAnbXVzdGFjaGUnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBtdXN0YWNoZSEnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgalF1ZXJ5XG4gICAgICogdmFyIGxpc3QgPSAnPCUganEuZWFjaChwZW9wbGUsIGZ1bmN0aW9uKG5hbWUpIHsgJT48bGk+PCUtIG5hbWUgJT48L2xpPjwlIH0pOyAlPic7XG4gICAgICogXy50ZW1wbGF0ZShsaXN0LCB7ICdwZW9wbGUnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSwgeyAnaW1wb3J0cyc6IHsgJ2pxJzogalF1ZXJ5IH0gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYHNvdXJjZVVSTGAgb3B0aW9uIHRvIHNwZWNpZnkgYSBjdXN0b20gc291cmNlVVJMIGZvciB0aGUgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gbmFtZSAlPicsIG51bGwsIHsgJ3NvdXJjZVVSTCc6ICcvYmFzaWMvZ3JlZXRpbmcuanN0JyB9KTtcbiAgICAgKiBjb21waWxlZChkYXRhKTtcbiAgICAgKiAvLyA9PiBmaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS5uYW1lICU+IScsIG51bGwsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICAgICAqIGNvbXBpbGVkLnNvdXJjZTtcbiAgICAgKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICogICB2YXIgX190LCBfX3AgPSAnJywgX19lID0gXy5lc2NhcGU7XG4gICAgICogICBfX3AgKz0gJ2hpICcgKyAoKF9fdCA9ICggZGF0YS5uYW1lICkpID09IG51bGwgPyAnJyA6IF9fdCkgKyAnISc7XG4gICAgICogICByZXR1cm4gX19wO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byBpbmxpbmUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciBtZWFuaW5nZnVsXG4gICAgICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBhIHN0YWNrIHRyYWNlXG4gICAgICogZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4oY3dkLCAnanN0LmpzJyksICdcXFxuICAgICAqICAgdmFyIEpTVCA9IHtcXFxuICAgICAqICAgICBcIm1haW5cIjogJyArIF8udGVtcGxhdGUobWFpblRleHQpLnNvdXJjZSArICdcXFxuICAgICAqICAgfTtcXFxuICAgICAqICcpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRlbXBsYXRlKHRleHQsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgIC8vIGJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb25cbiAgICAgIC8vIGh0dHA6Ly9lam9obi5vcmcvYmxvZy9qYXZhc2NyaXB0LW1pY3JvLXRlbXBsYXRpbmcvXG4gICAgICAvLyBhbmQgTGF1cmEgRG9rdG9yb3ZhJ3MgZG9ULmpzXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vb2xhZG8vZG9UXG4gICAgICB2YXIgc2V0dGluZ3MgPSBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncztcbiAgICAgIHRleHQgPSBTdHJpbmcodGV4dCB8fCAnJyk7XG5cbiAgICAgIC8vIGF2b2lkIG1pc3NpbmcgZGVwZW5kZW5jaWVzIHdoZW4gYGl0ZXJhdG9yVGVtcGxhdGVgIGlzIG5vdCBkZWZpbmVkXG4gICAgICBvcHRpb25zID0gZGVmYXVsdHMoe30sIG9wdGlvbnMsIHNldHRpbmdzKTtcblxuICAgICAgdmFyIGltcG9ydHMgPSBkZWZhdWx0cyh7fSwgb3B0aW9ucy5pbXBvcnRzLCBzZXR0aW5ncy5pbXBvcnRzKSxcbiAgICAgICAgICBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksXG4gICAgICAgICAgaW1wb3J0c1ZhbHVlcyA9IHZhbHVlcyhpbXBvcnRzKTtcblxuICAgICAgdmFyIGlzRXZhbHVhdGluZyxcbiAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgaW50ZXJwb2xhdGUgPSBvcHRpb25zLmludGVycG9sYXRlIHx8IHJlTm9NYXRjaCxcbiAgICAgICAgICBzb3VyY2UgPSBcIl9fcCArPSAnXCI7XG5cbiAgICAgIC8vIGNvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlclxuICAgICAgdmFyIHJlRGVsaW1pdGVycyA9IFJlZ0V4cChcbiAgICAgICAgKG9wdGlvbnMuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgaW50ZXJwb2xhdGUuc291cmNlICsgJ3wnICtcbiAgICAgICAgKGludGVycG9sYXRlID09PSByZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcbiAgICAgICwgJ2cnKTtcblxuICAgICAgdGV4dC5yZXBsYWNlKHJlRGVsaW1pdGVycywgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZVZhbHVlLCBpbnRlcnBvbGF0ZVZhbHVlLCBlc1RlbXBsYXRlVmFsdWUsIGV2YWx1YXRlVmFsdWUsIG9mZnNldCkge1xuICAgICAgICBpbnRlcnBvbGF0ZVZhbHVlIHx8IChpbnRlcnBvbGF0ZVZhbHVlID0gZXNUZW1wbGF0ZVZhbHVlKTtcblxuICAgICAgICAvLyBlc2NhcGUgY2hhcmFjdGVycyB0aGF0IGNhbm5vdCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHNcbiAgICAgICAgc291cmNlICs9IHRleHQuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShyZVVuZXNjYXBlZFN0cmluZywgZXNjYXBlU3RyaW5nQ2hhcik7XG5cbiAgICAgICAgLy8gcmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHNcbiAgICAgICAgaWYgKGVzY2FwZVZhbHVlKSB7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuX19lKFwiICsgZXNjYXBlVmFsdWUgKyBcIikgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZhbHVhdGVWYWx1ZSkge1xuICAgICAgICAgIGlzRXZhbHVhdGluZyA9IHRydWU7XG4gICAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlVmFsdWUgKyBcIjtcXG5fX3AgKz0gJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcnBvbGF0ZVZhbHVlKSB7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuKChfX3QgPSAoXCIgKyBpbnRlcnBvbGF0ZVZhbHVlICsgXCIpKSA9PSBudWxsID8gJycgOiBfX3QpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgICAgLy8gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBwcm9kdWN0cyByZXF1aXJlcyByZXR1cm5pbmcgdGhlIGBtYXRjaGBcbiAgICAgICAgLy8gc3RyaW5nIGluIG9yZGVyIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgYG9mZnNldGAgdmFsdWVcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7XG5cbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAgIC8vIGlmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCwgd3JhcCBhIHdpdGgtc3RhdGVtZW50IGFyb3VuZCB0aGUgZ2VuZXJhdGVkXG4gICAgICAvLyBjb2RlIHRvIGFkZCB0aGUgZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW5cbiAgICAgIHZhciB2YXJpYWJsZSA9IG9wdGlvbnMudmFyaWFibGUsXG4gICAgICAgICAgaGFzVmFyaWFibGUgPSB2YXJpYWJsZTtcblxuICAgICAgaWYgKCFoYXNWYXJpYWJsZSkge1xuICAgICAgICB2YXJpYWJsZSA9ICdvYmonO1xuICAgICAgICBzb3VyY2UgPSAnd2l0aCAoJyArIHZhcmlhYmxlICsgJykge1xcbicgKyBzb3VyY2UgKyAnXFxufVxcbic7XG4gICAgICB9XG4gICAgICAvLyBjbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3NcbiAgICAgIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nVHJhaWxpbmcsICckMTsnKTtcblxuICAgICAgLy8gZnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keVxuICAgICAgc291cmNlID0gJ2Z1bmN0aW9uKCcgKyB2YXJpYWJsZSArICcpIHtcXG4nICtcbiAgICAgICAgKGhhc1ZhcmlhYmxlID8gJycgOiB2YXJpYWJsZSArICcgfHwgKCcgKyB2YXJpYWJsZSArICcgPSB7fSk7XFxuJykgK1xuICAgICAgICBcInZhciBfX3QsIF9fcCA9ICcnLCBfX2UgPSBfLmVzY2FwZVwiICtcbiAgICAgICAgKGlzRXZhbHVhdGluZ1xuICAgICAgICAgID8gJywgX19qID0gQXJyYXkucHJvdG90eXBlLmpvaW47XFxuJyArXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHByaW50KCkgeyBfX3AgKz0gX19qLmNhbGwoYXJndW1lbnRzLCAnJykgfVxcblwiXG4gICAgICAgICAgOiAnO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIHNvdXJjZSArXG4gICAgICAgICdyZXR1cm4gX19wXFxufSc7XG5cbiAgICAgIC8vIFVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgIC8vIGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmxcbiAgICAgIHZhciBzb3VyY2VVUkwgPSAnXFxuLypcXG4vLyMgc291cmNlVVJMPScgKyAob3B0aW9ucy5zb3VyY2VVUkwgfHwgJy9sb2Rhc2gvdGVtcGxhdGUvc291cmNlWycgKyAodGVtcGxhdGVDb3VudGVyKyspICsgJ10nKSArICdcXG4qLyc7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBGdW5jdGlvbihpbXBvcnRzS2V5cywgJ3JldHVybiAnICsgc291cmNlICsgc291cmNlVVJMKS5hcHBseSh1bmRlZmluZWQsIGltcG9ydHNWYWx1ZXMpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdChkYXRhKTtcbiAgICAgIH1cbiAgICAgIC8vIHByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uJ3Mgc291cmNlIGJ5IGl0cyBgdG9TdHJpbmdgIG1ldGhvZCwgaW5cbiAgICAgIC8vIHN1cHBvcnRlZCBlbnZpcm9ubWVudHMsIG9yIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBhcyBhIGNvbnZlbmllbmNlIGZvclxuICAgICAgLy8gaW5saW5pbmcgY29tcGlsZWQgdGVtcGxhdGVzIGR1cmluZyB0aGUgYnVpbGQgcHJvY2Vzc1xuICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNhbGxiYWNrIGBuYCB0aW1lcywgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzXG4gICAgICogb2YgZWFjaCBjYWxsYmFjayBleGVjdXRpb24uIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIG9uZSBhcmd1bWVudDsgKGluZGV4KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGV4ZWN1dGUgdGhlIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBgY2FsbGJhY2tgIGV4ZWN1dGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGRpY2VSb2xscyA9IF8udGltZXMoMywgXy5wYXJ0aWFsKF8ucmFuZG9tLCAxLCA2KSk7XG4gICAgICogLy8gPT4gWzMsIDYsIDRdXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIGZ1bmN0aW9uKG4pIHsgbWFnZS5jYXN0U3BlbGwobik7IH0pO1xuICAgICAqIC8vID0+IGNhbGxzIGBtYWdlLmNhc3RTcGVsbChuKWAgdGhyZWUgdGltZXMsIHBhc3NpbmcgYG5gIG9mIGAwYCwgYDFgLCBhbmQgYDJgIHJlc3BlY3RpdmVseVxuICAgICAqXG4gICAgICogXy50aW1lcygzLCBmdW5jdGlvbihuKSB7IHRoaXMuY2FzdChuKTsgfSwgbWFnZSk7XG4gICAgICogLy8gPT4gYWxzbyBjYWxscyBgbWFnZS5jYXN0U3BlbGwobilgIHRocmVlIHRpbWVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGltZXMobiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIG4gPSAobiA9ICtuKSA+IC0xID8gbiA6IDA7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICAgICAgY2FsbGJhY2sgPSBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDEpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBjYWxsYmFjayhpbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLmVzY2FwZWAgdGhpcyBtZXRob2QgY29udmVydHMgdGhlIEhUTUwgZW50aXRpZXNcbiAgICAgKiBgJmFtcDtgLCBgJmx0O2AsIGAmZ3Q7YCwgYCZxdW90O2AsIGFuZCBgJiMzOTtgIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gICAgICogY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byB1bmVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuZXNjYXBlKCdGcmVkLCBCYXJuZXkgJmFtcDsgUGViYmxlcycpO1xuICAgICAqIC8vID0+ICdGcmVkLCBCYXJuZXkgJiBQZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlKHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZyA9PSBudWxsID8gJycgOiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlRXNjYXBlZEh0bWwsIHVuZXNjYXBlSHRtbENoYXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRC4gSWYgYHByZWZpeGAgaXMgcHJvdmlkZWQgdGhlIElEIHdpbGwgYmUgYXBwZW5kZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXhdIFRoZSB2YWx1ZSB0byBwcmVmaXggdGhlIElEIHdpdGguXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5pcXVlIElELlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCdjb250YWN0XycpO1xuICAgICAqIC8vID0+ICdjb250YWN0XzEwNCdcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoKTtcbiAgICAgKiAvLyA9PiAnMTA1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICAgICAgdmFyIGlkID0gKytpZENvdW50ZXI7XG4gICAgICByZXR1cm4gU3RyaW5nKHByZWZpeCA9PSBudWxsID8gJycgOiBwcmVmaXgpICsgaWQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHRoYXQgd3JhcHMgdGhlIGdpdmVuIHZhbHVlIHdpdGggZXhwbGljaXRcbiAgICAgKiBtZXRob2QgY2hhaW5pbmcgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIHlvdW5nZXN0ID0gXy5jaGFpbihjaGFyYWN0ZXJzKVxuICAgICAqICAgICAuc29ydEJ5KCdhZ2UnKVxuICAgICAqICAgICAubWFwKGZ1bmN0aW9uKGNocikgeyByZXR1cm4gY2hyLm5hbWUgKyAnIGlzICcgKyBjaHIuYWdlOyB9KVxuICAgICAqICAgICAuZmlyc3QoKVxuICAgICAqICAgICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcyBpcyAxJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoYWluKHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IG5ldyBsb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbiAgICAgIHZhbHVlLl9fY2hhaW5fXyA9IHRydWU7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyBgaW50ZXJjZXB0b3JgIHdpdGggdGhlIGB2YWx1ZWAgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGFuZCB0aGVuXG4gICAgICogcmV0dXJucyBgdmFsdWVgLiBUaGUgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2RcbiAgICAgKiBjaGFpbiBpbiBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluXG4gICAgICogdGhlIGNoYWluLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgMywgNF0pXG4gICAgICogIC50YXAoZnVuY3Rpb24oYXJyYXkpIHsgYXJyYXkucG9wKCk7IH0pXG4gICAgICogIC5yZXZlcnNlKClcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFwKHZhbHVlLCBpbnRlcmNlcHRvcikge1xuICAgICAgaW50ZXJjZXB0b3IodmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgZXhwbGljaXQgbWV0aG9kIGNoYWluaW5nIG9uIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNoYWluXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gd2l0aG91dCBleHBsaWNpdCBjaGFpbmluZ1xuICAgICAqIF8oY2hhcmFjdGVycykuZmlyc3QoKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGV4cGxpY2l0IGNoYWluaW5nXG4gICAgICogXyhjaGFyYWN0ZXJzKS5jaGFpbigpXG4gICAgICogICAuZmlyc3QoKVxuICAgICAqICAgLnBpY2soJ2FnZScpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiB7ICdhZ2UnOiAzNiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNoYWluKCkge1xuICAgICAgdGhpcy5fX2NoYWluX18gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgdGhlIGB0b1N0cmluZ2AgcmVzdWx0IG9mIHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgdG9TdHJpbmdcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZyByZXN1bHQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS50b1N0cmluZygpO1xuICAgICAqIC8vID0+ICcxLDIsMydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKHRoaXMuX193cmFwcGVkX18pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgdmFsdWVPZlxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHZhbHVlXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS52YWx1ZU9mKCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclZhbHVlT2YoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3dyYXBwZWRfXztcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIGFkZCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gd3JhcHBlZCB2YWx1ZXMgd2hlbiBjaGFpbmluZ1xuICAgIGxvZGFzaC5hZnRlciA9IGFmdGVyO1xuICAgIGxvZGFzaC5hc3NpZ24gPSBhc3NpZ247XG4gICAgbG9kYXNoLmF0ID0gYXQ7XG4gICAgbG9kYXNoLmJpbmQgPSBiaW5kO1xuICAgIGxvZGFzaC5iaW5kQWxsID0gYmluZEFsbDtcbiAgICBsb2Rhc2guYmluZEtleSA9IGJpbmRLZXk7XG4gICAgbG9kYXNoLmNoYWluID0gY2hhaW47XG4gICAgbG9kYXNoLmNvbXBhY3QgPSBjb21wYWN0O1xuICAgIGxvZGFzaC5jb21wb3NlID0gY29tcG9zZTtcbiAgICBsb2Rhc2guY29uc3RhbnQgPSBjb25zdGFudDtcbiAgICBsb2Rhc2guY291bnRCeSA9IGNvdW50Qnk7XG4gICAgbG9kYXNoLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBsb2Rhc2guY3JlYXRlQ2FsbGJhY2sgPSBjcmVhdGVDYWxsYmFjaztcbiAgICBsb2Rhc2guY3VycnkgPSBjdXJyeTtcbiAgICBsb2Rhc2guZGVib3VuY2UgPSBkZWJvdW5jZTtcbiAgICBsb2Rhc2guZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICBsb2Rhc2guZGVmZXIgPSBkZWZlcjtcbiAgICBsb2Rhc2guZGVsYXkgPSBkZWxheTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2U7XG4gICAgbG9kYXNoLmZpbHRlciA9IGZpbHRlcjtcbiAgICBsb2Rhc2guZmxhdHRlbiA9IGZsYXR0ZW47XG4gICAgbG9kYXNoLmZvckVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5mb3JFYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmZvckluID0gZm9ySW47XG4gICAgbG9kYXNoLmZvckluUmlnaHQgPSBmb3JJblJpZ2h0O1xuICAgIGxvZGFzaC5mb3JPd24gPSBmb3JPd247XG4gICAgbG9kYXNoLmZvck93blJpZ2h0ID0gZm9yT3duUmlnaHQ7XG4gICAgbG9kYXNoLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICBsb2Rhc2guZ3JvdXBCeSA9IGdyb3VwQnk7XG4gICAgbG9kYXNoLmluZGV4QnkgPSBpbmRleEJ5O1xuICAgIGxvZGFzaC5pbml0aWFsID0gaW5pdGlhbDtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuICAgIGxvZGFzaC5pbnZlcnQgPSBpbnZlcnQ7XG4gICAgbG9kYXNoLmludm9rZSA9IGludm9rZTtcbiAgICBsb2Rhc2gua2V5cyA9IGtleXM7XG4gICAgbG9kYXNoLm1hcCA9IG1hcDtcbiAgICBsb2Rhc2gubWFwVmFsdWVzID0gbWFwVmFsdWVzO1xuICAgIGxvZGFzaC5tYXggPSBtYXg7XG4gICAgbG9kYXNoLm1lbW9pemUgPSBtZW1vaXplO1xuICAgIGxvZGFzaC5tZXJnZSA9IG1lcmdlO1xuICAgIGxvZGFzaC5taW4gPSBtaW47XG4gICAgbG9kYXNoLm9taXQgPSBvbWl0O1xuICAgIGxvZGFzaC5vbmNlID0gb25jZTtcbiAgICBsb2Rhc2gucGFpcnMgPSBwYWlycztcbiAgICBsb2Rhc2gucGFydGlhbCA9IHBhcnRpYWw7XG4gICAgbG9kYXNoLnBhcnRpYWxSaWdodCA9IHBhcnRpYWxSaWdodDtcbiAgICBsb2Rhc2gucGljayA9IHBpY2s7XG4gICAgbG9kYXNoLnBsdWNrID0gcGx1Y2s7XG4gICAgbG9kYXNoLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgbG9kYXNoLnB1bGwgPSBwdWxsO1xuICAgIGxvZGFzaC5yYW5nZSA9IHJhbmdlO1xuICAgIGxvZGFzaC5yZWplY3QgPSByZWplY3Q7XG4gICAgbG9kYXNoLnJlbW92ZSA9IHJlbW92ZTtcbiAgICBsb2Rhc2gucmVzdCA9IHJlc3Q7XG4gICAgbG9kYXNoLnNodWZmbGUgPSBzaHVmZmxlO1xuICAgIGxvZGFzaC5zb3J0QnkgPSBzb3J0Qnk7XG4gICAgbG9kYXNoLnRhcCA9IHRhcDtcbiAgICBsb2Rhc2gudGhyb3R0bGUgPSB0aHJvdHRsZTtcbiAgICBsb2Rhc2gudGltZXMgPSB0aW1lcztcbiAgICBsb2Rhc2gudG9BcnJheSA9IHRvQXJyYXk7XG4gICAgbG9kYXNoLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBsb2Rhc2gudW5pb24gPSB1bmlvbjtcbiAgICBsb2Rhc2gudW5pcSA9IHVuaXE7XG4gICAgbG9kYXNoLnZhbHVlcyA9IHZhbHVlcztcbiAgICBsb2Rhc2gud2hlcmUgPSB3aGVyZTtcbiAgICBsb2Rhc2gud2l0aG91dCA9IHdpdGhvdXQ7XG4gICAgbG9kYXNoLndyYXAgPSB3cmFwO1xuICAgIGxvZGFzaC54b3IgPSB4b3I7XG4gICAgbG9kYXNoLnppcCA9IHppcDtcbiAgICBsb2Rhc2guemlwT2JqZWN0ID0gemlwT2JqZWN0O1xuXG4gICAgLy8gYWRkIGFsaWFzZXNcbiAgICBsb2Rhc2guY29sbGVjdCA9IG1hcDtcbiAgICBsb2Rhc2guZHJvcCA9IHJlc3Q7XG4gICAgbG9kYXNoLmVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5lYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmV4dGVuZCA9IGFzc2lnbjtcbiAgICBsb2Rhc2gubWV0aG9kcyA9IGZ1bmN0aW9ucztcbiAgICBsb2Rhc2gub2JqZWN0ID0gemlwT2JqZWN0O1xuICAgIGxvZGFzaC5zZWxlY3QgPSBmaWx0ZXI7XG4gICAgbG9kYXNoLnRhaWwgPSByZXN0O1xuICAgIGxvZGFzaC51bmlxdWUgPSB1bmlxO1xuICAgIGxvZGFzaC51bnppcCA9IHppcDtcblxuICAgIC8vIGFkZCBmdW5jdGlvbnMgdG8gYGxvZGFzaC5wcm90b3R5cGVgXG4gICAgbWl4aW4obG9kYXNoKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB1bndyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmdcbiAgICBsb2Rhc2guY2xvbmUgPSBjbG9uZTtcbiAgICBsb2Rhc2guY2xvbmVEZWVwID0gY2xvbmVEZWVwO1xuICAgIGxvZGFzaC5jb250YWlucyA9IGNvbnRhaW5zO1xuICAgIGxvZGFzaC5lc2NhcGUgPSBlc2NhcGU7XG4gICAgbG9kYXNoLmV2ZXJ5ID0gZXZlcnk7XG4gICAgbG9kYXNoLmZpbmQgPSBmaW5kO1xuICAgIGxvZGFzaC5maW5kSW5kZXggPSBmaW5kSW5kZXg7XG4gICAgbG9kYXNoLmZpbmRLZXkgPSBmaW5kS2V5O1xuICAgIGxvZGFzaC5maW5kTGFzdCA9IGZpbmRMYXN0O1xuICAgIGxvZGFzaC5maW5kTGFzdEluZGV4ID0gZmluZExhc3RJbmRleDtcbiAgICBsb2Rhc2guZmluZExhc3RLZXkgPSBmaW5kTGFzdEtleTtcbiAgICBsb2Rhc2guaGFzID0gaGFzO1xuICAgIGxvZGFzaC5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgIGxvZGFzaC5pbmRleE9mID0gaW5kZXhPZjtcbiAgICBsb2Rhc2guaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50cztcbiAgICBsb2Rhc2guaXNBcnJheSA9IGlzQXJyYXk7XG4gICAgbG9kYXNoLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcbiAgICBsb2Rhc2guaXNEYXRlID0gaXNEYXRlO1xuICAgIGxvZGFzaC5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG4gICAgbG9kYXNoLmlzRW1wdHkgPSBpc0VtcHR5O1xuICAgIGxvZGFzaC5pc0VxdWFsID0gaXNFcXVhbDtcbiAgICBsb2Rhc2guaXNGaW5pdGUgPSBpc0Zpbml0ZTtcbiAgICBsb2Rhc2guaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4gICAgbG9kYXNoLmlzTmFOID0gaXNOYU47XG4gICAgbG9kYXNoLmlzTnVsbCA9IGlzTnVsbDtcbiAgICBsb2Rhc2guaXNOdW1iZXIgPSBpc051bWJlcjtcbiAgICBsb2Rhc2guaXNPYmplY3QgPSBpc09iamVjdDtcbiAgICBsb2Rhc2guaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLmlzUmVnRXhwID0gaXNSZWdFeHA7XG4gICAgbG9kYXNoLmlzU3RyaW5nID0gaXNTdHJpbmc7XG4gICAgbG9kYXNoLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG4gICAgbG9kYXNoLmxhc3RJbmRleE9mID0gbGFzdEluZGV4T2Y7XG4gICAgbG9kYXNoLm1peGluID0gbWl4aW47XG4gICAgbG9kYXNoLm5vQ29uZmxpY3QgPSBub0NvbmZsaWN0O1xuICAgIGxvZGFzaC5ub29wID0gbm9vcDtcbiAgICBsb2Rhc2gubm93ID0gbm93O1xuICAgIGxvZGFzaC5wYXJzZUludCA9IHBhcnNlSW50O1xuICAgIGxvZGFzaC5yYW5kb20gPSByYW5kb207XG4gICAgbG9kYXNoLnJlZHVjZSA9IHJlZHVjZTtcbiAgICBsb2Rhc2gucmVkdWNlUmlnaHQgPSByZWR1Y2VSaWdodDtcbiAgICBsb2Rhc2gucmVzdWx0ID0gcmVzdWx0O1xuICAgIGxvZGFzaC5ydW5JbkNvbnRleHQgPSBydW5JbkNvbnRleHQ7XG4gICAgbG9kYXNoLnNpemUgPSBzaXplO1xuICAgIGxvZGFzaC5zb21lID0gc29tZTtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXggPSBzb3J0ZWRJbmRleDtcbiAgICBsb2Rhc2gudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICBsb2Rhc2gudW5lc2NhcGUgPSB1bmVzY2FwZTtcbiAgICBsb2Rhc2gudW5pcXVlSWQgPSB1bmlxdWVJZDtcblxuICAgIC8vIGFkZCBhbGlhc2VzXG4gICAgbG9kYXNoLmFsbCA9IGV2ZXJ5O1xuICAgIGxvZGFzaC5hbnkgPSBzb21lO1xuICAgIGxvZGFzaC5kZXRlY3QgPSBmaW5kO1xuICAgIGxvZGFzaC5maW5kV2hlcmUgPSBmaW5kO1xuICAgIGxvZGFzaC5mb2xkbCA9IHJlZHVjZTtcbiAgICBsb2Rhc2guZm9sZHIgPSByZWR1Y2VSaWdodDtcbiAgICBsb2Rhc2guaW5jbHVkZSA9IGNvbnRhaW5zO1xuICAgIGxvZGFzaC5pbmplY3QgPSByZWR1Y2U7XG5cbiAgICBtaXhpbihmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB7fVxuICAgICAgZm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAoIWxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgICBzb3VyY2VbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfSgpLCBmYWxzZSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIGFkZCBmdW5jdGlvbnMgY2FwYWJsZSBvZiByZXR1cm5pbmcgd3JhcHBlZCBhbmQgdW53cmFwcGVkIHZhbHVlcyB3aGVuIGNoYWluaW5nXG4gICAgbG9kYXNoLmZpcnN0ID0gZmlyc3Q7XG4gICAgbG9kYXNoLmxhc3QgPSBsYXN0O1xuICAgIGxvZGFzaC5zYW1wbGUgPSBzYW1wbGU7XG5cbiAgICAvLyBhZGQgYWxpYXNlc1xuICAgIGxvZGFzaC50YWtlID0gZmlyc3Q7XG4gICAgbG9kYXNoLmhlYWQgPSBmaXJzdDtcblxuICAgIGZvck93bihsb2Rhc2gsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBjYWxsYmFja2FibGUgPSBtZXRob2ROYW1lICE9PSAnc2FtcGxlJztcbiAgICAgIGlmICghbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdPSBmdW5jdGlvbihuLCBndWFyZCkge1xuICAgICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jKHRoaXMuX193cmFwcGVkX18sIG4sIGd1YXJkKTtcblxuICAgICAgICAgIHJldHVybiAhY2hhaW5BbGwgJiYgKG4gPT0gbnVsbCB8fCAoZ3VhcmQgJiYgIShjYWxsYmFja2FibGUgJiYgdHlwZW9mIG4gPT0gJ2Z1bmN0aW9uJykpKVxuICAgICAgICAgICAgPyByZXN1bHRcbiAgICAgICAgICAgIDogbmV3IGxvZGFzaFdyYXBwZXIocmVzdWx0LCBjaGFpbkFsbCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAqL1xuICAgIGxvZGFzaC5WRVJTSU9OID0gJzIuNC4xJztcblxuICAgIC8vIGFkZCBcIkNoYWluaW5nXCIgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyXG4gICAgbG9kYXNoLnByb3RvdHlwZS5jaGFpbiA9IHdyYXBwZXJDaGFpbjtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnRvU3RyaW5nID0gd3JhcHBlclRvU3RyaW5nO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudmFsdWUgPSB3cmFwcGVyVmFsdWVPZjtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnZhbHVlT2YgPSB3cmFwcGVyVmFsdWVPZjtcblxuICAgIC8vIGFkZCBgQXJyYXlgIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB1bndyYXBwZWQgdmFsdWVzXG4gICAgZm9yRWFjaChbJ2pvaW4nLCAncG9wJywgJ3NoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlSZWZbbWV0aG9kTmFtZV07XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLl9fd3JhcHBlZF9fLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIHJldHVybiBjaGFpbkFsbFxuICAgICAgICAgID8gbmV3IGxvZGFzaFdyYXBwZXIocmVzdWx0LCBjaGFpbkFsbClcbiAgICAgICAgICA6IHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBhZGQgYEFycmF5YCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gdGhlIGV4aXN0aW5nIHdyYXBwZWQgdmFsdWVcbiAgICBmb3JFYWNoKFsncHVzaCcsICdyZXZlcnNlJywgJ3NvcnQnLCAndW5zaGlmdCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IGFycmF5UmVmW21ldGhvZE5hbWVdO1xuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jLmFwcGx5KHRoaXMuX193cmFwcGVkX18sIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIGFkZCBgQXJyYXlgIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBuZXcgd3JhcHBlZCB2YWx1ZXNcbiAgICBmb3JFYWNoKFsnY29uY2F0JywgJ3NsaWNlJywgJ3NwbGljZSddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IGFycmF5UmVmW21ldGhvZE5hbWVdO1xuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IGxvZGFzaFdyYXBwZXIoZnVuYy5hcHBseSh0aGlzLl9fd3JhcHBlZF9fLCBhcmd1bWVudHMpLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGxvZGFzaDtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIGV4cG9zZSBMby1EYXNoXG4gIHZhciBfID0gcnVuSW5Db250ZXh0KCk7XG5cbiAgLy8gc29tZSBBTUQgYnVpbGQgb3B0aW1pemVycyBsaWtlIHIuanMgY2hlY2sgZm9yIGNvbmRpdGlvbiBwYXR0ZXJucyBsaWtlIHRoZSBmb2xsb3dpbmc6XG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEV4cG9zZSBMby1EYXNoIHRvIHRoZSBnbG9iYWwgb2JqZWN0IGV2ZW4gd2hlbiBhbiBBTUQgbG9hZGVyIGlzIHByZXNlbnQgaW5cbiAgICAvLyBjYXNlIExvLURhc2ggaXMgbG9hZGVkIHdpdGggYSBSZXF1aXJlSlMgc2hpbSBjb25maWcuXG4gICAgLy8gU2VlIGh0dHA6Ly9yZXF1aXJlanMub3JnL2RvY3MvYXBpLmh0bWwjY29uZmlnLXNoaW1cbiAgICByb290Ll8gPSBfO1xuXG4gICAgLy8gZGVmaW5lIGFzIGFuIGFub255bW91cyBtb2R1bGUgc28sIHRocm91Z2ggcGF0aCBtYXBwaW5nLCBpdCBjYW4gYmVcbiAgICAvLyByZWZlcmVuY2VkIGFzIHRoZSBcInVuZGVyc2NvcmVcIiBtb2R1bGVcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxuICAvLyBjaGVjayBmb3IgYGV4cG9ydHNgIGFmdGVyIGBkZWZpbmVgIGluIGNhc2UgYSBidWlsZCBvcHRpbWl6ZXIgYWRkcyBhbiBgZXhwb3J0c2Agb2JqZWN0XG4gIGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcbiAgICAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlNcbiAgICBpZiAobW9kdWxlRXhwb3J0cykge1xuICAgICAgKGZyZWVNb2R1bGUuZXhwb3J0cyA9IF8pLl8gPSBfO1xuICAgIH1cbiAgICAvLyBpbiBOYXJ3aGFsIG9yIFJoaW5vIC1yZXF1aXJlXG4gICAgZWxzZSB7XG4gICAgICBmcmVlRXhwb3J0cy5fID0gXztcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gaW4gYSBicm93c2VyIG9yIFJoaW5vXG4gICAgcm9vdC5fID0gXztcbiAgfVxufS5jYWxsKHRoaXMpKTtcbiJdfQ==
