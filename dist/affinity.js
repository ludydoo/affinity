(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.affinity = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = require('./lib');
},{"./lib":103}],2:[function(require,module,exports){
var Base = require('./Base.js');
var Type = require('./Type.js');
var _ = require('lodash');

var Attribute = Base.extend(

    {

        /**
         * @class Attribute
         * @extends Base
         * @param {Object} args
         * @param {String|null} [args.name] The name of the {@link Attribute}
         * @param {Type|null} [args.type] The {@link Type} of the {@link Attribute}
         * @param {*} [args.default] The default value of the Attribute
         *
         *
         * A {@link Relation}'s {@link Header} is composed of Attributes.
         *
         * An {@link Attribute} is simply an ordered {@link Set} {name : String, type : {@link Type}}
         *
         * The {@link Type} of an {@link Attribute} is a class that is mainly used to compare the values of the
         * Relation's tuples for this attibute.
         *
         * For example,
         * when running an {@link Operators.Union} on a {@link Relation}, the {@link Tuple}s will be tested for equality so that the
         * {@link Relation} does not include duplicates (as the mathematical definition of a {@link Set} tells us).
         * To do this, we compare two {@link Tuple} by comparing the value of their {@link Attribute}s. If for these two
         * {@link Tuple}s, all their {@link Attribute} values are equal, the two {@link Tuple}s are said to be equal.
         *
         * To test the equality of primitive {@link Attribute}s (String, Boolean, Integer...), this is easy.
         * We test the equality of two {@link Attribute}s with the equality operator "==".
         *
         * Though, when it comes to Object {@link Attribute}s, it is not possible to test the equality with the equality operator
         * "==". We need a function that will test the two objects for equality and that will return true/false.
         *
         * To resume, the {@link Type} of an {@link Attribute} must implement the methods used to compare the corresponding
         * {@link Tuple} {@link Attribute} values.
         *
         * For {@link Types.Numeric} {@link Type}s, the {@link Type} will also implement other comparison operators such as LargerThan (.lt()) ...
         *
         * For {@link Types.Date} {@link Type}s, the {@link Type} will also implement other operators such as DayOfWeek, ...
         *
         *     var fn = new affinity.Attribute({name : 'FirstName', type : 'affinity.String'})
         *     var ln = new affinity.Attribute({name : 'LastName', type : 'affinity.String'})
         *
         */
        constructor: function (args) {

            /**
             * Tells if the attribute was _negated in an expression
             * @private
             * @type {boolean}
             */
            this._negated = false;

            /**
             * Default value for the attribute
             * @type {undefined}
             * @private
             */
            this._default = undefined;

            /**
             * Tells if the attribute is an auto incrementing attribute
             * @type {boolean}
             * @private
             */
            this._autoIncrement = false;

            /**
             * Tells if the attribute is a calculated attribute
             * @type {boolean}
             * @private
             */
            this._calculated = false;

            /**
             * Name of the attribute
             * @type {String}
             */
            this.name = undefined;

            /**
             * Type of the attribute
             * @type {Type}
             */
            this.type = undefined;

            // Check if the args are given
            if (args) {

                // Check if the name arg is given
                if (args.name) {

                    // Check if the name arg is of good type
                    if (!_.isString(args.name)) {

                        // If the name is not a string, throw
                        throw new TypeError('Name is of wrong type');

                    } else {

                        // Name arg seems to be legit
                        this.name = args.name;
                    }
                } else {

                    // If the name arg is not given, set it to null
                    this.name = null;
                }

                // Check if the type arg is given
                if (args.type) {

                    // Check if the type arg is of good type
                    if (!(args.type.prototype instanceof Type) && !(args.type.__proto__ instanceof Type)) {

                        // If the type arg is not of type Type, throw
                        throw new TypeError('Type is of wrong type')

                    } else {
                        // Type arg seems to be legit
                        this.type = args.type;

                        _.forIn(args.type.payload, function(mix){

                            _.forIn(mix, function (mixin, key) {

                                this[key] = mixin;

                            },this)

                        },this);

                    }

                } else {
                    // If the type arg is not given, set it to null
                    this.type = null;
                }

                if (args.hasOwnProperty('default')){
                    this._default = args.default;
                }

                if (args.hasOwnProperty('autoIncrement')){
                    this._autoIncrement = args.autoIncrement;
                }

            }

            Base.apply(this, arguments);
        },

        /**
         * Calculted Property getter setter
         * @param {Boolean} isCalculated
         * @return {undefined|Boolean}
         */
        calculated : function(isCalculated){

            if(_.isBoolean(isCalculated)){
                this._calculated = isCalculated;
            } else {
                return this._calculated;
            }

        },

        /**
         * Clones the Attribute object
         * @return {Attribute} cloned attribute
         *
         *     var fn = new affinity.Attribute({name : 'FirstName',affinity.String});
         *
         *     var ln = attribute.clone();
         *
         *     ln.equal(fn) // true
         *
         *     ln.name = 'LastName';
         *
         *     ln.equal(fn) // false
         *
         *
         */
        clone: function () {

            var attr = new this.constructor({type: this.type, name: this.name});

            if (this.relationHeader) {
                attr.relationHeader = this.relationHeader;
;           }

            if (this.wrappedAttributes){
                attr.wrappedAttributes = this.wrappedAttributes;
            }

            attr.calculated(this.calculated());

            return attr;
        },

        /**
         * Checks if the attribute is being _negated in a predicate
         * @param expression
         * @returns {*}
         * @private
         */
        _checkNegatedAttribute: function (expression) {

            if (this._negated) {
                this._negated = false;
                return new (require('./functions/connective/Not.js'))(expression);

            } else {

                return expression;
            }

        },

        /**
         * String representation of the attribute. Used to print a Relation into console
         * as a Unicode Table
         * @private
         */
        toString: function () {

            return this.name + ' : ' + this.type.toString();

        },

        /**
         * Checks if two attributes are equal
         * @param attribute
         * @returns {boolean}
         */
        equal : function(attribute){

            return this.constructor.equal(this, attribute);

        },

        default : function(){

            if(this._autoIncrement){
                return this.header.relation.length() + this.header.relation._deletedCount;
            }

            return this._default;
        }

    }, {

        type : 'Attribute',

        /**
         * Asserts that a given name is valid for an attribute
         * @private
         * @param name
         */
        assertValidName : function(name){

            if(!_.isString(name)){
                throw new Error('Name must be a string')
            }

            if(name === ''){
                throw new Error('Attribute name cannot be empty string');
            }

        },

        /**
         * Tests for equality between two attributes
         *
         * This method returns a Boolean. It cannot be part of a predicate.
         *
         * @param {Attribute} attribute1
         * @param {Attribute} attribute2
         * @returns {boolean}
         * @static

         */
        equal: function (attribute1, attribute2) {

            return ((attribute1.name === attribute2.name) && (attribute1.type === attribute2.type))

        },

        /**
         * Coerces an arbitrary object to type Attribute
         * @param {Attribute|Object} attribute
         * @returns {Attribute}
         * @static
         *
         *     var fn1 = new affinity.Attribute({name : 'FirstName', type : affinity.String});
         *
         *     var fn2 = {name : 'FirstName' , type : affinity.String}
         *
         *     affinity.Attribute.coerce(fn1) === fn1 // true, the object was already an Attribute.
         *     affinity.Attribute.coerce(fn2) === fn2 // false, the object had to be coerced
         *
         *     affinity.Attribute.coerce(fn2).equal(fn1) // true
         *
         */
        coerce: function (attribute) {


            var name;
            var type;
            var attr;
            var keys;
            var autoIncrement;
            var defaultValue;

            if (attribute instanceof Attribute) {

                return attribute;

            }

            if(_.isObject(attribute)){

                // Attribute is of the type {name : <name>, type : <type>}
                if(attribute.type && attribute.name){

                    name = attribute.name;
                    type = attribute.type;
                    autoIncrement = attribute.autoIncrement;
                    defaultValue = attribute.default;

                } else {

                    // Attribute is either
                    // { <name> : { type : <type> } }
                    // { <name> : <Attribute> }

                    keys = _.keys(attribute);

                    if (keys.length !== 1){
                        throw new Error('Unsupported Attribute declaration');
                    }

                    // Name of the Attribute
                    name = keys[0];

                    // Attribute object
                    attr = attribute[name];


                    if(attr instanceof Attribute){

                        // Attribute is { <name> : <Attribute>}

                        attr.name = name;

                        return attr;

                    } else if(attr.type){

                        // Attribute is { <name> : { type : <type> } }

                        type = attribute[name].type;
                        autoIncrement = attribute[name].autoIncrement;
                        defaultValue = attribute[name].default;

                    }

                }

            }

            return new Attribute({name : name, type : type, autoIncrement : autoIncrement, default : defaultValue});

        }

    });

module.exports = Attribute;

},{"./Base.js":3,"./Type.js":12,"./functions/connective/Not.js":47,"lodash":105}],3:[function(require,module,exports){
var _ = require('lodash');
// Helper function to correctly set up the prototype chain, for subclasses.
// Similar to `goog.inherits`, but uses a hash of prototype properties and
// class properties to be extended.
var extend = function (protoProps, staticProps) {

    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
        child = protoProps.constructor;
    } else {
        child = function () {
            return parent.apply(this, arguments);
        };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function () {
        this.constructor = child;
    };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;

};

/**
 * @class Base
 */
var Base = function () {

};

/**
 * @member Base
 * @method extend
 */
Base.extend = extend;

/**
 * @member Base
 */
Base.mixin = function(mixin){
    _.extend(this.prototype, mixin);
};

module.exports = Base;
},{"lodash":105}],4:[function(require,module,exports){
var Base = require('./Base'),
    Index = require('./Index'),
    Header = require('./Header'),
    _ = require('lodash'),
    Attribute = require('./Attribute'),
    Tuple = require('./Tuple'),
    debug = require('./helpers/debug'),
    equal = require('./helpers/equal');

var ForeignKey = Base.extend({

    /**
     * @class ForeignKey
     * @extends Base
     * @param {Object} params
     * @param {Relation} params.relation
     * @param {string|string[]|Header} params.columnNames
     * @param {Relation} params.referencedRelation
     * @param {string|string[]|Header} params.referencedColumnNames
     * @param {string} params.onUpdate
     * @param {string} params.onDelete
     *
     * The ForeignKey class represents foreign keys to a relation.
     *
     * The foreign key enforces the relational integrity of different relations.
     *
     *
     *     var dogs = new affinity.Relation([
     *          {id : {type : affinity.Integer}},
     *          {ownerId : {type : affinity.Integer}},
     *          {name : {type : affinity.Integer}},
     *      ],[
     *          [0, 0, 'Fido'],
     *          [1, 0, 'Bobby'],
     *          [2, 1, 'Stacey'],
     *          [3, 2, 'Ceasar'],
     *      ],{
     *          pk : ['id'],
     *          fk : [
     *              {
     *                  columnNames           : ['ownerId'],
     *                  referencedRelation    : people,
     *                  referencedColumnNames : ['id'],
     *                  onUpdate              : 'cascade',
     *                  onDelete              : 'restrict'
 *                  },
     *              ...
     *          ]
     *      });
     */
    constructor: function (params) {

        debug.foreignKey.trace('#constructor');

        // relation, columnNames, referencedRelation, referencedColumnNames, onUpdate, onDelete

        /** @property {Header} columns */
        this.columns = null;

        /** @property {Header} referencedColumns */
        this.referencedColumns = null;

        /** @property {Relation} relation */
        this.relation = params.relation;

        /** @property {Relation} referencedRelation */
        this.referencedRelation = params.selfReferencing ? this.relation : params.referencedRelation;

        // Validate columnNames parameter

        if (params.columnNames instanceof Header) {

            // columnNames is already a header
            if (!params.columnNames.isSubset(relation.header()))
                throw new Error('Parameter columnNames passed as invalid Header. ');

            this.columns = params.columnNames;

        } else {

            if(!_.isArray(params.columnNames)){
                params.columnNames = [params.columnNames];
            }

            this.columns =  this.relation.header().clone().project(params.columnNames);

        }


        // Validate referencedColumnNames parameter

        if (params.referencedColumnNames instanceof Header) {

            // referencedColumnNames is already a header
            if (!params.referencedColumnNames.isSubset(params.referencedRelation.header()))
                throw new Error('Parameter referencedColumnNames passed as invalid Header. ');

            this.referencedColumns = params.referencedColumnNames;

        } else {

            if(!_.isArray(params.referencedColumnNames)){
                params.referencedColumnNames = [params.referencedColumnNames];
            }
            this.referencedColumns = this.referencedRelation.header().clone().project(params.referencedColumnNames);

        }

        //todo : Verify onUpdate
        //todo : Verify onDelete

        var that = this;


        // Check that the added tuple respects the foreign key constraint before adding the tuple

        this.relation.ee.on('afterAdd', function(tuple, tupleIndex){

            debug.foreignKey.trace('#beforeAdd');

            try {

                that.checkForeignKeyConstraint(tuple);

            } catch (err) {

                that.relation.removeAt(tupleIndex);

                throw(err);

            }

        });

        // Remove then add the tuple from index before the tuple update

        this.relation.ee.on('beforeUpdate', function(tuple, attributeName, attributeValue){

            debug.foreignKey.trace('#beforeUpdate');

            var projectedTuple = tuple.clone();

            projectedTuple.set(attributeName, attributeValue);

            that.checkForeignKeyConstraint(projectedTuple);

        });

    },

    checkForeignKeyConstraint : function(tuple){

        debug.foreignKey.trace('#checkForeignKeyConstraint');

        var that = this,
            keyTuple,
            temporaryRelation,
            Relation,
            projectedReferencedRelation,
            intersectedRelation;


        /// Build a tuple containing the required values for the given referenced columns

        keyTuple = new Tuple();

        that.referencedColumns.each(function(referencedAttribute, attributeIndex){

            var attribute = that.columns.atIndex(attributeIndex);

            keyTuple.set(referencedAttribute.name, tuple.get(attribute.name));

        });

        that.referencedRelation.each(function(tuple, index){

            var result = true;

            keyTuple.each(function(attribute){

                if (!equal(null, keyTuple.get(attribute), tuple.get(attribute))){
                    result = false;
                    return false;
                }

            });

            if (result == false){
                throw new Error('Foreign key constraint check fail')
            }

        });

    }

},{

    cascadeValues : ['cascade', 'prevent']

});

module.exports = ForeignKey;
},{"./Attribute":2,"./Base":3,"./Header":6,"./Index":7,"./Tuple":11,"./helpers/debug":84,"./helpers/equal":85,"lodash":105}],5:[function(require,module,exports){
var Base = require('./Base.js');
var _ = require('lodash');
var Attribute = require('./Attribute');

var Function = Base.extend(

    {

        /**
         * @class Function
         * @param parameters
         * @property [Array] parameters
         */
        constructor: function (parameters) {

            this.parameters = [];


            for (var i = 0, j = arguments.length; i < j; i++) {

                this.parameters.push(arguments[i]);

            }

            Base.apply(this, arguments);

        },

        /**
         * Sets the function's parameter
         * @param {Object} param The parameter of the function to set
         * @returns {Function} Returns this to chain call
         */
        set: function (param) {

            for (var a in param) {
                if (param.hasOwnProperty(a))
                    this[a] = param[a];
            }

            _.forEach(this.args, function (arg) {
                if (arg instanceof Function) {
                    arg.set(param);
                }
            });

            return this;

        },

        /**
         * Helper function used to convert attributes objects into functions that will get the tuple
         * value for that attribute
         */
        convertAttributeToTuple: function () {

            _.forEach(this.parameters, function (parameter, index) {

                if (_.isFunction(parameter.convertAttributeToTuple)) {
                    parameter.convertAttributeToTuple();
                }

                if (parameter instanceof Attribute) {

                    var newFunc = new (require('./functions/tuple/Attribute'))(parameter.name);

                    newFunc.type = parameter.type;

                    this.parameters[index] = newFunc;
                }

            }, this);

        },

        assignTuple : function(tuple){

            _.forEach(this.parameters, function (parameter, index) {

                if (parameter instanceof Function) {

                    parameter.assignTuple(tuple);

                }

            }, this);

            return this;

        },


        type : function(type){

            if(type){

                this._type = type;

                _.forIn(type.payload, function (mix) {

                    _.forIn(mix, function(mixin, key){

                        this[key] = mixin;

                    }, this)

                }, this)

            } else {
                return this._type;
            }

        }

    });

module.exports = Function;
},{"./Attribute":2,"./Base.js":3,"./functions/tuple/Attribute":80,"lodash":105}],6:[function(require,module,exports){
var Attribute = require('./Attribute.js');
var Set = require('./Set.js');
var _ = require('lodash');
var TString = require('./types/String');
var TType = require('./types/Type');
var debug = require('./helpers/debug.js');

var Header = Set.extend(

    {

        /**
         * Header object constructor.
         *
         * @class Header
         * @extends Set
         * @param {Object} [attributes]
         * @throws The attributes are not passed in Array format
         *
         *
         * A {@link Header} is one of the two main parts of a
         * {@link Relation}, along with the Body (which is a {@link Set}).
         *
         * It is a {@link Set} of {@link Attribute}s. It defines the structure of the
         * {@link Tuple}s that will be part of the body of the
         * {@link Relation}. Each {@link Tuple} in a
         * {@link Relation} must match its {@link Header}
         *
         *     var header = new affinity.header([
         *          {firstname : affinity.string},
         *          {lastname : affinity.string}
         *     ])
         *
         *     var relation = new affinity.relation(); // create an empty relation without a header and without body
         *
         *     relation.header(header); // sets the relation's header
         *
         *     relation.add({firstName : 'John', lastName : 'Doe'}); // Add a tuple in the Relation that matches the header
         *
         *
         */
        constructor: function (attributes) {

            debug.header.trace('#constructor');

            var result = [];

            /**
             * Attributes of the relation
             * @type {Object}
             * @private
             */
            this._attributes = {};

            /**
             * Tells if the relation was declared in an ordered way or not
             * @type {boolean}
             * @private
             */
            this._orderedDeclaration = false;

            if (attributes) {

                // There are attributes in the arguments

                if(_.isObject(attributes)){

                    // Attributes is either an array or an object

                    if(!_.isArray(attributes)){

                        // Attributes is an Object
                        // { <name> : {type : <type>}, <name> : {type : <type>}, ... }
                        // { <name> : <attribute>, <name> : <attribute>, <name> : <attribute>, ... }

                        _.forOwn(attributes, function(attribute, key){

                            var attr = {};
                            attr[key] = attribute;
                            result.push(attr);

                        });

                    } else {

                        // Attributes is an Array
                        // [ { <name> : {type : <type>} }, { <name> : {type : <type>} }, ... ]
                        // [{ <name> : <attribute>}, {<name> : <attribute>}, {<name> : <attribute>}, ... ]

                        this._orderedDeclaration = true;

                        _.forEach(attributes, function (attribute, key) {

                            result.push(attribute);

                        },this)

                    }

                } else {
                    throw new TypeError('Unsupported attribute declaration format');
                }

            } else {

                result = []

            }

            Set.call(this, {type: Attribute, elements: result});

        },

        /**
         * Binds the events for the object
         */
        bindEvents: function () {

            debug.header.trace('#bindEvents');

            var that = this;

            this.ee.on('beforeAdd', function (element) {

                if (that._attributes.hasOwnProperty(element.name)) {
                    throw new Error('Attribute with name ' + element.name + ' already exists in header');
                }

            });

            this.ee.on('afterAdd', function (element, index) {

                that._attributes[element.name] = index;

                element.header = that;

            });

            this.ee.on('afterRemove', function (element) {
                delete that._attributes[element.name];
                that.refreshAttributes();
            });
        },

        /**
         * Refreshes the list of attributes
         */
        refreshAttributes: function () {

            debug.header.trace('#refreshAttributes');

            this._attributes = {};

            this.each(function (element, index) {

                if(!_.isUndefined(element)){
                    this._attributes[element.name] = index;
                }

            }, this)

        },

        /**
         * Gets one of the header attributes
         * @param {Attribute|String} key
         * @returns {Attribute|null}
         */
        get: function (key) {

            debug.header.trace('#get');

            if(key instanceof Attribute){

                if (!this._attributes.hasOwnProperty(key.name)) {
                    return null;
                }

                var attr = this.get(key.name);

                if(!attr.equals(key)){
                    return null;
                } else {
                    return attr;
                }

            } else if (_.isString(key)){

                if (!this._attributes.hasOwnProperty(key)) {
                    return null;
                }

                return this.elements()[this._attributes[key]];

            }

        },

        /**
         * Gets the index of an attribute in the header
         * @param {String} name
         * @returns {null|Attribute}
         */
        getIndex: function (name) {

            debug.header.trace('#getIndex');

            if (!this._attributes.hasOwnProperty(name)) {
                return null;
            }

            return this._attributes[name];

        },

        /**
         * Gets an attribute at the specified index
         * @param index
         * @returns {Attribute|null}
         */
        getAt : function(index){

            if(this._elements[index] !== undefined){
                return this._elements[index];
            }
            return null;

        },

        /**
         * Gets or sets the header attributes list
         * @param {*[]} attributes
         * @returns {undefined|null|Array}
         */
        attributes: function (attributes) {

            debug.header.trace('#attributes');

            if (attributes) {

                return this.elements(attributes);

            } else {

                return this.elements();

            }

        },

        /**
         * Clones a header and its attributes
         * @returns {Header}
         */
        clone: function () {

            debug.header.trace('#clone');

            var newHeader = new this.constructor();

            this.each(function (element) {

                if(!_.isUndefined(element)){
                    newHeader.add(element.clone(), false);
                }

            });

            return newHeader;

        },

        /**
         * Project operation on Header object
         * @param {String[]|Attribute[]} projectedAttributes
         * @returns {Header}
         */
        project: function (projectedAttributes) {

            debug.header.trace('#project');

            var resultAttributes = {},
                a;

            a = projectedAttributes.length;

            while (a--) {

                var projectedAttribute = projectedAttributes[a];

                // If string given, find the attribute with this name
                if (_.isString(projectedAttribute)) {

                    var attributeName = projectedAttribute;

                    projectedAttribute = this.get(attributeName);

                    if (projectedAttribute === null) {
                        throw new ReferenceError('Attribute with name ' + attributeName + ' not found in header');
                    }

                } else if (projectedAttribute instanceof Attribute) {

                    // Find attribute in the header

                    var found = _.find(this.elements(), function (attribute) {
                        return attribute === projectedAttribute;
                    }, this);

                    if (!found) {
                        throw new ReferenceError('Attribute not found in the header');
                    }

                } else {
                    throw new TypeError('Wrong format given for attributes in Header project operation');
                }

                resultAttributes[projectedAttribute.name] = projectedAttribute.clone();
            }

            return new Header(resultAttributes);
        },


        /**
         * Perform a removal operation on the header
         * @param {Attribute[]|String[]|Attribute|String} attributesToRemove attributes to remove from the header
         * @return {Header} the resulting header
         */
        remove: function (attributesToRemove) {

            debug.header.trace('#remove');

            var resultHeader = this.clone(),
                a,
                attribute,
                attributeName;

            // Coerce the arguments to an array
            if (_.isString(attributesToRemove) || attributesToRemove instanceof Attribute) {

                attributesToRemove = [attributesToRemove];

            } else if (!_.isArray(attributesToRemove)) {

                throw new TypeError('Wrong argument type for removal operation');

            }

            a = attributesToRemove.length;

            // Loop through each given attributes to remove

            while (a--) {

                // Check that given attributesToRemove are in the header

                if (_.isString(attributesToRemove[a])) {

                    // Passed attribute is a string.
                    // We will check if the attribute name exists.

                    attributeName = attributesToRemove[a];

                    attribute = attributesToRemove[a] = this.get(attributeName);

                    if (attribute === null) {
                        throw new ReferenceError('Attribute with name ' + attributeName + ' not found in header');
                    }

                } else {

                    // Passed attribute is an Attribute object
                    // We will check if it exists in the header

                    attribute = attributesToRemove[a];

                    attributeName = attribute.name;

                    if (!this._attributes.hasOwnProperty(attributeName)) {

                        // The attribute name doesn't exist in the header

                        throw new ReferenceError('Attribute with name ' + attributeName + ' not found in header');

                    } else if (this.get(attributeName).equal(attribute) === false) {

                        // The attribute is found but doesn't have the same type

                        throw new ReferenceError('Attribute object found in the header but not of same type');
                    }

                }

                // Delete the found attributes from the resulting header

                resultHeader.removeAt(resultHeader.getIndex(attributeName));

            }

            return resultHeader;
        },

        /**
         * Rename operation on the header
         * @param {Object} attributes
         * @returns {Header} The new set
         *
         *     var newHeader = Header.rename( { oldName : 'newName' } );
         *
         */
        rename: function (attributes) {

            debug.header.trace('#rename');

            var resultHeader = this.clone(),
                key;

            if (_.isObject(attributes)) {

                for (key in attributes) {

                    if (attributes.hasOwnProperty(key)) {

                        var newName = attributes[key];

                        // Check if the specified name is a string
                        if (!_.isString(newName)) {
                            throw new TypeError('New name for attribute ' + key + ' must be a string');
                        }

                        var targetAttribute = this.get(key);

                        // Check if the key exists in the current header
                        if (targetAttribute === null) {
                            throw new ReferenceError('Attribute with name ' + key + ' doesn\'t exist in header');
                        }

                        // Check if the renamed operation does not overwrite an existing key in the header
                        if (this._attributes.hasOwnProperty(newName) && newName !== key) {
                            throw new ReferenceError('New attribute name ' + newName + ' already exists in the header');
                        }

                        // Check if the new name is not the same as the old name
                        if (newName === key) {
                            debug.header.warn('Useless renaming operations : ' + key + ' -> ' + newName);
                        }

                        // Check if two renamed attributes don't have the same target name
                        for (var a in attributes) {
                            if (attributes.hasOwnProperty(a) && a !== key) {
                                if (newName === attributes[a]) {
                                    throw new ReferenceError('Two renamed attributes have the same target name');
                                }
                            }
                        }

                        resultHeader._attributes[newName] = resultHeader._attributes[key];

                        if (key !== newName) {
                            delete resultHeader._attributes[key];
                        }

                        resultHeader.get(newName).name = newName;

                    }
                }

            } else {

                throw new TypeError('Wrong argument type for rename operation');
            }

            return resultHeader;

        },

        /**
         * @returns {Relation} The relation representation of the header
         *
         *     var header = new affinity.Header({ a : affinity.String, b : affinity.String });
         *
         *     var headerRelation = header.toRelation();
         *
         *     headerRelation.print();
         *
         *     // +---------------+-------------+
         *     // | name : String | type : Type |
         *     // +---------------+-------------+
         *     // | a             | String      |
         *     // +---------------+-------------+
         *     // | b             | String      |
         *     // +---------------+-------------+
         *
         */
        toRelation: function () {

            debug.header.trace('#toRelation');

            var rel = new (require('./Relation.js'))([
                {name: {type: TString}},
                {type: {type: TType}}
            ]);

            this.each(function (attribute) {
                rel.add({name: attribute.name, type: attribute.type});
            });

            return rel;

        },

        /**
         * @returns {string[]} An array containing the names of the attributes
         */
        toNameArray : function(){
            var result = [];

            this.each(function(attribute){
                result.push(attribute.name);
            });

            return result;

        },

        /**
         *
         * Converts a relation to a header. The relation must have a name : string and type : type structure.
         * Inverse of {@link Header#toRelation}
         * @param relation
         * @returns {Header}
         */
        fromRelation : function(relation){

            // Check that the relation has the right header
            if(!relation.header().exists({name : 'name', type : TString}) || !relation.header().exists({ name : 'type', type : TType}) || !(relation.header().length()==2)){
                throw new Error('Cannot convert relation to header');
            }

            relation.each(function(tuple){
                this.add({name : tuple.get('name'), type : tuple.get('type')}, false);
            }, this);

            return this;

        },

        /**
         * Copies attributes from a relation to another
         * @param {Header} header
         * @param {Header|string[]|Set} [attributesArgument=[]]
         * @param {Boolean} [exclude=false]
         * @returns {Header}
         */
        copy : function(header, attributesArgument, exclude){

            var that = this;

            if(exclude !== true && exclude !== false){
                exclude = false;
            }

            if (attributesArgument){

                // Coerce the attributesArgument arguments to a header argument

                if(!(attributesArgument instanceof Header)){

                    var tempHeader = new Header();

                    if(attributesArgument instanceof Set){

                        attributesArgument.each(function(attribute){
                            if(_.isString(attribute)){


                                var attr = header.get(attribute);


                                if(attr === null){
                                    throw new Error('Attribute with name "' + attribute + '" not found in the header');
                                }

                                tempHeader.add(header.get(attribute).clone());


                            } else if(attribute instanceof Attribute) {

                                if(header.get(attribute.name) === null){
                                    throw new Error('Attribute with name "' + attribute.name + '" not found in the header');
                                }

                                tempHeader.add(attribute.clone());

                            }
                        })

                    } else if (_.isArray(attributesArgument)){

                        _.forEach(attributesArgument, function(attribute){
                            if(_.isString(attribute)){

                                var attr = header.get(attribute);

                                if(attr === null){
                                    throw new Error('Attribute with name "' + attribute + '" not found in the header');
                                }

                                tempHeader.add(attr.clone());

                            } else if(attribute instanceof Attribute) {

                                if(header.get(attribute.name) === null){
                                    throw new Error('Attribute with name "' + attribute.name + '" not found in the header');
                                }

                                tempHeader.add(attribute.clone());

                            }
                        })

                    } else if (_.isString(attributesArgument)){

                        var attr = header.get(attributesArgument);

                        if(attr === null){
                            throw new Error('Attribute with name ' + attributesArgument + ' not found in the header');
                        }

                        tempHeader.add(attr);

                    }

                    attributesArgument = tempHeader;

                } else {

                    attributesArgument.each(function(attribute){

                        if(header.get(attribute.name) === null){
                            throw new Error('Attribute with name ' + attribute.name + ' not found in the header');
                        }

                    })

                }

            }

            if (exclude && attributesArgument){

                header.each(function(attribute){

                    var isExcluded = false;

                    attributesArgument.each(function(excludedAttribute){
                        if(attribute.equal(excludedAttribute)){
                            isExcluded = true;
                        }
                    }, this);

                    if(!isExcluded){
                        this.add(attribute.clone());
                    }

                }, this)


            } else if (!exclude && attributesArgument){

                attributesArgument.each(function(includedAttribute){

                    this.add(header.get(includedAttribute.name).clone());

                }, this)

            } else {

                header.each(function(attribute){
                    this.add(attribute.clone());
                },this)
            }

            return this;

        }


    }, {

        /**
         * @static
         * @param {Header} header
         * @param {string[]|Attribute[]} attributes
         */
        assertAttributesExist : function(header, attributes){

            var mismatch = false;

            _.forEach(attributes, function(attribute){

                if(_.isString(attribute)){
                    if(header.get(attribute) === null){
                        throw new Error('Attribute with name ' + attribute + ' does not exist in the header');
                    }
                } else if (attribute instanceof Attribute){
                    if(!header.exists(attribute)){
                        throw new Error('Attribute with name ' + attribute.name + ' does not exist in the header');
                    }
                } else {
                    throw new Error('Attribute is of wrong type');
                }

            });

        },

        /**
         * @static
         * @param {Header} header1
         * @param {Header} header2
         */
        assertSameNameSameType : function(header1, header2){

            header1.each(function(attribute1){

                header2.each(function(attribute2){

                    if(attribute1.name === attribute2.name && attribute1.type !== attribute2.type){
                        throw new Error('Headers must have same type on attributes of same naem');
                    }

                })

            })

        },

        /**
         * @static
         * @param {Header} header1
         * @param {Header} header2
         */
        assertUnionCompatible : function(header1, header2){

            if (!this.equal(header1, header2)) {
                throw new Error('Relations are not union compatible');
            }

        },

        /**
         * @static
         * @param {Header} header1
         * @param {Header} header2
         */
        assertDisjoint : function(header1, header2){

            if(!this.disjoint(header1, header2)){
                throw new Error('Headers must be disjoint');
            }

        },

        /**
         * @static
         * @param {Header} header1
         * @param {Header} header2
         * @returns {Set|*}
         */
        commonAttributes : function(header1, header2){

            return header1.setIntersection(header2);

        },

        /**
         * Converts a relation into a header.
         * The relation must have the header only with attributes name : TString and type : TType.
         * @static
         * @param relation
         * @returns {Header}
         */
        fromRelation : function(relation){

            var header = new Header();

            return header.fromRelation(relation);

        },

        /**
         * @static
         * @param {Header} header1
         * @param {Header} header2
         * @returns {boolean}
         */
        equal: function (header1, header2) {

            debug.header.trace('Header.equal');

            if (Object.keys(header1._attributes).length !== Object.keys(header2._attributes).length) {
                return false;
            }

            var mismatch = false;

            header1.each(function (attribute1) {

                var attribute1Name = attribute1.name;

                if (!header2._attributes.hasOwnProperty(attribute1Name)) {
                    mismatch = true;
                    return false;
                }

                if (!Attribute.equal(attribute1, header2.get(attribute1.name))) {
                    mismatch = true;
                    return false;
                }


            });

            return !mismatch;

        },

        /**
         * @static
         * @param {Header} header1
         * @param {Header} header2
         * @returns {boolean}
         */
        disjoint: function (header1, header2) {

            debug.header.trace('Header.disjoint');

            var headers = header1.length() > header2.length() ? [header1,header2] : [header2,header1];

            var different = true;

            // Check that header have no common attribute names
            headers[0].each(function (attribute1) {

                if (headers[1].get(attribute1.name) !== null) {
                    different = false;
                    return false;
                }

            });

            return different;

        },

        /**
         * @static
         * @param {Header|*} header
         * @returns {Header}
         */
        coerce : function(header){

            if(header instanceof this){
                return header;
            } else {
                return new Header(header);
            }
        }

    });

module.exports = Header;
},{"./Attribute.js":2,"./Relation.js":9,"./Set.js":10,"./helpers/debug.js":84,"./types/String":101,"./types/Type":102,"lodash":105}],7:[function(require,module,exports){
var Base = require('./Base');
var debug = require('./helpers/debug');

var Index = Base.extend(
    {

        /**
         * The Index class is a simple utility class allowing tuples to be indexed.
         * It speeds up operations on relations as iterations are reduced.
         * @class Index
         * @extends Base
         */
        constructor: function (header) {

            debug.index.trace('#constructor');

            /** @property {Header} header */
            this.header = header;

            /** @property {number} levels */
            this.levels = header.length();

            /** @property {Object} elements */
            this.elements = {};

            /** @property {Array} headerLevels */
            this.headerLevels = [];

            /* Recursively iterating through the header and populating the headerLevels array*/

            var targetHeader = this.header.clone();

            for(var k = 0; k < this.levels; k++){

                this.headerLevels[k] = targetHeader;
                targetHeader = targetHeader.remove(targetHeader.first());

            }

        },

        /**
         * Adds a tuple to the index
         * @param {Tuple} tuple
         * @param {number} index
         */
        add: function (tuple, index) {

            debug.index.trace('#add');

            var context = this;

            var headerCount = this.header.length();

            for (var a = 0; a <= headerCount - 1; a++) {

                var attribute = context.header.first();
                var tupleAttributeValue;

                if(!attribute.type.primitive){
                    tupleAttributeValue = attribute.type.serialize(tuple.get(attribute.name));
                } else {
                    tupleAttributeValue = tuple.get(attribute.name);
                }

                if (a === headerCount - 1) {

                    context.elements[tupleAttributeValue] = index

                } else {

                    if (!context.elements.hasOwnProperty(tupleAttributeValue)) {

                        var newIndex = new Index(this.headerLevels[a+1]);

                        context.elements[tupleAttributeValue] = newIndex;

                        context = newIndex;

                    } else {

                        context = context.elements[tupleAttributeValue];

                    }

                }

            }

        },

        /**
         * Get the index for a tuple
         * @param {Tuple} tuple
         * @returns {number|null}
         */
        getIndex: function (tuple) {

            debug.index.trace('#getIndex');

            var context = this;

            var headerCount = this.header.length();

            for (var a = 0; a <= headerCount - 1; a++) {

                var attribute = context.header.first();
                var tupleAttributeValue;

                if(!attribute.type.primitive){
                    tupleAttributeValue = attribute.type.serialize(tuple.get(attribute.name));
                } else {
                    tupleAttributeValue = tuple.get(attribute.name);
                }

                if (a === headerCount - 1) {

                    if (!context.elements.hasOwnProperty(tupleAttributeValue)) {
                        return null;
                    }

                    return context.elements[tupleAttributeValue];

                } else {

                    if (!context.elements.hasOwnProperty(tupleAttributeValue)) {

                        return null;

                    }

                    context = context.elements[tupleAttributeValue];


                }

            }

        },

        /**
         * Removes a tuple from the index
         * @param {Tuple} tuple
         * @returns {boolean} True if removed, false otherwise
         */
        remove: function (tuple) {

            debug.index.trace('#remove');

            var context = this;

            var headerCount = this.header.length();

            for (var a = 0; a <= headerCount - 1; a++) {

                var attribute = context.header.first();
                var tupleAttributeValue;

                if(!attribute.type.primitive){
                    tupleAttributeValue = attribute.type.serialize(tuple.get(attribute.name));
                } else {
                    tupleAttributeValue = tuple.get(attribute.name);
                }

                if (a === headerCount - 1) {

                    if (!context.elements.hasOwnProperty(tupleAttributeValue)) {
                        return false;
                    }

                    delete context.elements[tupleAttributeValue];

                    return true;

                } else {

                    if (!context.elements.hasOwnProperty(tupleAttributeValue)) {

                        return false;

                    }

                    context = context.elements[tupleAttributeValue];

                }

            }

        }

    });

module.exports = Index;
},{"./Base":3,"./helpers/debug":84}],8:[function(require,module,exports){
var Type = require('./Type'),
    Index = require('./Index'),
    Header = require('./Header'),
    _ = require('lodash'),
    debug = require('./helpers/debug');

var Key = Type.extend({

        /**
         * @class Key
         * @extends Base
         *
         * The Key class represents keys to a relation.
         *
         * When keys are not defined on a relation, a key is assumed on all attributes of the relation.
         * Though, when a key is defined on a subset of a relation's attributes, the uniqueness
         * of the tuples will be calculated only on those attributes.
         *
         * Also, a Key will index the tuples for its attributes, making operations a lot faster.
         *
         *
         *     var relation = new affinity.Relation([
         *          {attribute1 : {type : affinity.Integer}},
         *          {attribute2 : {type : affinity.Integer}},
         *          {attribute3 : {type : affinity.Integer}},
         *      ],[
         *          [1, 2, 3],
         *          [4, 2, 3], // -> Will fail to be added, as it does not respects the unique key constraint
         *          [1, 8, 9], // -> Will fail to be added, as it does not respected the pk constraint
         *          [10, 11, 12],
         *      ],{
         *          pk : ['attribute1'],
         *          unique : [['attribute2', 'attribute3']]
         *      });
         */
        constructor: function (relation, attributes) {

            debug.key.trace('#constructor');

            if(!_.isArray(attributes)){
                attributes = [attributes];
            }

            /**
             * @property {Header} header
             */
            var header = this.header = new Header();
            
            header.relation = relation;

            header.copy(relation.header(),attributes);

            /**
             * @property {Index} index
             */
            var index = this.index = new Index(this.header);

            // Add the tuple to the index after it is added in the relation
            relation.ee.on('afterAdd', function(tuple, tupleIndex){

                debug.key.trace('#afterAdd');

                index.add(tuple, tupleIndex);

            });

            // Remove the tuple from the before it is deleted
            relation.ee.on('beforeDelete', function(tuple, tupleIndex){

                debug.key.trace('#beforeDelete');

                index.remove(tuple, tupleIndex);

            });


            // Remove then add the tuple from index before the tuple update

            relation.ee.on('beforeUpdate', function(tuple, attributeName){

                debug.key.trace('#beforeUpdate');

                if(header.get(attributeName) !== null){
                    var tupleIndex = index.getIndex(tuple);
                    index.remove(tuple, tupleIndex);
                }

            });

            relation.ee.on('afterUpdate', function(tuple, attributeName){

                debug.key.trace('#afterUpdate');

                if(header.get(attributeName) !== null){
                    var tupleIndex = index.getIndex(tuple);
                    index.add(tuple, tupleIndex);
                }

            });

        }

    });

module.exports = Key;
},{"./Header":6,"./Index":7,"./Type":12,"./helpers/debug":84,"lodash":105}],9:[function(require,module,exports){
var Header = require('./Header.js');
var Tuple = require('./Tuple.js');
var Type = require('./Type.js');
var _ = require('lodash');
var Set = require('./Set');
var debug = require('./helpers/debug');
var coerce = require('./helpers/coerce');
var Key = require('./Key');
var ForeignKey = require('./ForeignKey');

var Relation = Set.extend(
    {

        /**
         *
         * @class Relation
         * @param {Header|Object[]|Attribute[]} header Header of the Relation
         * @param {Tuple[]|Object[]} body Body of the Relation
         * @param {Object} constraints Constraints for the relation
         * @param {String[]} constraints.pk Fields that will constitute primary key
         * @param {String[][]} constraints.unique Unique field definition
         * @param {Object[]} constraints.fk Foreign key definitions
         * @extends Set
         *
         * Relation constructor
         *
         * A Relation is basically a {@link Set}, implementing the basic set operators (Union, Difference, Intersection, Product)
         * and adding more operators. It also has a {@link Header}, and adds constraints to the basic {@link Set} behavior.
         *
         *     var relation = new affinity.Relation([
         *          {id : {type : affinity.Integer}},
         *          {name : {type : affinity.String}},
         *          {born : {type : affinity.Date}},
         *     ],[
         *          [1, 'John Doe', new Date(1934, 10, 20)],
         *          [2, 'John Wilson', new Date(1922, 7, 5)],
         *     ]);
         */
        constructor: function (header, body, constraints) {

            debug.relation.trace('#constructor');

            /**
             * @property {{pk: String, unique: String[][], fk: Object[]}} _constraintArguments
             * @private
             */
            this._constraintArguments = constraints;

            /**
             * @property {Key} _pk The Primary Key for the Relation
             * @private
             */
            this._pk = undefined;

            /**
             * @property {Set} _uks The Primary Keys for the Relation
             * @private
             */
            this._uks = undefined;

            /**
             * @property {Set} _fks The Foreign Keys for the Relation
             * @private
             */
            this._fks = undefined;

            /**
             * @property {Header} _header The relation header
             * @private
             */
            this.header(Header.coerce(header));

            Set.call(this, {type: Tuple, elements: body});

        },

        bindEvents: function () {

            debug.relation.trace('#bindEvents');

            var that = this;

            this.ee.on('beforeGetElements', function () {
                that.ee.emit('beforeGetBody');
            });

            this.ee.on('beforeAdd', function (tuple) {

                // Add default values
                that.header().each(function(attribute){

                    var tupleAttributeValue = tuple.get(attribute.name);

                    if(tupleAttributeValue === null || tupleAttributeValue === undefined || tupleAttributeValue === ''){

                        tuple.set(attribute.name, attribute.default());

                    }

                });

                // Coerce tuple attributes
                that.header().each(function(attribute){

                    var attributeValue, attributeType;

                    attributeValue = tuple.get(attribute.name);

                    attributeType = attribute.type;

                    attributeValue = coerce(attributeType, attributeValue);

                    tuple.set(attribute.name, attributeValue);

                });

                // Check that the tuple is union-compatible with the relation
                if (!that.isCompatible(tuple)) {
                    throw new Error('Tuple is not union compatible');
                }

                tuple.relation = that;

            });

            this.ee.once('beforeGetElements', function () {

                var constraintArguments = that._constraintArguments;

                // Parse constraint arguments
                if (constraintArguments) {

                    // Parse primary key argument
                    if (constraintArguments.pk) {

                        that.pk(constraintArguments.pk);

                    }

                    // Parse unique key arguments
                    if (constraintArguments.unique) {

                        _.forEach(constraintArguments.unique, function (unique) {

                            that.uks().add(new Key(that, unique));

                        }, that);

                    }

                    // Parse foreign key arguments
                    if (constraintArguments.fk) {
                        _.forEach(constraintArguments.fk, function (fkArgs) {

                            fkArgs.relation = that;

                            var fk = new ForeignKey(fkArgs);

                            that.fks().add(new ForeignKey(fkArgs));
                        })
                    }



                }

            });

            this.uks().ee.on('beforeAdd', function(constraint){

                // Insure corresponding key types has serialize method
                that._assertKeySerialize(constraint);

                // Check that the keys are unique
                that._assertKeysUnique(constraint);

                // Check that the keys are irreducible
                that._assertKeysIrreducible(constraint);

            });

            this.ee.on('afterAdd', function(tuple, index){
                tuple.index = index;
                tuple.relation = that;
            });

        },

        _assertKeySerialize : function(newKey){

            // Check that if the constraint applies on an object, that
            // its type has the serialize method

            newKey.header.each(

                function (attribute) {
                    if (!attribute.type.primitive && !_.isFunction(attribute.type.serialize)) {
                        throw new Error(
                            'Cannot index attribute "' + attribute.name + '". ' +
                            'Its type "' + attribute.type.type + '" must' +
                            'have a "serialize" method for it to be indexable.');
                    }
                });

        },

        _assertKeysUnique : function(newKey){

            var existingKeys = this.uks();

            existingKeys.each(function(key){

                if (key.header.equal(newKey.header)){
                    throw new Error('Constraints must be unique');
                }

            });

        },

        _assertKeysIrreducible : function(newKey){

            var existingKeys = this.uks();

            existingKeys.each(function(key){

                if (newKey.header.setIntersection(key.header).length() !== 0) {
                    throw new Error('Constraint must be irreducible');
                }

            });

        },

        /**
         * Delete or add tuples to match a given relation
         * @param {Relation} relation
         */
        adjustTo: function(relation){

            this.compute();

            relation.compute();

            var that = this;

            // 1. Delete tuples that do not exist in the given relation

            // Loop through each tuple
            that.each(function(tuple, index){

                // Check if the tuple exists in the given relation
                if (!relation.exists(tuple)){
                    that.removeAt(index);
                }

            });

            // 2. Add tuples that do not exist in the relation

            // Loop through each tuple of the given relation
            relation.each(function(tuple){

                // Check if the tuple is present in this relation
                if (!that.exists(tuple)){

                    that.add(tuple.clone());

                }

            });

        },

        _index: function (element) {

            // Look for the tuple in the PK if it exists

            if (this._pk) {

                var index = this._pk.index.getIndex(element);

                if (index !== null) {
                    return index;
                }

            }

            var result = null;

            this.uks().any(function (uniqueConstraint) {

                result = uniqueConstraint.index.getIndex(element);

                if (result !== null){
                    console.log('found by uk');
                    return false;
                }


            }, this);

            return result;

        },

        /**
         * Gets the specified attribute object by name
         * @param {String} attribute Attribute name
         * @returns {Attribute|null} The attribute or null if not found
         *
         *     var fn = new affinity.Attribute({name : 'firstName', type : affinity.String})
         *     var ln = new affinity.Attribute({name : 'lastName', type : affinity.String})
         *
         *     var relation = new affinity.Relation([
         *              fn,
         *              ln
         *          ],[
         *              ['John','Doe'],
         *              ['Hello','World'],
         *              ['Super','Duper'],
         *          ]);
         *
         *     relation.get('firstName') === fn // true
         *
         *
         */
        get: function (attribute) {

            debug.relation.trace('#get');

            return this.header().get(attribute);

        },

        /**
         * Get the tuple at the given index
         * @param {number} index The index of the tuple
         * @returns {*|null}
         *
         *     var relation = new affinity.Relation([
         *              { 'firstName' : {type : affinity.String}}
         *              { 'LastName'  : {type : affinity.String}}
         *          ],[
         *              ['John','Doe'],
         *              ['Hello','World'],
         *              ['Super','Duper'],
         *          ]);
         *
         *     relation.each(function(tuple, index){
         *
         *          console.log(relation.atIndex(index) === tuple) // true
         *
         *     })
         *
         * console.log(relation.atIndex(0).get('firstName')) // John
         *
         */
        atIndex: function (index) {

            debug.relation.trace('#atIndex');

            return this.elements()[index];

        },

        /**
         * @param {Set} [tuples] The new set of body
         * @returns {Set|Relation} The body/null if getter, this if setter
         *
         * Getter/Setter for the body property
         *
         * You will more likely always use the getter (Relation.body()) than the setter
         * (Relation.body(body)) part for this method.
         *     var relation = new affinity.Relation([
         *              { 'firstName' : {type : affinity.String}}
         *              { 'LastName'  : {type : affinity.String}}
         *          ]);
         *
         *     var set = new affinity.Set();
         *
         *     set.add(new affinity.Tuple({firstName : 'John', lastName : 'Doe'}))
         *     set.add(new affinity.Tuple({firstName : 'Hello', lastName : 'World'}))
         *     set.add(new affinity.Tuple({firstName : 'John', lastName : 'Cage'}))
         *
         *     relation.body(set); // Sets the relation's body
         *
         *     relation.body() // Gets the relation's body
         *
         *     console.log(relation.body() === set) // true
         *
         */
        body: function (tuples) {

            debug.relation.trace('#body');

            if (tuples) {

                this.elements(tuples);

                return this

            } else {

                this.ee.emit('beforeGetBody');

                return this.elements();

            }

        },

        /**
         * @return {Relation} Returns this for chaining
         *
         * Calculates the relation. Because the relations are only calculated when their header or their body
         * are requested, you must explicitly call compute() if you want to calculate a relation.
         *
         * You should not need to use this function. Calling body() or header() calculates the relation
         * automatically
         *
         *     var product = relation1.product(relation2);
         *
         *     // At this point, nothing has been calculated.
         *
         *     product.header() // Because we requested the header, it is calculated
         *
         *     product.body() // Because we requested the body, it is calculated
         *
         *     var product2 = relation1.product(relation2);
         *
         *     product2.compute(); // Calculates the header and the body;
         *
         */
        compute: function () {

            debug.relation.trace('#compute');

            this.header();
            this.body();

            return this;

        },

        /**
         * @param {Header} [header]
         * @returns {null|{Header}}
         *
         * Gets or sets the relation's header
         */
        header: function (header) {

            if (header) {

                debug.relation.trace('#header (set)');

                this._header = header;

                header.relation = this;

            } else {

                debug.relation.trace('#header (get)');

                this.ee.emit('beforeGetHeader');

                return this._header;

            }

        },

        /**
         * Gets / Sets the relation's primary key
         * @param {String} [primaryKeyName]
         */
        pk : function(primaryKeyName){

            if (primaryKeyName){

                if(this._pk !== undefined){
                    this.uks().remove(this._pk);
                }

                this._pk = new Key(this, primaryKeyName);

                this.uks().add(this._pk);

            } else {

                return this._pk;

            }

        },

        /**
         * Gets the foreign keys set
         * @returns {Set}
         */
        fks : function(){

            if (this._fks === undefined){
                this._fks = new Set({ type : ForeignKey});
            }

            return this._fks;
        },

        /**
         * Gets the unique keys set
         * @returns {Set}
         */
        uks : function(){

            if (this._uks === undefined){
                this._uks = new Set({ type : Key});
            }

            return this._uks;
        },

        /**
         * @param {Tuple|Object} tuple
         * @returns {boolean}
         *
         * Check if a tuple is compatible with the relation
         */
        isCompatible: function (tuple) {

            debug.relation.trace('#isCompatible');

            tuple = Tuple.coerce(tuple);

            var tupleKeys = Object.keys(tuple.attributes);
            var tupleKeyCount = tupleKeys.length;
            var headerKeys = Object.keys(this.header()._attributes);
            var headerKeyCount = headerKeys.length;


            /// Check if the given tuple has the same header as the relation

            // Header and Tuple must have the same number of attributes
            if (tupleKeyCount !== headerKeyCount) {
                return false;
            }

            // Header and Tuple must have the same attribute names
            return !_.some(headerKeys, function (headerAttribute) {

                // Loop through each attributes of the tuple
                return !_.some(tupleKeys, function (tupleAttribute) {

                    // Found a match
                    return (tupleAttribute === headerAttribute && (tuple.get(tupleAttribute) !== undefined) && (tuple.get(tupleAttribute) !== null));

                });

            });

        },

        /**
         * @param {Relation} relation The relation to compare to
         * @returns {boolean} If the relations are equal or not
         *
         * Tests if the relation is equal to another one
         */
        equal: function (relation) {

            debug.relation.trace('#equal');

            return this.constructor.equal(this, relation);
        },

        /**
         * Clones a relation
         * @param {boolean} [withTuples=true] Copies the tuples
         * @returns {Relation}
         */
        clone : function(withTuples){

            withTuples = !!(withTuples === undefined || withTuples === null);

            var newHeader = this.header().clone();

            var newRelation = new Relation(newHeader);

            // Clone the pk

            //todo PK Clone

            // Clone the uks

            //todo UKS clone

            // Clone the fks

            //todo FKS clone

            if (withTuples){
                this.each(function(tuple){
                    newRelation.add(tuple.clone());
                });
            }

            return newRelation;

        },

        /**
         * Prints the printable representation of the Relation to console
         */
        print: function () {

            debug.relation.trace('#print');

            console.log(this.toString());
        },

        /**
         * Gets the string representation of the relation
         * @returns {String} The string print representation of the relation
         */
        toString: function () {

            var hspacing = 1,
                vspacing = 1,
                arr = this.arr = [],
                headerRow = [],
                maxWidths = [],
                maxHeights = [];

            debug.relation.trace('#getPrintString');

            this.compute();

            this.header().each(function (attribute) {

                headerRow.push({ width: null, height: null, lines: null, attribute: attribute, string: attribute.toString()})

            }, this);

            // [ {width, height, lines, string},{width, height, lines, string},... ] ]

            arr.push(headerRow);

            this.each(function (tuple) {

                var tupleRow = [];

                _.forEach(headerRow, function (attr) {
                    tupleRow.push({ width: null, height: null, lines: null, string: tuple.get(attr.attribute.name).toString()})
                }, this);

                arr.push(tupleRow);

            }, this);

            function findHeight(string) {

                return string.split("\n").length;

            }

            function findWidth(string) {

                var lines = string.split('\n'),
                    max = 0;

                _.forEach(lines, function (line) {

                    var lineLength = line.length;

                    if (lineLength > max)
                        max = lineLength;

                }, this);

                return max;

            }

            function findMaxWidth(arr) {

                var max = 0;

                _.forEach(arr, function (obj) {

                    var lineWidth = obj.width;

                    if (lineWidth > max)
                        max = lineWidth;

                }, this);

                return max;
            }

            function findMaxHeight(arr) {

                var max = 0;

                _.forEach(arr, function (obj) {

                    var lineHeight = obj.height;

                    if (lineHeight > max)
                        max = lineHeight;

                }, this);

                return max;

            }

            function parseLines(string) {
                return string.split("\n");
            }

            // [
            //   [{width, height, lines, string},{width, height, lines, string},... ],
            //   [{width, height, lines, string},{width, height, lines, string},... ],
            //   [{width, height, lines, string},{width, height, lines, string},... ],
            //   ...
            // ]


            _.forEach(arr, function (row, rowIndex) {

                _.forEach(row, function (col, colIndex) {

                    col.width = findWidth(col.string);
                    col.height = findHeight(col.string);
                    col.lines = parseLines(col.string);

                    if (!maxWidths[colIndex] || maxWidths[colIndex] < col.width) {
                        maxWidths[colIndex] = col.width;
                    }

                    if (!maxHeights[rowIndex] || maxHeights[rowIndex] < col.height) {
                        maxHeights[rowIndex] = col.height;
                    }

                }, this);

            }, this);

            var result = '\n';


            // Printing the top border

            result += '+';

            _.forEach(maxWidths, function (maxWidth, index) {

                for (var a = 0; a < maxWidths[index] + hspacing * 2 + 2; a++) {
                    result += '-'
                }

                result += '+'

            }, this);

            result += '\n';

            // Printing the attributes

            _.forEach(arr, function (row, rowIndex) {

                var maxHeight = maxHeights[rowIndex];

                for (var a = 0; a < maxHeight; a++) {

                    result += '|';

                    _.forEach(row, function (col, colIndex) {

                        var maxWidth = maxWidths[colIndex];

                        var line = col.lines[a];

                        if (!line) line = '';

                        for (var i = 0; i < hspacing; i++) {
                            result += ' ';
                        }

                        var lineLength = line.length;

                        result += line;

                        for (var k = 0; k < hspacing; k++) {
                            result += ' ';
                        }

                        for (var b = 0; b < maxWidth - lineLength + 2 * hspacing; b++) {
                            result += ' ';
                        }

                        result += '|';

                    }, this);

                    result += '\n';

                }

                result += '+';

                _.forEach(maxWidths, function (maxWidth, index) {

                    for (var a = 0; a < maxWidths[index] + hspacing * 2 + 2; a++) {
                        if (rowIndex === 0) {
                            result += '='
                        } else {
                            result += '-'
                        }

                    }

                    result += '+'

                }, this);


                if (rowIndex != arr.length - 1) result += '\n';


            }, this);

            return result;

        },


        /**
         * Updates tuples in the relation
         * @param predicate
         * @param values
         *
         * Example
         *
         *     relation.update(age.gt(20), { age : age.old().plus(10), name : name.old().substr(0,1) });
         */
        update : function(predicate, values){

            predicate.convertAttributeToTuple();

            _.forEach(values, function(value){

                if(_.isFunction(value)){
                    value.convertAttributeToTuple()
                }

            });

            this.each(function(tuple){

                if(predicate.assignTuple(tuple).value() === true){

                    _.forEach(values, function(expression, key){

                        var value = _.isFunction(expression) ? expression.assignTuple(tuple).value() : expression;

                        tuple.set(key, value);

                    })

                }

            })

        },

        /**
         * Removes tuples from a relation based on a predicate
         * @param predicate
         */
        removeWhere : function(predicate){

            predicate.convertAttributeToTuple();

            var that = this;

            this.each(function(tuple, index){

                if(predicate.assignTuple(tuple).value() === true){

                    that.removeAt(index);

                }

            })

        },


        //region Operations

        /**
         *
         * @param {Relation} relation The relation to compute difference against
         * @returns {Operators.Difference} The resulting relation
         *
         * Shortcut to create a Difference relation based on this relation and the specified one
         *
         *     var relation1 = new affinity.Relation([
         *              {firstName : {type : affinity.String}}
         *              {lastName : {type : affinity.String}}
         *          ],[
         *              ['John','Doe'],
         *              ['Lucino','Veo'],
         *              ['Mary','Poppins'],
         *          ]);
         *
         *     var relation2 = new affinity.Relation([
         *              {firstName : {type : affinity.String}}
         *              {lastName : {type : affinity.String}}
         *          ],[
         *              ['John','Doe']
         *          ]);
         *
         *     var diff = relation1.difference(relation2);
         *
         *     // +---------------------+--------------------+
         *     // | firstName : TString | lastName : TString |
         *     // +---------------------+--------------------+
         *     // | Lucino              | Veo                |
         *     // +---------------------+--------------------+
         *     // | Mary                | Poppins            |
         *     // +---------------------+--------------------+
         */
        difference: function (relation) {

            debug.relation.trace('#difference');

            return new (require('./algebra/Difference'))(this, relation);
        },

        /**
         * @param {Relation} relation The relation to compute intersection against
         * @returns {Operators.Intersection} The resulting relation
         *
         * Shortcut to create an Intersect relation based on this relation and the specified one
         *
         *     var relation1 = new affinity.Relation([
         *              {firstName : {type : affinity.String}}
         *              {lastName : {type : affinity.String}}
         *          ],[
         *              ['John','Doe'],
         *              ['Lucino','Veo'],
         *              ['Mary','Poppins'],
         *          ]);
         *
         *     var relation2 = new affinity.Relation([
         *              {firstName : {type : affinity.String}}
         *              {lastName : {type : affinity.String}}
         *          ],[
         *              ['John','Doe']
         *          ]);
         *
         *     var intersection = relation1.intersect(relation2);
         *
         *     // +---------------------+--------------------+
         *     // | firstName : TString | lastName : TString |
         *     // +---------------------+--------------------+
         *     // | John                | Doe                |
         *     // +---------------------+--------------------+
         */
        intersect: function (relation) {

            debug.relation.trace('#intersect');

            var Intersection = require('./algebra/Intersection');

            return new Intersection(this, relation);
        },

        /**
         *
         * @param {Relation} relation The relation to compute the join against
         * @returns {Operators.Join} The resulting relation
         *
         * Shortcut to create a Join relation based on this relation and the specified one
         *
         *     var relation1 = new affinity.Relation([
         *              {firstName : {type : affinity.String}}
         *              {lastName : {type : affinity.String}}
         *          ],[
         *              ['John','Doe'],
         *              ['Lucino','Veo'],
         *              ['Mary','Poppins'],
         *          ]);
         *
         *     var relation2 = new affinity.Relation([
         *              {LastName : {type : affinity.String}}
         *              {Title    : {type : affinity.String}}
         *          ],[
         *              ['Doe','Mr'],
         *              ['Poppins','Lady']
         *          ]);
         *
         *     var join = relation1.join(relation2);
         *
         *     // +---------------------+--------------------+-----------------+
         *     // | firstName : TString | lastName : TString | Title : TString |
         *     // +---------------------+--------------------+-----------------+
         *     // | John                | Doe                | Mr              |
         *     // +---------------------+--------------------+-----------------+
         *     // | Mary                | Poppins            | Lady            |
         *     // +---------------------+--------------------+-----------------+
         */
        join: function (relation) {

            debug.relation.trace('#join');

            return new (require('./algebra/Join'))(this, relation);
        },

        /**
         *
         * @param {Relation} relation The relation to compute product against
         * @returns {Operators.Product} The resulting relation
         *
         * Shortcut to create a Product relation based on this relation and the specified one
         *
         *     var relation1 = new affinity.Relation([
         *              {firstName : {type : affinity.String}}
         *              {lastName : {type : affinity.String}}
         *          ],[
         *              ['John','Doe'],
         *              ['Lucino','Veo'],
         *              ['Mary','Poppins'],
         *          ]);
         *
         *     var relation2 = new affinity.Relation([
         *              {title : {type : affinity.String}}
         *          ],[
         *              ['Lady'],
         *              ['Mr']
         *          ]);
         *
         *     var product = relation1.product(relation2);
         *
         *     // +---------------------+--------------------+-----------------+
         *     // | firstName : TString | lastName : TString | Title : TString |
         *     // +---------------------+--------------------+-----------------+
         *     // | John                | Doe                | Lady            |
         *     // +---------------------+--------------------+-----------------+
         *     // | John                | Doe                | Mr              |
         *     // +---------------------+--------------------+-----------------+
         *     // | Lucino              | Veo                | Lady            |
         *     // +---------------------+--------------------+-----------------+
         *     // | Lucino              | Veo                | Mr              |
         *     // +---------------------+--------------------+-----------------+
         *     // | Mary                | Poppins            | Lady            |
         *     // +---------------------+--------------------+-----------------+
         *     // | Mary                | Poppins            | Mr              |
         *     // +---------------------+--------------------+-----------------+
         */
        product: function (relation) {

            debug.relation.trace('#product');

            return new (require('./algebra/Product'))(this, relation);
        },

        /**
         * @param {String[]} attributeNames The relation to compute intersection against
         * @returns {Operators.Projection} The resulting relation
         *
         * Shortcut to create a Project relation based on this relation
         *
         * The attributeNames parameter must be in the format :
         *
         *     relation.project(['argument1', 'argument2']);
         *
         *     var relation1 = new affinity.Relation([
         *              {firstName : {type : affinity.String}}
         *              {lastName : {type : affinity.String}}
         *          ],[
         *              ['John','Doe'],
         *              ['Lucino','Veo'],
         *              ['Mary','Poppins'],
         *          ]);
         *
         *     var intersection = relation1.project(['firstName']);
         *
         *     // +---------------------+
         *     // | firstName : TString |
         *     // +---------------------+
         *     // | John                |
         *     // +---------------------+
         *     // | Lucino              |
         *     // +---------------------+
         *     // | Mary                |
         *     // +---------------------+
         */
        project: function (attributeNames) {

            debug.relation.trace('#project');

            return new (require('./algebra/Projection'))(this, attributeNames);
        },

        /**
         *
         * @param {Object} newNames An object containing the new attribute names.
         * @returns {Operators.Rename} The resulting relation
         *
         * Shortcut to create a Rename relation based on this relation
         *
         *     var relation1 = new affinity.Relation([
         *              {firstName : {type : affinity.String}}
         *              {lastName : {type : affinity.String}}
         *          ],[
         *              ['John','Doe'],
         *              ['Lucino','Veo'],
         *              ['Mary','Poppins'],
         *          ]);
         *
         *     var rename = relation1.rename({lastName : 'Boogie'});
         *
         *     // +---------------------+--------------------+
         *     // | firstName : TString | Boogie : TString   |
         *     // +---------------------+--------------------+
         *     // | John                | Doe                |
         *     // +---------------------+--------------------+
         *     // | Lucino              | Veo                |
         *     // +---------------------+--------------------+
         *     // | Mary                | Poppins            |
         *     // +---------------------+--------------------+
         */
        rename: function (newNames) {

            debug.relation.trace('#rename');

            return new (require('./algebra/Rename'))(this, newNames);
        },

        /**
         *
         * @param {Function} predicate The predicate to test the tuples against
         * @returns {Operators.Restriction} The resulting relation
         *
         * Shortcut to create a Restrict relation based on this relation
         *
         *     var relation = new affinity.Relation([
         *              {firstName : {type : affinity.String}}
         *              {lastName : {type : affinity.String}}
         *          ],[
         *              ['John','Doe'],
         *              ['Lucino','Veo'],
         *              ['Mary','Poppins'],
         *              ['Robert','Robert']
         *          ]);
         *
         *     // Multiple ways to build a predicate:
         *
         *     // Compare with static value
         *     relation.restrict(relation.get('firstName').equal('John'));
         *
         *     // +---------------------+--------------------+
         *     // | firstName : TString | Boogie : TString   |
         *     // +---------------------+--------------------+
         *     // | John                | Doe                |
         *     // +---------------------+--------------------+
         *
         *     // Compare two attributes
         *     relation.restrict(relation.get('firstName').equal(relation.get('lastName'));
         *
         *     // +---------------------+--------------------+
         *     // | firstName : TString | Boogie : TString   |
         *     // +---------------------+--------------------+
         *     // | Robert              | Robert             |
         *     // +---------------------+--------------------+
         *
         *     // Combine with and, or, not
         *     relation.restrict( (relation.get('firstName').not().equal('John')) .and( relation.get('lastName').not().equal('Veo') ) )
         *
         *     // +---------------------+--------------------+
         *     // | firstName : TString | Boogie : TString   |
         *     // +---------------------+--------------------+
         *     // | Mary                | Poppins            |
         *     // +---------------------+--------------------+
         *     // | Robert              | Robert             |
         *     // +---------------------+--------------------+
         */
        restrict: function (predicate) {

            debug.relation.trace('#restrict');

            return new (require('./algebra/Restriction'))(this, predicate);
        },

        /**
         * Shortcut to create a Union relation based on this relation and the specified one
         * @param {Relation} relation The relation to perform Union with
         * @returns {Operators.Union} The resulting relation
         */
        union: function (relation) {

            debug.relation.trace('#union');

            return new (require('./algebra/Union'))(this, relation);
        },

        /**
         * @param {Relation} relation
         * @returns {Operators.Composition} The resulting relation
         */
        compose: function (relation) {

            debug.relation.trace('#compose');

            return new (require('./algebra/Composition'))(this, relation);

        },

        /**
         * @param {String} groupingAttributeName
         * @param {String[]} groupedAttributeNames
         * @return {Operators.Group}
         */
        group: function (groupingAttributeName, groupedAttributeNames) {

            debug.relation.trace('#group');

            return new (require('./algebra/Group'))(this, groupingAttributeName, groupedAttributeNames);

        },

        /**
         * @param {String[]} groupedAttributeNames
         * @returns {Operators.Ungroup}
         */
        ungroup: function (groupedAttributeNames) {

            debug.relation.trace('#ungroup');

            return new (require('./algebra/Ungroup'))(this, groupedAttributeNames);

        },

        /**
         * SemiDifference
         * @returns {Operators.SemiDifference} The resulting relation
         * @param relation
         */
        sdifference: function (relation) {

            debug.relation.trace('#sdifference');

            return new (require('./algebra/Semidifference'))(this, relation);

        },

        /**
         * SemiJoin
         * @returns {Operators.SemiJoin} The Resulting Relation
         * @param relation
         */
        sjoin: function (relation) {

            debug.relation.trace('#sjoin');

            return new (require('./algebra/Semijoin'))(this, relation);

        },

        /**
         * Shortcut to execute a Wrap operation
         * @param wrappingAttributeName The name of the new wrapping attribute
         * @param {String[]} wrappedAttributes The attribute names to be wrapped
         * @returns {Operators.Wrap} The resulting relation
         */
        wrap: function (wrappingAttributeName, wrappedAttributes) {

            debug.relation.trace('#wrap');

            return new (require('./algebra/Wrap'))(this, wrappingAttributeName, wrappedAttributes);

        },

        /**
         * Shortcut to execute an Unwrap operation
         * @param {String[]} wrappedAttributeNames The names of the wrapped attributes to unwrap
         * @returns {Operators.Unwrap} The resulting relation
         */
        unwrap: function (wrappedAttributeNames) {

            debug.relation.trace('#unwrap');

            return new (require('./algebra/Unwrap'))(this, wrappedAttributeNames);

        },

        /**
         * Shortcut to create an Extend operation
         * @param {Object[]} expressions The expressions to evaluate
         * @returns {Operators.Extension} The resulting relation
         */
        extend: function (expressions) {

            debug.relation.trace('#extend');

            return new (require('./algebra/Extension'))(this, expressions);

        },

        /**
         * Shortcut to the Summarize operation
         * @param {String[]|Attribute[]} attributes The attributes to summarize
         * @param {Object} summaries Summary expressions
         */
        summarize : function(attributes, summaries){
            debug.relation.trace('#summarize');

            return new (require('./algebra/Summarize'))(this, attributes, summaries);

        },


        //endregion

        //region Aggregates

        all : function(predicate){

            var All = require('./functions/aggregate/All.js');

            return new All(this, predicate);

        },

        any : function(predicate){

            var Any = require('./functions/aggregate/Any.js');

            return new Any(this, predicate);

        },

        count : function(){

            var Count = require('./functions/aggregate/Count.js');

            return new Count(this);

        }
        //endregion

    }, {

        /**
         * Gets the string representation of the Relation type
         * @returns {string}

         * @static
         */
        toString: function () {
            return 'Relation'
        },

        type: 'Relation',

        /**
         * Tests for equality between two relations
         * @param {Relation} rel1
         * @param {Relation} rel2

         * @static
         * @returns {boolean}
         */
        equal: function (rel1, rel2) {

            debug.relation.trace('Relation.equal');

            if (!rel1.header().equal(rel2.header())) {
                return false;
            }

            rel1.compute();
            rel2.compute();

            return Set.equal(rel1, rel2);

        }

    });


module.exports = Relation;

},{"./ForeignKey":4,"./Header.js":6,"./Key":8,"./Set":10,"./Tuple.js":11,"./Type.js":12,"./algebra/Composition":13,"./algebra/Difference":14,"./algebra/Extension":15,"./algebra/Group":16,"./algebra/Intersection":17,"./algebra/Join":18,"./algebra/Product":19,"./algebra/Projection":20,"./algebra/Rename":21,"./algebra/Restriction":22,"./algebra/Semidifference":25,"./algebra/Semijoin":26,"./algebra/Summarize":27,"./algebra/Ungroup":28,"./algebra/Union":29,"./algebra/Unwrap":30,"./algebra/Wrap":31,"./functions/aggregate/All.js":32,"./functions/aggregate/Any.js":33,"./functions/aggregate/Count.js":35,"./helpers/coerce":82,"./helpers/debug":84,"lodash":105}],10:[function(require,module,exports){
var Type = require('./Type.js');
var _ = require('lodash');
var coerce = require('./helpers/coerce');
var equal = require('./helpers/equal');
var clone = require('./helpers/clone');
var EventEmitter = require('eventemitter3').EventEmitter3;
var debug = require('./helpers/debug.js');


var Set = Type.extend(

    {
        /**
         * @class Set
         * @param {Object} [args] Constructor arguments
         * @param {Type} [args.type] Type of the elements contained in the set
         * @extends Type
         * A Set is an unordered collection of distinct objects (no duplicates).
         */
        constructor: function (args) {

            debug.set.trace('#constructor');

            /**
             * @property {EventEmitter} ee
             * @external
             */
            this.ee = new EventEmitter();

            this.ee.setMaxListeners(0);

            /**
             * @property {Type} _type
             * @private
             */
            this._type = null;

            /**
             * @property {Array} _elements
             * @private
             */
            this._elements = [];

            /**
             * @property {Number} _deletedCount
             * @private
             */
            this._deletedCount = 0;


            // Call bindEvents if is defined

            if (_.isFunction(this.bindEvents)) {
                this.bindEvents();
            }

            if (args) {

                if (args.type) {
                    this.type(args.type);
                }

                if (args.elements) {
                    this.elements(args.elements);
                }

            }



            // Call parent constructor

            Type.apply(this, arguments);

        },

        bindEvents : function(){

        },

        /**
         * @returns {Set}
         *
         * Clones a set
         */
        clone: function () {

            debug.set.trace('#clone');

            var newSet = new this.constructor({type : this.type()});

            this.each(function (element) {
                newSet.add(element, false);
            });

            return newSet;

        },

        /**
         * Destroys the set
         */
        destroy : function(){

            // Deletes the elements
            this.each(function(element, index){

                this.removeAt(index);

            });

            // Deletes the event emitter
            delete this.ee;

        },

        /**
         * Gets or sets the elements of the set
         * @param {Set} [elements] elements of the set
         * @returns {undefined|null|Array}
         * @throws Will throw if the type of the Set has not been set
         */
        elements: function (elements) {

            debug.set.trace('#elements');

            if (this.type() === null) {
                throw new Error('Must define the type of the set first');
            }

            if (elements) {

                if (!_.isArray(elements)) {
                    throw new TypeError('elements must be in array format')
                }

                this.ee.emit('beforeSetElements', elements);

                _.forEach(elements, function (element) {

                    this.add(element);

                }, this);

                this.ee.emit('afterSetElements', elements);

            } else {

                this.ee.emit('beforeGetElements');

                return this._elements;
            }

        },

        /**
         * @param {Type} [type] The type of the Set
         * @returns {null|Type}
         *
         * Getter/Setter for the type parameter. When used without parameter, will return
         * the type of the Set. When used with a parameter, will set the set's type.
         */
        type: function (type) {

            debug.set.trace('#type');

            if (type) {
                this._type = type;
            } else {
                return this._type;
            }

        },

        /**
         * @param {Function} callback The callback function
         * @param {Object} [context] The "this" context for the callback
         *
         * Iterator function. Only an alias for lodash _.forEach
         */
        each: function (callback, context) {

            debug.set.trace('#each');

            _.forEach(this.elements(), function(element, index){

                if(element !== undefined){
                    if(callback.call(context, element, index) === false){
                        return false;
                    }
                }

            });

        },

        /**
         * @param {Function} callback The callback function
         * @param {Object} [context] The "this" context for the callback
         *
         * Iterator function. Only an alias for lodash _.any
         */
        any : function(callback, context){

            debug.set.trace('#any');

            var result = false;

            _.any(this.elements(), function(element, index){

               return (element !== undefined && callback.call(context, element, index));

            });

            return result;

        },

        /**
         * @param {*} element
         * @param {boolean} [checkDuplicate=true] Tests for duplicate elements in the set. Set to false to skip this
         * verification if you are sure the element is not in the set
         * @returns {boolean} True if the element was added, false otherwise
         *
         * Directly add an element to the set.
         */
        add: function (element, checkDuplicate) {

            debug.set.trace('#add');

            if (_.isUndefined(checkDuplicate)) {
                checkDuplicate = true;
            }

            if (element) {

                debug.set.trace('#add coercing element');

                element = coerce(this.type(), element, this);

                if ((checkDuplicate && !this.exists(element)) || !checkDuplicate) {

                    this.ee.emit('beforeAdd', element);

                    var newIndex = this.elements().push(element) - 1;

                    this.ee.emit('afterAdd', element, newIndex);

                    return true;

                }

            }

            return false;

        },


        /**
         * @param {*} element The element to remove
         * @returns {boolean} Returns true if the element was removed, false otherwise
         *
         * Removes an element from the set.
         */
        remove: function (element) {

            debug.set.trace('#remove');

            element = coerce(this.type(), element);

            var index = this.index(element);

            return this.removeAt(index);

        },

        /**
         * @param {number} index The index at which to remove the element
         * @returns {Boolean} True if deleted, false otherwise
         *
         * Removes an element from the set at the specified index.
         */
        removeAt: function (index) {

            debug.set.trace('#removeAt');

            var element = this.atIndex(index);

            if(element === undefined){
                return false;
            }

            this.ee.emit('beforeRemove', element, index);

            this.elements()[index] = undefined;

            this._deletedCount++;

            this.ee.emit('afterRemove', element, index);

            return true;

        },

        /**
         * @returns {null|*} The first element or null.
         *
         * Gets the first element from the set.
         */
        first : function(){

            debug.set.trace('#first');

            var result = _.find(this.elements(), function(element){

                if(!_.isUndefined(element)){
                    return true;
                }

            });

            if(_.isUndefined(result)){
                return null;
            } else {
                return result;
            }

        },

        /**
         * @param {*} object
         * @returns {number|null} Index of object if found, null otherwise
         * @private
         *
         * Find the index of an element with defined type equality methods
         */
        _indexByEquality: function (object) {

            debug.set.trace('#indexByEquality');

            var result = null;

            this.each(function (element, key) {

                if (equal(this.type(), element, object)) {
                    result = key;
                    return false;
                }

            }, this);

            return result;

        },

        /**
         * @param {Object} element The element to search for
         * @returns {null|number} The index of the element if found, null otherwise
         *
         * Gets the index of an element
         */
        index: function (element) {

            debug.set.trace('#index');

            var result = null;

            element = coerce(this.type(), element);

            if(this._index){
                result = this._index(element);
            }

            if (result !== null) return result;

            return this._indexByEquality(element);

        },

        /**
         * Gets the element at the specified index
         * @param {number} index The index of the element
         * @returns {*} The resulting element
         */
        atIndex: function (index) {

            debug.set.trace('#atIndex');

            return this.elements()[index];
        },


        /**
         * @param {*} element The element to find
         * @returns {null|*} the resulting element or null if not found
         *
         * Finds an element
         */
        find: function (element) {

            debug.set.trace('#find');

            var index = this.index(element);

            if (index !== null) {
                return this.atIndex(index);
            } else {
                return null;
            }

        },

        /**
         * @param {*} element The element to check for
         * @returns {boolean} True if the element exists, false if not
         *
         * Checks if an element exists in the set.
         */
        exists: function (element) {

            debug.set.trace('#exists');

            return (this.index(element) !== null);

        },

        /**
         * @returns {number} Number of elements in the set
         */
        length: function () {

            debug.set.trace('#length');

            return this.elements().length-this._deletedCount;

        },

        /**
         * @param {Set} set2 The set to perform union with
         * @returns {Set} The resulting set
         *
         * Union of two sets. Returns a set containing all the elements from A and B.
         *
         *     var set1 = new affinity.Set(affinity.Integer, [1, 2, 3]);
         *
         *     var set2 = new affinity.Set(affinity.Integer, [3, 4, 5]);
         *
         *     var result = set1.setUnion(set2);
         *
         *     // Set has elements [1, 2, 3, 4, 5] (note no duplicates)
         */
        setUnion: function (set2) {

            debug.set.trace('#union');

            var thisType = this.type();
            var otherType = set2.type();

            var type = (thisType === otherType) ? thisType : null;

            var newSet = new this.constructor();

            newSet.type(type);

            _.forEach([this, set2], function (aSet) {

                aSet.each(function (element) {
                    newSet.add(clone(element));
                })

            });

            return newSet;

        },

        /**
         *
         * @param {Set} set2 The set acting as a pastry cutter
         * @returns {Set}
         *
         *     Perform a difference between two sets. Returns a set with the elements of A without
         *     those that A and B have in common.
         *
         *         var set1 = new affinity.Set(affinity.Integer, [1, 2, 3]);
         *
         *         var set2 = new affinity.Set(affinity.Integer, [3, 4, 5]);
         *
         *         var result = set1.setDifference(set2);
         *
         *         // Set has elements [1, 2]
         */
        setDifference: function (set2) {

            debug.set.trace('#difference');

            var newSet = new this.constructor();
            newSet.type(this.type());

            this.each(function (element) {

                if(!set2.exists(element)){
                    newSet.add(clone(element), false);
                }

            });

            return newSet;

        },

        /**
         *
         * @param {Set} set2 The set to perform product with
         * @returns {Set}
         *
         * Performs a product of two sets. Returns a set with all the possible combinations
         * of elements from A combined with those of B. This operation will return a set containing
         * tuples with attributes { 0 : attr1, 1 : attr2}. 0 is the left set element, 1 is the
         * right set element.
         *
         *     var set1 = new affinity.Set(affinity.Integer, [1, 2]);
         *
         *     var set2 = new affinity.Set(affinity.Integer, [3, 4]);
         *
         *     var result = set1.setProduct(set2);
         *
         *     // Set has elements [Tuple(0 : 1, 1 : 3),Tuple(0 : 1, 1 : 4),Tuple(0 : 2, 1 : 2),Tuple(0 : 2, 1 : 4)]
         */
        setProduct: function (set2) {

            debug.set.trace('#product');

            var Tuple = require('./Tuple.js');

            var newSet = new Set({type: Tuple});

            this.each(function (element1) {

                set2.each(function (element2) {

                    var tuple = new Tuple({0: element1, 1: element2});
                    newSet.add(tuple, false);

                });

            });

            return newSet;

        },

        /**
         *
         * @param {Set} set2 The set to be intersected with
         * @returns {Set} The resulting set
         *
         * Performs an intersection with another set. Returns a set with
         * the elements that A and B have in common.
         *
         *     var set1 = new affinity.Set(affinity.Integer, [1, 2, 3]);
         *
         *     var set2 = new affinity.Set(affinity.Integer, [3, 4, 5]);
         *
         *     var result = set1.setIntersection(set2);
         *
         *     // Set has elements [3]
         */
        setIntersection: function (set2) {

            debug.set.trace('#intersection');

            var newSet = new this.constructor();

            newSet.type(this.type());

            this.each(function (element1) {

                if (set2.exists(element1)) {
                    newSet.add(clone(element1), false);
                }

            }, this);

            return newSet;

        },

        /**
         *
         * @param {Set} set2 The set to peform symmetric difference against
         * @returns {Set} The resulting set
         *
         * Performs a symmetric difference. Returns a set with the elements that A
         * and B do not have in common.
         *
         *     var set1 = new affinity.Set(affinity.Integer, [1, 2, 3]);
         *
         *     var set2 = new affinity.Set(affinity.Integer, [3, 4, 5]);
         *
         *     var result = set1.setSymmetricDifference(set2);
         *
         *     // Set has elements [1, 2, 4, 5]
         */
        setSymmetricDifference: function (set2) {

            debug.set.trace('#symmetricDifference');

            var newSet = new (this.constructor)({type: this.type()});

            var set1 = this;

            set1.each(function (element1) {

                if (!set2.exists(element1)) {
                    newSet.add(clone(element1));
                }

            });

            set2.each(function (element2) {

                if (!set1.exists(element2)) {
                    newSet.add(clone(element2));
                }

            });

            return newSet;

        },

        /**
         * @param aSet
         * @returns {boolean}
         *
         * Determine if the set is a subset of another set.
         */
        isSubset : function(aSet){

            debug.set.trace('#isSubset');

            var match = true;

            this.each(function(element){
                if(!aSet.exists(element)){
                    match = false;
                    return false;
                }
            });

            return match;

        },

        /**
         * @param aSet
         * @returns {boolean}
         *
         * Determine if the set is a superset of another set
         */
        isSuperset : function(aSet){

            debug.set.trace('#isSuperset');

            return !aSet.isSubset(this);
        },

        /**
         * @param aSet
         * @returns {boolean}
         *
         * Determines if the set is a proper subset of another set
         */
        isProperSubset : function(aSet){

            debug.set.trace('#isProperSubset');

            if(this.length() >= aSet.length()){
                return false;
            }
            return this.isSubset(aSet);
        },

        /**
         * @param aSet
         * @returns {boolean}
         *
         * Determine if the set is a proper superset of another set
         */
        isProperSuperset : function(aSet){

            debug.set.trace('#isProperSuperset');

            return !aSet.isProperSubset(this);
        },

        /**
         * @param {Set} anotherSet
         * @returns {boolean}
         *
         * Checks if two sets are equal
         */
        equal: function (anotherSet) {

            debug.set.trace('#equal');

            return this.constructor.equal(this, anotherSet);

        }




    }, {

        /**
         *
         * @param {Set} set1 The first set to compare
         * @param {Set} set2 The second set to compare
         * @returns {boolean} True if the sets are equal, false otherwise
         * @static
         *
         * Checks if two sets are equal
         *
         */
        equal: function (set1, set2) {

            debug.set.trace('.equal');

            var setLength1 = set1.length(),
                setLength2 = set2.length(),
                mismatch = false;

            // Check that both sets are of the same type

            if (set1.type() && set2.type() && (set1.type() !== set2.type())) {
                return false;
            }

            // Check that both sets are of the same length
            if (setLength1 !== setLength2) {
                return false;
            }

            // Find each set1 items in set2
            set1.each(function (element1) {

                var index2 = set2.index(element1);

                if (index2 === null) {
                    mismatch = true;
                    return false;
                }

            });

            return !mismatch;

        }

    });

module.exports = Set;
},{"./Tuple.js":11,"./Type.js":12,"./helpers/clone":81,"./helpers/coerce":82,"./helpers/debug.js":84,"./helpers/equal":85,"eventemitter3":104,"lodash":105}],11:[function(require,module,exports){
var Type = require('./Type.js');
var Header = require('./Type.js');
var TString = require('./types/String.js');
var Attribute = require('./Attribute.js');
var _ = require('lodash');
var equal = require('./helpers/equal');
var value = require('./helpers/value');
var Set = require('./Set.js');
var Tuple = Type.extend(
    {

        /**
         * @class Tuple
         * @param attributes
         * @extends Type
         * @constructor
         */
        constructor: function (attributes) {

            this.attributes = {};

            if (attributes) {

                if (!_.isObject(attributes)) {
                    throw new TypeError('Tuple attributes in wrong format')
                }

                var a;

                for (a in attributes) {
                    if (attributes.hasOwnProperty(a)) this.set(a, attributes[a]);
                }
            }

            Type.apply(this, arguments);

        },


        /**
         * Iterator function that loops through each of the tuple attributes
         * @param {Function} callback Callback function
         * @param {Object} context Execution context of the callback
         */
        each : function(callback, context){
            _.forIn(this.attributes, callback, context);
        },

        /**
         * Copies attribtues from another tuple
         * @param {Tuple} tuple Tuple to copy attributes from
         * @param {Header|Attribute[]|Set|String[]} [attributesArgument=[]] Attributes to copy
         * @param {boolean} [exclude=false] Do we exclude or include the specified arguments
         */
        copy : function(tuple, attributesArgument, exclude){

            if (exclude !== true && exclude !== false){
                exclude = false;
            }

            if (!_.isUndefined(attributesArgument) && !_.isNull(attributesArgument)) {

                var result = new Set({type: TString});

                // Coerce the attributes argument to Set of string
                if (attributesArgument instanceof Header) {
                    attributesArgument.each(function (attribute) {
                        result.add(attribute.name);
                    })
                } else if (attributesArgument instanceof Set) {
                    attributesArgument.each(function (attributeArgument) {

                        if (attributeArgument instanceof Attribute) {
                            result.add(attributeArgument.name);
                        } else if (_.isString(attributeArgument)) {
                            result.add(attributeArgument);
                        }

                    })
                } else if (_.isArray(attributesArgument)) {
                    _.forEach(attributesArgument, function (attributeArgument) {
                        if (attributeArgument instanceof Attribute) {
                            result.add(attributeArgument.name);
                        } else if (_.isString(attributeArgument)) {
                            result.add(attributeArgument);
                        }
                    })
                } else if (_.isString(attributesArgument)) {
                    result.add(attributesArgument);
                }

                attributesArgument = result;

            }

            if(attributesArgument && exclude === false){

                attributesArgument.each(function(copiedAttribute){

                    this.set(value(copiedAttribute), tuple.get(value(copiedAttribute)));

                }, this)

            } else {

                _.forEach(tuple.attributes, function (tupleAttribute, tupleAttributeKey) {

                    if (attributesArgument && exclude === true){

                        var isExcludedAttribute = false;

                        attributesArgument.each(function(excludedAttribute){

                            if (equal(TString, excludedAttribute, tupleAttributeKey)){
                                isExcludedAttribute = true;
                                return false;
                            }

                        });

                        if(!isExcludedAttribute){
                           this.set(tupleAttributeKey, tupleAttribute);
                        }

                    } else {
                        this.set(tupleAttributeKey, tupleAttribute);
                    }

                }, this)

            }

        },

        /**
         * Test for equality with another tuple
         * @param {Tuple} tuple
         * @returns {boolean}
         */
        equals: function (tuple) {
            return Tuple.equal(this, tuple);
        },

        /**
         * Sets an attribute value
         * @param {String} attributeName Name of the attribute
         * @param {*} value Value of the attribute
         */
        set: function (attributeName, value) {

            if(this.relation){

                var clone = this.clone();

                var oldValue = this.attributes[attributeName];

                var foundIndex = undefined;

                value = this.relation.header().get(attributeName).type.coerce(value);

                clone.attributes[attributeName] = value;

                // Let's check if updating the tuple's attribute
                // will cause a duplicate tuple in the relation

                if((foundIndex = this.relation.index(clone)) !== null && (this.relation.atIndex(foundIndex) !== this)){

                    this.relation.remove(this);

                } else {

                    this.relation.ee.emit('beforeUpdate', this, attributeName, value);

                    this.attributes[attributeName] = value;

                    this.relation.ee.emit('afterUpdate', this, attributeName, value, oldValue);

                }

            } else {

                this.attributes[attributeName] = value;

            }

        },

        /**
         * Gets and attribute value
         * @param {Attribute|String} attributeName Name of the attribute
         * @returns {*}
         */
        get: function (attributeName) {

            return this.attributes[attributeName];

        },

        /**
         * Deletes an attribute from the tuple
         * @param {String} attributeName The attribute name to delete
         */
        delete: function (attributeName) {
            delete this.attributes[attributeName];
        },

        /**
         * Clones a tuple
         * @returns {Tuple}
         */
        clone: function () {

            var attr,
                newTuple = new (this.constructor)();

            _.forEach(this.attributes, function (attribute, key) {

                if (_.isFunction(attribute.clone)) {
                    attr = attribute.clone();
                } else {
                    attr = attribute;
                }

                newTuple.set(key, attr);

            }, this);

            return newTuple;

        },

        /**
         * String representation of the tuple
         * @returns {string}
         */
        toString : function(){

            var count = 0;

            var attrLength = Object.keys(this.attributes).length;
            var attrs = ['Tuple({'];

            this.each(function(attribute, key){

                attrs.push(key.toString()+ ' : ' + attribute.toString());

                if(count !== attrLength-1){
                    attrs.push(', ')
                }

                count++;

            },this);

            attrs.push('})');

            return attrs.join('');

        },

        toObject : function(recursive){

            recursive = typeof(recursive) !== 'undefined' ? recursive : false;

            var result = {};

            this.each(function(attribute, key) {

                if(recursive && !!this.relation && !!this.relation.get(key) && (this.relation.get(key).type === Tuple)) {
                    result[key] = attribute.toObject(true);
                } else {
                    result[key] = attribute;
                }

            }, this);

            return result;

        }


    }, {

        type: 'Tuple',

        toString: function () {
            return 'Tuple'
        },

        /**
         * Test for equality between two tuples
         * @param {Tuple} tuple1
         * @param {Tuple} tuple2
         * @returns {boolean}
         * @static

         */
        equal: function (tuple1, tuple2) {

            var key;

            if (!(tuple1 instanceof Tuple) || !(tuple2 instanceof Tuple)) {
                throw new Error('Provided tuples are of the wrong type');
            }

            var match = true;

            tuple1.each(function(attr, key){

                if(tuple2.get(key) === null){
                    match = false;
                    return false;
                }

                if(!equal(null, attr, tuple2.get(key))){
                    match = false;
                    return false;
                }

            });

            return match;

        },

        /**
         * Check that two tuples match on the given attributes
         * @param {Tuple} tuple1
         * @param {Tuple} tuple2
         * @param {Attribute[]} attributes
         * @returns {boolean}
         * @static

         */
        matchOnAttributes : function(tuple1, tuple2, attributes){

            var match = true;

            attributes.each(function(attribute){

               var attributeName = attribute.name;

                if(!equal(null, tuple1.get(attributeName), tuple2.get(attributeName))){
                    match = false;
                    return false;
                }

            });

            return match;

        },

        /**
         * Coerces an arbitrary object to type Tuple
         * @param {Object|Tuple} tuple
         * @param relation The Relation to which belongs the tuple.
         * @returns {Tuple}
         * @static

         */
        coerce: function (tuple, relation) {


            if(tuple instanceof Tuple){

                // Given tuple is of type Tuple.

                return tuple;

            } else {

                if(!_.isObject(tuple)){

                    // It is not an object. It can't be coerced.

                    throw new TypeError('Wrong parameter type. Expected an object or a Tuple')
                }

                // It is not a Tuple instance. Check if it might be coerced.
                if (_.isArray(tuple)) {

                    if (_.isUndefined(relation) || _.isNull(relation)) {
                        throw new Error('Cannot coerce array-declared tuple if no relation is specified')
                    }

                    if (_.isFunction(relation.header)) {

                        // Collection has header

                        var header = relation.header(),
                            headerCount = header.length();

                        if (headerCount > 0) {

                            // Header has one or more attributes

                            if(!header._orderedDeclaration){
                                throw new Error('Cannot coerce an array declared tuple if the header has not been declared in array format')
                            }

                            if(headerCount !== tuple.length){
                                throw new Error('Cannot coerce Tuple, it does not have the same number of attributes as the header');
                            }

                            var newTuple = new Tuple();

                            // Iterate through each attributes of the header in order

                            header.each(function(attribute, index){

                                // Set the corresponding tuple attribute

                                newTuple.set(attribute.name, tuple[index]);

                            });

                            return newTuple;

                        }

                    }

                }

                tuple = new Tuple(tuple);

                return tuple;

            }

        }

    });

module.exports = Tuple;
},{"./Attribute.js":2,"./Set.js":10,"./Type.js":12,"./helpers/equal":85,"./helpers/value":87,"./types/String.js":101,"lodash":105}],12:[function(require,module,exports){
var Base = require('./Base.js');

var Type = Base.extend(
    {

        /**
         * @class Type
         * @extends Base
         */
        constructor: function (value) {

            //this._value = value;

            Base.apply(this, arguments);

        },

        /**
         * Clones the object
         * @returns {Type}
         */
        clone : function(){

            return new this.constructor(this._value);

        },

        /**
         * Destroys the object
         */
        destroy : function(){

        }

    }, {

        type : 'Type',

        toString: function () {
            return 'Type'
        }

    });

module.exports = Type;
},{"./Base.js":3}],13:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var Tuple = require('./../Tuple.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');

var Composition = Relation.extend(

    {

        /**
         * @class Operators.Composition
         * @extends Relation
         *
         * @param {Relation} relationA The relation A
         * @param {Relation} relationB The relation B
         *
         *
         * The Composition operator will perform a natural join between A and B while removing the common attributes
         *
         *     var relationA = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {firstName: { type: affinity.String}},
         *              {lastName: { type: affinity.String}}
         *          ],[
         *              [1, 'John', 'Doe'],
         *              [2, 'Mary', 'Poppins'],
         *              [3, 'Lucky', 'Luke']
         *          ]);
         *     // +------------------------+---------------------+--------------------+
         *     // | characterId : TInteger | firstName : TString | lastName : TString |
         *     // +========================+=====================+====================+
         *     // | 1                      | John                | Doe                |
         *     // +------------------------+---------------------+--------------------+
         *     // | 2                      | Mary                | Poppins            |
         *     // +------------------------+---------------------+--------------------+
         *     // | 3                      | Lucky               | Luke               |
         *     // +------------------------+---------------------+--------------------+
         *
         *     var relationB = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {fan: { type: affinity.String}}
         *          ],[
         *              [1, 'Mr X'],
         *              [1, 'Miss Dibble'],
         *              [2, 'Nat Bibble']
         *          ]);
         *     // +------------------------+---------------+
         *     // | characterId : TInteger | fan : TString |
         *     // +========================+===============+
         *     // | 1                      | Mr X          |
         *     // +------------------------+---------------+
         *     // | 1                      | Miss Dibble   |
         *     // +------------------------+---------------+
         *     // | 2                      | Nat Bibble    |
         *     // +------------------------+---------------+
         *
         *     var relationC = relationA.compose(relationB);
         *
         *     // or
         *
         *     var relationC = new affinity.Composition(relationA, relationB)
         *
         *     // +---------------------+--------------------+---------------+
         *     // | firstName : TString | lastName : TString | fan : TString |
         *     // +=====================+====================+===============+
         *     // | John                | Doe                | Mr X          |
         *     // +---------------------+--------------------+---------------+
         *     // | John                | Doe                | Miss Dibble   |
         *     // +---------------------+--------------------+---------------+
         *     // | Mary                | Poppins            | Nat Bibble    |
         *     // +---------------------+--------------------+---------------+
         *     //
         */
        constructor: function (relationA, relationB) {

            /**
             * @property {Object} args
             * @property {Relation} args.left
             * @property {Relation} args.right
             */

            debug.compose.trace('#constructor');

            this.args = {};

            this.args.left = relationA;

            this.args.right = relationB;

            Relation.call(this);

            this.commonAttributes = null;

        },

        bindEvents: function () {

            debug.compose.trace('#bindEvents');

            // Calling the parent bindEvents
            Composition.__super__.bindEvents.call(this);

            var that = this;

            var left = that.args.left;
            var right = that.args.right;

            // beforeGetHeader
            this.ee.once('beforeGetHeader', function () {

                var leftHeader = left.header();
                var rightHeader = right.header();

                debug.compose.trace('beforeGetHeader');

                Header.assertSameNameSameType(leftHeader, rightHeader);

                that.commonAttributes = Header.commonAttributes(leftHeader, rightHeader);

                that.leftAttributes = leftHeader.setDifference(that.commonAttributes);

                that.rightAttributes = rightHeader.setDifference(that.commonAttributes);

                that.header().copy(leftHeader.setUnion(rightHeader).setDifference(that.commonAttributes));

            });

            // beforeGetBody
            this.ee.once('beforeGetBody', function () {

                debug.compose.trace('beforeGetBody');

                left.each(function (tuple) { that.doAfterAdd(left, tuple); });

                right.each(function (tuple) { that.doAfterAdd(right, tuple);});

            });

            left.ee.on('afterAdd', function(tuple){

                that.doAfterAdd(left, tuple);

            });

            right.ee.on('afterAdd', function(tuple){

                that.doAfterAdd(right, tuple);

            });

            left.ee.on('afterRemove', function(tuple, index){

                that.doAfterRemove(left, tuple);

            });

            right.ee.on('afterRemove', function(tuple, index){

                that.doAfterRemove(right, tuple);

            });

            left.ee.on('afterUpdate', function(tuple, attributeName, value){

                that.doAfterUpdate(left, tuple, attributeName, value);

            });

            right.ee.on('afterUpdate', function(tuple, attributeName, value){

                that.doAfterUpdate(right, tuple, attributeName, value);

            });

        },

        /**
         * Event handler when tuples are added to the base relations
         * @param {Relation} relation relation in which the tuple was added
         * @param {Tuple} tuple1 the tuple that was added
         */
        doAfterAdd : function(relation, tuple1){

            var that = this;

            var otherRelation = (relation === that.args.left ? that.args.right : that.args.left);

            otherRelation.each(function(tuple2){

                var match = Tuple.matchOnAttributes(tuple1, tuple2, that.commonAttributes);

                if(match){

                    var combinedTuple = _.extend({}, tuple1.attributes, tuple2.attributes);

                    var newTuple = new Tuple();

                    that.header().each(function(composeAttribute){

                        var composeAttributeName = composeAttribute.name;

                        newTuple.set(composeAttributeName, combinedTuple[composeAttributeName])

                    });

                    that.add(newTuple);

                }

            })

        },


        /**
         * Event handler when tuples are removed from the base relations.
         * @param {Relation} relation Relation in which the tuple was removed
         * @param {Tuple} removedTuple The tuple that was removed
         */
        doAfterRemove : function(relation, removedTuple){

            var that = this;

            var nonCommonAttributes = (relation === that.args.left ? that.leftAttributes : that.rightAttributes);

            // Find tuples which match the removed tuple on its attributes

            that.each(function(tuple, index){

                var match = Tuple.matchOnAttributes(tuple, removedTuple, nonCommonAttributes);

                if(match){

                    that.removeAt(index);

                }

            });

        },

        /**
         * Event handler when tuples are updated in the base relations
         * @param {Relation} relation The relation where the tuple was updated
         * @param {Tuple} tuple The tuple that was updated
         * @param {String} attributeName The name of the attribute that was updated
         * @param {*} value The new value of the attribute
         */
        doAfterUpdate : function(relation, tuple, attributeName, value, oldValue){

            var that = this;

            var otherRelation = (relation === that.args.left ? that.args.right : that.args.left);

            var result = this.args.left.compose(this.args.right);

            that.adjustTo(result);

        }

    }, {

        type : 'Composition'

    });

module.exports = Composition;
},{"./../Header.js":6,"./../Relation.js":9,"./../Tuple.js":11,"./../helpers/debug":84,"lodash":105}],14:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');

var Difference = Relation.extend(


    {

        /**
         * @class Operators.Difference
         * @extends Relation
         * @param {Relation} left The relation from which to remove the tuples
         * @param {Relation} right The relation that will be substracted from the other
         *
         * The Difference operation gives the first relation's tuples minus those that are in the second relation.
         *
         *     var left = new affinity.Relation([
         *              {a: { type: affinity.Integer}},
         *              {b: { type: affinity.Integer}},
         *              {c: { type: affinity.Integer}}
         *          ],[
         *              [1, 2, 3],
         *              [4, 5, 6],
         *              [7, 8, 9]
         *          ]);

         *     var right = new affinity.Relation([
         *              {a: { type: affinity.Integer}},
         *              {b: { type: affinity.Integer}},
         *              {c: { type: affinity.Integer}}
         *          ], [
         *              [1, 2, 3]
         *          ]);
         *
         *     var rel3 = left.difference(right);
         *
         *     // or
         *
         *     var rel4 = new affinity.Difference(left, right)
         *
         *     // +--------------+--------------+--------------+
         *     // | a : TInteger | b : TInteger | c : TInteger |
         *     // +==============+==============+==============+
         *     // | 4            | 5            | 6            |
         *     // +--------------+--------------+--------------+
         *     // | 7            | 8            | 9            |
         *     // +--------------+--------------+--------------+
         */
        constructor: function (left, right) {

            debug.difference.trace('#constructor');

            /**
             * @property {Object} args
             */
            this.args = {};

            /**
             * @property {Relation} left
             */
            this.args.left = left;

            /**
             * @property {Relation} right
             */
            this.args.right = right;

            /**
             * @property {Relation[]} relations
             */
            this.args.relations = [left, right];

            /**
             * @property {Boolean} computed
             */
            this.computed = false;

            // Calls the parent constructor
            Relation.call(this);

        },

        /**
         * @private
         */
        bindEvents: function () {

            debug.difference.trace('#bindEvents');

            Difference.__super__.bindEvents.call(this);

            var that = this;

            var left = that.args.left;
            var right = that.args.right;

            // BeforeGetHeader
            this.ee.once('beforeGetHeader', function () {

                var leftHeader = left.header();
                var rightHeader = right.header();

                debug.difference.trace('beforeGetHeader');

                Header.assertUnionCompatible(leftHeader, rightHeader);

                that.header().copy(leftHeader);

            });


            // BeforeGetBody
            this.ee.once('beforeGetBody', function () {

                debug.difference.trace('beforeGetBody');

                left.each(function (tuple1) {

                    if (right.index(tuple1) === null) {

                        that.add(tuple1.clone(), false);

                    }

                });

                that.computed = true;

            });

            left.ee.on('afterAdd', function(tuple, index){
                that.afterLeftAdd(left, tuple);
            });

            right.ee.on('afterAdd', function(tuple, index){
                that.afterRightAdd(left, tuple);
            });

            left.ee.on('afterRemove', function(tuple, index){
                that.afterLeftRemove(right, tuple);
            });

            right.ee.on('afterRemove', function(tuple, index){
                that.afterRightRemove(right, tuple);
            });

            left.ee.on('afterUpdate', function(tuple, attributeName, value, oldValue){
                that.afterLeftUpdate(left, tuple, attributeName, value, oldValue);
            });

            right.ee.on('afterUpdate', function(tuple, attributeName, value, oldValue){
                that.afterRightUpdate(right, tuple, attributeName, value, oldValue);
            });

        },

        /**
         * Event triggered when tuples are removed from the left relation
         * @param {Relation} relation
         * @param {Tuple} removedTuple
         * @private
         */
        afterLeftRemove : function(relation, removedTuple){

            // If the tuple is not present in the right relation,
            // remove it
            if(this.computed && this.args.right.index(removedTuple) === null){
                this.remove(removedTuple);
            }

        },

        /**
         * Event triggered when tuples are removed from the right relation
         * @param {Relation} relation
         * @param {Tuple} removedTuple
         * @private
         */
        afterRightRemove : function(relation, removedTuple){

            // If the tuple is present in the left relation,
            // add it.
            if(this.computed && this.args.left.index(removedTuple) !== null){
                this.add(removedTuple.clone());
            }

        },

        /**
         * Event triggered when tuples are added to the left base relation
         * @param {Relation} relation
         * @param {Tuple} addedTuple
         * @private
         */
        afterLeftAdd : function(relation, addedTuple){

            // If the tuple is not in the right
            // relation, add it.
            if(this.computed && this.args.right.index(addedTuple) === null){

                this.add(addedTuple.clone());

            }

        },

        /**
         * Event triggered when tuples are added to the right base relation
         * @param {Relation} relation
         * @param {Tuple} addedTuple
         * @private
         */
        afterRightAdd : function(relation, addedTuple){

            // If the tuple is present in the left
            // relation, remove it.
            if(this.computed && this.args.left.index(addedTuple) !== null){

                this.remove(addedTuple);

            }

        },

        /**
         * Event triggered when tuples are updated on the left relation
         * @param {Relation}relation
         * @param {Tuple} tuple
         * @param {String} attributeName
         * @param {*} value
         * @param {*} oldValue
         * @private
         */
        afterLeftUpdate : function(relation, tuple, attributeName, value, oldValue){

            if(this.computed){

                var oldRightIndex, rightIndex, oldTuple;

                oldTuple = tuple.clone();

                oldTuple.attributes[attributeName] = oldValue;

                oldRightIndex = this.args.right.index(oldTuple);
                rightIndex = this.args.right.index(tuple);

                if(oldRightIndex === null && rightIndex === null){

                    this.find(oldTuple).set(attributeName, value);

                } else if (oldRightIndex === null && rightIndex !== null){

                    this.remove(oldTuple);

                } else if (oldRightIndex !== null && rightIndex === null){

                    this.add(tuple.clone());

                }

            }


        },

        /**
         * Event triggered when tuples are updated on the right relation
         * @param {Relation}relation
         * @param {Tuple} tuple
         * @param {String} attributeName
         * @param {*} value
         * @param {*} oldValue
         * @private
         */
        afterRightUpdate : function(relation, tuple, attributeName, value, oldValue){

            if(this.computed){

                var oldLeftIndex, leftIndex, oldTuple;

                oldTuple = tuple.clone();

                oldTuple.attributes[attributeName] = oldValue;

                oldLeftIndex = this.args.left.index(oldTuple);
                leftIndex = this.args.left.index(tuple);

                if (oldLeftIndex === null && leftIndex !== null){

                    this.remove(tuple);

                } else if (oldLeftIndex !== null && leftIndex !== null){

                    this.add(oldTuple);

                    this.remove(tuple);

                } else if (oldLeftIndex !== null && leftIndex === null){

                    this.add(oldTuple);

                }
            }
        }

    }, {

        type : 'Difference'

    });

module.exports = Difference;
},{"./../Header.js":6,"./../Relation.js":9,"./../helpers/debug":84,"lodash":105}],15:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var Attribute = require('./../Attribute.js');
var Tuple = require('./../Tuple.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');

var Extend = Relation.extend(
    {

        constructor: function (relation, expressions) {
            /**
             * @class Operators.Extension
             * @extends Relation
             * @param {Relation} relation T{he relation from which to remove the tuples
             * @param {Object[]} expressions The arguments from which to calculate the new attribute value.
             *
             * The Extend operation allows the addition of calculated {@link Header} {@link Attribute}s
             *
             *     var relationA = new affinity.Relation([
             *              {name: { type: affinity.String}},
             *              {born: { type: affinity.Integer}},
             *              {died: { type: affinity.Integer}}
             *          ],[
             *              ['Aristotle', -384, -322],
             *              ['Plato',     -428, -348],
             *              ['Socrates',  -470, -399]
             *          ]);
             *
             *     var born = relationA.get('born');
             *     var died = relationA.get('died');
             *
             *     var relationB = relationA.extend([{ lived : died.minus(born) }]);
             *
             *     //or
             *
             *     // LIVED = DIED - BORN
             *
             *     var relationB = new affinity.Extend(relationA, [{ lived : died.minus(born) }]);
             *
             *     //                                                       <-EXTENDED ATTR-->
             *     // +----------------+-----------------+-----------------+------------------+
             *     // | name : TString | born : TInteger | died : TInteger | lived : TInteger |
             *     // +================+=================+=================+==================+
             *     // | Aristotle      | -384            | -322            | 62               |
             *     // +----------------+-----------------+-----------------+------------------+
             *     // | Plato          | -428            | -348            | 80               |
             *     // +----------------+-----------------+-----------------+------------------+
             *     // | Socrates       | -470            | -399            | 71               |
             *     // +----------------+-----------------+-----------------+------------------+
             *     //
             *
             *     // Possible to add multiple attributes in one call :
             *
             *     // LIVED = DIED - BORN, SINCE = YEAR(NOW())-DIED
             *
             *     var relationB = new affinity.Extend(relationA, [
             *          { lived : died.minus(born) },
             *          { since: affinity.year(affinity.now()).minus(died) }
             *     ]);
             *
             *     //                                                       <-EXTENDED ATTR--> <-EXTENDED ATTR-->
             *     // +----------------+-----------------+-----------------+------------------+------------------+
             *     // | name : TString | born : TInteger | died : TInteger | lived : TInteger | since : TInteger |
             *     // +================+=================+=================+==================+==================+
             *     // | Aristotle      | -384            | -322            | 62               | 2335             |
             *     // +----------------+-----------------+-----------------+------------------+------------------+
             *     // | Plato          | -428            | -348            | 80               | 2362             |
             *     // +----------------+-----------------+-----------------+------------------+------------------+
             *     // | Socrates       | -470            | -399            | 71               | 2413             |
             *     // +----------------+-----------------+-----------------+------------------+------------------+
             *     //
             *
             *     // Possible to have custom defined functions
             *     // Beware though to return the right data type (divisions by zero, tan(/2), ...)
             *
             *     // You may as well use this feature, but since affinity will later be a SQL parser too,
             *     // it will obviously not support the translation of custom defined functions into SQL code.
             *     // If you plan have use of affinity's future SQL parser, beware that these custom functions
             *     // will only run in javascript, because we need the AST so we can convert it to SQL.
             *
             *     // I would have loved javascript to support overloading of operators, but that won't
             *     // happen anytime soon.
             *
             *     var relationB = relation.extend([
             *
             *          {'lived' : {function(tuple){
             *              return tuple.get('died')-tuple.get('born');
             *          }, type : affinity.Integer},
             *
             *          {'died' : {function(tuple){
             *              return 2014 - tuple.get('died')
             *          }, type : affinity.Integer},
             *
             *     ]);
             *
             */

            debug.extend.trace('#constructor');

            /*
            * @property {Object} args
            * @property {Relation} args.relation
            * @property {Array} args.expressions
            */

            this.args = {};

            this.args.relation = relation;

            this.args.expressions = expressions;

            // Coerce the argument to an array if it is not already

            if (!_.isArray(this.args.expressions)) {
                this.args.expressions = [this.args.expressions];
            }

            // Throw an error if the expression array is of length 0
            if (this.args.expressions.length === 0) {
                throw new Error('You must define expressions!');
            }

            Relation.call(this);

        },

        bindEvents: function () {

            debug.extend.trace('#bindEvents');

            // Calling the parent bindEvents
            Extend.__super__.bindEvents.call(this);

            var that = this;

            var expressions = that.args.expressions;

            var relation = that.args.relation;

            /// BeforeGetHeader

            this.ee.once('beforeGetHeader', function () {

                debug.extend.trace('beforeGetHeader');

                // Add the attributes of the base relation

                that.header().copy(relation.header());

                /// Parse extension attributes

                _.forOwn(expressions, function (expression, key) {

                    // Expression must be an object
                    if (!_.isObject(expression)) {
                        throw new TypeError('Wrong expression format')
                    }

                    var keys = Object.keys(expression);

                    // Expression must have only one parameter
                    if (keys.length !== 1) {
                        throw new SyntaxError('Unhandled expression declaration');
                    }

                    // This is the name of the attribute to add
                    var extensionName = keys[0];

                    // This is the expression
                    var extensionParam = expression[extensionName];


                    var type;

                    // Check if the param is only an Attribute
                    if(extensionParam instanceof Attribute){

                        // Return the same type as the attribute
                        type = extensionParam.type;

                        // Convert the attribute to TupleAttribute
                        expressions[key][extensionName] = extensionParam = new (require('./../functions/tuple/Attribute'))(extensionParam.name);


                    } else {

                        // Convert the attributes objects to functions that iterate through tuples
                        extensionParam.convertAttributeToTuple();

                        // Get the return type of the expression
                        type = extensionParam.type();

                    }

                    // Key must not already exist in the current header
                    if (that.header().get(extensionName) !== null) {
                        throw new Error('Relation extension name already exists in the header');
                    }

                    // Create the new header attribute
                    var extensionAttribute = new Attribute({type: type, name: extensionName});

                    // The attribute is a calculated attribute
                    extensionAttribute.calculated(true);

                    // Add the attribute in the header
                    that.header().add(extensionAttribute);

                })

            });


            /// BeforeGetBody

            this.ee.once('beforeGetBody', function () {

                debug.extend.trace('beforeGetBody');

                relation.each(function (tuple) {

                    that.afterAdd(relation, tuple);

                })

            });

            relation.ee.on('afterAdd', function(tuple, index){
                that.afterAdd(that.args.relation, tuple);
            });

            relation.ee.on('afterRemove', function(tuple, index){
                that.afterRemove(that.args.relation, tuple);
            });

            relation.ee.on('afterUpdate', function(tuple, attributeName, value, oldValue){
                that.afterUpdate(that.args.relation, tuple, attributeName, value, oldValue);
            });

        },

        /**
         * Calculates the extend expressions values for a tuple
         * @param {Tuple} tuple The tuple to calculate expressions against
         * @param {Boolean} clone either to return a new instance of the tuple, or the passed instance
         * @returns {Tuple} The built tuple
         */
        buildTuple : function(tuple, clone){

            if (_.isBoolean(clone)){
                // clone = clone;
            } else {
                clone = true;
            }

            var that = this,
                newTuple;

            if (clone){

                // Create the tuple we are going to add
                newTuple = new Tuple();

                // Copy the attributes from the base tuple
                newTuple.copy(tuple);

            } else {

                newTuple = tuple;

            }

            _.forEach(that.args.expressions, function (expression) {

                // This is the new attribute name
                var attributeName = Object.keys(expression)[0];

                // This is the evaluation expression
                var attributeExpression = expression[attributeName];

                attributeExpression.assignTuple(newTuple);

                // This is the new value
                var expressionValue = attributeExpression.value();

                // Let's set the new value in the tuple
                newTuple.set(attributeName, expressionValue);

            });

            return newTuple;
        },

        afterAdd : function(relation, addedTuple){

            var that = this;

            that.add(that.buildTuple(addedTuple));

        },

        afterRemove : function(relation, tuple, index){

            var myTuple = this.buildTuple(tuple);

            this.remove(myTuple);
        },

        afterUpdate : function(relation, tuple, attributeName, value, oldValue){

            var that = this;

            var tupleClone = tuple.clone();

            tupleClone.set(attributeName, oldValue);

            tupleClone = that.buildTuple(tupleClone);

            var myTuple =  that.find(tupleClone);

            myTuple = that.find(myTuple);

            myTuple.set(attributeName, value);

            that.buildTuple(myTuple, false);

        }

    }, {

        type : 'Extension'

    });

module.exports = Extend;
},{"./../Attribute.js":2,"./../Header.js":6,"./../Relation.js":9,"./../Tuple.js":11,"./../functions/tuple/Attribute":80,"./../helpers/debug":84,"lodash":105}],16:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var Tuple = require('./../Tuple.js');
var Attribute = require('./../Attribute.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');




var Group = Relation.extend(

    {

        /**
         * @class Operators.Group
         * @extends Relation
         * @param {Relation} relation The relation to group
         * @param {String} attributeName The new grouped attribute name
         * @param {String[]} attributes The attributes to group
         *
         * The Group operation will group the specified tuple's attributes into one.
         * The resulting tuples will have an {@link Attribute} whose {@link Type} will be a {@link Relation}. See example.
         *
         *     var relationA = new affinity.Relation([
         *              {a: { type: affinity.Integer}},
         *              {b: { type: affinity.Integer}},
         *              {c: { type: affinity.Integer}}
         *          ],[
         *              [1, 2, 3],
         *              [4, 5, 6],
         *              [4, 9, 9],
         *              [7, 8, 9]
         *          ]);
         *
         *     var relationB = relationA.group('groupedAttribute', ['b', 'c'])
         *
         *     //or
         *
         *     var relationB = new affinity.Group(relationA, 'groupedAttribute', ['b','c'])
         *
         *     //                 <----GROUPING ATTRIBUTE---------->
         *     // +--------------+---------------------------------+
         *     // | a : TInteger | groupedAttribute : Relation     |
         *     // +==============+=================================+
         *     // | 1            | +--------------+--------------+ |
         *     // |              | | b : TInteger | c : TInteger | |
         *     // |              | +==============+==============+ |
         *     // |              | | 2            | 3            | |
         *     // |              | +--------------+--------------+ |
         *     // +--------------+---------------------------------+
         *     // | 4            | +--------------+--------------+ |
         *     // |              | | b : TInteger | c : TInteger | |
         *     // |              | +==============+==============+ |
         *     // |              | | 5            | 6            | |
         *     // |              | +--------------+--------------+ |
         *     // |              | | 9            | 9            | |
         *     // |              | +--------------+--------------+ |
         *     // +--------------+---------------------------------+
         *     // | 7            | +--------------+--------------+ |
         *     // |              | | b : TInteger | c : TInteger | |
         *     // |              | +==============+==============+ |
         *     // |              | | 8            | 9            | |
         *     // |              | +--------------+--------------+ |
         *     // +--------------+---------------------------------+
         */
        constructor: function (relation, attributeName, attributes) {

            /**
             * @property {Object} args
             * @property {Relation} args.relation
             * @property {String} args.groupingAttributeName
             * @property {String[]} args.groupedAttributeNames
             * @property {Attribute[]} args.groupedAttributes
             * @property {Attribute} args.groupingAttribute
             */

            debug.group.trace('#constructor');

            this.args = {};

            this.args.relation = relation;

            this.args.groupingAttributeName = attributeName;

            this.args.groupedAttributeNames = attributes;

            this.args.groupedAttributes = [];

            this.args.groupingAttribute = null;

            // Calling the parent constructor
            Relation.call(this);

        },

        bindEvents: function () {

            debug.group.trace('#bindEvents');

            // Calling the parent bindEvents
            Group.__super__.bindEvents.call(this);

            var that = this,
                groupedAttributeNames = this.args.groupedAttributeNames,
                groupingAttributeName = this.args.groupingAttributeName,
                relation = this.args.relation,
                groupedAttributes = that.args.groupedAttributes;

            // BeforeGetHeader
            that.ee.once('beforeGetHeader', function () {

                // We want to have this kind of relation
                //
                // +----------------+----------------+-------------------------------------+
                // | attr3 : <type> | attr4 : <type> | groupedAttr : Relation              |
                // +================+================+=====================================+
                //
                // Where attr3 and attr4 are non grouped attributes
                // and groupedAttr will contain the grouped attributes relations
                //

                var header = relation.header();

                debug.group.trace('beforeGetHeader');

                // Check that the attributes specified in groupedAttributeNames exists in the base header
                _.forEach(groupedAttributeNames, function(groupedAttributeName){
                    if(header.get(groupedAttributeName) === null){
                        throw new Error('Attribute with name "'+groupedAttributeName+'" does not exist in the header')
                    }
                });

                // Loop through each of the relation's header attributes
                header.each(function(attribute){

                    // Check if the attribute is part of the grouped attributes

                    var present = _.any(groupedAttributeNames, function(groupedAttributeName){
                        return groupedAttributeName === attribute.name;
                    });

                    if(!present){
                        // If it is not present, add it to the header.
                        that.header().add(attribute.clone());
                    } else {
                        // If it is present, store it in the groupedAttributeNames array
                        groupedAttributes.push(attribute);
                    }

                });

                // Let's create the groupingAttributeName and add it to the header

                that.args.groupingAttribute = new Attribute({name : groupingAttributeName, type : Relation});

                that.header().add(that.args.groupingAttribute);

            });


            // BeforeGetBody
            that.ee.once('beforeGetBody', function () {

                debug.group.trace('beforeGetBody');


                // Make sure the header is computed

                that.header();


                // Let's loop through each of the relation's tuples

                relation.each(function(tuple){

                    // This variable will store the tuple grouped attribute values
                    var groupedAttributeValues = {};

                    // This variable will store the tuple non-grouped attribute values
                    var nonGroupedAttributeValues = {};

                    // Now, we will build these variables

                    // Let's loop through each of the tuple's attribute values
                    tuple.each(function(value, key){

                        // Check if the current tuple attribute is grouped or not grouped
                        var grouped = _.any(that.args.groupedAttributes, function(groupedAttribute){
                            return key === groupedAttribute.name;
                        });

                        if(grouped){

                            // Tuple attribute is part of the grouped attributes

                            groupedAttributeValues[key] = value;

                        } else {

                            // Tuple attribute is not part of the grouped attributes

                            nonGroupedAttributeValues[key] = value;

                        }

                    });


                    // The groupedAttributeValues and nonGroupedAttributeValues are now built
                    //
                    // We started with a tuple like
                    // { attr1 : value, attr2 : value, attr3: value, attr4 : value}
                    //
                    // We grouped 'attr1' and 'attr2'
                    //
                    // And we simply divided the tuples into two objects, one containing the attribute values
                    // that are supposed to be grouped, and another that is not supposed to be grouped
                    //
                    // They should look somewhat like :
                    // groupedAttributeValues : { attr1 : value, attr2 : value, ... }
                    // nonGroupedAttributeValues : { attr3 : value, attr4 : value, ...}


                    // If two tuples have the same non grouped attribute values, what we will do
                    // is merge their nonGroupedAttributeValues into a "nested relation", meaning
                    // that we will have a relation that will contain relations.


                    // Let's loop through each tuple of the being-built relation
                    // and see if a tuple already exists with the same nonGroupedAttributeValues


                    var matchingTuple = null;

                    that.each(function(tuple){

                        var match = true;

                        _.forOwn(nonGroupedAttributeValues, function(value, key){

                            if(tuple.get(key) !== value){

                                match = false;
                                return false;

                            }

                        });

                        if(match){
                            matchingTuple = tuple;
                            return false;
                        }

                    });


                    if (matchingTuple === null){

                        // A tuple with the same non grouped attribute values has not been found.
                        // We will create it and create the nested relation too.

                        var newTuple = new Tuple(nonGroupedAttributeValues);


                        // This tuple should look like
                        // +----------------+----------------+
                        // | attr3 : <type> | attr4 : <type> |
                        // +================+================+
                        // | value          | value          |
                        // +----------------+----------------+


                        // Creating the relation

                        var newRelation = new Relation();


                        // Adding the grouped attributes to the new nested relation header

                        _.forOwn(groupedAttributes, function(attribute){

                            newRelation.header().add(attribute.clone());

                        });

                        // We will store the relation header in the root relation header attribute
                        // So that we will know what kind of relation this is without having to access
                        // the body

                        that.args.groupingAttribute.relationHeader = newRelation.header().clone();

                        // This relation should look like
                        // +----------------+----------------+
                        // | attr1 : <type> | attr2 : <type> |
                        // +================+================+


                        // Setting the relation in the tuple grouped attribute

                        newTuple.set(groupingAttributeName, newRelation);

                        // The tuple will now be
                        // +----------------+----------------+-------------------------------------+
                        // | attr3 : <type> | attr4 : <type> | groupedAttr : Relation              |
                        // +================+================+=====================================+
                        // | value          | value          | +----------------+----------------+ |
                        // |                |                | | attr1 : <type> | attr2 : <type> | |
                        // |                |                | +================+================+ |
                        // +----------------+----------------+-------------------------------------+



                        // Adding the tuple to the relation

                        that.add(newTuple, false);


                        // A matching tuple now exists because we just created it

                        matchingTuple = newTuple;

                    }

                    // We create the tuple that will be inserted in the nested relation

                    var nestedTuple = new Tuple(groupedAttributeValues);

                    // We add this tuple to the nested relation

                    matchingTuple.get(groupingAttributeName).add(nestedTuple, false);

                    // And voil!

                });


            });

            // Binds the base relation afterAdd event
            that.args.relation.ee.on('afterAdd', function(tuple, index){
                that.afterAdd(relation, tuple);
            });

            // Binds the base relation afterRemove event
            that.args.relation.ee.on('afterRemove', function(tuple, index){
                that.afterRemove(relation, tuple);
            });

            // Binds the base relation afterUpdate event
            that.args.relation.ee.on('afterUpdate', function(tuple, attributeName, value, oldValue){
                that.afterUpdate(relation, tuple, attributeName, value, oldValue);
            });

        },

        /**
         * Event handler when a tuple has been added to the base relation
         * @param {Relation} relation
         * @param {Tuple} tuple
         */
        afterAdd : function(relation, tuple){
            debug.group.trace('Group#afterAdd');
            var result = this.args.relation.group(this.args.groupingAttributeName, this.args.groupedAttributeNames);
            this.adjustTo(result);
        },

        /**
         * Event handler when a tuple has been removed from the base relation
         * @param {Relation} relation
         * @param {Tuple} tuple
         */
        afterRemove : function(relation, tuple){
            debug.group.trace('Group#afterRemove');
            var result = this.args.relation.group(this.args.groupingAttributeName, this.args.groupedAttributeNames);
            this.adjustTo(result);
        },

        /**
         * Event handler when a tuple has been updated from the base relation
         * @param {Relation} relation
         * @param {Tuple} tuple
         * @param {String} attributeName
         * @param {*} value
         * @param {*} oldValue
         */
        afterUpdate : function(relation, tuple, attributeName, value, oldValue){
            debug.group.trace('Group#afterUpdate');
            var result = this.args.relation.group(this.args.groupingAttributeName, this.args.groupedAttributeNames);
            this.adjustTo(result);
        }

    }, {

        type : 'Group'

    });

module.exports = Group;
},{"./../Attribute.js":2,"./../Header.js":6,"./../Relation.js":9,"./../Tuple.js":11,"./../helpers/debug":84,"lodash":105}],17:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');


var Intersection = Relation.extend(

    {

        /**
         * @class Operators.Intersection
         * @param {Relation} relationA
         * @param {Relation} relationB
         * @extends Relation
         *
         * The intersection creates a new relation with tuples common in relationA and relationB
         *
         *     var rel1 = new affinity.Relation([
         *           {a: { type: affinity.Integer}},
         *           {b: { type: affinity.Integer}},
         *           {c: { type: affinity.Integer}}
         *       ], [
         *           [1, 2, 3],
         *           [4, 5, 6],
         *           [7, 8, 9]
         *       ]);
         *
         *     var rel2 = new affinity.Relation([
         *          {a: { type: affinity.Integer}},
         *          {b: { type: affinity.Integer}},
         *          {c: { type: affinity.Integer}}
         *      ], [
         *          [1, 2, 3]
         *      ]);
         *
         *v    ar rel3 = new affinity.Intersection(rel1, rel2);
         *
         *     // +--------------+--------------+--------------+
         *     // | a : TInteger | b : TInteger | c : TInteger |
         *     // +==============+==============+==============+
         *     // | 1            | 2            | 3            |
         *     // +--------------+--------------+--------------+
         */

        constructor: function (relationA, relationB) {

            this.rels = [relationA, relationB];

            Relation.call(this);

        },

        bindEvents: function () {

            debug.intersection.trace('#bindEvents');

            Intersection.__super__.bindEvents.call(this);

            var that = this;

            var rel1 = that.rels[0],
                rel2 = that.rels[1];


            // BeforeGetHeader

            this.ee.once('beforeGetHeader', function () {

                var header1 = rel1.header();
                var header2 = rel2.header();

                debug.intersection.trace('beforeGetHeader');

                Header.assertUnionCompatible(header1, header2);

                that.header().copy(header1);

            });


            // BeforeGetBody

            this.ee.once('beforeGetBody', function () {

                debug.intersection.trace('beforeGetBody');

                rel1.each(function (tuple1) {

                    if (rel2.index(tuple1) !== null) {
                        that.add(tuple1.clone(), false);
                    }

                })

            });

        },

        afterLeftAdd : function(relation, tuple){

        },

        afterLeftRemove : function(relation, tuple){

        },

        afterLeftUpdate : function(relation, tuple, attributeName, value, oldValue){

        },

        afterRightAdd : function(relation, tuple){

        },

        afterRightRemove : function(relation, tuple){

        },

        afterRightUpdate : function(relation, tuple, attributeName, value, oldValue){

        }

    }, {

        type : 'Intersection'

    });

module.exports = Intersection;
},{"./../Header.js":6,"./../Relation.js":9,"./../helpers/debug":84,"lodash":105}],18:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var Tuple = require('./../Tuple.js');
var debug = require('./../helpers/debug');

var _ = require('lodash');



var Join = Relation.extend(

    {

        /**
         * @class Operators.Join
         * @param {Relation} relationA
         * @param {Relation} relationB
         * @extends Relation
         *
         * The Join operation returns all possible combinations of tuples from relationA and relationB where
         * the tuples have the same value for their common attributes.
         *
         *     var relationA = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {firstName: { type: affinity.String}},
         *              {lastName: { type: affinity.String}}
         *          ],[
         *              [1, 'John', 'Doe'],
         *              [2, 'Mary', 'Poppins'],
         *              [3, 'Lucky', 'Luke']
         *          ]);
         *
         *     var relationB = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {fan: { type: affinity.String}}
         *          ],[
         *              [1, 'Mr X'],
         *              [1, 'Miss Dibble'],
         *              [2, 'Nat Bibble']
         *          ]);
         *
         *     var relationC = relationA.join(relationB);
         *
         *     // or
         *
         *     var relationC = new affinity.Join(relationA, relationB)
         *
         *     // <---COMMON ATTRIBUTE---->
         *     // +------------------------+---------------------+--------------------+---------------+
         *     // | characterId : TInteger | firstName : TString | lastName : TString | fan : TString |
         *     // +========================+=====================+====================+===============+
         *     // | 1                      | John                | Doe                | Mr X          |
         *     // +------------------------+---------------------+--------------------+---------------+
         *     // | 2                      | John                | Doe                | Miss Dibble   |
         *     // +------------------------+---------------------+--------------------+---------------+
         *     // | 3                      | Mary                | Poppins            | Nat Bibble    |
         *     // +------------------------+---------------------+--------------------+---------------+
         *     //
         *
         */
        constructor: function (relationA, relationB) {

            this.rels = [relationA, relationB];
            this._commonAttributes = [];

            Relation.call(this);

            var that = this;

        },

        bindEvents: function () {

            debug.join.trace('#bindEvents');

            Join.__super__.bindEvents.call(this);

            var that = this;

            var rel1 = that.rels[0];
            var rel2 = that.rels[1];

            // BeforeGetHeader

            this.ee.once('beforeGetHeader', function () {

                debug.join.trace('beforeGetHeader');

                var header1 = rel1.header();
                var header2 = rel2.header();

                Header.assertSameNameSameType(header1, header2);

                that.commonAttributes = Header.commonAttributes(header1, header2);

                that.header().copy(header1);
                that.header().copy(header2);

            });


            // BeforeGetBody

            this.ee.once('beforeGetBody', function () {

                that.header();

                debug.join.trace('beforeGetBody');

                // Loop through each body of the first relation
                rel1.each(function (tuple1) {

                    // Loop through each tuples of the second relation
                    rel2.each(function (tuple2) {

                        var match = Tuple.matchOnAttributes(tuple1, tuple2, that.commonAttributes);

                        // If a match was detected
                        if (match) {

                            // Clone the first tuple
                            var newTuple = new Tuple();

                            // Copy the joined tuple attributes
                            newTuple.copy(tuple1);
                            newTuple.copy(tuple2);

                            // Then add it to the relation
                            that.add(newTuple, false);
                        }

                    }, that);

                }, that)

            });

            that.rels[0].ee.on('afterAdd', function(tuple, index){
                that.afterLeftAdd(that.rels[0], tuple, index);
            });

            that.rels[1].ee.on('afterAdd', function(tuple, index){
                that.afterRightAdd(that.rels[1], tuple, index);
            });

            that.rels[0].ee.on('afterRemove', function(tuple, index){
                that.afterLeftRemove(that.rels[0], tuple, index);
            });

            that.rels[1].ee.on('afterRemove', function(tuple, index){
                that.afterRightRemove(that.rels[0], tuple, index);
            });

            that.rels[0].ee.on('afterUpdate', function(tuple, attributeName, value, oldValue){
                that.afterLeftUpdate(that.rels[0], tuple, attributeName, value, oldValue);
            });

            that.rels[1].ee.on('afterUpdate', function(tuple, attributeName, value, oldValue){
                that.afterLeftUpdate(that.rels[0], tuple, attributeName, value, oldValue);
            });


        },

        afterLeftAdd : function(relation, tuple){
            debug.group.trace('Join#afterLeftAdd');
            var result = this.rels[0].join(this.rels[1]);
            this.adjustTo(result);
        },

        afterLeftRemove : function(relation, tuple){
            debug.group.trace('Join#afterLeftRemove');
            var result = this.rels[0].join(this.rels[1]);
            this.adjustTo(result);
        },

        afterLeftUpdate : function(relation, tuple, attributeName, value, oldValue){
            debug.group.trace('Join#afterLeftUpdate');
            var result = this.rels[0].join(this.rels[1]);
            this.adjustTo(result);
        },

        afterRightAdd : function(relation, tuple){
            debug.group.trace('Join#afterRightAdd');
            var result = this.rels[0].join(this.rels[1]);
            this.adjustTo(result);
        },

        afterRightRemove : function(relation, tuple){
            debug.group.trace('Join#afterRightRemove');
            var result = this.rels[0].join(this.rels[1]);
            this.adjustTo(result);
        },

        afterRightUpdate : function(relation, tuple, attributeName, value, oldValue){
            debug.group.trace('Join#afterRightUpdate');
            var result = this.rels[0].join(this.rels[1]);
            this.adjustTo(result);
        }

    }, {

        type : 'Join'

    });

module.exports = Join;
},{"./../Header.js":6,"./../Relation.js":9,"./../Tuple.js":11,"./../helpers/debug":84,"lodash":105}],19:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var Tuple = require('./../Tuple.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');



var Product = Relation.extend(

    {

        /**
         * @class Operators.Product
         * @param {Relation} relationA
         * @param {Relation} relationB
         * @extends Relation
         *
         * Example :
         *
         *     var relationA = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {firstName: { type: affinity.String}},
         *              {lastName: { type: affinity.String}}
         *          ],[
         *              [1, 'John', 'Doe'],
         *              [2, 'Mary', 'Poppins'],
         *              [3, 'Lucky', 'Luke']
         *          ]);
         *
         *     var relationB = new affinity.Relation([
         *              {product: { type: affinity.String}}
         *          ],[
         *              ['Doll'],
         *              ['PlayMobile'],
         *          ]);
         *
         *     var relationC = relationA.product(relationB);
         *
         *     // or
         *
         *     var relationC = new affinity.Product(relationA, relationB)
         *
         *     // +------------------------+---------------------+--------------------+-------------------+
         *     // | characterId : TInteger | firstName : TString | lastName : TString | product : TString |
         *     // +========================+=====================+====================+===================+
         *     // | 1                      | John                | Doe                | Doll              |
         *     // +------------------------+---------------------+--------------------+-------------------+
         *     // | 2                      | John                | Doe                | PlayMobile        |
         *     // +------------------------+---------------------+--------------------+-------------------+
         *     // | 1                      | Mary                | Poppins            | Doll              |
         *     // +------------------------+---------------------+--------------------+-------------------+
         *     // | 2                      | Mary                | Poppins            | PlayMobile        |
         *     // +------------------------+---------------------+--------------------+-------------------+
         *     // | 1                      | Lucky               | Luke               | Doll              |
         *     // +------------------------+---------------------+--------------------+-------------------+
         *     // | 2                      | Lucky               | Luke               | PlayMobile        |
         *     // +------------------------+---------------------+--------------------+-------------------+
         *     //
         *
         */
        constructor: function (relationA, relationB) {

            debug.product.trace('#constructor');

            this.rels = [relationA, relationB];

            Relation.call(this);

        },

        bindEvents: function () {

            debug.product.trace('#bindEvents');

            Product.__super__.bindEvents.call(this);

            var that = this;

            var rel1 = this.rels[0];
            var rel2 = this.rels[1];

            // BeforeGetHeader

            that.ee.once('beforeGetHeader', function () {

                debug.product.trace('beforeGetHeader');

                var header1 = rel1.header();
                var header2 = rel2.header();

                // Check that the two relations have disjoint headers
                Header.assertDisjoint(header1, header2);

                that.header().copy(header1.setUnion(header2));

            });


            // BeforeGetBody

            that.ee.once('beforeGetBody', function () {

                debug.product.trace('beforeGetBody');

                var tupleSet = rel1.setProduct(rel2);

                tupleSet.each(function (tuplePair) {

                    var newTuple = new Tuple();

                    newTuple.copy(tuplePair.get('0'));
                    newTuple.copy(tuplePair.get('1'));

                    that.add(newTuple, false);

                }, that);

            });

        },

        afterLeftAdd : function(relation, tuple){

        },

        afterLeftRemove : function(relation, tuple){

        },

        afterLeftUpdate : function(relation, tuple, attributeName, value, oldValue){

        },

        afterRightAdd : function(relation, tuple){

        },

        afterRightRemove : function(relation, tuple){

        },

        afterRightUpdate : function(relation, tuple, attributeName, value, oldValue){

        }

    }, {

        type : 'Product'

    });

module.exports = Product;
},{"./../Header.js":6,"./../Relation.js":9,"./../Tuple.js":11,"./../helpers/debug":84,"lodash":105}],20:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var Tuple = require('./../Tuple.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');



var Projection = Relation.extend(

    {

        /**
         * @class Operators.Projection
         * @param {Relation} relation
         * @param {String[]} args
         * @extends Relation
         *
         * Example :
         *
         *     var relationA = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {firstName: { type: affinity.String}},
         *              {lastName: { type: affinity.String}}
         *          ],[
         *              [1, 'John', 'Doe'],
         *              [2, 'Mary', 'Poppins'],
         *              [3, 'Lucky', 'Luke']
         *          ]);
         *
         *     // +------------------------+---------------------+--------------------+
         *     // | characterId : TInteger | firstName : TString | lastName : TString |
         *     // +========================+=====================+====================+
         *     // | 1                      | John                | Doe                |
         *     // +------------------------+---------------------+--------------------+
         *     // | 2                      | Mary                | Poppins            |
         *     // +------------------------+---------------------+--------------------+
         *     // | 3                      | Lucky               | Luke               |
         *     // +------------------------+---------------------+--------------------+
         *
         *     var relationB = relationA.project(['firstName']);
         *
         *     // or
         *
         *     var relationC = new affinity.Projection(relationA, ['firstName']);
         *
         *     // +---------------------+
         *     // | firstName : TString |
         *     // +=====================+
         *     // | John                |
         *     // +---------------------+
         *     // | Mary                |
         *     // +---------------------+
         *     // | Lucky               |
         *     // +---------------------+
         *
         */
        constructor: function (relation, args) {

            this.rel = relation;
            this.args = args;

            Relation.call(this);

        },

        bindEvents: function () {

            debug.projection.trace('#bindEvents');

            Projection.__super__.bindEvents.call(this);

            var that = this;

            var relation = this.rel;

            that.ee.once('beforeGetBody', function () {

                debug.projection.trace('beforeGetBody');

                relation.each(function (tuple) {

                    var newTuple = new Tuple();

                    newTuple.copy(tuple, that.args);

                    that.add(newTuple);

                }, that)

            });

            that.ee.once('beforeGetHeader', function () {

                debug.projection.trace('beforeGetHeader');

                that.header().copy(relation.header().project(that.args))

            });

            // Binds the base relation afterAdd event
            relation.ee.on('afterAdd', function(tuple, index){
                that.afterAdd(relation, tuple);
            });

            // Binds the base relation afterRemove event
            relation.ee.on('afterRemove', function(tuple, index){
                that.afterRemove(relation, tuple);
            });

            // Binds the base relation afterUpdate event
            relation.ee.on('afterUpdate', function(tuple, attributeName, value, oldValue){
                that.afterUpdate(relation, tuple, attributeName, value, oldValue);
            });

        },

        afterAdd : function(relation, tuple){
            var result = relation.project(this.args);
            debug.group.trace('Projection#afterAdd');
            this.adjustTo(result);
        },

        afterRemove : function(relation, tuple){
            var result = relation.project(this.args);
            debug.group.trace('Projection#afterRemove');
            this.adjustTo(result);
        },

        afterUpdate : function(relation, tuple, attributeName, value, oldValue){
            var result = relation.project(this.args);
            debug.group.trace('Projection#afterUpdate');
            this.adjustTo(result);
        }

    }, {

        type : 'Projection'

    });

module.exports = Projection;
},{"./../Header.js":6,"./../Relation.js":9,"./../Tuple.js":11,"./../helpers/debug":84,"lodash":105}],21:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Tuple = require('./../Tuple.js');
var Set = require('./../Set.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');



var Rename = Relation.extend(

    {

        /**
         * @class Operators.Rename
         * @param {Relation} relation
         * @param {Object} args
         * @extends Relation
         *
         * Example :
         *
         *     var relationA = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {firstName: { type: affinity.String}},
         *              {lastName: { type: affinity.String}}
         *          ],[
         *              [1, 'John', 'Doe'],
         *              [2, 'Mary', 'Poppins'],
         *              [3, 'Lucky', 'Luke']
         *          ]);
         *
         *     var relationB = relationA.rename({'firstName':'familyName'})
         *
         *     // or
         *
         *     var relationC = new affinity.Projection(relationA, {'lastName':'familyName'});
         *
         *     //                                                <--RENAMED ATTRIBUTE--->
         *     // +------------------------+---------------------+----------------------+
         *     // | characterId : TInteger | firstName : TString | familyName : TString |
         *     // +========================+=====================+======================+
         *     // | 1                      | John                | Doe                  |
         *     // +------------------------+---------------------+----------------------+
         *     // | 2                      | Mary                | Poppins              |
         *     // +------------------------+---------------------+----------------------+
         *     // | 3                      | Lucky               | Luke                 |
         *     // +------------------------+---------------------+----------------------+
         */
        constructor: function (relation, args) {

            this.relation = relation;
            this.args = args;

            Relation.call(this);

        },

        bindEvents: function () {

            debug.rename.trace('#bindEvents');

            Rename.__super__.bindEvents.call(this);

            var that = this;

            that.ee.once('beforeGetBody', function () {

                debug.rename.trace('beforeGetBody');

                //var a, b, tupleCount, tuple, tuples, keys, keyCount, key, newName;

                //that._body = new Set({type: Tuple});

                //tuples = that.relation.body();
                //tupleCount = tuples.length;
                //keys = Object.keys(that.args);
                //keyCount = keys.length;

                that.relation.each(function(tuple){

                    var newTuple = tuple.clone();

                    _.forIn(that.args, function(value, key){

                        if(value !== key){
                            newTuple.set(value, newTuple.get(key));
                            delete newTuple.attributes[key];
                        }

                    });

                    that.add(newTuple, false);

                });

            });

            that.ee.once('beforeGetHeader', function () {

                debug.rename.trace('beforeGetHeader');

                that.header().copy(that.relation.header().rename(that.args));

            });

        },

        afterAdd : function(relation, tuple){
            var result = this.relation.rename(this.args);
            this.adjustTo(result);
        },

        afterRemove : function(relation, tuple){
            var result = this.relation.rename(this.args);
            this.adjustTo(result);
        },

        afterUpdate : function(relation, tuple, attributeName, value, oldValue){
            var result = this.relation.rename(this.args);
            this.adjustTo(result);
        }

    }, {



    }, {

        type : 'Rename'

    });

module.exports = Rename;
},{"./../Relation.js":9,"./../Set.js":10,"./../Tuple.js":11,"./../helpers/debug":84,"lodash":105}],22:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');
var Function = require('./../Function.js');



var Restriction = Relation.extend(

    {

        /**
         * @class Operators.Restriction
         * @param {Relation} relation
         * @param {Function} predicate
         * @extends Relation
         *
         * Example :
         *
         *     var relationA = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {firstName: { type: affinity.String}},
         *              {lastName: { type: affinity.String}}
         *          ],[
         *              [1, 'John', 'Doe'],
         *              [2, 'Mary', 'Poppins'],
         *              [3, 'Lucky', 'Luke']
         *          ]);
         *
         *     var characterId = relationA.get('characterId')
         *     var firstName = relationA.get('firstName')
         *     var lastName = relationA.get('lastName')
         *
         *
         *
         *     var relationC = relationA.restrict(characterId.equals(1))
         *
         *     // or
         *
         *     var relationC = new affinity.Projection(relationA, characterId.equals(1));
         *
         *     // +------------------------+---------------------+--------------------+
         *     // | characterId : TInteger | firstName : TString | lastName : TString |
         *     // +========================+=====================+====================+
         *     // | 1                      | John                | Doe                |
         *     // +------------------------+---------------------+--------------------+
         *
         */
        constructor: function (relation, predicate) {

            this.rel = relation;
            this.predicate = predicate;
            Relation.call(this);

        },

        bindEvents: function () {

            debug.restriction.trace('#bindEvents');

            Restriction.__super__.bindEvents.call(this);

            var that = this;


            that.ee.once('beforeGetHeader', function () {

                debug.restriction.trace('beforeGetHeader');

                that.header().copy(that.rel.header());

            });


            that.ee.once('beforeGetBody', function () {

                that.rel.each( function (tuple) { that.afterAdd(tuple); })

            });

            that.rel.ee.on('afterAdd', function(tuple){
                that.afterAdd(tuple);
            })

        },

        afterAdd : function(tuple){

            debug.restriction.trace('afterAdd');

            var that = this;

            that.header();

            if(that.predicate instanceof Function){

                that.predicate.convertAttributeToTuple();

                if (that.predicate.assignTuple(tuple).value() === true) {
                    that.add(tuple.clone(), false);
                }

            } else if (_.isFunction(that.predicate)) {

                if(that.predicate(tuple)){
                    that.add(tuple.clone(), false);
                }

            } else {
                throw new TypeError('Unsupported predicate type')
            }

        },

        afterRemove : function(relation, tuple){
            var result = this.relation.restrict(this.predicate);
            this.adjustTo(result);
        },

        afterUpdate : function(relation, tuple, attributeName, value, oldValue){
            var result = this.relation.restrict(this.predicate);
            this.adjustTo(result);
        }

    }, {

        type : 'Restriction'

    });

module.exports = Restriction;
},{"./../Function.js":5,"./../Header.js":6,"./../Relation.js":9,"./../helpers/debug":84,"lodash":105}],23:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var Tuple = require('./../Tuple.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');
var equal = require('./../helpers/equal');



var SemiDifference = Relation.extend(

    {

        /**
         * @class Operators.SemiDifference
         * @extends Relation
         * @param {Relation} relationA The relation from which to seek tuples with no counterpart
         * @param {Relation} relationB The relation containing the counterparts
         *
         * The SemiDifference will find all tuples in A that do not have a counterpart in B on their common attributes
         *
         *     // Find the characters that do not have fans
         *
         *     var relationA = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {firstName: { type: affinity.String}},
         *              {lastName: { type: affinity.String}}
         *          ],[
         *              [1, 'John', 'Doe'],
         *              [2, 'Mary', 'Poppins'],
         *              [3, 'Lucky', 'Luke']
         *          ]);
         *
         *     var relationB = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {fan: { type: affinity.String}}
         *          ],[
         *              [1, 'Mr X'],
         *              [1, 'Miss Dibble'],
         *              [2, 'Nat Bibble']
         *          ]);
         *
         *     var relationC = relationA.sdifference(relationB);
         *
         *     // or
         *
         *     var relationC = new affinity.SemiDifference(relationA, relationB)
         *
         *     // +------------------------+---------------------+--------------------+
         *     // | characterId : TInteger | firstName : TString | lastName : TString |
         *     // +========================+=====================+====================+
         *     // | 3                      | Lucky               | Luke               |
         *     // +------------------------+---------------------+--------------------+
         *     //
         *     // Lucky Luke is the only character without a fan
         *
         */
        constructor: function (relationA, relationB) {

            debug.semiDifference.trace('#constructor');

            this.rels = [relationA, relationB];

            Relation.call(this);

        },

        bindEvents: function () {

            debug.semiDifference.trace('#bindEvents');

            // Calling the parent bindEvents
            SemiDifference.__super__.bindEvents.call(this);

            var that = this;

            // BeforeGetHeader
            this.ee.once('beforeGetHeader', function () {

                debug.semiDifference.trace('beforeGetHeader');

                Header.assertSameNameSameType(that.rels[0].header(), that.rels[1].header());

                that.commonAttributes = that.rels[0].header().setIntersection(that.rels[1].header());

                that.header().copy(that.rels[0].header());

            });


            // BeforeGetBody
            this.ee.once('beforeGetBody', function () {

                that.header();

                debug.semiDifference.trace('beforeGetBody');

                var rel1 = that.rels[0];
                var rel2 = that.rels[1];

                rel1.each(function(tuple1){

                    var counterpart = false;

                    if(that.commonAttributes.length() > 0){

                        rel2.each(function(tuple2){

                            // Check if tuple1 has same common attributes as tuple2

                            var match = Tuple.matchOnAttributes(tuple1, tuple2, that.commonAttributes);

                            if(match){
                                counterpart = true;
                                return false;
                            }

                        });

                    }

                    if(!counterpart){
                        that.add(tuple1.clone(), false);
                    }

                })

            });

        },

        afterLeftAdd : function(relation, tuple){

        },

        afterLeftRemove : function(relation, tuple){

        },

        afterLeftUpdate : function(relation, tuple, attributeName, value, oldValue){

        },

        afterRightAdd : function(relation, tuple){

        },

        afterRightRemove : function(relation, tuple){

        },

        afterRightUpdate : function(relation, tuple, attributeName, value, oldValue){

        }

    }, {

        type : 'SemiDifference'

    });

module.exports = SemiDifference;
},{"./../Header.js":6,"./../Relation.js":9,"./../Tuple.js":11,"./../helpers/debug":84,"./../helpers/equal":85,"lodash":105}],24:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var Tuple = require('./../Tuple.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');
var equal = require('./../helpers/equal');



var SemiJoin = Relation.extend(

    {

        /**
         * @class Operators.SemiJoin
         * @extends Relation
         * @param {Relation} relationA The relation from which to seek tuples with their counterparts in B
         * @param {Relation} relationB The relation containing the counterparts
         *
         * The SemiJoin will find all tuples in A that have a counterpart in B on their common attributes
         *
         *     // Find the characters that have fans
         *
         *     var relationA = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {firstName: { type: affinity.String}},
         *              {lastName: { type: affinity.String}}
         *          ],[
         *              [1, 'John', 'Doe'],
         *              [2, 'Mary', 'Poppins'],
         *              [3, 'Lucky', 'Luke']
         *          ]);
         *
         *     var relationB = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {fan: { type: affinity.String}}
         *          ],[
         *              [1, 'Mr X'],
         *              [1, 'Miss Dibble'],
         *              [2, 'Nat Bibble']
         *          ]);
         *
         *     var relationC = relationA.sjoin(relationB);
         *
         *     // or
         *
         *     var relationC = new affinity.SemiJoin(relationA, relationB)
         *
         *     // +------------------------+---------------------+--------------------+
         *     // | characterId : TInteger | firstName : TString | lastName : TString |
         *     // +========================+=====================+====================+
         *     // | 1                      | John                | Doe                |
         *     // +------------------------+---------------------+--------------------+
         *     // | 2                      | Mary                | Poppins            |
         *     // +------------------------+---------------------+--------------------+
         *     //
         *     // John Doe and Mary Poppins have fans
         */
        constructor: function (relationA, relationB) {

            debug.semiJoin.trace('#constructor');

            this.rels = [relationA, relationB];

            Relation.call(this);

        },

        bindEvents: function () {

            debug.semiJoin.trace('#bindEvents');

            // Calling the parent bindEvents
            SemiJoin.__super__.bindEvents.call(this);

            var that = this;

            // BeforeGetHeader
            this.ee.once('beforeGetHeader', function () {

                debug.semiJoin.trace('beforeGetHeader');

                Header.assertSameNameSameType(that.rels[0].header(), that.rels[1].header());

                that.commonAttributes = that.rels[0].header().setIntersection(that.rels[1].header());

                that.header().copy(that.rels[0].header());

            });


            // BeforeGetBody
            this.ee.once('beforeGetBody', function () {

                debug.semiJoin.trace('beforeGetBody');

                var relation1 = that.rels[0];
                var relation2 = that.rels[1];

                relation1.each(function(tuple1){

                    var counterpart = false;

                    if (that.commonAttributes.length() > 0){

                        relation2.each(function(tuple2){

                            var match = Tuple.matchOnAttributes(tuple1, tuple2, that.commonAttributes);

                            if(match){
                                counterpart = true;
                                return false;
                            }

                        });

                    }

                    if(counterpart){
                        that.add(tuple1.clone(), false);
                    }

                })

            });

        },

        afterLeftAdd : function(relation, tuple){

        },

        afterLeftRemove : function(relation, tuple){

        },

        afterLeftUpdate : function(relation, tuple, attributeName, value, oldValue){

        },

        afterRightAdd : function(relation, tuple){

        },

        afterRightRemove : function(relation, tuple){

        },

        afterRightUpdate : function(relation, tuple, attributeName, value, oldValue){

        }

    }, {

        type : 'SemiJoin'

    });

module.exports = SemiJoin;
},{"./../Header.js":6,"./../Relation.js":9,"./../Tuple.js":11,"./../helpers/debug":84,"./../helpers/equal":85,"lodash":105}],25:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./../Header.js":6,"./../Relation.js":9,"./../Tuple.js":11,"./../helpers/debug":84,"./../helpers/equal":85,"dup":23,"lodash":105}],26:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./../Header.js":6,"./../Relation.js":9,"./../Tuple.js":11,"./../helpers/debug":84,"./../helpers/equal":85,"dup":24,"lodash":105}],27:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var Tuple = require('./../Tuple.js');
var Attribute = require('./../Attribute.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');

var Summarize = Relation.extend({

    /**
     * @class Operators.Summarize
     * @extends Relation
     *
     * The Summarize operation will be the projection result of given relation attributes
     * while extending this resulting relation with calculated attributes.
     *
     * Example :
     *
     *     var relation = new affinity.Relation([
     *         { id : {type : affinity.Integer} },
     *         { name : {type : affinity.String} },
     *         { age : {type : affinity.Integer} },
     *     ],[
     *         [1, 'John Doe', 23],
     *         [2, 'John Doe', 35],
     *         [3, 'John Doe', 27],
     *         [4, 'Bo Derek', 12],
     *         [5, 'Bo Derek', 7],
     *         [6, 'Marilyn Monroe', 16],
     *     ]);
     *
     *     var age = relation.get('age');
     *
     *     var summarized = relation.summarize(
     *         ['name'],
     *         [
     *             { "age.avg()" : age.avg()        },
     *             { "age.sum()" : age.sum()        },
     *             { "count()"   : affinity.count() }
     *         ]
     *     );
     *
     *     summarized.print();
     *
     *     // +------------------+----------------------+---------------------+---------------------+
     *     // | name : String    | age.avg() : Float    | age.sum() : Float   | count() : Integer   |
     *     // +==================+======================+=====================+=====================+
     *     // | John Doe         | 28.333333333333332   | 85                  | 3                   |
     *     // +------------------+----------------------+---------------------+---------------------+
     *     // | Bo Derek         | 9.5                  | 19                  | 2                   |
     *     // +------------------+----------------------+---------------------+---------------------+
     *     // | Marilyn Monroe   | 16                   | 16                  | 1                   |
     *     // +------------------+----------------------+---------------------+---------------------+
     */

    /**
     * Create a new Summary relation
     * @param {Relation} relation The relation to summarize
     * @param {Attribute[]|String[]} attributes The attributes to keep
     * @param {Object[]} summaries The summary expressions
     */
    constructor : function(relation, attributes, summaries){

        this.args = {};

        this.args.relation = relation;

        this.args.attributes = attributes;

        this.args.summaries = summaries;

        Relation.call(this);

    },

    bindEvents : function(){

        debug.semiJoin.trace('#bindEvents');

        // Calling the parent bindEvents
        Summarize.__super__.bindEvents.call(this);

        var that = this;

        that.ee.once('beforeGetHeader', function(){

            var relation = that.args.relation;

            var header = relation.header();

            var attributes = that.args.attributes;

            var summaries = that.args.summaries;

            // Check that the given attributes exist in the
            // base header.
            Header.assertAttributesExist(header, attributes);

            // Copy the given attributes from the base header
            that.header().copy(relation.header(), attributes);

            // Add the summaries attributes
            _.forEach(summaries, function(summary){

                var summaryName = Object.keys(summary)[0];

                var summaryExpression = summary[summaryName];

                var summaryType = summaryExpression.type();

                var newAttribute = new Attribute({name : summaryName, type : summaryType});

                that.header().add(newAttribute);

            });

        });

        that.ee.once('beforeGetBody', function(){

            var relation = that.args.relation;

            var header = relation.header();

            var attributes = that.args.attributes;

            var summaries = that.args.summaries;

            var instanceAttributes = new Header();

            instanceAttributes.copy(header, attributes);

            // These are the attributes that will be grouped
            var otherAttributes = header.setDifference(instanceAttributes);

            var otherAttributeNames = [];

            otherAttributes.each(function(otherAttribute){
                otherAttributeNames.push(otherAttribute.name);
            });

            // Create an intermediary group relation
            var grouped = relation.group('___grouped___', otherAttributeNames);

            grouped.each(function(groupedTuple){

                // Create the tuple that will be inserted
                var newTuple = new Tuple();

                // Copy the non-grouped attributes into the new tuple
                newTuple.copy(groupedTuple, attributes);

                // Get the grouped relation
                var groupedRelation = groupedTuple.get('___grouped___');

                _.forEach(summaries, function(summary){

                    var summaryName = Object.keys(summary)[0];

                    var summaryExpression = summary[summaryName];

                    summaryExpression.relation = groupedRelation;

                    var summaryValue = summaryExpression.value();

                    newTuple.set(summaryName, summaryValue);

                });

                that.add(newTuple);

            });

        })

    },

    afterAdd : function(relation, tuple){

    },

    afterRemove : function(relation, tuple){

    },

    afterUpdate : function(relation, tuple, attributeName, value, oldValue){

    }

}, {

    type : 'Summarize'

});


module.exports = Summarize;
},{"./../Attribute.js":2,"./../Header.js":6,"./../Relation.js":9,"./../Tuple.js":11,"./../helpers/debug":84,"lodash":105}],28:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var Tuple = require('./../Tuple.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');



var Ungroup = Relation.extend(
    {

        /**
         * @class Operators.Ungroup
         * @extends Relation
         * @param {Relation} relation The relation to ungroup
         * @param {String[]} groupedAttributes The grouped attribute names to ungroup
         *
         * The Ungroup operation will ungroup the specified grouped attributes.
         *
         *     var relationA = new affinity.Relation([
         *              {a: { type: affinity.Integer}},
         *              {b: { type: affinity.Integer}},
         *              {c: { type: affinity.Integer}}
         *          ],[
         *              [1, 2, 3],
         *              [4, 5, 6],
         *              [4, 9, 9],
         *              [7, 8, 9]
         *          ]);
         *
         *     var relationB = relationA.group('groupedAttribute', ['b', 'c'])
         *
         *     // +--------------+---------------------------------+
         *     // | a : TInteger | groupedAttribute : Relation     |
         *     // +==============+=================================+
         *     // | 1            | +--------------+--------------+ |
         *     // |              | | b : TInteger | c : TInteger | |
         *     // |              | +==============+==============+ |
         *     // |              | | 2            | 3            | |
         *     // |              | +--------------+--------------+ |
         *     // +--------------+---------------------------------+
         *     // | 4            | +--------------+--------------+ |
         *     // |              | | b : TInteger | c : TInteger | |
         *     // |              | +==============+==============+ |
         *     // |              | | 5            | 6            | |
         *     // |              | +--------------+--------------+ |
         *     // |              | | 9            | 9            | |
         *     // |              | +--------------+--------------+ |
         *     // +--------------+---------------------------------+
         *     // | 7            | +--------------+--------------+ |
         *     // |              | | b : TInteger | c : TInteger | |
         *     // |              | +==============+==============+ |
         *     // |              | | 8            | 9            | |
         *     // |              | +--------------+--------------+ |
         *     // +--------------+---------------------------------+
         *
         *     var relationC = relationB.ungroup(['groupedAttribute']);
         *
         *     //                 <----UNGROUPED ATTRIBUTES---->
         *     // +--------------+--------------+--------------+
         *     // | a : TInteger | b : TInteger | c : TInteger |
         *     // +==============+==============+==============+
         *     // | 1            | 2            | 3            |
         *     // +--------------+--------------+--------------+
         *     // | 4            | 5            | 6            |
         *     // +--------------+--------------+--------------+
         *     // | 4            | 9            | 9            |
         *     // +--------------+--------------+--------------+
         *     // | 7            | 8            | 9            |
         *     // +--------------+--------------+--------------+
         *
         *     relationC.equal(relationA) // true
         */
        constructor: function (relation, groupedAttributes) {

            debug.ungroup.trace('#constructor');

            this.relation = relation;
            this.groupedAttributeNames = groupedAttributes;

            Relation.call(this);

        },

        bindEvents: function () {

            debug.ungroup.trace('#bindEvents');

            // Calling the parent bindEvents
            Ungroup.__super__.bindEvents.call(this);

            var that = this;

            // BeforeGetHeader
            this.ee.once('beforeGetHeader', function () {

                debug.ungroup.trace('beforeGetHeader');

                // Let's "flatten" the headers. We will add the nested relation header attributes
                // to this relation

                _.forEach(that.groupedAttributeNames, function(groupedAttributeName){

                    // A RVA (relation-valued attribute) stores a copy of the header of it's nested relations
                    // in the attribute.relationHeader property.
                    var relationHeader = that.relation.header().get(groupedAttributeName).relationHeader;

                    that.header().copy(relationHeader);

                });

                // Let's add all the other non-grouped attributes to the header

                that.relation.header().each(function(attribute){

                    var grouped = _.any(that.groupedAttributeNames, function(groupedAttributeName){

                        return groupedAttributeName === attribute.name;

                    });

                    if(!grouped){

                        that.header().add(attribute.clone());

                    }

                });

            });

            // BeforeGetBody
            this.ee.once('beforeGetBody', function () {

                debug.ungroup.trace('beforeGetBody');

                that.relation.each(function(tuple){

                    _.forEach(that.groupedAttributeNames, function(groupedAttributeName){

                        tuple.get(groupedAttributeName).each(function(nestedTuple){

                            var newTuple = new Tuple();

                            // Copy the non grouped attributes from the root tuple
                            newTuple.copy(tuple, that.groupedAttributeNames, true);

                            // Copy the attributes from the nested tuple

                            newTuple.copy(nestedTuple);

                            that.add(newTuple, false);

                        })

                    })

                })

            });

        },

        afterAdd : function(relation, tuple){
            var result = this.relation.ungroup(this.groupedAttributeNames);
            this.adjustTo(result);
        },

        afterRemove : function(relation, tuple){
            var result = this.relation.ungroup(this.groupedAttributeNames);
            this.adjustTo(result);
        },

        afterUpdate : function(relation, tuple, attributeName, value, oldValue){
            var result = this.relation.ungroup(this.groupedAttributeNames);
            this.adjustTo(result);
        }

    }, {

        type : 'Ungroup'

    });

module.exports = Ungroup;
},{"./../Header.js":6,"./../Relation.js":9,"./../Tuple.js":11,"./../helpers/debug":84,"lodash":105}],29:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');



var Union = Relation.extend(

    {

        /**
         * @class Operators.Union
         * @param {Relation} relationA
         * @param {Relation} relationB
         * @extends Relation
         *
         * Example :
         *
         *     var relationA = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {firstName: { type: affinity.String}},
         *              {lastName: { type: affinity.String}}
         *          ],[
         *              [1, 'John', 'Doe'],
         *              [2, 'Mary', 'Poppins'],
         *              [3, 'Lucky', 'Luke']
         *          ]);
         *
         *
         *     var relationB = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {firstName: { type: affinity.String}},
         *              {lastName: { type: affinity.String}}
         *          ],[
         *              [1, 'Mr', 'X'],
         *              [2, 'Lady', 'Gaga'],
         *              [3, 'Bo', 'Vril']
         *          ]);
         *
         *     var relationC = relationA.union(relationB)
         *
         *     // or
         *
         *     var relationC = new affinity.Union(relationA, relationB);
         *
         *     // +------------------------+---------------------+--------------------+
         *     // | characterId : TInteger | firstName : TString | lastName : TString |
         *     // +========================+=====================+====================+   -
         *     // | 1                      | John                | Doe                |    |
         *     // +------------------------+---------------------+--------------------+    |
         *     // | 2                      | Mary                | Poppins            |    | RelationA
         *     // +------------------------+---------------------+--------------------+    |
         *     // | 3                      | Lucky               | Luke               |    |
         *     // +------------------------+---------------------+--------------------+   -
         *     // | 1                      | Mr                  | X                  |    |
         *     // +------------------------+---------------------+--------------------+    |
         *     // | 2                      | Lady                | Gaga               |    | RelationB
         *     // +------------------------+---------------------+--------------------+    |
         *     // | 3                      | Bo                  | Vril               |    |
         *     // +------------------------+---------------------+--------------------+   -
         *
         */
        constructor: function (relationA, relationB) {
            this.rels = [relationA, relationB];
            Relation.call(this);
        },

        bindEvents: function () {

            debug.union.trace('#bindEvents');

            Union.__super__.bindEvents.call(this);

            var that = this;

            that.ee.once('beforeGetBody', function () {

                debug.union.trace('beforeGetBody');

                _.forEach(that.rels, function (relation) {

                    relation.each(function(tuple){

                        that.add(tuple.clone());

                    });

                }, that)

            });

            that.ee.once('beforeGetHeader', function () {

                debug.union.trace('beforeGetHeader');

                Header.assertUnionCompatible(that.rels[0].header(), that.rels[1].header());

                that.header().copy(that.rels[0].header());

            });

        },

        afterLeftAdd : function(relation, tuple){

        },

        afterLeftRemove : function(relation, tuple){

        },

        afterLeftUpdate : function(relation, tuple, attributeName, value, oldValue){

        },

        afterRightAdd : function(relation, tuple){

        },

        afterRightRemove : function(relation, tuple){

        },

        afterRightUpdate : function(relation, tuple, attributeName, value, oldValue){

        }

    }, {

        type : 'Union'

    });

module.exports = Union;
},{"./../Header.js":6,"./../Relation.js":9,"./../helpers/debug":84,"lodash":105}],30:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Header = require('./../Header.js');
var Tuple = require('./../Tuple.js');
var Set = require('./../Set.js');
var Attribute = require('./../Attribute.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');



var Unwrap = Relation.extend(

    {

        /**
         * @class Operators.Unwrap
         * @extends Relation
         * @param {Relation} relation The relation to Unwrap
         * @param {String[]|String|Set|Header} attributeNames The name of the wrapped attributes to unwrap
         *
         * The Unwrap operator will reverse the {@link Operators.Wrap} operation, converting a tuple-valued attribute into
         * the attributes of the tuples.
         *
         *     var relationA = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {firstName: { type: affinity.String}},
         *              {lastName: { type: affinity.String}}
         *          ],[
         *              [1, 'John', 'Doe'],
         *              [2, 'Mary', 'Poppins'],
         *              [3, 'Lucky', 'Luke']
         *          ]);
         *
         *     var relationB = relationA.Unwrap('UnwrappedAttribute', ['firstName','lastName']);
         *
         *
         *     // +-------------------------------------------------------------------------+
         *     // | characterId : TInteger | unwrappedAttribute : Tuple                     |
         *     // +========================+================================================+
         *     // | 1                      | Tuple{firstName : 'John', lastName : 'Doe'}    |
         *     // +-------------------------------------------------------------------------+
         *     // | 2                      | Tuple{firstName : 'Mary', lastName : 'Poppins'}|
         *     // +-------------------------------------------------------------------------+
         *     // | 3                      | Tuple{firstName : 'Lucky', lastName : 'Luke'}  |
         *     // +-------------------------------------------------------------------------+
         *     //
         *
         *     var relationC = relationB.unwrap('unwrappedAttribute');
         *
         *     // or
         *
         *     var relationC = new affinity.Unwrap(relationB, 'unwrappedAttribute');
         *
         *
         *     //                          <-------UNWRAPPED ATTRIBUTES--------------->
         *     // +------------------------+---------------------+--------------------+
         *     // | characterId : TInteger | firstName : TString | lastName : TString |
         *     // +========================+=====================+====================+
         *     // | 1                      | John                | Doe                |
         *     // +------------------------+---------------------+--------------------+
         *     // | 2                      | Mary                | Poppins            |
         *     // +------------------------+---------------------+--------------------+
         *     // | 3                      | Lucky               | Luke               |
         *     // +------------------------+---------------------+--------------------+
         *
         */
        constructor: function (relation, attributeNames) {

            debug.unwrap.trace('#constructor');

            // Check if the relation argument is of good type
            if(!(relation instanceof Relation)){
                throw new TypeError('Specified relation is of wrong type');
            }

            // If the attributeNames is a string, coerce it to an array
            if(_.isString(attributeNames)){
                attributeNames = [attributeNames];
            }

            // If the attributeNames is not an array or set, throw an error
            if(!_.isArray(attributeNames) && !(attributeNames instanceof Set)){
                throw new Error('Unsupported type of specified attributeNames to unwrap');
            }

            if(_.isArray(attributeNames) && attributeNames.length <= 0){
                throw new Error('You must specify attributes to unwrap!');
            }

            if((attributeNames instanceof Set) && attributeNames.length() <= 0){
                throw new Error('You must specify attributes to unwrap!');
            }

            this.attributeNames = attributeNames;
            this.relation = relation;

            Relation.call(this);

        },

        bindEvents: function () {

            debug.unwrap.trace('#bindEvents');

            // Calling the parent bindEvents
            Unwrap.__super__.bindEvents.call(this);

            var relation = this.relation;

            var that = this;

            // BeforeGetHeader
            this.ee.once('beforeGetHeader', function () {

                debug.unwrap.trace('beforeGetHeader');

                // Copy all attributes from the base header that will not be unwrapped
                that.header().copy(relation.header(), that.attributeNames, true);

                // Get all attributes that were wrapped in the base relation
                var alreadyWrappedAttributes = new Header();
                relation.header().each(function(attribute){
                    if(attribute.wrappedAttributes){
                        alreadyWrappedAttributes.add(attribute.clone());
                    }
                });

                // Get the attributes which will be unwrapped
                var unwrappedAttributes = new Header();
                unwrappedAttributes.copy(relation.header(), that.attributeNames);
                that.unwrappedAttributes = unwrappedAttributes;

                // Get the attributes which will not be unwrapped
                var nonUnwrappedAttributes = new Header();
                nonUnwrappedAttributes.copy(relation.header(), that.attributeNames, true);
                that.nonUnwrappedAttributes = nonUnwrappedAttributes;

                // Check that the attributes to be unwrapped are wrapped. We would not want
                // to unwrap non-wrapped attributes!
                if(!unwrappedAttributes.isSubset(alreadyWrappedAttributes)){
                    throw new Error('Specified attributes are not all wrapped attributes. Must specify attributes which are wrapped.');
                }

                // Add all nested unwrapped attributes in the header
                unwrappedAttributes.each(function(unwrappedAttribute){
                    unwrappedAttribute.wrappedAttributes.each(function(wrappedAttribute){
                        that.header().add(wrappedAttribute.clone());
                    })
                })

            });

            // BeforeGetBody
            this.ee.once('beforeGetBody', function () {

                debug.unwrap.trace('beforeGetBody');

                // Loop through each tuple of the relation
                that.relation.each(function(tuple){

                    // Create the tuple to be inserted
                    var newTuple = new Tuple();

                    // Assign the values to the attributes which will not be unwrapped
                    that.nonUnwrappedAttributes.each(function(attribute){
                        newTuple.set(attribute.name, tuple.get(attribute.name));
                    });

                    // Loop through the attributes to be unwrapped
                    that.unwrappedAttributes.each(function(unwrappedAttribute){

                        // Loop through the wrapped attribute header
                        unwrappedAttribute.wrappedAttributes.each(function(wrappedAttribute){

                            // Set the tuple value for this attribute
                            newTuple.set(wrappedAttribute.name, tuple.get(unwrappedAttribute.name).get(wrappedAttribute.name));

                        })

                    });

                    that.add(newTuple);

                })

            });

        },

        afterAdd : function(relation, tuple){
            var result = this.relation.unwrap(this.attributeNames);
            this.adjustTo(result);
        },

        afterRemove : function(relation, tuple){
            var result = this.relation.unwrap(this.attributeNames);
            this.adjustTo(result);
        },

        afterUpdate : function(relation, tuple, attributeName, value, oldValue){
            var result = this.relation.unwrap(this.attributeNames);
            this.adjustTo(result);
        }

    }, {

        type : 'Unwrap'

    });

module.exports = Unwrap;
},{"./../Attribute.js":2,"./../Header.js":6,"./../Relation.js":9,"./../Set.js":10,"./../Tuple.js":11,"./../helpers/debug":84,"lodash":105}],31:[function(require,module,exports){
var Relation = require('./../Relation.js');
var Set = require('./../Set.js');
var Header = require('./../Header.js');
var Attribute = require('./../Attribute.js');
var Tuple = require('./../Tuple.js');
var _ = require('lodash');
var debug = require('./../helpers/debug');



var Wrap = Relation.extend(

    {

        /**
         * @class Operators.Wrap
         * @extends Relation
         * @param {Relation} relationA The relation to wrap
         * @param {String} wrappingAttributeName The name of the wrapping attribute
         * @param {String[]} wrappedAttributes The wrappedAttributes to wrap
         *
         * The Wrap will gather multiple wrappedAttributes into a single one, converting them to a tuple-valued attribute
         *
         *     var relationA = new affinity.Relation([
         *              {characterId: { type: affinity.Integer}},
         *              {firstName: { type: affinity.String}},
         *              {lastName: { type: affinity.String}}
         *          ],[
         *              [1, 'John', 'Doe'],
         *              [2, 'Mary', 'Poppins'],
         *              [3, 'Lucky', 'Luke']
         *          ]);
         *
         *     // +------------------------+---------------------+--------------------+
         *     // | characterId : TInteger | firstName : TString | lastName : TString |
         *     // +========================+=====================+====================+
         *     // | 1                      | John                | Doe                |
         *     // +------------------------+---------------------+--------------------+
         *     // | 2                      | Mary                | Poppins            |
         *     // +------------------------+---------------------+--------------------+
         *     // | 3                      | Lucky               | Luke               |
         *     // +------------------------+---------------------+--------------------+
         *
         *     var relationC = relationA.wrap('wrappedAttribute', ['firstName','lastName']);
         *
         *     // or
         *
         *     var relationC = new affinity.Wrap(relationA, 'wrappedAttribute', ['firstName','lastName']);
         *
         *     //                          <----WRAPPING ATTRIBUTE-------------------------->
         *     // +-------------------------------------------------------------------------+
         *     // | characterId : TInteger | wrappedAttribute : Tuple                       |
         *     // +========================+================================================+
         *     // | 1                      | Tuple{firstName : 'John', lastName : 'Doe'}    |
         *     // +-------------------------------------------------------------------------+
         *     // | 2                      | Tuple{firstName : 'Mary', lastName : 'Poppins'}|
         *     // +-------------------------------------------------------------------------+
         *     // | 3                      | Tuple{firstName : 'Lucky', lastName : 'Luke'}  |
         *     // +-------------------------------------------------------------------------+
         *     //
         *
         */
        constructor: function (relationA, wrappingAttributeName, wrappedAttributes) {

            debug.wrap.trace('#constructor');

            this.relation = relationA;

            Attribute.assertValidName(wrappingAttributeName);

            if(!_.isArray(wrappedAttributes) && !(wrappedAttributes instanceof Set)){
                throw new Error('Wrapped attributes must be an array or set of attributes / attribute names');
            }

            if(_.isArray(wrappedAttributes) && wrappedAttributes.length <= 0){
                throw new Error('There must be at least one attribute to wrap');
            }

            if(wrappedAttributes instanceof Set && wrappedAttributes.length() <= 0){
                throw new Error('There must be at least one attribute to wrap');
            }

            this.wrappedAttributeName = wrappingAttributeName;
            this.wrappedAttributes = wrappedAttributes;

            Relation.call(this);

        },

        bindEvents: function () {

            debug.wrap.trace('#bindEvents');

            // Calling the parent bindEvents
            Wrap.__super__.bindEvents.call(this);

            var that = this;

            // BeforeGetHeader
            this.ee.once('beforeGetHeader', function () {

                debug.wrap.trace('beforeGetHeader');

                // Check that the passed attributes exist in the base header
                Header.assertAttributesExist(that.relation, that.wrappedAttributes);

                // Extract the wrapped attributes, convert them to a Header instance
                var wrappedAttributes = new Header();
                wrappedAttributes.copy(that.relation.header(), that.wrappedAttributes);
                that.wrappedAttributes = wrappedAttributes;

                // Extract the non wrapped attributes in another variable, and
                // copy the attributes in this header
                that.nonWrappedAttributes = new Header();
                that.nonWrappedAttributes.copy(that.relation.header(), that.wrappedAttributes, true);
                that.header().copy(that.nonWrappedAttributes);

                // Create the wrapped attribute
                var newWrappedAttribute = new Attribute({name : that.wrappedAttributeName, type : Tuple})

                // Store the wrapped header in the attribute
                newWrappedAttribute.wrappedAttributes = that.wrappedAttributes;

                // Add it to the header
                that.header().add(newWrappedAttribute);

            });


            // BeforeGetBody
            this.ee.once('beforeGetBody', function () {

                debug.wrap.trace('beforeGetBody');

                that.relation.each(function(tuple){

                    // Create the tuple we will later insert
                    var newTuple = new Tuple();

                    // Copy the value of the non-wrapped attributes
                    newTuple.copy(tuple, that.nonWrappedAttributes);

                    // Create the nested tuple
                    var nestedTuple = new Tuple();

                    // Copy the values of the wrapped attributes in the nested tuple
                    nestedTuple.copy(tuple, that.wrappedAttributes);

                    // Add the nested tuple to the containing tuple
                    newTuple.set(that.wrappedAttributeName, nestedTuple);

                    that.add(newTuple);

                })

            });

        },

        afterAdd : function(relation, tuple){
            var result = this.relation.wrap(this.wrappedAttributeName, this.wrappedAttributes);
            this.adjustTo(result);
        },

        afterRemove : function(relation, tuple){
            var result = this.relation.wrap(this.wrappedAttributeName, this.wrappedAttributes);
            this.adjustTo(result);
        },

        afterUpdate : function(relation, tuple, attributeName, value, oldValue){
            var result = this.relation.wrap(this.wrappedAttributeName, this.wrappedAttributes);
            this.adjustTo(result);
        }

    }, {

        type : 'Wrap'

    });

module.exports = Wrap;
},{"./../Attribute.js":2,"./../Header.js":6,"./../Relation.js":9,"./../Set.js":10,"./../Tuple.js":11,"./../helpers/debug":84,"lodash":105}],32:[function(require,module,exports){
var Function = require('./../../Function');

var Boolean = require('./../../types/Boolean.js');

var _ = require('lodash');

var All = Function.extend({

    /**
     * @class Functions.Aggregate.All
     * @extends Function
     *
     * Functions that checks if all the tuples in a relation match the
     * given boolean predicate.
     *
     * Example :
     *
     *     var relation = new affinity.Relation([
     *         { name : { type : affinity.String } },
     *         { age : { type : affinity.Integer } }
     *     ],[
     *         ['John Doe', 23],
     *         ['Mark Clinton', 36],
     *         ['Super Woman', 56]
     *     ]);
     *
     *     var name = relation.get('name');
     *     var age = relation.get('age')
     *
     *     var all = relation.all(age.gt(20));
     *
     *     console.log(all.value());
     *
     *     // true
     */

    constructor : function(relation, predicate){

        Function.apply(this, Array.prototype.slice.call(arguments,0));

        this.name = 'All';

        this.predicate = predicate;

        this.relation = relation;

        this.type(Boolean);

    },


    value : function(){

        var relation = this.relation;

        var predicate = this.predicate;

        var result = true;

        predicate.convertAttributeToTuple();

        relation.each(function(tuple){

            predicate.assignTuple(tuple);

            if( predicate.value() === false ){

                result = false;
                return false;

            }

        });

        return result;

    }

});

module.exports = All;
},{"./../../Function":5,"./../../types/Boolean.js":95,"lodash":105}],33:[function(require,module,exports){
var Function = require('./../../Function');

var Boolean = require('./../../types/Boolean.js');

var _ = require('lodash');

var Any = Function.extend({

    /**
     * @class Functions.Aggregate.Any
     * @extends Function
     *
     * Functions that checks if any of the tuples in a relation match the
     * given boolean predicate.
     *
     * Example :
     *
     *     var relation = new affinity.Relation([
     *         { name : { type : affinity.String } },
     *         { age : { type : affinity.Integer } }
     *     ],[
     *         ['John Doe', 23],
     *         ['Mark Clinton', 36],
     *         ['Super Woman', 56]
     *     ]);
     *
     *     var name = relation.get('name');
     *     var age = relation.get('age')
     *
     *     var any = relation.any(age.gt(50));
     *
     *     console.log(any.value());
     *
     *     // true
     */

    constructor : function(relation, predicate){

        Function.apply(this, Array.prototype.slice.call(arguments,0));

        this.name = 'Any';

        this.type(Boolean);

        this.relation = relation;

        this.predicate = predicate;

    },

    value : function(){

        var relation = this.relation;

        var predicate = this.predicate;

        var result = false;

        predicate.convertAttributeToTuple();

        relation.each(function(tuple){

            predicate.assignTuple(tuple);

            if( predicate.value() === true ){

                result = true;
                return false;

            }

        });

        return result;

    }
});

module.exports = Any;
},{"./../../Function":5,"./../../types/Boolean.js":95,"lodash":105}],34:[function(require,module,exports){
var Function = require('./../../Function');

var Float = require('./../../types/Float.js');

var _ = require('lodash');

var Average = Function.extend({

    /**
     * @class Functions.Aggregate.Average
     * @extends Function
     *
     * Functions that returns the average for a relation
     * attribute
     *
     * Example :
     *
     *     var relation = new affinity.Relation([
     *         { name : { type : affinity.String } },
     *         { age : { type : affinity.Integer } }
     *     ],[
     *         ['John Doe', 23],
     *         ['Mark Clinton', 36],
     *         ['Super Woman', 56]
     *     ]);
     *
     *     var age = relation.get('age');
     *
     *     var max = relation.avg(age)
     *
     *     console.log(max.value());
     *
     *     // 38.33333333
     */

    constructor : function(attribute){

        Function.apply(this, Array.prototype.slice.call(arguments,0));

        this.name = 'Average';

        this.type(Float);

        this.attribute = attribute;

        this.relation = attribute.header.relation;

    },

    value : function(){

        var attribute = this.attribute;

        var relation = this.relation;

        var result = 0;

        var length = relation.length();

        relation.each(function(tuple){

            result += tuple.get(attribute.name);

        });

        result = result / length;

        return result;

    }
});

module.exports = Average;
},{"./../../Function":5,"./../../types/Float.js":97,"lodash":105}],35:[function(require,module,exports){
var Function = require('./../../Function');

var Integer = require('./../../types/Integer.js');

var _ = require('lodash');

var Count = Function.extend({

    /**
     * @class Functions.Aggregate.Count
     * @extends Function
     *
     * Functions that counts the number of tuples
     *
     * Example :
     *
     *     var relation = new affinity.Relation([
     *         { name : { type : affinity.String } },
     *         { age : { type : affinity.Integer } }
     *     ],[
     *         ['John Doe', 23],
     *         ['Mark Clinton', 36],
     *         ['Super Woman', 56]
     *     ]);
     *
     *     var count = relation.count()
     *
     *     console.log(count.value());
     *
     *     // 3
     */

    constructor : function(relation){

        Function.apply(this, Array.prototype.slice.call(arguments,0));

        this.name = 'Count';

        this.type(Integer);

        this.relation = relation;

    },

    value : function(){

        return this.relation.length();

    }

});

module.exports = Count;
},{"./../../Function":5,"./../../types/Integer.js":98,"lodash":105}],36:[function(require,module,exports){
var Function = require('./../../Function');

var compare = require('./../../helpers/compare.js');

var Integer = require('./../../types/Integer.js');

var Maximum = Function.extend({

    /**
     * @class Functions.Aggregate.Maximum
     * @extends Function
     *
     * Functions that returns the largest value of an attribute in a relation.
     *
     * Example :
     *
     *     var relation = new affinity.Relation([
     *         { name : { type : affinity.String } },
     *         { age : { type : affinity.Integer } }
     *     ],[
     *         ['John Doe', 23],
     *         ['Mark Clinton', 36],
     *         ['Super Woman', 56]
     *     ]);
     *
     *     var age = relation.get('age');
     *
     *     var max = relation.max(age)
     *
     *     console.log(max.value());
     *
     *     // 56
     */

    constructor : function(attribute){

        Function.apply(this, Array.prototype.slice.call(arguments,0));

        this.name = 'Maximum';

        this.type(Integer);

        this.attribute = attribute;

        this.relation = attribute.header.relation;

    },

    value : function(){

        var relation = this.relation;

        var attribute = this.attribute;

        var type = this.attribute.type;

        var max = null;

        relation.each(function(tuple){

            var value = tuple.get(attribute.name);

            if(max === null){
                max = value;
            } else if ( compare(type, value, max) > 0 ){
                max = value;
            }

        });

        return max;

    }
});

module.exports = Maximum;
},{"./../../Function":5,"./../../helpers/compare.js":83,"./../../types/Integer.js":98}],37:[function(require,module,exports){
var Function = require('./../../Function');

var compare = require('./../../helpers/compare.js');

var Integer = require('./../../types/Integer.js');

var Minimum = Function.extend({

    /**
     * @class Functions.Aggregate.Minimum
     * @extends Function
     *
     * Functions that returns the minimum value of an attribute in a relation.
     *
     * Example :
     *
     *     var relation = new affinity.Relation([
     *         { name : { type : affinity.String } },
     *         { age : { type : affinity.Integer } }
     *     ],[
     *         ['John Doe', 23],
     *         ['Mark Clinton', 36],
     *         ['Super Woman', 56]
     *     ]);
     *
     *     var age = relation.get('age');
     *
     *     var min = relation.min(age);
     *
     *     console.log(min.value());
     *
     *     // 23
     */

    constructor : function(attribute){

        Function.apply(this, Array.prototype.slice.call(arguments,0));

        this.name = 'Minimum';

        this.type(Integer);

        this.attribute = attribute;

        this.relation = attribute.header.relation;

    },

    value : function(){

        var relation = this.relation;

        var attribute = this.attribute;

        var type = this.attribute.type;

        var min = null;

        relation.each(function(tuple){

            var value = tuple.get(attribute.name);

            if(min === null){
                min = value;
            } else if ( compare(type, value, min) < 0 ){
                min = value;
            }

        });

        return min;

    }

});

module.exports = Minimum;
},{"./../../Function":5,"./../../helpers/compare.js":83,"./../../types/Integer.js":98}],38:[function(require,module,exports){
var Function = require('./../../Function');

var Float = require('./../../types/Float.js');

var Variance = require('./Variance.js');

var StandardDeviation = Function.extend({

    /**
     * @class Functions.Aggregate.StandardDeviation
     * @extends Function
     *
     * Functions that returns the standard deviation
     * of an attribute in a relation
     *
     * Example :
     *
     *     var relation = new affinity.Relation([
     *         { name : { type : affinity.String } },
     *         { age : { type : affinity.Integer } }
     *     ],[
     *         ['John Doe', 23],
     *         ['Mark Clinton', 36],
     *         ['Super Woman', 56]
     *     ]);
     *
     *     var age = relation.get('age');
     *
     *     var stdev = relation.standardDeviation(age)
     *
     *     console.log(stdev.value());
     *
     *     // 16.6232768531
     */

    constructor : function(attribute){

        Function.apply(this, Array.prototype.slice.call(arguments,0));

        this.name = 'StandardDeviation';

        this.type(Float);

        this.attribute = attribute;

    },

    value : function(){

        var attribute = this.attribute;

        var variance = new Variance(attribute).value();

        return Math.sqrt(variance);

    }
});

module.exports = StandardDeviation;
},{"./../../Function":5,"./../../types/Float.js":97,"./Variance.js":40}],39:[function(require,module,exports){
var Function = require('./../../Function');

var Float = require('./../../types/Float.js');

var Sum = Function.extend({

    /**
     * @class Functions.Aggregate.Count
     * @extends Function
     *
     * Functions that calculates the sum of all values for
     * an attribute in a relation
     *
     * Example :
     *
     *     var relation = new affinity.Relation([
     *         { name : { type : affinity.String } },
     *         { age : { type : affinity.Integer } }
     *     ],[
     *         ['John Doe', 23],
     *         ['Mark Clinton', 36],
     *         ['Super Woman', 56]
     *     ]);
     *
     *     var age = relation.get('age');
     *
     *     var sum = relation.sum(age);
     *
     *     console.log(sum.value());
     *
     *     // 115
     */

    constructor : function(attribute){

        Function.apply(this, Array.prototype.slice.call(arguments,0));

        this.name = 'Sum';

        this.type(Float);

        this.attribute = attribute;

        this.relation = attribute.header.relation;

    },

    value : function(){

        var relation = this.relation;

        var attributeName = this.attribute.name;

        var sum = 0;

        relation.each(function(tuple){

            sum += tuple.get(attributeName);

        });

        return sum;

    }

});

module.exports = Sum;
},{"./../../Function":5,"./../../types/Float.js":97}],40:[function(require,module,exports){
var Function = require('./../../Function');

var Average = require('./Average.js');

var Float = require('./../../types/Float.js');

var Variance = Function.extend({

    /**
     * @class Functions.Aggregate.Variance
     * @extends Function
     *
     * Functions that returns the variance
     * of attribute values in a relation
     *
     * Example :
     *
     *     var relation = new affinity.Relation([
     *         { name : { type : affinity.String } },
     *         { age : { type : affinity.Integer } }
     *     ],[
     *         ['John Doe', 23],
     *         ['Mark Clinton', 36],
     *         ['Super Woman', 56]
     *     ]);
     *
     *     var age = relation.get('age');
     *
     *     var variance = relation.variance(age)
     *
     *     console.log(variance.value());
     *
     *     // 184.22222
     */

    constructor : function(attribute){

        Function.apply(this, Array.prototype.slice.call(arguments,0));

        this.name = 'Sum';

        this.type(Float);

        this.attribute = attribute;

        this.relation = attribute.header.relation

    },

    value : function(){

        var attribute = this.attribute;

        var relation = this.relation;

        var attributeName = this.attribute.name;

        var average = new Average(attribute).value();

        var length = relation.length();

        var totalVariance = 0;

        relation.each(function(tuple){

            var value = tuple.get(attributeName);

            totalVariance += Math.pow((value - average), 2);

        });

        return totalVariance / length;

    }
});

module.exports = Variance;
},{"./../../Function":5,"./../../types/Float.js":97,"./Average.js":34}],41:[function(require,module,exports){
var Function = require('./../../Function.js');
var TBoolean = require('./../../types/Boolean.js');
var _ = require('lodash');
var equal = require('./../../helpers/equal');

var FEqual = Function.extend(

    {

        /**
         * @class Functions.Comparable.Equal
         * @extends Function
         *
         * Function that compares if two values are equal. Only applies
         * to types that implement a static "equal" method or to primitives.
         *
         * When used with an Extension operator :
         *
         *      var philosophers = new affinity.Relation([
         *              {name: { type: affinity.String}},
         *              {born: { type: affinity.Integer}},
         *              {died: { type: affinity.Integer}}
         *          ],[
         *              ['Aristotle', -384, -322],
         *              ['Plato',     -428, -348],
         *              ['Socrates',  -470, -399]
         *          ]);
         *
         *      name = philosophers.get('name');
         *      born = philosophers.get('born');
         *      died = philosophers.get('died');
         *
         *      var extended = philosophers.extend([{ diedIn322BC : died.eq(-322) }]);
         *
         *      // or equivalent :
         *
         *      var extended = philosophers.extend([{ diedIn322BC : new affinity.Equal(died, -322) }]);
         *
         *      extended.print();
         *
         *      // +----------------+-----------------+-----------------+------------------------+
         *      // | name : TString | born : TInteger | died : TInteger | diedIn322BC : TBoolean |
         *      // +================+=================+=================+========================+
         *      // | Aristotle      | -384            | -322            | true                   |
         *      // +----------------+-----------------+-----------------+------------------------+
         *      // | Plato          | -428            | -348            | false                  |
         *      // +----------------+-----------------+-----------------+------------------------+
         *      // | Socrates       | -470            | -399            | false                  |
         *      // +----------------+-----------------+-----------------+------------------------+
         *
         *
         * When used with a Restriction operator :
         *
         *      var restricted = philosophers.restrict(died.eq(-322));
         *
         *      // or equivalent :
         *
         *      var restricted = philosophers.restrict(new affinity.Equal(died, -322));
         *
         *      restricted.print();
         *
         *      // +----------------+-----------------+-----------------+
         *      // | name : TString | born : TInteger | died : TInteger |
         *      // +================+=================+=================+
         *      // | Aristotle      | -384            | -322            |
         *      // +----------------+-----------------+-----------------+
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments,0));

            this.name = 'Equals';

            this.type(TBoolean);

        },

        /**
         * Gets the result of the function
         * @returns {Boolean}
         */
        value: function () {

            return equal(null, this.parameters[0], this.parameters[1]);

        }

});

module.exports = FEqual;
},{"./../../Function.js":5,"./../../helpers/equal":85,"./../../types/Boolean.js":95,"lodash":105}],42:[function(require,module,exports){
var Function = require('./../../Function.js');
var TBoolean = require('./../../types/Boolean.js');
var _ = require('lodash');
var compare = require('./../../helpers/compare');

var GreaterThan = Function.extend(

    {

        /**
         * @class Functions.Comparable.GreaterThan
         * @extends Function
         *
         * Function that checks if a value is greater than another one.
         * Only applies to types that implement the static "compare" method
         * or to primitives.
         *
         * When used with an Extension operator :
         *
         *      var philosophers = new affinity.Relation([
         *              {name: { type: affinity.String}},
         *              {born: { type: affinity.Integer}},
         *              {died: { type: affinity.Integer}}
         *          ],[
         *              ['Aristotle', -384, -322],
         *              ['Plato',     -428, -348],
         *              ['Socrates',  -470, -399]
         *          ]);
         *
         *      name = philosophers.get('name');
         *      born = philosophers.get('born');
         *      died = philosophers.get('died');
         *
         *      var extended = philosophers.extend([{ diedAfter350BC : died.gt(-322) }]);
         *
         *      // or equivalent :
         *
         *      var extended = philosophers.extend([{ diedAfter350BC : new affinity.GreaterThan(died, -322) }]);
         *
         *      extended.print();
         *
         *      // +----------------+-----------------+-----------------+---------------------------+
         *      // | name : TString | born : TInteger | died : TInteger | diedAfter350BC : TBoolean |
         *      // +================+=================+=================+===========================+
         *      // | Aristotle      | -384            | -322            | true                      |
         *      // +----------------+-----------------+-----------------+---------------------------+
         *      // | Plato          | -428            | -348            | true                      |
         *      // +----------------+-----------------+-----------------+---------------------------+
         *      // | Socrates       | -470            | -399            | true                      |
         *      // +----------------+-----------------+-----------------+---------------------------+
         *
         *
         * When used with a Restriction operator :
         *
         *      var restricted = philosophers.restrict(died.gt(-350));
         *
         *      // or equivalent :
         *
         *      var restricted = philosophers.restrict(new affinity.GreaterThan(died, -350));
         *
         *      restricted.print();
         *
         *      // +----------------+-----------------+-----------------+
         *      // | name : TString | born : TInteger | died : TInteger |
         *      // +================+=================+=================+
         *      // | Aristotle      | -384            | -322            |
         *      // +----------------+-----------------+-----------------+
         *      // | Plato          | -428            | -348            |
         *      // +----------------+-----------------+-----------------+
         *
         */
        constructor: function () {

            Function.apply(this, arguments);

            this.name = 'GreaterThan';

            this.type(TBoolean);

        },

        /**
         * Gets the result of the function
         * @returns {boolean}
         */
        value: function () {

            return (compare(null, this.parameters[0], this.parameters[1]) > 0);

        }

    },{

    });

module.exports = GreaterThan;
},{"./../../Function.js":5,"./../../helpers/compare":83,"./../../types/Boolean.js":95,"lodash":105}],43:[function(require,module,exports){
var Function = require('./../../Function.js');
var compare = require('./../../helpers/compare');
var TBoolean = require('./../../types/Boolean.js');
var _ = require('lodash');

var FLargerThanEqual = Function.extend(

    {

        /**
         * @class Functions.Comparable.GreaterThanEqual
         * @extends Function
         *
         * Function that checks if a value is greater than or equal to another one. It only applies
         * to types that implement a static "compare" method or to primitives.
         *
         * When used with an Extension operator :
         *
         *      var philosophers = new affinity.Relation([
         *              {name: { type: affinity.String}},
         *              {born: { type: affinity.Integer}},
         *              {died: { type: affinity.Integer}}
         *          ],[
         *              ['Aristotle', -384, -322],
         *              ['Plato',     -428, -348],
         *              ['Socrates',  -470, -399]
         *          ]);
         *
         *      name = philosophers.get('name');
         *      born = philosophers.get('born');
         *      died = philosophers.get('died');
         *
         *      var extended = philosophers.extend([{ diedSince348BC : died.gte(-348) }]);
         *
         *      // or equivalent :
         *
         *      var extended = philosophers.extend([{ diedSince348BC : new affinity.GreaterThanEqual(died, -348) }]);
         *
         *      extended.print();
         *
         *      // +----------------+-----------------+-----------------+---------------------------+
         *      // | name : TString | born : TInteger | died : TInteger | diedSince348BC : TBoolean |
         *      // +================+=================+=================+===========================+
         *      // | Aristotle      | -384            | -322            | false                     |
         *      // +----------------+-----------------+-----------------+---------------------------+
         *      // | Plato          | -428            | -348            | true                      |
         *      // +----------------+-----------------+-----------------+---------------------------+
         *      // | Socrates       | -470            | -399            | true                      |
         *      // +----------------+-----------------+-----------------+---------------------------+
         *
         *
         * When used with a Restriction operator :
         *
         *      var restricted = philosophers.restrict(died.gte(-348));
         *
         *      // or equivalent :
         *
         *      var restricted = philosophers.restrict(new affinity.GreaterThanEqual(died, -348));
         *
         *      restricted.print();
         *
         *      // +----------------+-----------------+-----------------+
         *      // | name : TString | born : TInteger | died : TInteger |
         *      // +================+=================+=================+
         *      // | Aristotle      | -384            | -322            |
         *      // +----------------+-----------------+-----------------+
         *      // | Plato          | -428            | -348            |
         *      // +----------------+-----------------+-----------------+
         */
        constructor: function () {

            Function.apply(this, arguments);

            this.name = 'GreaterThanEqual';

            this.type(TBoolean);

        },

        /**
         * Gets the result of the function
         * @returns {boolean}
         */
        value: function () {

            return (compare(null, this.parameters[0], this.parameters[1]) >= 0);

        }

    },{



    });

module.exports = FLargerThanEqual;
},{"./../../Function.js":5,"./../../helpers/compare":83,"./../../types/Boolean.js":95,"lodash":105}],44:[function(require,module,exports){
var Function = require('./../../Function.js');
var compare = require('./../../helpers/compare');
var TBoolean = require('./../../types/Boolean.js');
var _ = require('lodash');

var FSmallerThan = Function.extend(

    {

        /**
         * @class Functions.Comparable.SmallerThan
         * @extends Function
         *
         * Function that checks if a value is smaller than another one. It only applies
         * to types that implement a static "compare" method or to primitives.
         *
         * When used with an Extension operator :
         *
         *      var philosophers = new affinity.Relation([
         *              {name: { type: affinity.String}},
         *              {born: { type: affinity.Integer}},
         *              {died: { type: affinity.Integer}}
         *          ],[
         *              ['Aristotle', -384, -322],
         *              ['Plato',     -428, -348],
         *              ['Socrates',  -470, -399]
         *          ]);
         *
         *      name = philosophers.get('name');
         *      born = philosophers.get('born');
         *      died = philosophers.get('died');
         *
         *      var extended = philosophers.extend([{ diedBefore348BC : died.st(-348) }]);
         *
         *      // or equivalent :
         *
         *      var extended = philosophers.extend([{ diedBefore348BC : new affinity.SmallerThan(died, -348) }]);
         *
         *      extended.print();
         *
         *      // +----------------+-----------------+-----------------+----------------------------+
         *      // | name : TString | born : TInteger | died : TInteger | diedBefore348BC : TBoolean |
         *      // +================+=================+=================+============================+
         *      // | Aristotle      | -384            | -322            | true                       |
         *      // +----------------+-----------------+-----------------+----------------------------+
         *      // | Plato          | -428            | -348            | false                      |
         *      // +----------------+-----------------+-----------------+----------------------------+
         *      // | Socrates       | -470            | -399            | false                      |
         *      // +----------------+-----------------+-----------------+----------------------------+
         *
         *
         * When used with a Restriction operator :
         *
         *      var restricted = philosophers.restrict(died.st(-348));
         *
         *      // or equivalent :
         *
         *      var restricted = philosophers.restrict(new affinity.SmallerThan(died, -348));
         *
         *      restricted.print();
         *
         *      // +----------------+-----------------+-----------------+
         *      // | name : TString | born : TInteger | died : TInteger |
         *      // +================+=================+=================+
         *      // | Aristotle      | -384            | -322            |
         *      // +----------------+-----------------+-----------------+
         */
        constructor: function () {

            Function.apply(this, arguments);

            this.name = 'SmallerThan';

            this.type(TBoolean);

        },

        /**
         * Gets the result of the function
         * @returns {boolean}
         */
        value: function () {

            return (compare(null, this.parameters[0], this.parameters[1]) < 0);

        }

    },{



    });

module.exports = FSmallerThan;
},{"./../../Function.js":5,"./../../helpers/compare":83,"./../../types/Boolean.js":95,"lodash":105}],45:[function(require,module,exports){
var Function = require('./../../Function.js');
var compare = require('./../../helpers/compare');
var TBoolean = require('./../../types/Boolean.js');
var _ = require('lodash');

var FSmallerThanEqual = Function.extend(

    {

        /**
         * @class Functions.Comparable.SmallerThanEqual
         * @extends Function
         *
         * Function that checks if a value is smaller than or equal to another one. It only applies
         * to types that implement a static "compare" method or to primitives.
         *
         * When used with an Extension operator :
         *
         *      var philosophers = new affinity.Relation([
         *              {name: { type: affinity.String}},
         *              {born: { type: affinity.Integer}},
         *              {died: { type: affinity.Integer}}
         *          ],[
         *              ['Aristotle', -384, -322],
         *              ['Plato',     -428, -348],
         *              ['Socrates',  -470, -399]
         *          ]);
         *
         *      name = philosophers.get('name');
         *      born = philosophers.get('born');
         *      died = philosophers.get('died');
         *
         *      var extended = philosophers.extend([{ diedUpTo348BC : died.ste(-348) }]);
         *
         *      // or equivalent :
         *
         *      var extended = philosophers.extend([{ diedUpTo348BC : new affinity.SmallerThanEqual(died, -348) }]);
         *
         *      extended.print();
         *
         *      // +----------------+-----------------+-----------------+--------------------------+
         *      // | name : TString | born : TInteger | died : TInteger | diedUpTo348BC : TBoolean |
         *      // +================+=================+=================+==========================+
         *      // | Aristotle      | -384            | -322            | true                     |
         *      // +----------------+-----------------+-----------------+--------------------------+
         *      // | Plato          | -428            | -348            | true                     |
         *      // +----------------+-----------------+-----------------+--------------------------+
         *      // | Socrates       | -470            | -399            | false                    |
         *      // +----------------+-----------------+-----------------+--------------------------+
         *
         *
         * When used with a Restriction operator :
         *
         *      var restricted = philosophers.restrict(died.ste(-348));
         *
         *      // or equivalent :
         *
         *      var restricted = philosophers.restrict(new affinity.SmallerThanEqual(died, -348));
         *
         *      restricted.print();
         *
         *      // +----------------+-----------------+-----------------+
         *      // | name : TString | born : TInteger | died : TInteger |
         *      // +================+=================+=================+
         *      // | Aristotle      | -384            | -322            |
         *      // +----------------+-----------------+-----------------+
         *      // | Plato          | -428            | -348            |
         *      // +----------------+-----------------+-----------------+
         *
         */
        constructor: function () {

            Function.apply(this, arguments);

            this.name = 'SmallerThanEqual';

            this.type(TBoolean);

        },

        /**
         * Gets the result of the function
         * @returns {boolean}
         */
        value: function () {

            return (compare(null, this.parameters[0], this.parameters[1]) <= 0);

        }

    },{



    });

module.exports = FSmallerThanEqual;
},{"./../../Function.js":5,"./../../helpers/compare":83,"./../../types/Boolean.js":95,"lodash":105}],46:[function(require,module,exports){
var Function = require('./../../Function.js');
var TBoolean = require('./../../types/Boolean.js');
var _ = require('lodash');

var And = Function.extend(
    {

        /**
         * @class Functions.Connective.And
         * @extends Function
         *
         * Function that checks if its arguments all return a true boolean.
         *
         * When used with an Extension operator :
         *
         *      var philosophers = new affinity.Relation([
         *              {name: { type: affinity.String}},
         *              {born: { type: affinity.Integer}},
         *              {died: { type: affinity.Integer}}
         *          ],[
         *              ['Aristotle', -384, -322],
         *              ['Plato',     -428, -348],
         *              ['Socrates',  -470, -399]
         *          ]);
         *
         *      name = philosophers.get('name');
         *      born = philosophers.get('born');
         *      died = philosophers.get('died');
         *
         *      var extended = philosophers.extend([{ "322to384BC" : died.eq(-322).and(born.eq(-384)) }]);
         *
         *      // or equivalent :
         *
         *      var extended = philosophers.extend([
         *          { diedIn322BC : new affinity.And(new affinity.Equal(died, -322), new affinity.Equal(born, -384)) }
         *      ]);
         *
         *      extended.print();
         *
         *      // +----------------+-----------------+-----------------+------------------------+
         *      // | name : TString | born : TInteger | died : TInteger | 322to384BC : TBoolean  |
         *      // +================+=================+=================+========================+
         *      // | Aristotle      | -384            | -322            | true                   |
         *      // +----------------+-----------------+-----------------+------------------------+
         *      // | Plato          | -428            | -348            | false                  |
         *      // +----------------+-----------------+-----------------+------------------------+
         *      // | Socrates       | -470            | -399            | false                  |
         *      // +----------------+-----------------+-----------------+------------------------+
         *
         *
         * When used with a Restriction operator :
         *
         *      var restricted = philosophers.restrict(died.eq(-322).and(born.eq(-384)));
         *
         *      // or equivalent :
         *
         *      var restricted = philosophers.restrict(
         *          new affinity.And(new affinity.Equal(died, -322), new affinity.Equal(born, -384))
         *      );
         *
         *      restricted.print();
         *
         *      // +----------------+-----------------+-----------------+
         *      // | name : TString | born : TInteger | died : TInteger |
         *      // +================+=================+=================+
         *      // | Aristotle      | -384            | -322            |
         *      // +----------------+-----------------+-----------------+
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TBoolean);

            this.name = 'And';

        },

        /**
         * Gets the function return value
         * @returns {boolean}
         */
        value: function () {

            return _.every(this.parameters, function(parameter){

                if(!_.isBoolean(parameter)){
                    parameter = parameter.value();
                }
                return parameter;

            });

        }

    },{



    });

module.exports = And;
},{"./../../Function.js":5,"./../../types/Boolean.js":95,"lodash":105}],47:[function(require,module,exports){
var Function = require('./../../Function.js');
var TBoolean = require('./../../types/Boolean.js');
var _ = require('lodash');

var Not = Function.extend(

    {

        /**
         * @class Functions.Connective.Not
         * @extends Function
         *
         * Function that checks if its argument returns false
         *
         * When used with an Extension operator :
         *
         *      var philosophers = new affinity.Relation([
         *              {name: { type: affinity.String}},
         *              {born: { type: affinity.Integer}},
         *              {died: { type: affinity.Integer}}
         *          ],[
         *              ['Aristotle', -384, -322],
         *              ['Plato',     -428, -348],
         *              ['Socrates',  -470, -399]
         *          ]);
         *
         *      name = philosophers.get('name');
         *      born = philosophers.get('born');
         *      died = philosophers.get('died');
         *
         *      var extended = philosophers.extend([{ "notBornIn384BC" : born.not().eq(-384) }]);
         *
         *      // or equivalent :
         *
         *      var extended = philosophers.extend([
         *          { diedIn322BC : new affinity.Not(new affinity.Equal(born, -322)) }
         *      ]);
         *
         *      extended.print();
         *
         *      // +----------------+-----------------+-----------------+----------------------------+
         *      // | name : TString | born : TInteger | died : TInteger | notBornIn384BC : TBoolean  |
         *      // +================+=================+=================+============================+
         *      // | Aristotle      | -384            | -322            | false                      |
         *      // +----------------+-----------------+-----------------+----------------------------+
         *      // | Plato          | -428            | -348            | true                       |
         *      // +----------------+-----------------+-----------------+----------------------------+
         *      // | Socrates       | -470            | -399            | true                       |
         *      // +----------------+-----------------+-----------------+----------------------------+
         *
         *
         * When used with a Restriction operator :
         *
         *      var restricted = philosophers.restrict(born.not().eq(-384));
         *
         *      // or equivalent :
         *
         *      var restricted = philosophers.restrict(
         *          new affinity.Not(new affinity.Equal(born, -322))
         *      );
         *
         *      restricted.print();
         *
         *      // +----------------+-----------------+-----------------+
         *      // | name : TString | born : TInteger | died : TInteger |
         *      // +================+=================+=================+
         *      // | Plato          | -428            | -348            |
         *      // +----------------+-----------------+-----------------+
         *      // | Socrates       | -470            | -399            |
         *      // +----------------+-----------------+-----------------+
         *
         */
        constructor: function () {

            Function.apply(this, arguments);

            this.type(TBoolean);

            this.name = 'Not';

        },

        /**
         * Gets the function return value
         * @returns {boolean}
         */
        value: function () {

            if(!_.isBoolean(this.parameters[0])){
                return !this.parameters[0].value();
            }

            return !this.parameters[0];

        }

    },{



    });

module.exports = Not;
},{"./../../Function.js":5,"./../../types/Boolean.js":95,"lodash":105}],48:[function(require,module,exports){
var Function = require('./../../Function.js');
var TBoolean = require('./../../types/Boolean.js');
var _ = require('lodash');

var Or = Function.extend(
    {

        /**
         * @class Functions.Connective.Or
         * @extends Function
         *
         * Function that checks if one of its arguments return true
         *
         * When used with an Extension operator :
         *
         *      var philosophers = new affinity.Relation([
         *              {name: { type: affinity.String}},
         *              {born: { type: affinity.Integer}},
         *              {died: { type: affinity.Integer}}
         *          ],[
         *              ['Aristotle', -384, -322],
         *              ['Plato',     -428, -348],
         *              ['Socrates',  -470, -399]
         *          ]);
         *
         *      name = philosophers.get('name');
         *      born = philosophers.get('born');
         *      died = philosophers.get('died');
         *
         *      var extended = philosophers.extend([{ "born384or428BC" : born.eq(-384).or(born.eq(-428)) }]);
         *
         *      // or equivalent :
         *
         *      var extended = philosophers.extend([
         *          { diedIn322BC : new affinity.Or(new affinity.Equal(born, -384), new affinity.Equal(born, -428)) }
         *      ]);
         *
         *      extended.print();
         *
         *      // +----------------+-----------------+-----------------+----------------------------+
         *      // | name : TString | born : TInteger | died : TInteger | born384or428BC : TBoolean  |
         *      // +================+=================+=================+============================+
         *      // | Aristotle      | -384            | -322            | true                       |
         *      // +----------------+-----------------+-----------------+----------------------------+
         *      // | Plato          | -428            | -348            | true                       |
         *      // +----------------+-----------------+-----------------+----------------------------+
         *      // | Socrates       | -470            | -399            | false                      |
         *      // +----------------+-----------------+-----------------+----------------------------+
         *
         *
         * When used with a Restriction operator :
         *
         *      var restricted = philosophers.restrict(born.eq(-384).or(born.eq(-428)));
         *
         *      // or equivalent :
         *
         *      var restricted = philosophers.restrict(
         *          new affinity.Or(new affinity.Equal(born, -384), new affinity.Equal(born, -428))
         *      );
         *
         *      restricted.print();
         *
         *      // +----------------+-----------------+-----------------+
         *      // | name : TString | born : TInteger | died : TInteger |
         *      // +================+=================+=================+
         *      // | Aristotle      | -384            | -322            |
         *      // +----------------+-----------------+-----------------+
         *      // | Plato          | -428            | -348            |
         *      // +----------------+-----------------+-----------------+
         *
         */
        constructor: function () {

            Function.apply(this, arguments);

            this.type(TBoolean);

            this.name = 'Or';

        },

        value: function () {


            return _.any(this.parameters, function(parameter){

                if(!_.isBoolean(parameter)){
                    parameter = parameter.value();
                }
                return parameter;

            });

        }

    },{


    });

module.exports = Or;
},{"./../../Function.js":5,"./../../types/Boolean.js":95,"lodash":105}],49:[function(require,module,exports){
var Function = require('./../../Function.js');
var TInteger = require('./../../types/Integer.js');
var value = require('./../../helpers/value');

var FDayOfMonth = Function.extend(
    {

        /**
         * @class Functions.Date.DayOfMonth
         * @extends Function
         *
         * Function that extracts a date's day of the month
         *
         * With extend operation :
         *
         *      var events = new affinity.Relation([
         *          {date : {type : affinity.Date}},
         *          {name : {type : affinity.String}}
         *      ],[
         *          [new Date(2014, 1, 07), 'Sochi'],
         *          [new Date(2014, 0, 02), 'Chocolate rush'],
         *          [new Date(2014, 3, 15), 'Millionth coffee drank']
         *      ])
         *
         *      var date = events.get('date')
         *
         *      var extended = events.extend([ { "date.dayOfMonth()" : date.dayOfMonth() } ]);
         *
         *      // or equivalent
         *
         *      var extended = events.extend([ { "date.dayOfMonth()" : new affinity.DayOfMonth(date) } ]);
         *
         *      extended.print();
         *
         *      +-------------------------------------------+--------------------------+-------------------------------+
         *      | date : Date                               | name : String            | date.dayOfMonth() : Integer   |
         *      +===========================================+==========================+===============================+
         *      | Fri Feb 07 2014 00:00:00 GMT-0500 (EST)   | Sochi                    | 7                             |
         *      +-------------------------------------------+--------------------------+-------------------------------+
         *      | Thu Jan 02 2014 00:00:00 GMT-0500 (EST)   | Chocolate rush           | 2                             |
         *      +-------------------------------------------+--------------------------+-------------------------------+
         *      | Tue Apr 15 2014 00:00:00 GMT-0400 (EDT)   | Millionth coffee drank   | 15                            |
         *      +-------------------------------------------+--------------------------+-------------------------------+
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TInteger);

            this.name = 'DayOfMonth';

        },

        /**
         * Gets the function's return value
         * @returns {number}
         */
        value: function () {

            return value(this.parameters[0]).getDate();

        }

    },{


    });

module.exports = FDayOfMonth;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../types/Integer.js":98}],50:[function(require,module,exports){
var Function = require('./../../Function.js');
var TInteger = require('./../../types/Integer.js');
var value = require('./../../helpers/value');

var FDayOfWeek = Function.extend(
    {

        /**
         * @class Functions.Date.DayOfWeek
         * @extends Function
         *
         * Function that extracts a date's day of the week
         *
         * Sunday is 0, Saturday is 6
         *
         * With extend operation :
         *
         *      var events = new affinity.Relation([
         *          {date : {type : affinity.Date}},
         *          {name : {type : affinity.String}}
         *      ],[
         *          [new Date(2014, 1, 07), 'Sochi'],
         *          [new Date(2014, 0, 02), 'Chocolate rush'],
         *          [new Date(2014, 3, 15), 'Millionth coffee drank']
         *      ])
         *
         *      var date = events.get('date')
         *
         *      var extended = events.extend([ { "date.dayOfWeek()" : date.dayOfWeek() } ]);
         *
         *      // or equivalent
         *
         *      var extended = events.extend([ { "date.dayOfWeek()" : new affinity.DayOfWeek(date) } ]);
         *
         *      extended.print();
         *
         *      // +-------------------------------------------+--------------------------+------------------------------+
         *      // | date : Date                               | name : String            | date.dayOfWeek() : Integer   |
         *      // +===========================================+==========================+==============================+
         *      // | Fri Feb 07 2014 00:00:00 GMT-0500 (EST)   | Sochi                    | 5                            |
         *      // +-------------------------------------------+--------------------------+------------------------------+
         *      // | Thu Jan 02 2014 00:00:00 GMT-0500 (EST)   | Chocolate rush           | 4                            |
         *      // +-------------------------------------------+--------------------------+------------------------------+
         *      // | Tue Apr 15 2014 00:00:00 GMT-0400 (EDT)   | Millionth coffee drank   | 2                            |
         *      // +-------------------------------------------+--------------------------+------------------------------+
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TInteger);

            this.name = 'DayOfWeek';

        },

        /**
         * Gets the function return value
         * @returns {number}
         */
        value: function () {

            return value(this.parameters[0]).getDay();

        }

    },{


    });

module.exports = FDayOfWeek;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../types/Integer.js":98}],51:[function(require,module,exports){
var Function = require('./../../Function.js');
var TInteger = require('./../../types/Integer.js');
var value = require('./../../helpers/value');

var FDayOfYear = Function.extend(
    {

        /**
         * @class Functions.Date.DayOfYear
         * @extends Function
         *
         * Function that extracts a date's day of the year
         *
         * January 1st is 0
         *
         * With extend operation :
         *
         *      var events = new affinity.Relation([
         *          {date : {type : affinity.Date}},
         *          {name : {type : affinity.String}}
         *      ],[
         *          [new Date(2014, 1, 07), 'Sochi'],
         *          [new Date(2014, 0, 02), 'Chocolate rush'],
         *          [new Date(2014, 3, 15), 'Millionth coffee drank']
         *      ])
         *
         *      var date = events.get('date')
         *
         *      var extended = events.extend([ { "date.dayOfYear()" : date.dayOfYear() } ]);
         *
         *      // or equivalent
         *
         *      var extended = events.extend([ { "date.dayOfYear()" : new affinity.DayOfYear(date) } ]);
         *
         *      extended.print();
         *
         *      // +-------------------------------------------+--------------------------+------------------------------+
         *      // | date : Date                               | name : String            | date.dayOfYear() : Integer   |
         *      // +===========================================+==========================+==============================+
         *      // | Fri Feb 07 2014 00:00:00 GMT-0500 (EST)   | Sochi                    | 37                           |
         *      // +-------------------------------------------+--------------------------+------------------------------+
         *      // | Thu Jan 02 2014 00:00:00 GMT-0500 (EST)   | Chocolate rush           | 1                            |
         *      // +-------------------------------------------+--------------------------+------------------------------+
         *      // | Tue Apr 15 2014 00:00:00 GMT-0400 (EDT)   | Millionth coffee drank   | 104                          |
         *      // +-------------------------------------------+--------------------------+------------------------------+
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TInteger);

            this.name = 'DayOfYear';

        },

        value: function () {

            var date = value(this.parameters[0]);

            var begin = new Date(date.getFullYear(),0,1);

            return Math.ceil((date - begin) / 86400000);

        }

    },{


    });

module.exports = FDayOfYear;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../types/Integer.js":98}],52:[function(require,module,exports){
var Function = require('./../../Function.js');
var TInteger = require('./../../types/Integer.js');
var value = require('./../../helpers/value');

var FHours = Function.extend(
    {

        /**
         * @class Functions.Date.Hours
         * @extends Function
         *
         * Function that extracts a date's hours component as an integer
         *
         * Midnight is 0
         *
         * With extend operation :
         *
         *      var wokeUp = new Date();
         *      wokeUp.setHours(8);
         *
         *      var breakfast = new Date();
         *      breakfast.setHours(9)
         *
         *      var dinner = new Date();
         *      dinner.setHours(18);
         *
         *      var events = new affinity.Relation([
         *          {time : {type : affinity.Date}},
         *          {name : {type : affinity.String}}
         *      ],[
         *          [wokeUp, 'Woke Up'],
         *          [breakfast, 'Breakfast'],
         *          [dinner, 'Dinner']
         *      ])
         *
         *      var time = events.get('time')
         *
         *      var extended = events.extend([ { "time.hours()" : time.hours() } ]);
         *
         *      // or equivalent
         *
         *      var extended = events.extend([ { "time.hours()" : new affinity.Hours(time) } ]);
         *
         *      extended.print();
         *
         *      // +-------------------------------------------+-----------------+--------------------------+
         *      // | time : Date                               | name : String   | time.hours() : Integer   |
         *      // +===========================================+=================+==========================+
         *      // | Sun Jun 29 2014 08:43:39 GMT-0400 (EDT)   | Woke Up         | 8                        |
         *      // +-------------------------------------------+-----------------+--------------------------+
         *      // | Sun Jun 29 2014 09:43:39 GMT-0400 (EDT)   | Breakfast       | 9                        |
         *      // +-------------------------------------------+-----------------+--------------------------+
         *      // | Sun Jun 29 2014 18:43:39 GMT-0400 (EDT)   | Dinner          | 18                       |
         *      // +-------------------------------------------+-----------------+--------------------------+
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TInteger);

            this.name = 'Hours';

        },

        /**
         * Gets the function's return value
         * @returns {number}
         */
        value: function () {

            return value(this.parameters[0]).getHours();

        }

    },{


    });

module.exports = FHours;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../types/Integer.js":98}],53:[function(require,module,exports){
var Function = require('./../../Function.js');
var TInteger = require('./../../types/Integer.js');
var value = require('./../../helpers/value');

var FMilliseconds = Function.extend(
    {

        /**
         * @class Functions.Date.Milliseconds
         * @extends Function
         *
         * Function that extracts a date's milliseconds component
         *
         * Midnight is 0
         *
         * With extend operation :
         *
         *      var date1 = new Date();
         *      date1.setMilliseconds(100);
         *
         *
         *      var date2 = new Date();
         *      date2.setMilliseconds(200);
         *
         *      var date3 = new Date();
         *      date3.setMilliseocnds(300);
         *
         *      var events = new affinity.Relation([
         *          {time : {type : affinity.Date}}
         *      ],[
         *         [date1], [date2], [date3]
         *      ])
         *
         *      var time = events.get('time')
         *
         *      var extended = events.extend([ { "time.milliseconds()" : time.milliseconds() } ]);
         *
         *      // or equivalent
         *
         *      var extended = events.extend([ { "time.milliseconds()" : new affinity.Milliseconds(time) } ]);
         *
         *      extended.print();
         *
         *      // +-------------------------------------------+---------------------------------+
         *      // | time : Date                               | time.milliseconds() : Integer   |
         *      // +===========================================+=================================+
         *      // | Sun Jun 29 2014 08:44:17 GMT-0400 (EDT)   | 100                             |
         *      // +-------------------------------------------+---------------------------------+
         *      // | Sun Jun 29 2014 08:44:17 GMT-0400 (EDT)   | 200                             |
         *      // +-------------------------------------------+---------------------------------+
         *      // | Sun Jun 29 2014 08:44:17 GMT-0400 (EDT)   | 557                             |
         *      // +-------------------------------------------+---------------------------------+
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TInteger);

            this.name = 'Milliseconds';

        },

        /**
         * Gets the function return value
         * @returns {number}
         */
        value: function () {

            return value(this.parameters[0]).getMilliseconds();

        }

    },{


    });

module.exports = FMilliseconds;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../types/Integer.js":98}],54:[function(require,module,exports){
var Function = require('./../../Function.js');
var TInteger = require('./../../types/Integer.js');
var value = require('./../../helpers/value');

var FMinutes = Function.extend(
    {

        /**
         * @class Functions.Date.Minutes
         * @extends Function
         *
         * Function that extracts a date's minutes component as an integer
         *
         *
         * With extend operation :
         *
         *      var quarterToFive = new Date();
         *      quarterToFive.setHours(4);
         *      quarterToFive.setMinutes(45);
         *
         *      var five = new Date();
         *      five.setHours(5)
         *      five.setMinutes(0);
         *
         *      var sixThirty = new Date();
         *      sixThirty.setHours(6);
         *      sixThirty.setMinutes(30);
         *
         *
         *      var events = new affinity.Relation([
         *          {time : {type : affinity.Date}},
         *          {name : {type : affinity.String}}
         *      ],[
         *          [quarterToFive, 'Quarter to Five'],
         *          [five, 'Five'],
         *          [sixThirty, 'Six Thirty']
         *      ])
         *
         *      var time = events.get('time')
         *
         *      var extended = events.extend([ { "time.minutes()" : time.minutes() } ]);
         *
         *      // or equivalent
         *
         *      var extended = events.extend([ { "time.minutes()" : new affinity.Minutes(time) } ]);
         *
         *      extended.print();
         *
         *      // +-------------------------------------------+-------------------+----------------------------+
         *      // | time : Date                               | name : String     | time.minutes() : Integer   |
         *      // +===========================================+===================+============================+
         *      // | Sun Jun 29 2014 04:45:49 GMT-0400 (EDT)   | Quarter to Five   | 45                         |
         *      // +-------------------------------------------+-------------------+----------------------------+
         *      // | Sun Jun 29 2014 05:00:49 GMT-0400 (EDT)   | Five              | 0                          |
         *      // +-------------------------------------------+-------------------+----------------------------+
         *      // | Sun Jun 29 2014 06:30:49 GMT-0400 (EDT)   | Six Thirty        | 30                         |
         *      // +-------------------------------------------+-------------------+----------------------------+
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TInteger);

            this.name = 'Minutes';

        },

        value: function () {

            return value(this.parameters[0]).getMinutes();

        }

    },{


    });

module.exports = FMinutes;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../types/Integer.js":98}],55:[function(require,module,exports){
var Function = require('./../../Function.js');
var TInteger = require('./../../types/Integer.js');
var value = require('./../../helpers/value');

var FMonth = Function.extend(
    {

        /**
         * @class Functions.Date.Month
         * @extends Function
         *
         * Function that extracts a date's month number
         *
         * January is 0
         *
         * With extend operation :
         *
         *      var events = new affinity.Relation([
         *          {date : {type : affinity.Date}},
         *          {name : {type : affinity.String}}
         *      ],[
         *          [new Date(2014, 1, 07), 'Sochi'],
         *          [new Date(2014, 0, 02), 'Chocolate rush'],
         *          [new Date(2014, 3, 15), 'Millionth coffee drank']
         *      ])
         *
         *      var date = events.get('date')
         *
         *      var extended = events.extend([ { "date.month()" : date.month() } ]);
         *
         *      // or equivalent
         *
         *      var extended = events.extend([ { "date.month()" : new affinity.Month(date) } ]);
         *
         *      extended.print();
         *
         *      // +-------------------------------------------+--------------------------+--------------------------+
         *      // | date : Date                               | name : String            | date.month() : Integer   |
         *      // +===========================================+==========================+==========================+
         *      // | Fri Feb 07 2014 00:00:00 GMT-0500 (EST)   | Sochi                    | 1                        |
         *      // +-------------------------------------------+--------------------------+--------------------------+
         *      // | Thu Jan 02 2014 00:00:00 GMT-0500 (EST)   | Chocolate rush           | 0                        |
         *      // +-------------------------------------------+--------------------------+--------------------------+
         *      // | Tue Apr 15 2014 00:00:00 GMT-0400 (EDT)   | Millionth coffee drank   | 3                        |
         *      // +-------------------------------------------+--------------------------+--------------------------+
         *      //
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TInteger);

            this.name = 'Month';

        },

        value: function () {

            return value(this.parameters[0]).getMonth();

        }

    },{


    });

module.exports = FMonth;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../types/Integer.js":98}],56:[function(require,module,exports){
var Function = require('./../../Function.js');
var TInteger = require('./../../types/Integer.js');
var value = require('./../../helpers/value');

var Seconds = Function.extend(
    {

        /**
         * @class Functions.Date.Seconds
         * @extends Function
         *
         * Function that extracts a date's second number
         *
         * With extend operation :
         *
         *      var events = new affinity.Relation([
         *          {date : {type : affinity.Date}},
         *          {name : {type : affinity.String}}
         *      ],[
         *          [new Date(), 'Now'],
         *      ])
         *
         *      var date = events.get('date')
         *
         *      var extended = events.extend([ { "date.seconds()" : date.seconds() } ]);
         *
         *      // or equivalent
         *
         *      var extended = events.extend([ { "date.seconds()" : new affinity.Seconds(date) } ]);
         *
         *      extended.print();
         *
         *      // +-------------------------------------------+-----------------+----------------------------+
         *      // | date : Date                               | name : String   | date.seconds() : Integer   |
         *      // +===========================================+=================+============================+
         *      // | Sun Jun 29 2014 08:51:05 GMT-0400 (EDT)   | Now             | 5                          |
         *      // +-------------------------------------------+-----------------+----------------------------+
         *      //
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TInteger);

            this.name = 'Seconds';

        },

        /**
         * Gets the function return value
         * @returns {number}
         */
        value: function () {

            return value(this.parameters[0]).getSeconds();

        }

    },{


    });

module.exports = Seconds;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../types/Integer.js":98}],57:[function(require,module,exports){
var Function = require('./../../Function.js');
var Integer = require('./../../types/Integer.js');
var value = require('./../../helpers/value');

var Timestamp = Function.extend(

    {

        /**
         * @class Functions.Date.Timestamp
         * @extends Function
         *
         * Function that extracts a date's timestamp
         *
         * With extend operation :
         *
         *      var events = new affinity.Relation([
         *          {date : {type : affinity.Date}},
         *          {name : {type : affinity.String}}
         *      ],[
         *          [new Date(), 'Now'],
         *      ])
         *
         *      var date = events.get('date')
         *
         *      var extended = events.extend([ { "date.timestamp()" : date.ts() } ]);
         *
         *      // or equivalent
         *
         *      var extended = events.extend([ { "date.timestamp()" : new affinity.Timestamp(date) } ]);
         *
         *      extended.print();
         *
         *      // +-------------------------------------------+-----------------+------------------------------+
         *      // | date : Date                               | name : String   | date.timestamp() : Integer   |
         *      // +===========================================+=================+==============================+
         *      // | Sun Jun 29 2014 10:02:34 GMT-0400 (EDT)   | Now             | 1404050554805                |
         *      // +-------------------------------------------+-----------------+------------------------------+
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(Integer);

            this.name = 'Timestamp';

        },

        value: function () {

            var param = value(this.parameters[0]);

            return value(this.parameters[0]).getTime();

        }

    },{


    });

module.exports = Timestamp;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../types/Integer.js":98}],58:[function(require,module,exports){
var Function = require('./../../Function.js');
var TInteger = require('./../../types/Integer.js');
var value = require('./../../helpers/value');

var WeekOfYear = Function.extend(
    {

        /**
         * @class Functions.Date.WeekOfYear
         * @extends Function
         *
         * Function that extracts a date's week number (0-51)
         *
         * With extend operation :
         *
         *      var events = new affinity.Relation([
         *          {date : {type : affinity.Date}},
         *          {name : {type : affinity.String}}
         *      ],[
         *          [new Date(2014, 02, 07), 'Sochi'],
         *          [new Date(2014, 01, 02), 'Chocolate rush'],
         *          [new Date(2014, 04, 15), 'Millionth coffee drank']
         *      ])
         *
         *      var date = events.get('date')
         *
         *      var extended = events.extend([ { "date.weekOfYear()" : date.weekOfYear() } ]);
         *
         *      // or equivalent
         *
         *      var extended = events.extend([ { "date.weekOfYear()" : new affinity.weekOfYear(date) } ]);
         *
         *      extended.print();
         *
         *      // +-------------------------------------------+--------------------------+-------------------------------+
         *      // | date : Date                               | name : String            | date.weekOfYear() : Integer   |
         *      // +===========================================+==========================+===============================+
         *      // | Fri Mar 07 2014 00:00:00 GMT-0500 (EST)   | Sochi                    | 10                            |
         *      // +-------------------------------------------+--------------------------+-------------------------------+
         *      // | Sun Feb 02 2014 00:00:00 GMT-0500 (EST)   | Chocolate rush           | 5                             |
         *      // +-------------------------------------------+--------------------------+-------------------------------+
         *      // | Thu May 15 2014 00:00:00 GMT-0400 (EDT)   | Millionth coffee drank   | 20                            |
         *      // +-------------------------------------------+--------------------------+-------------------------------+
         *      //
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TInteger);

            this.name = 'WeekOfYear';

        },

        /**
         * Gets the function return value
         * @returns {number}
         */
        value: function () {

            var d = new Date(+value(this.parameters[0]));
            d.setHours(0,0,0);
            d.setDate(d.getDate()+4-(d.getDay()||7));
            return Math.ceil((((d-new Date(d.getFullYear(),0,1))/8.64e7)+1)/7);

        }

    },{


    });

module.exports = WeekOfYear;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../types/Integer.js":98}],59:[function(require,module,exports){
var Function = require('./../../Function.js');
var TInteger = require('./../../types/Integer.js');
var value = require('./../../helpers/value');

var Year = Function.extend(
    {

        /**
         * @class Functions.Date.Year
         * @extends Function
         *
         *
         * Function that extracts a date's full year number
         *
         * With extend operation :
         *
         *      var events = new affinity.Relation([
         *          {date : {type : affinity.Date}},
         *          {name : {type : affinity.String}}
         *      ],[
         *          [new Date(2013, 01, 02)],
         *          [new Date(2011, 06, 30)],
         *          [new Date(2010, 04, 15)]
         *      ])
         *
         *      var date = events.get('date')
         *
         *      var extended = events.extend([ { "date.year()" : date.year() } ]);
         *
         *      // or equivalent
         *
         *      var extended = events.extend([ { "date.year()" : new affinity.Year(date) } ]);
         *
         *      extended.print();
         *
         *      // +-------------------------------------------+--------------------------+-------------------------+
         *      // | date : Date                               | name : String            | date.year() : Integer   |
         *      // +===========================================+==========================+=========================+
         *      // | Fri Mar 07 2014 00:00:00 GMT-0500 (EST)   | Sochi                    | 2014                    |
         *      // +-------------------------------------------+--------------------------+-------------------------+
         *      // | Sun Feb 02 2014 00:00:00 GMT-0500 (EST)   | Chocolate rush           | 2014                    |
         *      // +-------------------------------------------+--------------------------+-------------------------+
         *      // | Thu May 15 2014 00:00:00 GMT-0400 (EDT)   | Millionth coffee drank   | 2014                    |
         *      // +-------------------------------------------+--------------------------+-------------------------+
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TInteger);

            this.name = 'Year';

        },

        value: function () {

            return value(this.parameters[0]).getFullYear();

        }

    },{


    });

module.exports = Year;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../types/Integer.js":98}],60:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');

var Absolute = Function.extend(
    {

        /**
         * @class Functions.Numeric.Absolute
         * @extends Function
         *
         * Function that extracts the Absolute value of a Number
         *
         * Example with Extend operator :
         *
         *      var relation = new affinity.Relation([
         *          { A :  {type : affinity.Integer} },
         *      ],[
         *          [-10], [-5], [0], [5], [10]]
         *      ])
         *
         *      var A = relation.get('A');
         *
         *
         *      var extended = relation.extend([{ "A.abs()" : A.abs() }]);
         *
         *      // or
         *
         *      var extended = relation.extend([{ "A.abs()" : new affinity.Absolute(A) }]);
         *
         *      extended.print();
         *
         *      //+---------------+---------------------+
         *      //| A : Integer   | A.abs() : Integer   |
         *      //+===============+=====================+
         *      //| -10           | 10                  |
         *      //+---------------+---------------------+
         *      //| -5            | 5                   |
         *      //+---------------+---------------------+
         *      //| 0             | 0                   |
         *      //+---------------+---------------------+
         *      //| 5             | 5                   |
         *      //+---------------+---------------------+
         *      //| 10            | 10                  |
         *      //+---------------+---------------------+
         *
         */

        /**
         * @param {Number|Function|Attribute} param The number to absolucize
         *
         * Create a new Absolute function
         */
        constructor: function (param) {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TNumeric);

            this.name = 'Absolute';

        },

        /**
         * @returns {Number} The result
         *
         * Gets the function result
         */
        value: function () {

            return Math.abs(value(this.parameters[0]));

        }

    });

Absolute.mixin(require('./../../mixins/numeric'));
Absolute.mixin(require('./../../mixins/comparable'));
Absolute.mixin(require('./../../mixins/size-comparable'));

module.exports = Absolute;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../mixins/comparable":88,"./../../mixins/numeric":92,"./../../mixins/size-comparable":93,"./../../types/Numeric.js":99}],61:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');

var FCeil = Function.extend(
    {

        /**
         * @class Functions.Numeric.Ceil
         * @extends Function
         *
         * Function that rounds a number upwards
         *
         * Example with Extend operator :
         *
         *      var relation = new affinity.Relation([
         *          { A :  {type : affinity.Integer} },
         *      ],[
         *          [1.01], [-2.85], [3], [3.12], [10.2]]
         *      ])
         *
         *      var A = relation.get('A');
         *
         *
         *      var extended = relation.extend([{ "A.ceil()" : A.ceil() }]);
         *
         *      // or
         *
         *      var extended = relation.extend([{ "A.ceil()" : new affinity.Ceil(A) }]);
         *
         *      extended.print();
         *
         *      //+---------------+----------------------+
         *      //| A : Integer   | A.ceil() : Integer   |
         *      //+===============+======================+
         *      //| 1.01          | 2                    |
         *      //+---------------+----------------------+
         *      //| -2.85         | -2                   |
         *      //+---------------+----------------------+
         *      //| 3             | 3                    |
         *      //+---------------+----------------------+
         *      //| 3.12          | 4                    |
         *      //+---------------+----------------------+
         *      //| 10.2          | 11                   |
         *      //+---------------+----------------------+
         *
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TNumeric);

            this.name = 'Ceil';

        },

        /**
         * Gets the function return value
         * @returns {number}
         */
        value: function () {

            return Math.ceil(value(this.parameters[0]));

        }

    });

FCeil.mixin(require('./../../mixins/numeric'));
FCeil.mixin(require('./../../mixins/comparable'));
FCeil.mixin(require('./../../mixins/size-comparable'));

module.exports = FCeil;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../mixins/comparable":88,"./../../mixins/numeric":92,"./../../mixins/size-comparable":93,"./../../types/Numeric.js":99}],62:[function(require,module,exports){
var Function = require('./../../Function.js');
var Numeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');

var Cosine = Function.extend(
    {

        /**
         * @class Functions.Numeric.Cosine
         * @extends Function
         *
         * Function that returns the cosine of a number
         *
         * Example with Extend operator :
         *
         *      var relation = new affinity.Relation([
         *          { A :  {type : affinity.Integer} },
         *      ],[
         *          [0], [Math.PI/2], [Math.PI], [3*Math.PI/2], [2*Math.PI]
         *      ])
         *
         *      var A = relation.get('A');
         *
         *
         *      var extended = relation.extend([{ "cos(A)" : A.cos() }]);
         *
         *      // or
         *
         *      var extended = relation.extend([{ "cos(A)" : new affinity.Cosine(A) }]);
         *
         *      extended.print();
         *
         *      // The following result shows a bug, but it's not affinity's fault.
         *      // Due to a bug in V8
         *      // (see this http://stackoverflow.com/questions/24455775/why-does-node-not-evaluate-math-tanmath-pi-2-to-infinity-but-chrome-v8-does)
         *      // Math.tan(Math.PI/2) won't evaluate to Infinity.
         *      // Math.tan(Math.PI) won't evaluate to 0.
         *      // And so on. This is due to Math.cos(Math.PI/2) not evaluating to 0.
         *
         *      // This will be fixed in node v0.11. as I tested the v0.11.14-pre version.
         *
         *      //+---------------+--------------------------+
         *      //| A : Integer   | cos(A) : Numeric         |
         *      //+===============+==========================+
         *      //| 0             | 1                        |
         *      //+---------------+--------------------------+
         *      //| PI/2          | 6.123031769111886e-17    |
         *      //+---------------+--------------------------+
         *      //|              | -1                       |
         *      //+---------------+--------------------------+
         *      //| 3/2          | -1.836909530733566e-16   |
         *      //+---------------+--------------------------+
         *      //| 2            | 1                        |
         *      //+---------------+--------------------------+
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(Numeric);

            this.name = 'Cos';

        },

        /**
         * Gets the function result
         * @returns {Number}
         */
        value: function () {

            return Math.cos(value(this.parameters[0]));

        }

    });

Cosine.mixin(require('./../../mixins/numeric'));
Cosine.mixin(require('./../../mixins/comparable'));
Cosine.mixin(require('./../../mixins/size-comparable'));

module.exports = Cosine;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../mixins/comparable":88,"./../../mixins/numeric":92,"./../../mixins/size-comparable":93,"./../../types/Numeric.js":99}],63:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');

var FDivision = Function.extend(
    {

        /**
         * @class Functions.Numeric.Division
         * @extends Function
         *
         * Function that returns the result of a division between two numbers
         *
         * Example with Extend operator :
         *
         *      var relation = new affinity.Relation([
         *          { A :  {type : affinity.Integer} },
         *      ],[
         *          [-2], [-1], [0], [1], [2]]
         *      ])
         *
         *      var relation2 = relation.extend([{B : relation.get('A')}]);
         *
         *      var product = relation2.project(['A']).product(relation2.get('B'));
         *
         *      var A = product.get('A');
         *      var B = product.get('B');
         *
         *
         *      var extended = product.extend([{"A / B" : A.div(B)}]);
         *
         *      // or equivalent
         *
         *      new affinity.Extend(product, [{ "A / B" : new affinity.Division(A, B) }])
         *
         *
         *      extended.print();
         *
         *
         *      // (Standard behaviour of JavaScript)
         *      // +---------------+---------------+-----------------+
         *      // | A : Integer   | B : Integer   | A / B : Numeric |
         *      // +===============+===============+=================+
         *      // | -2            | -2            | 1               |
         *      // +---------------+---------------+-----------------+
         *      // | -2            | -1            | 2               |
         *      // +---------------+---------------+-----------------+
         *      // | -2            | 0             | -Infinity       |
         *      // +---------------+---------------+-----------------+
         *      // | -2            | 1             | -2              |
         *      // +---------------+---------------+-----------------+
         *      // | -2            | 2             | -1              |
         *      // +---------------+---------------+-----------------+
         *      // | -1            | -2            | 0.5             |
         *      // +---------------+---------------+-----------------+
         *      // | -1            | -1            | 1               |
         *      // +---------------+---------------+-----------------+
         *      // | -1            | 0             | -Infinity       |
         *      // +---------------+---------------+-----------------+
         *      // | -1            | 1             | -1              |
         *      // +---------------+---------------+-----------------+
         *      // | -1            | 2             | -0.5            |
         *      // +---------------+---------------+-----------------+
         *      // | 0             | -2            | 0               |
         *      // +---------------+---------------+-----------------+
         *      // | 0             | -1            | 0               |
         *      // +---------------+---------------+-----------------+
         *      // | 0             | 0             | NaN             |
         *      // +---------------+---------------+-----------------+
         *      // | 0             | 1             | 0               |
         *      // +---------------+---------------+-----------------+
         *      // | 0             | 2             | 0               |
         *      // +---------------+---------------+-----------------+
         *      // | 1             | -2            | -0.5            |
         *      // +---------------+---------------+-----------------+
         *      // | 1             | -1            | -1              |
         *      // +---------------+---------------+-----------------+
         *      // | 1             | 0             | Infinity        |
         *      // +---------------+---------------+-----------------+
         *      // | 1             | 1             | 1               |
         *      // +---------------+---------------+-----------------+
         *      // | 1             | 2             | 0.5             |
         *      // +---------------+---------------+-----------------+
         *      // | 2             | -2            | -1              |
         *      // +---------------+---------------+-----------------+
         *      // | 2             | -1            | -2              |
         *      // +---------------+---------------+-----------------+
         *      // | 2             | 0             | Infinity        |
         *      // +---------------+---------------+-----------------+
         *      // | 2             | 1             | 2               |
         *      // +---------------+---------------+-----------------+
         *      // | 2             | 2             | 1               |
         *      // +---------------+---------------+-----------------+
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TNumeric);

            this.name = 'Division';

        },

        /**
         * Gets the function result
         * @returns {number}
         */
        value: function () {

            return value(this.parameters[0])/value(this.parameters[1]);

        }

    });

FDivision.mixin(require('./../../mixins/numeric'));
FDivision.mixin(require('./../../mixins/comparable'));
FDivision.mixin(require('./../../mixins/size-comparable'));

module.exports = FDivision;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../mixins/comparable":88,"./../../mixins/numeric":92,"./../../mixins/size-comparable":93,"./../../types/Numeric.js":99}],64:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');

var FExp = Function.extend(
    {

        /**
         * @class Functions.Numeric.Exponential
         * @extends Function
         *
         * Returns the exponential of a number (e^x)
         *
         * Example :
         *
         *     var relation = new affinity.Relation([{ A : {type : affinity.Integer} }],[[-2], [-1],[0],[1],[2]]);
         *
         *     var extended = relation.extend([{ "A.exp()" : relation.get('A').exp()}])
         *
         *     or equivalent
         *
         *     var extended = relation.extend([{ "A.exp()" : new affinity.Exp(A)}]);
         *
         *     extended.print();
         *
         *     // +---------------+-----------------------+
         *     // | A : Integer   | A.exp() : Numeric     |
         *     // +===============+=======================+
         *     // | -2            | 0.1353352832366127    |
         *     // +---------------+-----------------------+
         *     // | -1            | 0.36787944117144233   |
         *     // +---------------+-----------------------+
         *     // | 0             | 1                     |
         *     // +---------------+-----------------------+
         *     // | 1             | 2.718281828459045     |
         *     // +---------------+-----------------------+
         *     // | 2             | 7.38905609893065      |
         *     // +---------------+-----------------------+
         *
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TNumeric);

            this.name = 'Exponent';

        },

        /**
         * Gets the function result
         * @returns {number}
         */
        value: function () {

            return Math.exp(value(this.parameters[0]));

        }

    });

FExp.mixin(require('./../../mixins/numeric'));
FExp.mixin(require('./../../mixins/comparable'));
FExp.mixin(require('./../../mixins/size-comparable'));

module.exports = FExp;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../mixins/comparable":88,"./../../mixins/numeric":92,"./../../mixins/size-comparable":93,"./../../types/Numeric.js":99}],65:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');

var Floor = Function.extend(
    {

        /**
         * @class Functions.Numeric.Floor
         * @extends Function
         *
         * Function that rounds a number downwards
         *
         * Example with Extend operator :
         *
         *      var relation = new affinity.Relation([
         *          { A :  {type : affinity.Integer} },
         *      ],[
         *          [1.01], [-2.85], [3], [3.12], [10.2]]
         *      ])
         *
         *      var A = relation.get('A');
         *
         *
         *      var extended = relation.extend([{ "A.floor()" : A.Floor() }]);
         *
         *      // or
         *
         *      var extended = relation.extend([{ "A.floor()" : new affinity.floor(A) }]);
         *
         *      extended.print();
         *
         *      //+---------------+-----------------------+
         *      //| A : Integer   | A.floor() : Integer   |
         *      //+===============+=======================+
         *      //| 1.01          | 1                     |
         *      //+---------------+-----------------------+
         *      //| -2.85         | -3                    |
         *      //+---------------+-----------------------+
         *      //| 3             | 3                     |
         *      //+---------------+-----------------------+
         *      //| 3.12          | 3                     |
         *      //+---------------+-----------------------+
         *      //| 10.2          | 10                    |
         *      //+---------------+-----------------------+
         *
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TNumeric);

            this.name = 'Floor';

        },

        /**
         * Gets the function return value
         * @returns {number}
         */
        value: function () {

            return Math.floor(value(this.parameters[0]));

        }

    });

Floor.mixin(require('./../../mixins/numeric'));
Floor.mixin(require('./../../mixins/comparable'));
Floor.mixin(require('./../../mixins/size-comparable'));

module.exports = Floor;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../mixins/comparable":88,"./../../mixins/numeric":92,"./../../mixins/size-comparable":93,"./../../types/Numeric.js":99}],66:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');
var type = require('./../../helpers/type');

var FMinus = Function.extend(
    {

        /**
         * @class Functions.Numeric.Minus
         * @extends Function
         *
         * Subtracts two numbers
         *
         * Example :
         *
         *     var relation = new affinity.Relation([
         *              {A : {type : affinity.Integer}},
         *              {B : {type : affinity.Integer}}
         *          ],[
         *              [1, 2],
         *              [0, 0],
         *              [10, 1]
         *          ]);
         *
         *     var A = relation.get('A');
         *     var B = relation.get('B');
         *
         *     var extended = relation.extend([{ "A - B" : A.minus(B)}])
         *
         *     // or equivalent
         *
         *     var extended = relation.extend([{"A - B" : new affinity.Minus(A, B)}])
         *
         *     extended.print();
         *
         *     // +---------------+---------------+-------------------+
         *     // | A : Integer   | B : Integer   | A - B : Integer   |
         *     // +===============+===============+===================+
         *     // | 1             | 2             | -1                |
         *     // +---------------+---------------+-------------------+
         *     // | 0             | 0             | 0                 |
         *     // +---------------+---------------+-------------------+
         *     // | 10            | 1             | 9                 |
         *     // +---------------+---------------+-------------------+
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(type(this.parameters[0]));

            this.name = 'Minus';

        },

        /**
         * Gets the function return value
         * @returns {number}
         */
        value: function () {

            return this.type().coerce(value(this.parameters[0])-value(this.parameters[1]));

        }

    });

FMinus.mixin(require('./../../mixins/numeric'));
FMinus.mixin(require('./../../mixins/comparable'));
FMinus.mixin(require('./../../mixins/size-comparable'));

module.exports = FMinus;
},{"./../../Function.js":5,"./../../helpers/type":86,"./../../helpers/value":87,"./../../mixins/comparable":88,"./../../mixins/numeric":92,"./../../mixins/size-comparable":93,"./../../types/Numeric.js":99}],67:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');

var FModulo = Function.extend(
    {

        /**
         * @class Functions.Numeric.Modulo
         * @extends Function
         *
         * Gets the modulo of two numbers
         *
         * Example :
         *
         *     var relation = new affinity.Relation([
         *              {A : {type : affinity.Integer}},
         *              {B : {type : affinity.Integer}}
         *          ],[
         *              [1, 2],
         *              [0, 0],
         *              [10, 1],
         *              [10, 2]
         *          ]);
         *
         *     var A = relation.get('A');
         *     var B = relation.get('B');
         *
         *     var extended = relation.extend([{"A % B" : A.mod(B)}]);
         *
         *     // or equivalent
         *
         *     var extended = relation.extend([{"A % B" : new affinity.Modulo(A, B)}]);
         *
         *     extended.print();
         *
         *     // +---------------+---------------+--------------------+
         *     // | A : Integer   | B : Integer   | A % B : Numeric    |
         *     // +===============+===============+====================+
         *     // | 1             | 2             | 1                  |
         *     // +---------------+---------------+--------------------+
         *     // | 0             | 0             | NaN                |
         *     // +---------------+---------------+--------------------+
         *     // | 10            | 1             | 0                  |
         *     // +---------------+---------------+--------------------+
         *     // | 10            | 2             | 0                  |
         *     // +---------------+---------------+--------------------+
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TNumeric);

            this.name = 'Modulo';

        },

        /**
         * Gets the function return value
         * @returns {number}
         */
        value : function () {

            return value(this.parameters[0])%value(this.parameters[1]);

        }

    });

FModulo.mixin(require('./../../mixins/numeric'));
FModulo.mixin(require('./../../mixins/comparable'));
FModulo.mixin(require('./../../mixins/size-comparable'));

module.exports = FModulo;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../mixins/comparable":88,"./../../mixins/numeric":92,"./../../mixins/size-comparable":93,"./../../types/Numeric.js":99}],68:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');

var FMultiplication = Function.extend(
    {

        /**
         * @class Functions.Numeric.Multiplication
         * @extends Function
         *
         * Multiplies two numbers
         *
         * example :
         *
         *     var relation = new affinity.Relation([
         *          { A : { type : affinity.Integer}},
         *          { B : { type : affinity.Integer}},
         *     ],[
         *          [1, -1],
         *          [-1, 1],
         *          [0, 10],
         *          [1, 10],
         *          [2, -10],
         *     ])
         *
         *     var A = relation.get('A')
         *     var B = relation.get('B')
         *
         *     var extended = relation.extend([{ "A x B" : A.times(B)}])
         *
         *     // or
         *
         *     var extended = relation.extend([{ "A x B" : new affinity.Multiplication(A, B)}])
         *
         *     extended.print()
         *
         *     // +---------------+---------------+-----------------+
         *     // | A : Integer   | B : Integer   | A x B : Numeric |
         *     // +===============+===============+=================+
         *     // | 1             | -1            | -1              |
         *     // +---------------+---------------+-----------------+
         *     // | -1            | 1             | -1              |
         *     // +---------------+---------------+-----------------+
         *     // | 0             | 10            | 0               |
         *     // +---------------+---------------+-----------------+
         *     // | 1             | 10            | 10              |
         *     // +---------------+---------------+-----------------+
         *     // | 2             | -10           | -20             |
         *     // +---------------+---------------+-----------------+
         *
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TNumeric);

            this.name = 'Multiplication';

        },

        value : function () {

            return value(this.parameters[0])*value(this.parameters[1]);

        }

    });

FMultiplication.mixin(require('./../../mixins/numeric'));
FMultiplication.mixin(require('./../../mixins/comparable'));
FMultiplication.mixin(require('./../../mixins/size-comparable'));

module.exports = FMultiplication;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../mixins/comparable":88,"./../../mixins/numeric":92,"./../../mixins/size-comparable":93,"./../../types/Numeric.js":99}],69:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');
var type = require('./../../helpers/type');

var Plus = Function.extend(
    {

        /**
         * @class Functions.Numeric.Plus
         * @extends Function
         *
         * Adds two numbers
         *
         * example :
         *
         *     var relation = new affinity.Relation([
         *          { A : { type : affinity.Integer}},
         *          { B : { type : affinity.Integer}},
         *     ],[
         *          [1, -1],
         *          [-1, 1],
         *          [0, 10],
         *          [1, 10],
         *          [2, -10],
         *     ])
         *
         *     var A = relation.get('A')
         *     var B = relation.get('B')
         *
         *     var extended = relation.extend([{ "A + B" : A.plus(B)}])
         *
         *     // or
         *
         *     var extended = relation.extend([{ "A + B" : new affinity.Plus(A, B)}])
         *
         *     extended.print()
         *
         *     // +---------------+---------------+-----------------+
         *     // | A : Integer   | B : Integer   | A + B : Numeric |
         *     // +===============+===============+=================+
         *     // | 1             | -1            | 0               |
         *     // +---------------+---------------+-----------------+
         *     // | -1            | 1             | 0               |
         *     // +---------------+---------------+-----------------+
         *     // | 0             | 10            | 10              |
         *     // +---------------+---------------+-----------------+
         *     // | 1             | 10            | 11              |
         *     // +---------------+---------------+-----------------+
         *     // | 2             | -10           | -18             |
         *     // +---------------+---------------+-----------------+
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(this.parameters[0]);

            this.name = 'Plus';

        },

        /**
         * Gets the function return value
         * @returns {number}
         */
        value: function () {

            return this.type().coerce(value(this.parameters[0])+value(this.parameters[1]));

        }

    });

Plus.mixin(require('./../../mixins/numeric'));
Plus.mixin(require('./../../mixins/comparable'));
Plus.mixin(require('./../../mixins/size-comparable'));

module.exports = Plus;
},{"./../../Function.js":5,"./../../helpers/type":86,"./../../helpers/value":87,"./../../mixins/comparable":88,"./../../mixins/numeric":92,"./../../mixins/size-comparable":93,"./../../types/Numeric.js":99}],70:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');

var FPow = Function.extend(
    {

        /**
         * @class Functions.Numeric.Power
         * @extends Function
         *
         * Returns a number to the power of another number
         *
         * example :
         *
         *     var relation = new affinity.Relation([
         *          { A : { type : affinity.Integer}},
         *          { B : { type : affinity.Integer}},
         *     ],[
         *          [1, -1],
         *          [-1, 1],
         *          [0, 10],
         *          [1, 10],
         *          [2, -10],
         *     ])
         *
         *     var A = relation.get('A')
         *     var B = relation.get('B')
         *
         *     var extended = relation.extend([{ "A ^ B" : A.pow(B)}])
         *
         *     // or
         *
         *     var extended = relation.extend([{ "A ^ B" : new affinity.Pow(A, B)}])
         *
         *     extended.print()
         *
         *     // +---------------+---------------+-----------------+
         *     // | A : Integer   | B : Integer   | A ^ B : Numeric |
         *     // +===============+===============+=================+
         *     // | 1             | -1            | 1               |
         *     // +---------------+---------------+-----------------+
         *     // | -1            | 1             | -1              |
         *     // +---------------+---------------+-----------------+
         *     // | 0             | 10            | 0               |
         *     // +---------------+---------------+-----------------+
         *     // | 1             | 10            | 1               |
         *     // +---------------+---------------+-----------------+
         *     // | 2             | -10           | 0.0009765625    |
         *     // +---------------+---------------+-----------------+
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TNumeric);

            this.name = 'Power';

        },

        /**
         * Gets the function's return value;
         * @returns {number}
         */
        value: function () {

            return Math.pow(value(this.parameters[0]),value(this.parameters[1]));

        }

    });

FPow.mixin(require('./../../mixins/numeric'));
FPow.mixin(require('./../../mixins/comparable'));
FPow.mixin(require('./../../mixins/size-comparable'));

module.exports = FPow;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../mixins/comparable":88,"./../../mixins/numeric":92,"./../../mixins/size-comparable":93,"./../../types/Numeric.js":99}],71:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');

var Round = Function.extend(
    {

        /**
         * @class Functions.Numeric.Round
         * @extends Function
         *
         * Rounds a number to its closest whole number
         *
         * example :
         *
         *     var relation = new affinity.Relation([
         *          { A : { type : affinity.Integer}}
         *     ],[
         *          [-10],[-5],[-2],[-1],[0],[1],[2],[5],[10]
         *     ]);
         *
         *     var A = relation.get('A');
         *
         *     var extended = relation.extend([{"A.sqrt()" : A.sqrt()}, {"A.sqrt().round()" : A.sqrt().round()}]);
         *
         *     // or
         *
         *     var extended = relation.extend([
         *         {"A.sqrt()"         : new affinity.SquareRoot(A)},
         *         {"A.sqrt().round()" : new affinity.Round(new affinity.SquareRoot(A))}
         *     ]);
         *
         *     extended.print();
         *
         *     // +---------------+----------------------+------------------------------+
         *     // | A : Integer   | A.sqrt() : Numeric   | A.sqrt().round() : Numeric   |
         *     // +===============+======================+==============================+
         *     // | -10           | NaN                  | NaN                          |
         *     // +---------------+----------------------+------------------------------+
         *     // | -5            | NaN                  | NaN                          |
         *     // +---------------+----------------------+------------------------------+
         *     // | -2            | NaN                  | NaN                          |
         *     // +---------------+----------------------+------------------------------+
         *     // | -1            | NaN                  | NaN                          |
         *     // +---------------+----------------------+------------------------------+
         *     // | 0             | 0                    | 0                            |
         *     // +---------------+----------------------+------------------------------+
         *     // | 1             | 1                    | 1                            |
         *     // +---------------+----------------------+------------------------------+
         *     // | 2             | 1.4142135623730951   | 1                            |
         *     // +---------------+----------------------+------------------------------+
         *     // | 5             | 2.23606797749979     | 2                            |
         *     // +---------------+----------------------+------------------------------+
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TNumeric);

            this.name = 'Round';

        },

        /**
         * Gets the function's return value
         * @returns {number}
         */
        value: function () {

            return Math.round(value(this.parameters[0]));

        }

    });

Round.mixin(require('./../../mixins/numeric'));
Round.mixin(require('./../../mixins/comparable'));
Round.mixin(require('./../../mixins/size-comparable'));

module.exports = Round;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../mixins/comparable":88,"./../../mixins/numeric":92,"./../../mixins/size-comparable":93,"./../../types/Numeric.js":99}],72:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');

var Sine = Function.extend(
    {

        /**
         * @class Functions.Numeric.Sine
         * @extends Function
         *
         * Function that returns the sine of a number
         *
         * Example with Extend operator :
         *
         *      var relation = new affinity.Relation([
         *          { A :  {type : affinity.Integer} },
         *      ],[
         *          [0], [Math.PI/2], [Math.PI], [3*Math.PI/2], [2*Math.PI]
         *      ])
         *
         *      var A = relation.get('A');
         *
         *
         *      var extended = relation.extend([{ "sin(A)" : A.sin() }]);
         *
         *      // or
         *
         *      var extended = relation.extend([{ "sin(A)" : new affinity.Sine(A) }]);
         *
         *      extended.print();
         *
         *      //+---------------+------------------+
         *      //| A : Integer   | sin(A) : Numeric |
         *      //+===============+==================+
         *      //| 0             | 0                |
         *      //+---------------+------------------+
         *      //| PI/2          | 1                |
         *      //+---------------+------------------+
         *      //|              | 0                |
         *      //+---------------+------------------+
         *      //| 3/2          | 1                |
         *      //+---------------+------------------+
         *      //| 2            | 0                |
         *      //+---------------+------------------+
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TNumeric);

            this.name = 'Sine';

        },

        /**
         * Gets the function return value
         * @returns {number}
         */
        value: function () {

            return Math.sin(value(this.parameters[0]));

        }

    });

Sine.mixin(require('./../../mixins/numeric'));
Sine.mixin(require('./../../mixins/comparable'));
Sine.mixin(require('./../../mixins/size-comparable'));

module.exports = Sine;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../mixins/comparable":88,"./../../mixins/numeric":92,"./../../mixins/size-comparable":93,"./../../types/Numeric.js":99}],73:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');

var FSquareRoot = Function.extend(
    {

        /**
         * @class Functions.Numeric.SquareRoot
         * @extends Function
         *
         *
         * Returns the square root of a number
         *
         * example :
         *
         *     var relation = new affinity.Relation([
         *          { A : { type : affinity.Integer}}
         *     ],[
         *          [-10],[-5],[-2],[-1],[0],[1],[2],[5],[10]
         *     ])
         *
         *     var A = relation.get('A')
         *
         *     var extended = relation.extend([{"A.sqrt()" : A.sqrt()}]);
         *
         *     // or
         *
         *     var extended = relation.extend([{ "A.sqrt()" : new affinity.Sqrt(A)}])
         *
         *     extended.print();
         *
         *     // +---------------+----------------------+
         *     // | A : Integer   | A.sqrt() : Numeric   |
         *     // +===============+======================+
         *     // | -10           | NaN                  |
         *     // +---------------+----------------------+
         *     // | -5            | NaN                  |
         *     // +---------------+----------------------+
         *     // | -2            | NaN                  |
         *     // +---------------+----------------------+
         *     // | -1            | NaN                  |
         *     // +---------------+----------------------+
         *     // | 0             | 0                    |
         *     // +---------------+----------------------+
         *     // | 1             | 1                    |
         *     // +---------------+----------------------+
         *     // | 2             | 1.4142135623730951   |
         *     // +---------------+----------------------+
         *     // | 5             | 2.23606797749979     |
         *     // +---------------+----------------------+
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TNumeric);

            this.name = 'Square Root';

        },

        /**
         * Gets the function result
         * @returns {number}
         */
        value: function () {

            return Math.sqrt(value(this.parameters[0]));

        }

    });

FSquareRoot.mixin(require('./../../mixins/numeric'));
FSquareRoot.mixin(require('./../../mixins/comparable'));
FSquareRoot.mixin(require('./../../mixins/size-comparable'));

module.exports = FSquareRoot;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../mixins/comparable":88,"./../../mixins/numeric":92,"./../../mixins/size-comparable":93,"./../../types/Numeric.js":99}],74:[function(require,module,exports){
var Function = require('./../../Function.js');
var TNumeric = require('./../../types/Numeric.js');
var value = require('./../../helpers/value');

var Tangent = Function.extend(
    {

        /**
         * @class Functions.Numeric.Tangent
         * @extends Function
         *
         * Function that returns the Tangent of a number
         *
         * Example with Extend operator :
         *
         *      var relation = new affinity.Relation([
         *          { A :  {type : affinity.Integer} },
         *      ],[
         *          [0], [Math.PI/2], [Math.PI], [3*Math.PI/2], [2*Math.PI]
         *      ]);
         *
         *      var A = relation.get('A');
         *
         *
         *      var extended = relation.extend([{ "tan(A)" : A.tan() }]);
         *
         *      // or
         *
         *      var extended = relation.extend([{ "tan(A)" : new affinity.Tangent(A) }]);
         *
         *      extended.print();
         *
         *      // The following result shows a bug, but it's not affinity's fault.
         *      // Due to a bug in V8
         *      // (see this http://stackoverflow.com/questions/24455775/why-does-node-not-evaluate-math-tanmath-pi-2-to-infinity-but-chrome-v8-does)
         *      // Math.tan(Math.PI/2) won't evaluate to Infinity.
         *      // Math.tan(Math.PI) won't evaluate to 0.
         *      // And so on. This is due to Math.cos(Math.PI/2) not evaluating to 0.
         *
         *      // This will be fixed in node v0.11. as I tested the v0.11.14-pre version.
         *
         *      //+---------------+---------------------------+
         *      //| A : Integer   | tan(A) : Numeric          |
         *      //+===============+===========================+
         *      //| 0             | 0                         |
         *      //+---------------+---------------------------+
         *      //| PI/2          | 16331778728383844         |
         *      //+---------------+---------------------------+
         *      //|              | -1.2246063538223773e-16   |
         *      //+---------------+---------------------------+
         *      //| 3/2          | 5443926242794615          |
         *      //+---------------+---------------------------+
         *      //| 2            | -2.4492127076447545e-16   |
         *      //+---------------+---------------------------+
         *
         */
        constructor: function () {

            Function.apply(this, Array.prototype.slice.call(arguments, 0));

            this.type(TNumeric);

            this.name = 'Tangent';

        },

        /**
         * Gets the function return value
         * @returns {number}
         */
        value: function () {

            return Math.tan(value(this.parameters[0]));

        }

    });

Tangent.mixin(require('./../../mixins/numeric'));
Tangent.mixin(require('./../../mixins/comparable'));
Tangent.mixin(require('./../../mixins/size-comparable'));

module.exports = Tangent;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../mixins/comparable":88,"./../../mixins/numeric":92,"./../../mixins/size-comparable":93,"./../../types/Numeric.js":99}],75:[function(require,module,exports){
var Function = require('./../../Function.js');
var TInteger = require('./../../types/Integer.js');
var value = require('./../../helpers/value');

var Length = Function.extend({

    /**
     * @class Functions.String.Length
     *
     * Returns the length of a string
     *
     * Example with Extension operator :
     *
     *     var affinity = require('./index.js');
     *
     *     var relation = new affinity.Relation([
     *          { name : { type : affinity.String}}
     *     ],[
     *          ['John Doe'], ['Mark Clinton'], ['Bo Vril']
     *     ]);
     *
     *     var name = relation.get('name');
     *
     *     var extended = relation.extend([{"name.length()" : name.length()}]);
     *
     *     // or
     *
     *     var extended = relation.extend([
     *         {"name.length()" : new affinity.Length(name)}
     *     ]);
     *
     *     extended.print();
     *
     *     // +-----------------+-------------------------+
     *     // | name : String   | name.length() : Integer |
     *     // +=================+=========================+
     *     // | John Doe        | 8                       |
     *     // +-----------------+-------------------------+
     *     // | Mark Clinton    | 12                      |
     *     // +-----------------+-------------------------+
     *     // | Bo Vril         | 7                       |
     *     // +-----------------+-------------------------+
     *
     */
    constructor: function () {

        Function.apply(this, Array.prototype.slice.call(arguments, 0));

        this.type(TInteger);

        this.name = 'Length';

    },

    /**
     * Gets the function return value
     * @returns {number}
     */
    value: function () {

        return value(this.parameters[0]).length;

    }

});

module.exports = Length;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../types/Integer.js":98}],76:[function(require,module,exports){
var Function = require('./../../Function.js');
var TString = require('./../../types/String.js');
var value = require('./../../helpers/value');

var Length = Function.extend({

    /**
     * @class Functions.String.Lowercase
     *
     * Returns the lowercase version of a string
     *
     * Example with Extension operator :
     *
     *     var affinity = require('./index.js');
     *
     *     var relation = new affinity.Relation([
     *          { name : { type : affinity.String}}
     *     ],[
     *          ['John Doe'], ['Mark Clinton'], ['Bo Vril']
     *     ]);
     *
     *     var name = relation.get('name');
     *
     *     var extended = relation.extend([{"name.lowercase()" : name.lowercase()}]);
     *
     *     // or
     *
     *     var extended = relation.extend([
     *         { "name.lowercase()" : new affinity.Lowercase(name) }
     *     ])
     *
     *     extended.print();
     *
     *     // +-----------------+---------------------------+
     *     // | name : String   | name.lowercase() : String |
     *     // +=================+===========================+
     *     // | John Doe        | john doe                  |
     *     // +-----------------+---------------------------+
     *     // | Mark Clinton    | mark clinton              |
     *     // +-----------------+---------------------------+
     *     // | Bo Vril         | bo vril                   |
     *     // +-----------------+---------------------------+
     */
    constructor: function () {

        Function.apply(this, Array.prototype.slice.call(arguments, 0));

        this.type(TString);

        this.name = 'Lowercase';

    },

    value: function () {

        return value(this.parameters[0]).toLowerCase();

    }

});

module.exports = Length;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../types/String.js":101}],77:[function(require,module,exports){
var Function = require('./../../Function.js');
var TString = require('./../../types/String.js');
var value = require('./../../helpers/value');

var Uppercase = Function.extend({

    /**
     * @class Functions.String.Substring
     *
     * Returns a substring from a string
     *
     * Example with Extension operator :
     *
     *     var affinity = require('./index.js');
     *
     *     var relation = new affinity.Relation([
     *          { name : { type : affinity.String}}
     *     ],[
     *          ['John Doe'], ['Mark Clinton'], ['Bo Vril']
     *     ]);
     *
     *     var name = relation.get('name');
     *
     *     var extended = relation.extend([{"name.substr(0,5)" : name.substr(0, 5)}]);
     *
     *     //or
     *
     *     var extended = relation.extend([
     *         { "name.substr(0,5)" : new affinity.Substring(name, 0, 5) }
     *     ]);
     *
     *     extended.print();
     *
     *     // +-----------------+---------------------------+
     *     // | name : String   | name.substr(0,5) : String |
     *     // +=================+===========================+
     *     // | John Doe        | John                      |
     *     // +-----------------+---------------------------+
     *     // | Mark Clinton    | Mark                      |
     *     // +-----------------+---------------------------+
     *     // | Bo Vril         | Bo Vr                     |
     *     // +-----------------+---------------------------+
     */
    constructor: function () {

        Function.apply(this, Array.prototype.slice.call(arguments, 0));

        this.type(TString);

        this.name = 'Substring';

    },

    value: function () {

        var start = value(this.parameters[1]);
        var length = value(this.parameters[2]);
        return value(this.parameters[0]).substr(start, length);

    }

});

module.exports = Uppercase;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../types/String.js":101}],78:[function(require,module,exports){
var Function = require('./../../Function.js');
var TString = require('./../../types/String.js');
var value = require('./../../helpers/value');

var Test = Function.extend({

    /**
     * @class Functions.String.Test
     *
     * Tests a regex on a string.
     *
     * Example with Extension operator :
     *
     *     var affinity = require('./index.js');
     *
     *     var relation = new affinity.Relation([
     *          { name : { type : affinity.String}}
     *     ],[
     *          ['John Doe'], ['Mark Clinton'], ['Bo Vril']
     *     ]);
     *
     *     var name = relation.get('name');
     *
     *     var extended = relation.extend([{ "name.test(/Doe/)" : name.test(/Doe/)}]);
     *
     *     // or
     *
     *     var extended = relation.extend([
     *         { "name.test(/Doe/)" : new affinity.Test(name, /Doe/) }
     *     ])
     *
     *     extended.print();
     *
     *     // +-----------------+----------------------------+
     *     // | name : String   | name.test(/Doe/) : Boolean |
     *     // +=================+============================+
     *     // | John Doe        | true                       |
     *     // +-----------------+----------------------------+
     *     // | Mark Clinton    | false                      |
     *     // +-----------------+----------------------------+
     *     // | Bo Vril         | false                      |
     *     // +-----------------+----------------------------+
     */
    constructor: function () {

        Function.apply(this, Array.prototype.slice.call(arguments, 0));

        this.type(TString);

        this.name = 'Test';

    },

    /**
     * Gets the function return value
     * @returns {boolean}
     */
    value: function () {

        var regex = value(this.parameters[1]);
        return regex.test(value(this.parameters[0]));

    }

});

module.exports = Test;
},{"./../../Function.js":5,"./../../helpers/value":87,"./../../types/String.js":101}],79:[function(require,module,exports){
var Function = require('./../../Function.js');
var TString = require('./../../types/String.js');
var value = require('./../../helpers/value');

var Uppercase = Function.extend({

    /**
     * @class Functions.String.Uppercase
     *
     * Returns the uppercase version of a string
     *
     * Example with Extension operator :
     *
     *     var affinity = require('./index.js');
     *
     *     var relation = new affinity.Relation([
     *          { upcs : { type : affinity.String}}
     *     ],[
     *          ['John Doe'], ['Mark Clinton'], ['Bo Vril']
     *     ]);
     *
     *     var extended = relation.extend([{"name.uppercase()" : relation.get('name').uppercase()}]);
     *
     *     // or
     *
     *     var extended = relation.extend([
     *         { "name.uppercase()" : new affinity.Uppercase(name) }
     *     ])
     *
     *     extended.print();
     *
     *     // +-----------------+---------------------------+
     *     // | name : String   | name.uppercase() : String |
     *     // +=================+===========================+
     *     // | John Doe        | JOHN DOE                  |
     *     // +-----------------+---------------------------+
     *     // | Mark Clinton    | MARK CLINTON              |
     *     // +-----------------+---------------------------+
     *     // | Bo Vril         | BO VRIL                   |
     *     // +-----------------+---------------------------+
     */
    constructor: function () {

        Function.apply(this, Array.prototype.slice.call(arguments, 0));

        this.type(TString);

        this.name = 'Uppercase';

    },

    /**
     * Gets the function return value
     * @returns {string}
     */
    value: function () {

        return value(this.parameters[0]).toUpperCase();

    }

});

module.exports = Uppercase;



},{"./../../Function.js":5,"./../../helpers/value":87,"./../../types/String.js":101}],80:[function(require,module,exports){
var Function = require('./../../Function.js');
var Type = require('./../../Type.js');
var TBoolean = require('./../../types/Boolean.js');

var TupleAttribute = Function.extend({

    /**
     * @class Functions.Tuple.AttributeValue
     * @extends Function
     *
     * When building a predicate, you pass the Header Attributes directly like this :
     *
     *     var extended = relation.extend(relation.get('attribute1').plus(relation.get('attribute2')));
     *
     * In the documentation for Relation#get, it is specified that it returns an Attribute.
     *
     * Though, when building predicates for restriction or extension operators, we convert the passed Attributes
     * into a function TupleAttribute. So this is the same as the above :
     *
     *     var extended = relation.extend(new affinity.TupleAttribute('attribute1').plus(new affinity.TupleAttribute('attribute2')));
     *
     * Directly passing the Header Attribute is just some nice sugar.
     *
     */
    constructor: function (attributeName) {

        Function.apply(this, arguments);

        this.attributeName = attributeName;

        this.name = 'TupleAttribute';

    },

    /**
     * Gets the function return value
     * @returns {*}
     */
    value: function () {

        var tuple = this.parameters[0];

        var attributeName = this.attributeName;

        if(!tuple.attributes.hasOwnProperty(attributeName)){
            throw new Error('Attribute "'+attributeName+'" does not exist in Tuple');
        }

        return tuple.get(attributeName);

    },

    /**
     * Assigns a tuple to the function
     * @param tuple
     */
    assignTuple : function(tuple){

        this.parameters[0] = tuple;

    }

},{


});

module.exports = TupleAttribute;
},{"./../../Function.js":5,"./../../Type.js":12,"./../../types/Boolean.js":95}],81:[function(require,module,exports){
var _ = require('lodash');
var debug = require('./debug');

var clone = function (element) {

    debug.clone.trace('#clone');

    if (element.clone && _.isFunction(element.clone)) {

        return element.clone();

    } else {

        return _.cloneDeep(element);

    }

};

module.exports = clone;
},{"./debug":84,"lodash":105}],82:[function(require,module,exports){
var _ = require('lodash');
var debug = require('./debug');
var coerce = function (type, value) {
    debug.coerce.trace('#coerce');
    if(value instanceof type){
        return value;
    } else if (type && _.isFunction(type.coerce)) {
        return type.coerce.apply(this, Array.prototype.slice.call(arguments, 1));
    } else {
        if (type && value instanceof type) {
            return value;
        }
        if (type) {
            var result = new (type.prototype.constructor.bind.apply(type, (Array.prototype.slice.call(arguments, 0))));
        } else {
            result = value;
        }
        return result;
    }
};
module.exports = coerce;
},{"./debug":84,"lodash":105}],83:[function(require,module,exports){
var value = require('./value');
var _ = require('lodash');
var Function = require('./../Function');
var Type = require('./../Type');
var debug = require('./debug');

var compare = function (type, value1, value2) {

    debug.compare.trace('#compare');

    // Get the function return values if applicable

    value1 = value(value1);
    value2 = value(value2);


    // Access the type's equal function

    if(value1 instanceof Type){
        return value1.constructor.compare(value1, value2);
    }

    if(value2 instanceof Type){
        return value2.constructor.compare(value1, value2);
    }

    if(value1 instanceof Date){
        value1 = value1.getTime();
    }

    if(value2 instanceof Date){
        value2 = value2.getTime();
    }


    if(value1 === value2){
        return 0;
    } else if (value1 > value2){
        return 1;
    } else if (value2 > value1){
        return -1;
    }


};

module.exports = compare;
},{"./../Function":5,"./../Type":12,"./debug":84,"./value":87,"lodash":105}],84:[function(require,module,exports){

var log4js;

try {
    log4js = require("log4js");

    log4js.configure({
        appenders: [
            { type: 'console' }
        ],
        replaceConsole: false
    });

    log4js.setGlobalLogLevel(log4js.levels.WARN);

} catch(e) {
    log4js = {};

    var logger = function(){
        this.trace = this.warn = this.debug = function(){
            return;
        }
    };

    log4js.getLogger = function(){
        return new logger();
    };
}

var Set = module.exports.set = log4js.getLogger('Set');
var Relation = module.exports.relation = log4js.getLogger('Relation');
var Header = module.exports.header = log4js.getLogger('Header');

var Compose = module.exports.compose = log4js.getLogger('Compose');
var Difference = module.exports.difference = log4js.getLogger('Difference');
var Extend = module.exports.extend = log4js.getLogger('Extend');
var Group = module.exports.group = log4js.getLogger('Group');
var Intersection = module.exports.intersection = log4js.getLogger('Intersection');
var Join = module.exports.join = log4js.getLogger('Join');
var Product = module.exports.product = log4js.getLogger('Product');
var Projection = module.exports.projection = log4js.getLogger('Projection');
var Rename = module.exports.rename = log4js.getLogger('Rename');
var Restriction = module.exports.restriction = log4js.getLogger('Restriction');
var SemiJoin = module.exports.semiJoin = log4js.getLogger('SemiJoin');
var SemiDifference = module.exports.semiDifference = log4js.getLogger('SemiDifference');
var Ungroup = module.exports.ungroup = log4js.getLogger('Ungroup');
var Union = module.exports.union = log4js.getLogger('Union');
var Unwrap = module.exports.unwrap = log4js.getLogger('Unwrap');
var Wrap = module.exports.wrap = log4js.getLogger('Wrap');
var TableDump = module.exports.reldump = log4js.getLogger('TableDump');
var Test = module.exports.test = log4js.getLogger('Test');

var Index = module.exports.index = log4js.getLogger('Index');
var Key = module.exports.key = log4js.getLogger('Key');
var ForeignKey = module.exports.foreignKey = log4js.getLogger('ForeignKey');


var Clone = module.exports.clone = log4js.getLogger('Clone');
var Type = module.exports.type = log4js.getLogger('Type');
var Coerce = module.exports.coerce = log4js.getLogger('Coerce');
var Compare = module.exports.compare = log4js.getLogger('Compare');
var Value = module.exports.value = log4js.getLogger('Value');
var Equal = module.exports.equal = log4js.getLogger('Equal');



},{"log4js":undefined}],85:[function(require,module,exports){
var value = require('./value');
var _ = require('lodash');
var Function = require('./../Function');
var Type = require('./../Type');
var debug = require('./debug');

var equal = function (type, value1, value2) {

    debug.equal.trace('#equal');

    // Get the function return values if applicable

    value1 = value(value1);
    value2 = value(value2);

    if(_.isUndefined(value1) && _.isUndefined(value2)){
        return true;
    } else if (_.isUndefined(value1) || _.isUndefined(value2)){
        return false;
    } else if (_.isNull(value1) && _.isNull(value2)){
        return true;
    } else if (_.isNull(value1) || _.isNull(value2)){
        return false;
    }


    // Access the type's equal function

    if(value1.constructor && value1.constructor.equal){
        return value1.constructor.equal(value1, value2);
    }

    if(value2.constructor && value2.constructor.equal){
        return value2.constructor.equal(value1, value2);
    }


    // Fallback on good'ol lodash

    return _.isEqual(value1, value2);


};

module.exports = equal;
},{"./../Function":5,"./../Type":12,"./debug":84,"./value":87,"lodash":105}],86:[function(require,module,exports){
var value = require('./value');
var _ = require('lodash');
var Function = require('./../Function');
var Attribute = require('./../Attribute');
var Type = require('./../Type');
var debug = require('./debug');

var TBoolean = require('./../types/Boolean');
var TString = require('./../types/String');
var TDate = require('./../types/Date');
var TInteger = require('./../types/Integer');
var TNumeric = require('./../types/Numeric');
var TFloat = require('./../types/Float');


var type = function(thang){

    debug.type.trace('#type');

    if(thang instanceof Attribute){
        return thang.type;
    }

    if(thang instanceof Type){
        return thang.constructor;
    }

    if(thang instanceof Function){
        return thang.type();
    }

    if(_.isBoolean(thang)){
        return TBoolean;
    }

    if(_.isNumber(thang)){
        return TNumeric;
    }

    if(_.isDate(thang)){
        return TDate;
    }

};

module.exports = type;


},{"./../Attribute":2,"./../Function":5,"./../Type":12,"./../types/Boolean":95,"./../types/Date":96,"./../types/Float":97,"./../types/Integer":98,"./../types/Numeric":99,"./../types/String":101,"./debug":84,"./value":87,"lodash":105}],87:[function(require,module,exports){

var debug = require('./debug');
var Function = require('./../Function');

var value = function (value) {

    debug.value.trace('#value');

    if(value instanceof Function){

        value = value.value();

    }

    return value;

};

module.exports = value;
},{"./../Function":5,"./debug":84}],88:[function(require,module,exports){
/**
 * @class Mixins.Comparable
 */


/**
 * @member Mixins.Comparable
 */
module.exports.equals = function (attr) {

    var Equal = require('./../functions/comparable/Equal.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Equal(this, attr));
    }

    return new Equal(this, attr);

};

/**
 * @member Mixins.Comparable
 */
module.exports.eq = function(attr){
    return module.exports.equals.call(this, attr);
};
},{"./../functions/comparable/Equal.js":41}],89:[function(require,module,exports){
/**
 * @class Mixins.Chainable
 */

/**
 * @member Mixins.Chainable
 */
module.exports.and = function (param) {

    var And = require('./../functions/connective/And.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new And(this, param));
    }

    return new And(this, param);

};

/**
 * @member Mixins.Chainable
 */
module.exports.or = function () {

    var Or = require('./../functions/connective/Or.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Or(this));
    }

    return new Or(this);

};
},{"./../functions/connective/And.js":46,"./../functions/connective/Or.js":48}],90:[function(require,module,exports){
module.exports.dayOfMonth = function () {

    var DayOfMonth = require('./../functions/date/DayOfMonth.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new DayOfMonth(this));
    }

    return new DayOfMonth(this);

};

module.exports.dayOfWeek = function () {

    var DayOfWeek = require('./../functions/date/DayOfWeek.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new DayOfWeek(this));
    }

    return new DayOfWeek(this);

};

module.exports.dayOfYear = function () {

    var DayOfYear = require('./../functions/date/DayOfYear.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new DayOfYear(this));
    }

    return new DayOfYear(this);

};


module.exports.month = function () {

    var Month = require('./../functions/date/Month.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Month(this));
    }

    return new Month(this);

};

module.exports.ts = function () {

    var Timestamp = require('./../functions/date/Timestamp.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Timestamp(this));
    }

    return new Timestamp(this);

};

module.exports.weekOfYear = function () {

    var WeekOfYear = require('./../functions/date/WeekOfYear.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new WeekOfYear(this));
    }

    return new WeekOfYear(this);

};

module.exports.year = function () {

    var Year = require('./../functions/date/Year.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Year(this));
    }

    return new Year(this);

};

module.exports.hours = function () {

    var Hours = require('./../functions/date/Hours.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Hours(this));
    }

    return new Hours(this);

};

module.exports.minutes = function () {

    var Minutes = require('./../functions/date/Minutes.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Minutes(this));
    }

    return new Minutes(this);

};

module.exports.seconds = function () {

    var Seconds = require('./../functions/date/Seconds.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Seconds(this));
    }

    return new Seconds(this);

};

module.exports.milliseconds = function () {

    var Milliseconds = require('./../functions/date/Milliseconds.js');

    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Milliseconds(this));
    }

    return new Milliseconds(this);

};
},{"./../functions/date/DayOfMonth.js":49,"./../functions/date/DayOfWeek.js":50,"./../functions/date/DayOfYear.js":51,"./../functions/date/Hours.js":52,"./../functions/date/Milliseconds.js":53,"./../functions/date/Minutes.js":54,"./../functions/date/Month.js":55,"./../functions/date/Seconds.js":56,"./../functions/date/Timestamp.js":57,"./../functions/date/WeekOfYear.js":58,"./../functions/date/Year.js":59}],91:[function(require,module,exports){
/**
 * @class Mixins.Negatable
 */

/**
 * @member Mixins.Negatable
 */
module.exports.not = function (attr) {

    this._negated = true;
    return this;

};
},{}],92:[function(require,module,exports){
module.exports.abs = function () {
    var Absolute = require('./../functions/numeric/Absolute.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Absolute(this));
    }
    return new Absolute(this);
};

module.exports.ceil = function (attr) {
    var Ceil = require('./../functions/numeric/Ceil.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Ceil(this));
    }
    return new Ceil(this);
};

module.exports.floor = function (attr) {
    var Floor = require('./../functions/numeric/Floor.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Ceil(this));
    }
    return new Floor(this);
};

module.exports.cos = function (attr) {
    var Cos = require('./../functions/numeric/Cosine.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Cos(this));
    }
    return new Cos(this);
};

module.exports.div = function (attr) {
    var Division = require('./../functions/numeric/Division.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Division(this, attr));
    }
    return new Division(this, attr);
};


module.exports.exp = function () {
    var Exp = require('./../functions/numeric/Exponential.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Exp(this));
    }
    return new Exp(this);
};


module.exports.minus = function (attr) {
    var Minus = require('./../functions/numeric/Minus.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Minus(this, attr));
    }
    return new Minus(this, attr);
};


module.exports.mod = function (attr) {
    var Modulo = require('./../functions/numeric/Modulo.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Modulo(this, attr));
    }
    return new Modulo(this, attr);
};


module.exports.times = function (attr) {
    var Multiplication = require('./../functions/numeric/Multiplication.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Multiplication(this, attr));
    }
    return new Multiplication(this, attr);
};


module.exports.plus = function (attr) {
    var Plus = require('./../functions/numeric/Plus.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Plus(this, attr));
    }
    return new Plus(this, attr);
};


module.exports.pow = function (attr) {
    var Pow = require('./../functions/numeric/Power.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Pow(this, attr));
    }
    return new Pow(this, attr);
};


module.exports.round = function () {
    var Round = require('./../functions/numeric/Round.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Round(this));
    }
    return new Round(this);
};


module.exports.sin = function () {
    var Sin = require('./../functions/numeric/Sine.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Sin(this));
    }
    return new Sin(this);
};


module.exports.sqrt = function () {
    var Sqrt = require('./../functions/numeric/SquareRoot.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Sqrt(this));
    }
    return new Sqrt(this);
};


module.exports.tan = function () {
    var Tan = require('./../functions/numeric/Tangent.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Tan(this));
    }
    return new Tan(this);
};

module.exports.avg = function(){

    var Average = require('./../functions/aggregate/Average.js');
    return new Average(this);

};

module.exports.standardDeviation = function(){

    var StandardDeviation = require('./../functions/aggregate/StandardDeviation.js');
    return new StandardDeviation(this);

};

module.exports.sum = function(){

    var Sum = require('./../functions/aggregate/Sum.js');
    return new Sum(this);

};

module.exports.variance = function(){

    var Variance = require('./../functions/aggregate/Variance.js');
    return new Variance(this);

};


},{"./../functions/aggregate/Average.js":34,"./../functions/aggregate/StandardDeviation.js":38,"./../functions/aggregate/Sum.js":39,"./../functions/aggregate/Variance.js":40,"./../functions/numeric/Absolute.js":60,"./../functions/numeric/Ceil.js":61,"./../functions/numeric/Cosine.js":62,"./../functions/numeric/Division.js":63,"./../functions/numeric/Exponential.js":64,"./../functions/numeric/Floor.js":65,"./../functions/numeric/Minus.js":66,"./../functions/numeric/Modulo.js":67,"./../functions/numeric/Multiplication.js":68,"./../functions/numeric/Plus.js":69,"./../functions/numeric/Power.js":70,"./../functions/numeric/Round.js":71,"./../functions/numeric/Sine.js":72,"./../functions/numeric/SquareRoot.js":73,"./../functions/numeric/Tangent.js":74}],93:[function(require,module,exports){
/**
 * @class Mixins.SizeComparable
 */

/**
 * @member Mixins.SizeComparable
 */
module.exports.gt = function (attr) {
    var GreaterThan = require('./../functions/comparable/GreaterThan.js');
    return new GreaterThan(this, attr);
};

/**
 * @member Mixins.SizeComparable
 */
module.exports.gte = function (attr) {
    var GreaterThanEqual = require('./../functions/comparable/GreaterThanEqual.js');
    return new GreaterThanEqual(this, attr);
};

/**
 * @member Mixins.SizeComparable
 */
module.exports.st = function (attr) {
    var SmallerThan = require('./../functions/comparable/SmallerThan.js');
    return new SmallerThan(this, attr);
};

/**
 * @member Mixins.SizeComparable
 */
module.exports.ste = function (attr) {
    var SmallerThanEqual = require('./../functions/comparable/SmallerThanEqual.js');
    return new SmallerThanEqual(this, attr);
};

module.exports.max = function(){
    var Maximum = require('./../functions/aggregate/Maximum');

    return new Maximum(this);
};

module.exports.min = function(){
    var Minimum = require('./../functions/aggregate/Minimum');

    return new Minimum(this);
};
},{"./../functions/aggregate/Maximum":36,"./../functions/aggregate/Minimum":37,"./../functions/comparable/GreaterThan.js":42,"./../functions/comparable/GreaterThanEqual.js":43,"./../functions/comparable/SmallerThan.js":44,"./../functions/comparable/SmallerThanEqual.js":45}],94:[function(require,module,exports){


module.exports.length = function () {
    var Length = require('./../functions/string/Length.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Length(this));
    }
    return new Length(this);
};

module.exports.lowercase = function () {
    var Lowercase = require('./../functions/string/Lowercase.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Lowercase(this));
    }
    return new Lowercase(this);
};

module.exports.test = function (regex) {
    var Test = require('./../functions/string/Test.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Test(this, regex));
    }
    return new Test(this, regex);
};

module.exports.substr = function (index, len) {
    var Substring = require('./../functions/string/Substring.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Substring(this, index, len));
    }
    return new Substring(this, index, len);
};

module.exports.uppercase = function () {
    var Uppercase = require('./../functions/string/Uppercase.js');
    if (this._checkNegatedAttribute) {
        return this._checkNegatedAttribute(new Uppercase(this));
    }
    return new Uppercase(this);
};
},{"./../functions/string/Length.js":75,"./../functions/string/Lowercase.js":76,"./../functions/string/Substring.js":77,"./../functions/string/Test.js":78,"./../functions/string/Uppercase.js":79}],95:[function(require,module,exports){
var Type = require('./../Type');
var _ = require('lodash');

var TBoolean = Type.extend(/**
 * @class Types.Boolean
 * @extends Type
 *
 * Represents a Boolean Type
 *
 * This class should not be instantiated. It is only used to define
 * relation header attribute types or function return types.
 *
 */{



}, {

    /**
     * @param {boolean|Types.Boolean} boolean1
     * @param {boolean|Types.Boolean} boolean2
     * @static
     * @returns {boolean}
     *
     * Method to check if two boolean object are equal
     *
     */
    equal: function (boolean1, boolean2) {

        return boolean1 === boolean2;

    },

    /**
     * @param {*} value The variable to coerce to Boolean type
     * @static
     * @returns {boolean}
     */
    coerce : function(value){

        var lowerCaseValue;

        if(_.isBoolean(value)){
            return value;
        } else if (value === 0){
            return false;
        } else if (value === 1){
            return true;
        } else if (_.isString(value)){

            lowerCaseValue = value.toLowerCase();

            if(lowerCaseValue === 'true' || lowerCaseValue === 't'){
                return true;
            } else if(lowerCaseValue === 'false' || lowerCaseValue === 'f'){
                return false;
            }

        }

    },

    /**
     * @static
     * @returns {string}
     *
     * String representation of the Boolean type
     */
    toString: function () {
        return 'Boolean'
    },

    /**
     * @param {boolean} boolean
     * @static
     * @returns {boolean}
     *
     * Returns the value of a boolean
     */
    value : function(boolean){

        return boolean;

    },

    /**
     * Mixins for Booleans
     * @static
     */
    payload : [
        require('./../mixins/comparable'),
        require('./../mixins/connectable'),
        require('./../mixins/not')
    ],

    type : 'Boolean'

});

module.exports = TBoolean;


},{"./../Type":12,"./../mixins/comparable":88,"./../mixins/connectable":89,"./../mixins/not":91,"lodash":105}],96:[function(require,module,exports){
var Object = require('./Object');
var _ = require('lodash');

var Date = Object.extend({

    /**
     * @class Types.Date
     * @extends Type
     *
     * Represents a Date type.
     *
     * Should not be instantiated. Only used to represent
     * relation header attribute types or function return types.
     */

}, {

    /**
     * Serialize method for Dates.
     * @param {Date|Types.Date} date
     * @static
     * @returns {number}
     */
    serialize : function(date){

        return date.getTime();

    },

    /**
     * Coerces an arbitrary object into a date
     * @param {string|number|Date|Types.Date} value
     * @static
     * @returns {Date}
     */
    coerce : function(value){

        if(_.isString(value)){
            return new Date(value);
        } else if (_.isNumber(value)){
            var result = new Date();
            result.setTime(value);
            return result;
        } else if(_.isDate(value)){
            return value;
        }

    },

    /**
     * Check if two dates are equal
     * @param {Date|Types.Date} date1
     * @param {Date|Types.Date} date2
     * @static
     * @returns {boolean}
     */
    equal: function (date1, date2) {

        return date1 === date2;

    },

    /**
     * String representation of the Date type
     * @static
     * @returns {string}
     */
    toString: function () {
        return 'Date'
    },

    /**
     * Gets the value of a date
     * @static
     * @param date
     * @returns {Date}
     */
    value : function(date){

        return date;

    },

    /**
     * Mixins for dates
     */
    payload : [
        require('./../mixins/comparable'),
        require('./../mixins/size-comparable'),
        require('./../mixins/not'),
        require('./../mixins/date')
    ],

    type : 'Date'

});

module.exports = Date;


},{"./../mixins/comparable":88,"./../mixins/date":90,"./../mixins/not":91,"./../mixins/size-comparable":93,"./Object":100,"lodash":105}],97:[function(require,module,exports){
var Numeric = require('./Numeric.js');
var _ = require('lodash');

var Float = Numeric.extend({

    /**
     * @class Types.Float
     * @extends Types.Numeric
     *
     * Represents a Float type.
     *
     * This class should not be instantiated. It is only used
     * to represent relation header attribute types or function return types.
     */

}, {

    /**
     * String representation of the Float type
     * @static
     * @returns {string}
     */
    toString: function () {
        return 'Float'
    },


    /**
     * Coerces an arbitrary value to Float type
     * @param value
     * @returns {number}
     */
    coerce : function(value){

        if (_.isNumber(value) || _.isString(value)){
            return parseFloat(value);
        }

    },

    primitive : true,

    type : 'Float'

});

module.exports = Float;


},{"./Numeric.js":99,"lodash":105}],98:[function(require,module,exports){
var TNumeric = require('./Numeric.js');
var _ = require('lodash');

var Integer = TNumeric.extend({

    /**
     * @class Types.Integer
     * @extends Types.Numeric
     *
     * Represents an Integer type.
     *
     * This class should not be instantiated. It is only used
     * to represent relation header attribute types or function return types.
     */

}, {

    /**
     * Coerces an arbitrary value to Integer type
     * @param value
     * @returns {number}
     */
    coerce : function(value){

        if (_.isNumber(value) || _.isString(value)){
            return parseInt(value);
        }

    },

    /**
     * String representation of the Integer Type
     * @returns {string}
     */
    toString: function () {
        return 'Integer'
    },

    primitive : true,

    type : 'Integer'

});

module.exports = Integer;


},{"./Numeric.js":99,"lodash":105}],99:[function(require,module,exports){
var Type = require('./../Type');
var _ = require('lodash');

var Numeric = Type.extend({

    /**
     * @class Types.Numeric
     *
     * Represents a Numeric type.
     *
     * This class should not be instantiated. It is only used
     * to represent relation header attribute types or function return types.
     */

}, {

    /**
     * @param {*} value
     * @returns {number}
     *
     * Coerces an arbitrary value to type float
     *
     */
    coerce : function(value){

        if(_.isNumber(value)){
            return value;
        } else if (_.isString(value)){
            return parseFloat(value);
        }

    },

    /**
     * Mixins for Numeric types
     */
    payload : [
        require('./../mixins/comparable'),
        require('./../mixins/size-comparable'),
        require('./../mixins/numeric'),
        require('./../mixins/connectable'),
        require('./../mixins/not')
    ],

    /**
     * Returns the value of the Numeric object
     * @param numeric
     * @returns {*}
     */
    value : function(numeric){

        return numeric;

    },

    equal: function (numeric1, numeric2) {

        return (numeric1 === numeric2);

    },

    toString: function () {
        return 'Numeric'
    },

    primitive : true,

    type : 'Numeric'

});


module.exports = Numeric;


},{"./../Type":12,"./../mixins/comparable":88,"./../mixins/connectable":89,"./../mixins/not":91,"./../mixins/numeric":92,"./../mixins/size-comparable":93,"lodash":105}],100:[function(require,module,exports){
var Type = require('./../Type');
var _ = require('lodash');

var TObject = Type.extend({

    /**
     * @class Types.Object
     * @extends Type
     *
     * Represents an Object Type.
     */

    /**
     * Creates new Object instances
     * @param value
     */
    constructor: function (value) {

        Type.apply(this, Array.prototype.slice.call(arguments, 0));

        if(_.isObject(value)){
            _.extend(this, value);
        }

        this.name = 'Object';
    },

    /**
     * String representation of an Object value
     * @returns {string}
     */
    toString: function () {

        return 'Object';

    }

}, {

    /**
     * Method to coerce an arbitrary value into an Object instance
     * @param value
     * @returns {Object}
     */
    coerce : function(value){

        return value;

    },

    /**
     * Mixins for Object type
     */
    payload : [
        require('./../mixins/comparable'),
        require('./../mixins/connectable'),
        require('./../mixins/not')
    ],

    /**
     * Returns the value of the object
     * @param object
     * @returns {*}
     */
    value : function(object){

        return object;

    },

    /**
     * Tests for equality between two objects
     * @static
     * @param object1
     * @param object2
     * @returns {boolean}
     */
    equal: function (object1, object2) {

        return _.isEqual(object1, object2);

    },

    /**
     * String representation of an object
     * @static
     * @returns {string}
     */
    toString: function () {

        return 'Object'

    },

    /**
     * Object is not a primitive type
     */
    primitive : false,

    type : 'Object'

});


module.exports = TObject;


},{"./../Type":12,"./../mixins/comparable":88,"./../mixins/connectable":89,"./../mixins/not":91,"lodash":105}],101:[function(require,module,exports){
var Type = require('./../Type');
var TBoolean = require('./Boolean');
var _ = require('lodash');

var String = Type.extend({

    /**
     * @class Types.String
     * @extends Type
     *
     * Represents a String Attribute Type.
     *
     * Should not be instantiated. It is only
     * used to represent relation header attribute types or function return types.
     *
     */

}, {

    coerce : function(value){

        return value;

    },

    /**
     * Mixins for String types
     */
    payload : [
        require('./../mixins/comparable'),
        require('./../mixins/size-comparable'),
        require('./../mixins/connectable'),
        require('./../mixins/not'),
        require('./../mixins/string'),
    ],

    /**
     * Checks for equality between two strings
     * @param str1
     * @param str2
     * @returns {boolean}
     */
    equal: function (str1, str2) {

        return str2 === str1;

    },

    /**
     * String representation of a String Type
     * @returns {string}
     */
    toString: function () {
        return 'String'
    },

    /**
     * String is a primitive
     */
    primitive : true,

    type : 'TString'

});

module.exports = String;


},{"./../Type":12,"./../mixins/comparable":88,"./../mixins/connectable":89,"./../mixins/not":91,"./../mixins/size-comparable":93,"./../mixins/string":94,"./Boolean":95,"lodash":105}],102:[function(require,module,exports){
var Type = require('./../Type');
var TBoolean = require('./Boolean');

var TType = Type.extend({

    /**
     * @class Types.Type
     * @extends Type
     *
     * Represents a Type Attribute type.
     *
     * Should not be instantiated. It is only
     * used to represent relation header attribute types or function return types.
     *
     */

}, {

    /**
     * Check if two Types are equal
     * @param {Function} type1
     * @param {Function} type2
     * @returns {boolean}
     */
    equal: function (type1, type2) {

        return (type1 === type2);

    },

    toString: function () {
        return 'Type'
    },

    type : 'Type'

});

module.exports = TType;


},{"./../Type":12,"./Boolean":95}],103:[function(require,module,exports){
/**
 * @class Affinity
 * @type {Object} 
 * @member Affinity
 */
var affinity = {};

//region Types

/**
 * @member Affinity
 * @type {Index}
 */
affinity.Index = require('./affinity/Index.js');

/**
 * @type {Types.Type}  
 * @member Affinity
 */
affinity.Type = require('./affinity/types/Type.js');

/**
 * @type {Set} 
 * @member Affinity
 */
affinity.Set = require('./affinity/Set.js');

/**
 * @type {Relation} 
 * @member Affinity
 */
affinity.Relation = require('./affinity/Relation.js');

/**
 * @type {Tuple} 
 * @member Affinity
 */
affinity.Tuple = require('./affinity/Tuple.js');

/**
 * @type {Header} 
 * @member Affinity
 */
affinity.Header = require('./affinity/Header.js');

/**
 * @type {Attribute} 
 * @member Affinity
 */
affinity.Attribute = require('./affinity/Attribute.js');

/**
 * @type {Types.Object} 
 * @member Affinity
 */
affinity.Object = require('./affinity/types/Object');

/**
 * @type {Types.Integer} 
 * @member Affinity
 */
affinity.Integer = require('./affinity/types/Integer');

/**
 * @type {Types.Float} 
 * @member Affinity
 */
affinity.Float = require('./affinity/types/Float');

/**
 * @type {Types.String} 
 * @member Affinity
 */
affinity.String = require('./affinity/types/String');

/**
 * @type {Types.Boolean} 
 * @member Affinity
 */
affinity.Boolean = require('./affinity/types/Boolean');

/**
 * @type {Types.Date} 
 * @member Affinity
 */
affinity.Date = require('./affinity/types/Date');
//endregion

/**
 * @type {Function} 
 * @member Affinity
 */
affinity.Function = require('./affinity/Function.js');

//region Connective Functions

/**
 * @type {Functions.Connective.And} 
 * @member Affinity
 */
affinity.And = require('./affinity/functions/connective/And.js');

/**
 * @type {Functions.Connective.Or} 
 * @member Affinity
 */
affinity.Or = require('./affinity/functions/connective/Or.js');

/**
 * @type {Functions.Connective.Not} 
 * @member Affinity
 */
affinity.Not = require('./affinity/functions/connective/Not.js');
//endregion

//region Comparative Functions

/**
 * @type {Functions.Comparable.Equal} 
 * @member Affinity
 */
affinity.Equal = require('./affinity/functions/comparable/Equal.js');

/**
 * @type {Functions.Comparable.Equal} 
 * @member Affinity
 */
affinity.eq = function(attr1, attr2){
    return new affinity.Equal(attr1, attr2);
};


/**
 * @type {Functions.Comparable.GreaterThan} 
 * @member Affinity
 */
affinity.GreaterThan = require('./affinity/functions/comparable/GreaterThan.js');

/**
 * @type {Functions.Comparable.GreaterThan} 
 * @member Affinity
 */
affinity.gt = function(attr1, attr2){
    return new affinity.GreaterThan(attr1, attr2);
};


/**
 * @type {Functions.Comparable.GreaterThanEqual} 
 * @member Affinity
 */
affinity.GreaterThanEqual = require('./affinity/functions/comparable/GreaterThanEqual.js');

/**
 * @type {Functions.Comparable.GreaterThanEqual} 
 * @member Affinity
 */
affinity.gte = function(attr1, attr2){
    return new affinity.GreaterThanEqual(attr1, attr2);
};


/**
 * @type {Functions.Comparable.SmallerThan} 
 * @member Affinity
 */
affinity.SmallerThan = require('./affinity/functions/comparable/SmallerThan.js');

/**
 * @type {Functions.Comparable.SmallerThan} 
 * @member Affinity
 */
affinity.st = function(attr1, attr2){
    return new affinity.SmallerThan(attr1, attr2);
};


/**
 * @type {Functions.Comparable.SmallerThanEqual} 
 * @member Affinity
 */
affinity.SmallerThanEqual = require('./affinity/functions/comparable/SmallerThanEqual.js');

/**
 * @type {Functions.Comparable.SmallerThanEqual} 
 * @member Affinity
 */
affinity.ste = function(attr1, attr2){
    return new affinity.SmallerThanEqual(attr1, attr2);
};

//endregion

//region Numeric Functions

/**
 * @type {Functions.Numeric.Absolute} 
 * @member Affinity
 */
affinity.Absolute = require('./affinity/functions/numeric/Absolute.js');

/**
 * @type {Functions.Numeric.Ceil} 
 * @member Affinity
 */
affinity.Ceil = require('./affinity/functions/numeric/Ceil.js');
/**
 * @type {Functions.Numeric.Cosine} 
 * @member Affinity
 */
affinity.Cosine = require('./affinity/functions/numeric/Cosine.js');

/**
 * @type {Functions.Numeric.Division} 
 * @member Affinity
 */
affinity.Division = require('./affinity/functions/numeric/Division.js');

/**
 * @type {Functions.Numeric.Exponential} 
 * @member Affinity
 */
affinity.Exponential = require('./affinity/functions/numeric/Exponential.js');

/**
 * @type {Functions.Numeric.Floor} 
 * @member Affinity
 */
affinity.Floor = require('./affinity/functions/numeric/Floor.js');

/**
 * @type {Functions.Numeric.Minus} 
 * @member Affinity
 */
affinity.Minus = require('./affinity/functions/numeric/Minus.js');

/**
 * @type {Functions.Numeric.Modulo} 
 * @member Affinity
 */
affinity.Modulo = require('./affinity/functions/numeric/Modulo.js');

/**
 * @type {Functions.Numeric.Multiplication} 
 * @member Affinity
 */
affinity.Multiplication = require('./affinity/functions/numeric/Multiplication.js');

/**
 * @type {Functions.Numeric.Plus} 
 * @member Affinity
 */
affinity.Plus = require('./affinity/functions/numeric/Plus.js');

/**
 * @type {Functions.Numeric.Power} 
 * @member Affinity
 */
affinity.Power = require('./affinity/functions/numeric/Power.js');

/**
 * @type {Functions.Numeric.Round} 
 * @member Affinity
 */
affinity.Round = require('./affinity/functions/numeric/Round.js');

/**
 * @type {Functions.Numeric.Sine} 
 * @member Affinity
 */
affinity.Sine = require('./affinity/functions/numeric/Sine.js');

/**
 * @type {Functions.Numeric.SquareRoot} 
 * @member Affinity
 */
affinity.SquareRoot = require('./affinity/functions/numeric/SquareRoot.js');

/**
 * @type {Functions.Numeric.Tangent} 
 * @member Affinity
 */
affinity.Tangent = require('./affinity/functions/numeric/Tangent.js');

/**
 * @param attr
 * @returns {Functions.Numeric.Absolute}
 */
affinity.abs = function(attr){
    return new affinity.Absolute(attr);
};

/**
 * @param attr
 * @returns {Functions.Numeric.Ceil}
 */
affinity.ceil = function(attr){
    return new affinity.Ceil(attr);
};

/**
 * @param attr
 * @returns {Functions.Numeric.Floor}
 */
affinity.floor = function(attr){
    return new affinity.Floor(attr);
};

/**
 * @param attr
 * @returns {Functions.Numeric.Cosine}
 */
affinity.cos = function(attr){
    return new affinity.Cosine(attr);
};

/**
 * @param attr1
 * @param attr2
 * @returns {Functions.Numeric.Division}
 */
affinity.div = function(attr1, attr2){
    return new affinity.Division(attr1, attr2);
};

/**
 * @param attr
 * @returns {Functions.Numeric.Exponential}
 */
affinity.exp = function(attr){
    return new affinity.Exponential(attr);
};

/**
 * @param attr1
 * @param attr2
 * @returns {Functions.Numeric.Minus}
 */
affinity.minus = function(attr1, attr2){
    return new affinity.Minus(attr1, attr2);
};

/**
 * @param attr1
 * @param attr2
 * @returns {Functions.Numeric.Modulo}
 */
affinity.mod = function(attr1, attr2){
    return new affinity.Modulo(attr1, attr2);
};

/**
 * @param attr1
 * @param attr2
 * @returns {Functions.Numeric.Multiplication}
 */
affinity.times = function(attr1, attr2){
    return new affinity.Multiplication(attr1, attr2);
};

/**
 * @param attr1
 * @param attr2
 * @returns {Functions.Numeric.Plus}
 */
affinity.plus = function(attr1, attr2){
    return new affinity.Plus(attr1, attr2);
};

/**
 * @param attr1
 * @param attr2
 * @returns {Functions.Numeric.Power}
 */
affinity.pow = function(attr1, attr2){
    return new affinity.Power(attr1, attr2);
};

/**
 * @param attr
 * @returns {Functions.Numeric.Round}
 */
affinity.round = function(attr){
    return new affinity.Round(attr);
};

/**
 * @param attr
 * @returns {Functions.Numeric.Sine}
 */
affinity.sin = function(attr){
    return new affinity.Sine(attr);
};

/**
 * @param attr
 * @returns {Functions.Numeric.SquareRoot}
 */
affinity.sqrt = function(attr){
    return new affinity.SquareRoot(attr);
};

/**
 * @param attr
 * @returns {Functions.Numeric.Tangent}
 */
affinity.tan = function(attr){
    return new affinity.Tangent(attr);
};
//endregion

//region String Functions

/**
 * @type {Functions.String.Length} 
 * @member Affinity
 */
affinity.Length = require('./affinity/functions/string/Length.js');

/**
 * @type {Functions.String.Lowercase} 
 * @member Affinity
 */
affinity.Lowercase = require('./affinity/functions/string/Lowercase.js');

/**
 * @type {Functions.String.Test} 
 * @member Affinity
 */
affinity.Test = require('./affinity/functions/string/Test.js');

/**
 * @type {Functions.String.Substring} 
 * @member Affinity
 */
affinity.Substring = require('./affinity/functions/string/Substring.js');

/**
 * @type {Functions.String.Uppercase} 
 * @member Affinity
 */
affinity.Uppercase = require('./affinity/functions/string/Uppercase.js');

/**
 * @param attr
 * @returns {Functions.String.Length}
 */
affinity.length = function(attr){
    return new affinity.Length(attr);
};

/**
 * @param attr
 * @returns {Functions.String.Lowercase}
 */
affinity.lowercase = function(attr){
    return new affinity.Lowercase(attr);
};

/**
 * @param attr
 * @param regex
 * @returns {Functions.String.Test}
 */
affinity.test = function(attr, regex){
    return new affinity.Test(attr, regex);
};

/**
 * @param attr
 * @param start
 * @param length
 * @returns {Functions.String.Substring}
 */
affinity.substr = function(attr, start, length){
    return new affinity.Length(attr, start, length);
};

/**
 * @param attr
 * @returns {Functions.String.Uppercase}
 */
affinity.uppercase = function(attr){
    return new affinity.Length(attr);
};
//endregion

//region Tuple Functions

/**
 * @type {Functions.Tuple.AttributeValue} 
 * @member Affinity
 */
affinity.TupleValue = require('./affinity/functions/tuple/Attribute.js');

/**
 * @param relation
 * @param attributeName
 * @returns {Functions.Tuple.AttributeValue}
 */
affinity.value = function(relation, attributeName){
    var result = new affinity.TupleValue(attributeName);
    result.type(relation.header().get(attributeName));
    return result;
};
//endregion

//region Date Functions

affinity.DayOfMonth = require('./affinity/functions/date/DayOfMonth.js');
affinity.DayOfMonth = require('./affinity/functions/date/DayOfMonth.js');
affinity.DayOfWeek = require('./affinity/functions/date/DayOfWeek.js');
affinity.DayOfYear = require('./affinity/functions/date/DayOfYear.js');
affinity.Hours = require('./affinity/functions/date/Hours.js');
affinity.Milliseconds = require('./affinity/functions/date/Milliseconds.js');
affinity.Minutes = require('./affinity/functions/date/Minutes.js');
affinity.Month = require('./affinity/functions/date/Month.js');
affinity.Seconds = require('./affinity/functions/date/Seconds.js');
affinity.Timestamp = require('./affinity/functions/date/Timestamp.js');
affinity.WeekOfYear = require('./affinity/functions/date/WeekOfYear.js');
affinity.Year = require('./affinity/functions/date/Year.js');
//endregion

affinity.count = function(){
    return new (require('./affinity/functions/aggregate/Count.js'));
};

//region Relational Operators

/**
 * @type {Operators.Composition} 
 * @member Affinity
 */
affinity.Composition = require('./affinity/algebra/Composition.js');

/**
 * @type {Operators.Difference} 
 * @member Affinity
 */
affinity.Difference = require('./affinity/algebra/Difference.js');

/**
 * @type {Operators.Extension} 
 * @member Affinity
 */
affinity.Extension = require('./affinity/algebra/Extension.js');

/**
 * @type {Operators.Group} 
 * @member Affinity
 */
affinity.Group = require('./affinity/algebra/Group.js');

/**
 * @type {Operators.Intersection} 
 * @member Affinity
 */
affinity.Intersection = require('./affinity/algebra/Intersection.js');

/**
 * @type {Operators.Join} 
 * @member Affinity
 */
affinity.Join = require('./affinity/algebra/Join.js');

/**
 * @type {Operators.Product} 
 * @member Affinity
 */
affinity.Product = require('./affinity/algebra/Product.js');

/**
 * @type {Operators.Projection} 
 * @member Affinity
 */
affinity.Projection = require('./affinity/algebra/Projection.js');

/**
 * @type {Operators.Rename} 
 * @member Affinity
 */
affinity.Rename = require('./affinity/algebra/Rename.js');

/**
 * @type {Operators.Restriction} 
 * @member Affinity
 */
affinity.Restriction = require('./affinity/algebra/Restriction.js');

/**
 * @type {Operators.SemiDifference} 
 * @member Affinity
 */
affinity.SemiDifference = require('./affinity/algebra/SemiDifference.js');

/**
 * @type {Operators.SemiJoin} 
 * @member Affinity
 */
affinity.SemiJoin = require('./affinity/algebra/SemiJoin.js');

/**
 * @type {Operators.Ungroup} 
 * @member Affinity
 */
affinity.Ungroup = require('./affinity/algebra/Ungroup.js');

/**
 * @type {Operators.Union} 
 * @member Affinity
 */
affinity.Union = require('./affinity/algebra/Union.js');

/**
 * @type {Operators.Unwrap} 
 * @member Affinity
 */
affinity.Unwrap = require('./affinity/algebra/Unwrap.js');

/**
 * @type {Operators.Wrap} 
 * @member Affinity
 */
affinity.Wrap = require('./affinity/algebra/Wrap.js');
//endregion

//region Constants

/**
 * @type {Relation} 
 * @member Affinity
 */
affinity.TABLE_DUM = new affinity.Relation([]);

/**
 * @type {Relation} 
 * @member Affinity
 */
affinity.TABLE_DEE = new affinity.Relation([], [
    []
]);
//endregion

module.exports = affinity;

},{"./affinity/Attribute.js":2,"./affinity/Function.js":5,"./affinity/Header.js":6,"./affinity/Index.js":7,"./affinity/Relation.js":9,"./affinity/Set.js":10,"./affinity/Tuple.js":11,"./affinity/algebra/Composition.js":13,"./affinity/algebra/Difference.js":14,"./affinity/algebra/Extension.js":15,"./affinity/algebra/Group.js":16,"./affinity/algebra/Intersection.js":17,"./affinity/algebra/Join.js":18,"./affinity/algebra/Product.js":19,"./affinity/algebra/Projection.js":20,"./affinity/algebra/Rename.js":21,"./affinity/algebra/Restriction.js":22,"./affinity/algebra/SemiDifference.js":23,"./affinity/algebra/SemiJoin.js":24,"./affinity/algebra/Ungroup.js":28,"./affinity/algebra/Union.js":29,"./affinity/algebra/Unwrap.js":30,"./affinity/algebra/Wrap.js":31,"./affinity/functions/aggregate/Count.js":35,"./affinity/functions/comparable/Equal.js":41,"./affinity/functions/comparable/GreaterThan.js":42,"./affinity/functions/comparable/GreaterThanEqual.js":43,"./affinity/functions/comparable/SmallerThan.js":44,"./affinity/functions/comparable/SmallerThanEqual.js":45,"./affinity/functions/connective/And.js":46,"./affinity/functions/connective/Not.js":47,"./affinity/functions/connective/Or.js":48,"./affinity/functions/date/DayOfMonth.js":49,"./affinity/functions/date/DayOfWeek.js":50,"./affinity/functions/date/DayOfYear.js":51,"./affinity/functions/date/Hours.js":52,"./affinity/functions/date/Milliseconds.js":53,"./affinity/functions/date/Minutes.js":54,"./affinity/functions/date/Month.js":55,"./affinity/functions/date/Seconds.js":56,"./affinity/functions/date/Timestamp.js":57,"./affinity/functions/date/WeekOfYear.js":58,"./affinity/functions/date/Year.js":59,"./affinity/functions/numeric/Absolute.js":60,"./affinity/functions/numeric/Ceil.js":61,"./affinity/functions/numeric/Cosine.js":62,"./affinity/functions/numeric/Division.js":63,"./affinity/functions/numeric/Exponential.js":64,"./affinity/functions/numeric/Floor.js":65,"./affinity/functions/numeric/Minus.js":66,"./affinity/functions/numeric/Modulo.js":67,"./affinity/functions/numeric/Multiplication.js":68,"./affinity/functions/numeric/Plus.js":69,"./affinity/functions/numeric/Power.js":70,"./affinity/functions/numeric/Round.js":71,"./affinity/functions/numeric/Sine.js":72,"./affinity/functions/numeric/SquareRoot.js":73,"./affinity/functions/numeric/Tangent.js":74,"./affinity/functions/string/Length.js":75,"./affinity/functions/string/Lowercase.js":76,"./affinity/functions/string/Substring.js":77,"./affinity/functions/string/Test.js":78,"./affinity/functions/string/Uppercase.js":79,"./affinity/functions/tuple/Attribute.js":80,"./affinity/types/Boolean":95,"./affinity/types/Date":96,"./affinity/types/Float":97,"./affinity/types/Integer":98,"./affinity/types/Object":100,"./affinity/types/String":101,"./affinity/types/Type.js":102}],104:[function(require,module,exports){
'use strict';

/**
 * Representation of a single EventEmitter function.
 *
 * @param {Function} fn Event handler to be called.
 * @param {Mixed} context Context for function execution.
 * @param {Boolean} once Only emit once
 * @api private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Minimal EventEmitter interface that is molded against the Node.js
 * EventEmitter interface.
 *
 * @constructor
 * @api public
 */
function EventEmitter() { /* Nothing to set */ }

/**
 * Holds the assigned EventEmitters by name.
 *
 * @type {Object}
 * @private
 */
EventEmitter.prototype._events = undefined;

/**
 * Return a list of assigned event listeners.
 *
 * @param {String} event The events that should be listed.
 * @returns {Array}
 * @api public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  if (!this._events || !this._events[event]) return [];
  if (this._events[event].fn) return [this._events[event].fn];

  for (var i = 0, l = this._events[event].length, ee = new Array(l); i < l; i++) {
    ee[i] = this._events[event][i].fn;
  }

  return ee;
};

/**
 * Emit an event to all registered event listeners.
 *
 * @param {String} event The name of the event.
 * @returns {Boolean} Indication if we've emitted an event.
 * @api public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  if (!this._events || !this._events[event]) return false;

  var listeners = this._events[event]
    , len = arguments.length
    , args
    , i;

  if ('function' === typeof listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Register a new EventListener for the given event.
 *
 * @param {String} event Name of the event.
 * @param {Functon} fn Callback function.
 * @param {Mixed} context The context of the function.
 * @api public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  var listener = new EE(fn, context || this);

  if (!this._events) this._events = {};
  if (!this._events[event]) this._events[event] = listener;
  else {
    if (!this._events[event].fn) this._events[event].push(listener);
    else this._events[event] = [
      this._events[event], listener
    ];
  }

  return this;
};

/**
 * Add an EventListener that's only called once.
 *
 * @param {String} event Name of the event.
 * @param {Function} fn Callback function.
 * @param {Mixed} context The context of the function.
 * @api public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  var listener = new EE(fn, context || this, true);

  if (!this._events) this._events = {};
  if (!this._events[event]) this._events[event] = listener;
  else {
    if (!this._events[event].fn) this._events[event].push(listener);
    else this._events[event] = [
      this._events[event], listener
    ];
  }

  return this;
};

/**
 * Remove event listeners.
 *
 * @param {String} event The event we want to remove.
 * @param {Function} fn The listener that we need to find.
 * @param {Boolean} once Only remove once listeners.
 * @api public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, once) {
  if (!this._events || !this._events[event]) return this;

  var listeners = this._events[event]
    , events = [];

  if (fn) {
    if (listeners.fn && (listeners.fn !== fn || (once && !listeners.once))) {
      events.push(listeners);
    }
    if (!listeners.fn) for (var i = 0, length = listeners.length; i < length; i++) {
      if (listeners[i].fn !== fn || (once && !listeners[i].once)) {
        events.push(listeners[i]);
      }
    }
  }

  //
  // Reset the array, or remove it completely if we have no more listeners.
  //
  if (events.length) {
    this._events[event] = events.length === 1 ? events[0] : events;
  } else {
    delete this._events[event];
  }

  return this;
};

/**
 * Remove all listeners or only the listeners for the specified event.
 *
 * @param {String} event The event want to remove all listeners for.
 * @api public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  if (!this._events) return this;

  if (event) delete this._events[event];
  else this._events = {};

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// This function doesn't apply anymore.
//
EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
  return this;
};

//
// Expose the module.
//
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.EventEmitter2 = EventEmitter;
EventEmitter.EventEmitter3 = EventEmitter;

//
// Expose the module.
//
module.exports = EventEmitter;

},{}],105:[function(require,module,exports){
(function (global){
/**
 * @license
 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
 * Build: `lodash modern -o ./dist/lodash.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to pool arrays and objects used internally */
  var arrayPool = [],
      objectPool = [];

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date + '';

  /** Used as the size when optimizations are enabled for large arrays */
  var largeArraySize = 75;

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to detect and test whitespace */
  var whitespace = (
    // whitespace
    ' \t\x0B\f\xA0\ufeff' +

    // line terminators
    '\n\r\u2028\u2029' +

    // unicode category "Zs" space separators
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to match empty string literals in compiled template source */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to detected named functions */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match leading whitespace and zeros to be removed */
  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to detect functions containing a `this` reference */
  var reThis = /\bthis\b/;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** Used to assign default `context` object properties */
  var contextProps = [
    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
    'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify */
  var templateCounter = 0;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used as an internal `_.debounce` options object */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used as the property descriptor for `__bindData__` */
  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object'
      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
      : (cache ? 0 : -1);
  }

  /**
   * Adds a given value to the corresponding cache object.
   *
   * @private
   * @param {*} value The value to add to the cache.
   */
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }

  /**
   * Used by `_.max` and `_.min` as the default callback when a given
   * collection is a string value.
   *
   * @private
   * @param {string} value The character to inspect.
   * @returns {number} Returns the code unit of given character.
   */
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }

  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index < length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value > other || typeof value == 'undefined') {
          return 1;
        }
        if (value < other || typeof other == 'undefined') {
          return -1;
        }
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to return the same value for
    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
    //
    // This also ensures a stable sort in V8 and other engines.
    // See http://code.google.com/p/v8/issues/detail?id=90
    return a.index - b.index;
  }

  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
   */
  function createCache(array) {
    var index = -1,
        length = array.length,
        first = array[0],
        mid = array[(length / 2) | 0],
        last = array[length - 1];

    if (first && typeof first == 'object' &&
        mid && typeof mid == 'object' && last && typeof last == 'object') {
      return false;
    }
    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return result;
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'true': false,
      'undefined': false,
      'value': null
    };
  }

  /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Releases the given object back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new `lodash` function using the given context object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns the `lodash` function.
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See http://es5.github.io/#x11.1.5.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references */
    var Array = context.Array,
        Boolean = context.Boolean,
        Date = context.Date,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];

    /** Used for native method references */
    var objectProto = Object.prototype;

    /** Used to restore the original `_` reference in `noConflict` */
    var oldDash = context._;

    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;

    /** Used to detect if a method is native */
    var reNative = RegExp('^' +
      String(toString)
        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        .replace(/toString| for [^\]]+/g, '.*?') + '$'
    );

    /** Native method shortcuts */
    var ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        fnToString = Function.prototype.toString,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        push = arrayRef.push,
        setTimeout = context.setTimeout,
        splice = arrayRef.splice,
        unshift = arrayRef.unshift;

    /** Used to set meta data on functions */
    var defineProperty = (function() {
      // IE 8 only accepts DOM elements
      try {
        var o = {},
            func = isNative(func = Object.defineProperty) && func,
            result = func(o, o, o) && func;
      } catch(e) { }
      return result;
    }());

    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used to lookup a built-in constructor by [[Class]] */
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps the given value to enable intuitive
     * method chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
     * and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
     * `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * provided, otherwise they return unwrapped values.
     *
     * Explicit chaining can be enabled by using the `_.chain` method.
     *
     * @name _
     * @constructor
     * @category Chaining
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
       ? value
       : new lodashWrapper(value);
    }

    /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap in a `lodash` instance.
     * @param {boolean} chainAll A flag to enable chaining for all methods
     * @returns {Object} Returns a `lodash` instance.
     */
    function lodashWrapper(value, chainAll) {
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    }
    // ensure `new lodashWrapper` is an instance of `lodash`
    lodashWrapper.prototype = lodash.prototype;

    /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';

    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': /<%-([\s\S]+?)%>/g,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': /<%([\s\S]+?)%>/g,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*--------------------------------------------------------------------------*/

    /**
     * The base implementation of `_.bind` that creates the bound function and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new bound function.
     */
    function baseBind(bindData) {
      var func = bindData[0],
          partialArgs = bindData[2],
          thisArg = bindData[4];

      function bound() {
        // `Function#bind` spec
        // http://es5.github.io/#x15.3.4.5
        if (partialArgs) {
          // avoid `arguments` object deoptimizations by using `slice` instead
          // of `Array.prototype.slice.call` and not assigning `arguments` to a
          // variable as a ternary expression
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        // mimic the constructor's `return` behavior
        // http://es5.github.io/#x13.2.2
        if (this instanceof bound) {
          // ensure `new bound` is an instance of `func`
          var thisBinding = baseCreate(func.prototype),
              result = func.apply(thisBinding, args || arguments);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisArg, args || arguments);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.clone` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, callback, stackA, stackB) {
      if (callback) {
        var result = callback(value);
        if (typeof result != 'undefined') {
          return result;
        }
      }
      // inspect [[Class]]
      var isObj = isObject(value);
      if (isObj) {
        var className = toString.call(value);
        if (!cloneableClasses[className]) {
          return value;
        }
        var ctor = ctorByClass[className];
        switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+value);

          case numberClass:
          case stringClass:
            return new ctor(value);

          case regexpClass:
            result = ctor(value.source, reFlags.exec(value));
            result.lastIndex = value.lastIndex;
            return result;
        }
      } else {
        return value;
      }
      var isArr = isArray(value);
      if (isDeep) {
        // check for circular references and return corresponding clone
        var initedStack = !stackA;
        stackA || (stackA = getArray());
        stackB || (stackB = getArray());

        var length = stackA.length;
        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }
        result = isArr ? ctor(value.length) : {};
      }
      else {
        result = isArr ? slice(value) : assign({}, value);
      }
      // add array properties assigned by `RegExp#exec`
      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      }
      // exit for shallow clone
      if (!isDeep) {
        return result;
      }
      // add the source value to the stack of traversed objects
      // and associate it with its clone
      stackA.push(value);
      stackB.push(result);

      // recursively populate clone (susceptible to call stack limits)
      (isArr ? forEach : forOwn)(value, function(objValue, key) {
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(prototype, properties) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }
    // fallback for browsers without `Object.create`
    if (!nativeCreate) {
      baseCreate = (function() {
        function Object() {}
        return function(prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object;
            Object.prototype = null;
          }
          return result || context.Object();
        };
      }());
    }

    /**
     * The base implementation of `_.createCallback` without support for creating
     * "_.pluck" or "_.where" style callbacks.
     *
     * @private
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     */
    function baseCreateCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      // exit early for no `thisArg` or already bound by `Function#bind`
      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
        return func;
      }
      var bindData = func.__bindData__;
      if (typeof bindData == 'undefined') {
        if (support.funcNames) {
          bindData = !func.name;
        }
        bindData = bindData || !support.funcDecomp;
        if (!bindData) {
          var source = fnToString.call(func);
          if (!support.funcNames) {
            bindData = !reFuncName.test(source);
          }
          if (!bindData) {
            // checks if `func` references the `this` keyword and stores the result
            bindData = reThis.test(source);
            setBindData(func, bindData);
          }
        }
      }
      // exit early if there are no `this` references or `func` is bound
      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 2: return function(a, b) {
          return func.call(thisArg, a, b);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return bind(func, thisArg);
    }

    /**
     * The base implementation of `createWrapper` that creates the wrapper and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new function.
     */
    function baseCreateWrapper(bindData) {
      var func = bindData[0],
          bitmask = bindData[1],
          partialArgs = bindData[2],
          partialRightArgs = bindData[3],
          thisArg = bindData[4],
          arity = bindData[5];

      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          key = func;

      function bound() {
        var thisBinding = isBind ? thisArg : this;
        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        if (partialRightArgs || isCurry) {
          args || (args = slice(arguments));
          if (partialRightArgs) {
            push.apply(args, partialRightArgs);
          }
          if (isCurry && args.length < arity) {
            bitmask |= 16 & ~32;
            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
          }
        }
        args || (args = arguments);
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (this instanceof bound) {
          thisBinding = baseCreate(func.prototype);
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.difference` that accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {Array} [values] The array of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     */
    function baseDifference(array, values) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
          result = [];

      if (isLarge) {
        var cache = createCache(values);
        if (cache) {
          indexOf = cacheIndexOf;
          values = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(values);
      }
      return result;
    }

    /**
     * The base implementation of `_.flatten` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns a new flattened array.
     */
    function baseFlatten(array, isShallow, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (value && typeof value == 'object' && typeof value.length == 'number'
            && (isArray(value) || isArguments(value))) {
          // recursively flatten arrays (susceptible to call stack limits)
          if (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }
          var valIndex = -1,
              valLength = value.length,
              resIndex = result.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[resIndex++] = value[valIndex];
          }
        } else if (!isStrict) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
     * that allows partial "_.where" style comparisons.
     *
     * @private
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      if (callback) {
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;

      // exit early for unlike primitive values
      if (a === a &&
          !(a && objectTypes[type]) &&
          !(b && objectTypes[otherType])) {
        return false;
      }
      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
      // http://es5.github.io/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return (a != +a)
            ? b != +b
            // but treat `+0` vs. `-0` as not equal
            : (a == 0 ? (1 / a == 1 / b) : a == +b);

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');

        if (aWrapped || bWrapped) {
          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        }
        // exit for functions and DOM nodes
        if (className != objectClass) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = a.constructor,
            ctorB = b.constructor;

        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB &&
              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
              ('constructor' in a && 'constructor' in b)
            ) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;

      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);

      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        // compare lengths to determine if a deep comparison is necessary
        length = a.length;
        size = b.length;
        result = size == length;

        if (result || isWhere) {
          // deep compare the contents, ignoring non-numeric properties
          while (size--) {
            var index = length,
                value = b[size];

            if (isWhere) {
              while (index--) {
                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      }
      else {
        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
        // which, in this case, is more costly
        forIn(b, function(value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            // count the number of properties.
            size++;
            // deep compare each property value.
            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
          }
        });

        if (result && !isWhere) {
          // ensure both objects have the same number of properties
          forIn(a, function(value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              // `size` will be `-1` if `a` has more properties than `b`
              return (result = --size > -1);
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.merge` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     */
    function baseMerge(object, source, callback, stackA, stackB) {
      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
        var found,
            isArr,
            result = source,
            value = object[key];

        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          // avoid merging previously merged cyclic sources
          var stackLength = stackA.length;
          while (stackLength--) {
            if ((found = stackA[stackLength] == source)) {
              value = stackB[stackLength];
              break;
            }
          }
          if (!found) {
            var isShallow;
            if (callback) {
              result = callback(value, source);
              if ((isShallow = typeof result != 'undefined')) {
                value = result;
              }
            }
            if (!isShallow) {
              value = isArr
                ? (isArray(value) ? value : [])
                : (isPlainObject(value) ? value : {});
            }
            // add `source` and associated `value` to the stack of traversed objects
            stackA.push(source);
            stackB.push(value);

            // recursively merge objects and arrays (susceptible to call stack limits)
            if (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        }
        else {
          if (callback) {
            result = callback(value, source);
            if (typeof result == 'undefined') {
              result = source;
            }
          }
          if (typeof result != 'undefined') {
            value = result;
          }
        }
        object[key] = value;
      });
    }

    /**
     * The base implementation of `_.random` without argument juggling or support
     * for returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns a random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function} [callback] The function called per iteration.
     * @returns {Array} Returns a duplicate-value-free array.
     */
    function baseUniq(array, isSorted, callback) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [];

      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
          seen = (callback || isLarge) ? getArray() : result;

      if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
      }
      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;

        if (isSorted
              ? !index || seen[seen.length - 1] !== computed
              : indexOf(seen, computed) < 0
            ) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an object composed
     * of keys generated from the results of running each element of the collection
     * through a callback. The given `setter` function sets the keys and values
     * of the composed object.
     *
     * @private
     * @param {Function} setter The setter function.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter) {
      return function(collection, callback, thisArg) {
        var result = {};
        callback = lodash.createCallback(callback, thisArg, 3);

        var index = -1,
            length = collection ? collection.length : 0;

        if (typeof length == 'number') {
          while (++index < length) {
            var value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } else {
          forOwn(collection, function(value, key, collection) {
            setter(result, value, callback(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that, when called, either curries or invokes `func`
     * with an optional `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of method flags to compose.
     *  The bitmask may be composed of the following flags:
     *  1 - `_.bind`
     *  2 - `_.bindKey`
     *  4 - `_.curry`
     *  8 - `_.curry` (bound)
     *  16 - `_.partial`
     *  32 - `_.partialRight`
     * @param {Array} [partialArgs] An array of arguments to prepend to those
     *  provided to the new function.
     * @param {Array} [partialRightArgs] An array of arguments to append to those
     *  provided to the new function.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new function.
     */
    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;

      if (!isBindKey && !isFunction(func)) {
        throw new TypeError;
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        // clone `bindData`
        bindData = slice(bindData);
        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }
        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        }
        // set `thisBinding` is not previously bound
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        // set if previously bound but not currently (subsequent curried functions)
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        // set curried arity if not yet set
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        // append partial left arguments
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        // append partial right arguments
        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        // merge flags
        bindData[1] |= bitmask;
        return createWrapper.apply(null, bindData);
      }
      // fast path for `_.bind`
      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }

    /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} match The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized, this method returns the custom method, otherwise it returns
     * the `baseIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */
    function getIndexOf() {
      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
      return result;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
     */
    function isNative(value) {
      return typeof value == 'function' && reNative.test(value);
    }

    /**
     * Sets `this` binding data on a given function.
     *
     * @private
     * @param {Function} func The function to set data on.
     * @param {Array} value The data array to set.
     */
    var setBindData = !defineProperty ? noop : function(func, value) {
      descriptor.value = value;
      defineProperty(func, '__bindData__', descriptor);
    };

    /**
     * A fallback implementation of `isPlainObject` which checks if a given value
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var ctor,
          result;

      // avoid non Object objects, `arguments` objects, and DOM elements
      if (!(value && toString.call(value) == objectClass) ||
          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
        return false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function(value, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} match The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == argsClass || false;
    }

    /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */
    var isArray = nativeIsArray || function(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == arrayClass || false;
    };

    /**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     */
    var shimKeys = function(object) {
      var index, iterable = object, result = [];
      if (!iterable) return result;
      if (!(objectTypes[typeof object])) return result;
        for (index in iterable) {
          if (hasOwnProperty.call(iterable, index)) {
            result.push(index);
          }
        }
      return result
    };

    /**
     * Creates an array composed of the own enumerable property names of an object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (!isObject(object)) {
        return [];
      }
      return nativeKeys(object);
    };

    /**
     * Used to convert characters to HTML entities:
     *
     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
     * don't require escaping in HTML and have no special meaning unless they're part
     * of a tag or an unquoted attribute value.
     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
     */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    /** Used to convert HTML entities to characters */
    var htmlUnescapes = invert(htmlEscapes);

    /** Used to match HTML entities and HTML characters */
    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

    /*--------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a callback is provided it will be executed to produce the
     * assigned values. The callback is bound to `thisArg` and invoked with two
     * arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @type Function
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
     * // => { 'name': 'fred', 'employer': 'slate' }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * var object = { 'name': 'barney' };
     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var assign = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
        callback = args[--argsLength];
      }
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
        }
        }
      }
      return result
    };

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a callback
     * is provided it will be executed to produce the cloned values. If the
     * callback returns `undefined` cloning will be handled by the method instead.
     * The callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var shallow = _.clone(characters);
     * shallow[0] === characters[0];
     * // => true
     *
     * var deep = _.clone(characters, true);
     * deep[0] === characters[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, callback, thisArg) {
      // allows working with "Collections" methods without using their `index`
      // and `collection` arguments for `isDeep` and `callback`
      if (typeof isDeep != 'boolean' && isDeep != null) {
        thisArg = callback;
        callback = isDeep;
        isDeep = false;
      }
      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates a deep clone of `value`. If a callback is provided it will be
     * executed to produce the cloned values. If the callback returns `undefined`
     * cloning will be handled by the method instead. The callback is bound to
     * `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var deep = _.cloneDeep(characters);
     * deep[0] === characters[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */
    function cloneDeep(value, callback, thisArg) {
      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? assign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param- {Object} [guard] Allows working with `_.reduce` without using its
     *  `key` and `object` arguments as sources.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var object = { 'name': 'barney' };
     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var defaults = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (typeof result[index] == 'undefined') result[index] = iterable[index];
        }
        }
      }
      return result
    };

    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': false },
     *   'fred': {    'age': 40, 'blocked': true },
     *   'pebbles': { 'age': 1,  'blocked': false }
     * };
     *
     * _.findKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (property order is not guaranteed across environments)
     *
     * // using "_.where" callback shorthand
     * _.findKey(characters, { 'age': 1 });
     * // => 'pebbles'
     *
     * // using "_.pluck" callback shorthand
     * _.findKey(characters, 'blocked');
     * // => 'fred'
     */
    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': true },
     *   'fred': {    'age': 40, 'blocked': false },
     *   'pebbles': { 'age': 1,  'blocked': true }
     * };
     *
     * _.findLastKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
     *
     * // using "_.where" callback shorthand
     * _.findLastKey(characters, { 'age': 40 });
     * // => 'fred'
     *
     * // using "_.pluck" callback shorthand
     * _.findLastKey(characters, 'blocked');
     * // => 'pebbles'
     */
    function findLastKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwnRight(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over own and inherited enumerable properties of an object,
     * executing the callback for each property. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forIn(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
     */
    var forIn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        for (index in iterable) {
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forIn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forInRight(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
     */
    function forInRight(object, callback, thisArg) {
      var pairs = [];

      forIn(object, function(value, key) {
        pairs.push(key, value);
      });

      var length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(pairs[length--], pairs[length], object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Iterates over own enumerable properties of an object, executing the callback
     * for each property. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
     */
    var forOwn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forOwn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */
    function forOwnRight(object, callback, thisArg) {
      var props = keys(object),
          length = props.length;

      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        var key = props[length];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Creates a sorted array of property names of all enumerable properties,
     * own and inherited, of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */
    function functions(object) {
      var result = [];
      forIn(object, function(value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }

    /**
     * Checks if the specified property name exists as a direct property of `object`,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to check.
     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of the given object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     * _.invert({ 'first': 'fred', 'second': 'barney' });
     * // => { 'fred': 'first', 'barney': 'second' }
     */
    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }

    /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        value && typeof value == 'object' && toString.call(value) == boolClass || false;
    }

    /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */
    function isDate(value) {
      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */
    function isElement(value) {
      return value && value.nodeType === 1 || false;
    }

    /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value),
          length = value.length;

      if ((className == arrayClass || className == stringClass || className == argsClass ) ||
          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
        return !length;
      }
      forOwn(value, function() {
        return (result = false);
      });
      return result;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If a callback is provided it will be executed
     * to compare values. If the callback returns `undefined` comparisons will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var copy = { 'name': 'fred' };
     *
     * object == copy;
     * // => false
     *
     * _.isEqual(object, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */
    function isEqual(a, b, callback, thisArg) {
      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
    }

    /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite` which will return true for
     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }

    /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */
    function isFunction(value) {
      return typeof value == 'function';
    }

    /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // check if the value is the ECMAScript language type of Object
      // http://es5.github.io/#x8
      // and avoid a V8 bug
      // http://code.google.com/p/v8/issues/detail?id=2291
      return !!(value && objectTypes[typeof value]);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN` which will return `true` for
     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // `NaN` as a primitive is the only value that is not equal to itself
      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is a number.
     *
     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        value && typeof value == 'object' && toString.call(value) == numberClass || false;
    }

    /**
     * Checks if `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * _.isPlainObject(new Shape);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && toString.call(value) == objectClass)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/fred/);
     * // => true
     */
    function isRegExp(value) {
      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
    }

    /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('fred');
     * // => true
     */
    function isString(value) {
      return typeof value == 'string' ||
        value && typeof value == 'object' && toString.call(value) == stringClass || false;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     *
     * var characters = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // using "_.pluck" callback shorthand
     * _.mapValues(characters, 'age');
     * // => { 'fred': 40, 'pebbles': 1 }
     */
    function mapValues(object, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg, 3);

      forOwn(object, function(value, key, object) {
        result[key] = callback(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a callback is
     * provided it will be executed to produce the merged values of the destination
     * and source properties. If the callback returns `undefined` merging will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'characters': [
     *     { 'name': 'barney' },
     *     { 'name': 'fred' }
     *   ]
     * };
     *
     * var ages = {
     *   'characters': [
     *     { 'age': 36 },
     *     { 'age': 40 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */
    function merge(object) {
      var args = arguments,
          length = 2;

      if (!isObject(object)) {
        return object;
      }
      // allows working with `_.reduce` and `_.reduceRight` without using
      // their `index` and `collection` arguments
      if (typeof args[2] != 'number') {
        length = args.length;
      }
      if (length > 3 && typeof args[length - 2] == 'function') {
        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
      } else if (length > 2 && typeof args[length - 1] == 'function') {
        callback = args[--length];
      }
      var sources = slice(arguments, 1, length),
          index = -1,
          stackA = getArray(),
          stackB = getArray();

      while (++index < length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }
      releaseArray(stackA);
      releaseArray(stackB);
      return object;
    }

    /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` omitting the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The properties to omit or the
     *  function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
     * // => { 'name': 'fred' }
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'fred' }
     */
    function omit(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var props = [];
        forIn(object, function(value, key) {
          props.push(key);
        });
        props = baseDifference(props, baseFlatten(arguments, true, false, 1));

        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          result[key] = object[key];
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (!callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * Creates a two dimensional array of an object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` picking the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The function called per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
     * // => { 'name': 'fred' }
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'fred' }
     */
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var index = -1,
            props = baseFlatten(arguments, true, false, 1),
            length = isObject(object) ? props.length : 0;

        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * An alternative to `_.reduce` this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable properties through a callback, with each callback execution
     * potentially mutating the `accumulator` object. The callback is bound to
     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
     * Callbacks may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;

          accumulator = baseCreate(proto);
        }
      }
      if (callback) {
        callback = lodash.createCallback(callback, thisArg, 4);
        (isArr ? forEach : forOwn)(object, function(value, index, object) {
          return callback(accumulator, value, index, object);
        });
      }
      return accumulator;
    }

    /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (property order is not guaranteed across environments)
     */
    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
     *   to retrieve, specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var args = arguments,
          index = -1,
          props = baseFlatten(args, true, false, 1),
          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
          result = Array(length);

      while(++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }

    /**
     * Checks if a given value is present in a collection using strict equality
     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
     * offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {*} target The value to check for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.contains('pebbles', 'eb');
     * // => true
     */
    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = getIndexOf(),
          length = collection ? collection.length : 0,
          result = false;

      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (isArray(collection)) {
        result = indexOf(collection, target, fromIndex) > -1;
      } else if (typeof length == 'number') {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        forOwn(collection, function(value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through the callback. The corresponding value
     * of each key is the number of times the key was returned by the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
    });

    /**
     * Checks if the given callback returns truey value for **all** elements of
     * a collection. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if all elements passed the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes']);
     * // => false
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(characters, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(characters, { 'age': 36 });
     * // => false
     */
    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return (result = !!callback(value, index, collection));
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning an array of all elements
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(characters, 'blocked');
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     *
     * // using "_.where" callback shorthand
     * _.filter(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     */
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning the first element that
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.find(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
     *
     * // using "_.where" callback shorthand
     * _.find(characters, { 'age': 1 });
     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
     *
     * // using "_.pluck" callback shorthand
     * _.find(characters, 'blocked');
     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
     */
    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }

    /**
     * This method is like `_.find` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(num) {
     *   return num % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forEachRight(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over elements of a collection, executing the callback for each
     * element. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * Note: As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
     * // => logs each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
     * // => logs each number and returns the object (property order is not guaranteed across environments)
     */
    function forEach(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        forOwn(collection, callback);
      }
      return collection;
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
     * // => logs each number from right to left and returns '3,2,1'
     */
    function forEachRight(collection, callback, thisArg) {
      var length = collection ? collection.length : 0;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (length--) {
          if (callback(collection[length], length, collection) === false) {
            break;
          }
        }
      } else {
        var props = keys(collection);
        length = props.length;
        forOwn(collection, function(value, key, collection) {
          key = props ? props[--length] : --length;
          return callback(collection[key], key, collection);
        });
      }
      return collection;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of a collection through the callback. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of the collection through the given callback. The corresponding
     * value of each key is the last element responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keys = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keys, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in the `collection`
     * returning an array of the results of each invoked method. Additional arguments
     * will be provided to each invoked method. If `methodName` is a function it
     * will be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [arg] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      var args = slice(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in the collection
     * through the callback. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (property order is not guaranteed across environments)
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(characters, 'name');
     * // => ['barney', 'fred']
     */
    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        result = [];
        forOwn(collection, function(value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }

    /**
     * Retrieves the maximum value of a collection. If the collection is empty or
     * falsey `-Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.max(characters, function(chr) { return chr.age; });
     * // => { 'name': 'fred', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(characters, 'age');
     * // => { 'name': 'fred', 'age': 40 };
     */
    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the minimum value of a collection. If the collection is empty or
     * falsey `Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.min(characters, function(chr) { return chr.age; });
     * // => { 'name': 'barney', 'age': 36 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(characters, 'age');
     * // => { 'name': 'barney', 'age': 36 };
     */
    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the value of a specified property from all elements in the collection.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} property The name of the property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(characters, 'name');
     * // => ['barney', 'fred']
     */
    var pluck = map;

    /**
     * Reduces a collection to a value which is the accumulated result of running
     * each element in the collection through the callback, where each successive
     * callback execution consumes the return value of the previous execution. If
     * `accumulator` is not provided the first element of the collection will be
     * used as the initial `accumulator` value. The callback is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function reduce(collection, callback, accumulator, thisArg) {
      if (!collection) return accumulator;
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);

      var index = -1,
          length = collection.length;

      if (typeof length == 'number') {
        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          accumulator = noaccum
            ? (noaccum = false, value)
            : callback(accumulator, value, index, collection)
        });
      }
      return accumulator;
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      forEachRight(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The opposite of `_.filter` this method returns the elements of a
     * collection that the callback does **not** return truey for.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that failed the callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(characters, 'blocked');
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     *
     * // using "_.where" callback shorthand
     * _.reject(characters, { 'age': 36 });
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     */
    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      return filter(collection, function(value, index, collection) {
        return !callback(value, index, collection);
      });
    }

    /**
     * Retrieves a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Allows working with functions like `_.map`
     *  without using their `index` arguments as `n`.
     * @returns {Array} Returns the random sample(s) of `collection`.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (collection && typeof collection.length != 'number') {
        collection = values(collection);
      }
      if (n == null || guard) {
        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(nativeMax(0, n), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */
    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        var rand = baseRandom(0, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }

    /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }

    /**
     * Checks if the callback returns a truey value for **any** element of a
     * collection. The function returns as soon as it finds a passing value and
     * does not iterate over the entire collection. The callback is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if any element passed the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(characters, 'blocked');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(characters, { 'age': 1 });
     * // => false
     */
    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if ((result = callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through the callback. This method
     * performs a stable sort, that is, it will preserve the original sort order
     * of equal elements. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an array of property names is provided for `callback` the collection
     * will be sorted by each property value.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'barney',  'age': 26 },
     *   { 'name': 'fred',    'age': 30 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(_.sortBy(characters, 'age'), _.values);
     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
     *
     * // sorting by multiple properties
     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortBy(collection, callback, thisArg) {
      var index = -1,
          isArr = isArray(callback),
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      if (!isArr) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      forEach(collection, function(value, key, collection) {
        var object = result[++index] = getObject();
        if (isArr) {
          object.criteria = map(callback, function(key) { return value[key]; });
        } else {
          (object.criteria = getArray())[0] = callback(value, key, collection);
        }
        object.index = index;
        object.value = value;
      });

      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        if (!isArr) {
          releaseArray(object.criteria);
        }
        releaseObject(object);
      }
      return result;
    }

    /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */
    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return slice(collection);
      }
      return values(collection);
    }

    /**
     * Performs a deep comparison of each element in a `collection` to the given
     * `properties` object, returning an array of all elements that have equivalent
     * property values.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Object} props The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given properties.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.where(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
     *
     * _.where(characters, { 'pets': ['dino'] });
     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
     */
    var where = filter;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using strict
     * equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */
    function difference(array) {
      return baseDifference(array, baseFlatten(arguments, true, true, 1));
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.findIndex(characters, function(chr) {
     *   return chr.age < 20;
     * });
     * // => 2
     *
     * // using "_.where" callback shorthand
     * _.findIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findIndex(characters, 'blocked');
     * // => 1
     */
    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': true },
     *   { 'name': 'fred',    'age': 40, 'blocked': false },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
     * ];
     *
     * _.findLastIndex(characters, function(chr) {
     *   return chr.age > 30;
     * });
     * // => 1
     *
     * // using "_.where" callback shorthand
     * _.findLastIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findLastIndex(characters, 'blocked');
     * // => 2
     */
    function findLastIndex(array, callback, thisArg) {
      var length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Gets the first element or first `n` elements of an array. If a callback
     * is provided elements at the beginning of the array are returned as long
     * as the callback returns truey. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(characters, 'blocked');
     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
     * // => ['barney', 'fred']
     */
    function first(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = -1;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[0] : undefined;
        }
      }
      return slice(array, 0, nativeMin(nativeMax(0, n), length));
    }

    /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truey, the array will only be flattened a single level. If a callback
     * is provided each element of the array is passed through the callback before
     * flattening. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(characters, 'pets');
     * // => ['hoppy', 'baby puss', 'dino']
     */
    function flatten(array, isShallow, callback, thisArg) {
      // juggle arguments
      if (typeof isShallow != 'boolean' && isShallow != null) {
        thisArg = callback;
        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
        isShallow = false;
      }
      if (callback != null) {
        array = map(array, callback, thisArg);
      }
      return baseFlatten(array, isShallow);
    }

    /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the array is already sorted
     * providing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element or last `n` elements of an array. If a
     * callback is provided elements at the end of the array are excluded from
     * the result as long as the callback returns truey. The callback is bound
     * to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(characters, 'blocked');
     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
     * // => ['barney', 'fred']
     */
    function initial(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }

    /**
     * Creates an array of unique values present in all provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of shared values.
     * @example
     *
     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = getArray(),
          indexOf = getIndexOf(),
          trustIndexOf = indexOf === baseIndexOf,
          seen = getArray();

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(trustIndexOf && value.length >= largeArraySize &&
            createCache(argsIndex ? args[argsIndex] : seen));
        }
      }
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [];

      outer:
      while (++index < length) {
        var cache = caches[0];
        value = array[index];

        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }

    /**
     * Gets the last element or last `n` elements of an array. If a callback is
     * provided elements at the end of the array are returned as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.last(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.last(characters, { 'employer': 'na' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function last(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[length - 1] : undefined;
        }
      }
      return slice(array, nativeMax(0, length - n));
    }

    /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from the given array using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {...*} [value] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull(array) {
      var args = arguments,
          argsIndex = 0,
          argsLength = args.length,
          length = array ? array.length : 0;

      while (++argsIndex < argsLength) {
        var index = -1,
            value = args[argsIndex];
        while (++index < length) {
          if (array[index] === value) {
            splice.call(array, index--, 1);
            length--;
          }
        }
      }
      return array;
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`. If `start` is less than `stop` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      start = +start || 0;
      step = typeof step == 'number' ? step : (+step || 1);

      if (end == null) {
        end = start;
        start = 0;
      }
      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
      var index = -1,
          length = nativeMax(0, ceil((end - start) / (step || 1))),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Removes all elements from an array that the callback returns truey for
     * and returns an array of removed elements. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4, 5, 6];
     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
     *
     * console.log(array);
     * // => [1, 3, 5]
     *
     * console.log(evens);
     * // => [2, 4, 6]
     */
    function remove(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (callback(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * The opposite of `_.initial` this method gets all but the first element or
     * first `n` elements of an array. If a callback function is provided elements
     * at the beginning of the array are excluded from the result as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.rest(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.rest(characters, { 'employer': 'slate' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;

        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }

    /**
     * Uses a binary search to determine the smallest index at which a value
     * should be inserted into a given sorted array in order to maintain the sort
     * order of the array. If a callback is provided it will be executed for
     * `value` and each element of `array` to compute their sort ranking. The
     * callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low;

      // explicitly reference `identity` for better inlining in Firefox
      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);

      while (low < high) {
        var mid = (low + high) >>> 1;
        (callback(array[mid]) < value)
          ? low = mid + 1
          : high = mid;
      }
      return low;
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of combined values.
     * @example
     *
     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2, 3, 5, 4]
     */
    function union() {
      return baseUniq(baseFlatten(arguments, true, true));
    }

    /**
     * Creates a duplicate-value-free version of an array using strict equality
     * for comparisons, i.e. `===`. If the array is sorted, providing
     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
     * each element of `array` is passed through the callback before uniqueness
     * is computed. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, callback, thisArg) {
      // juggle arguments
      if (typeof isSorted != 'boolean' && isSorted != null) {
        thisArg = callback;
        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
        isSorted = false;
      }
      if (callback != null) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      return baseUniq(array, isSorted, callback);
    }

    /**
     * Creates an array excluding all provided values using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {...*} [value] The values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
    function without(array) {
      return baseDifference(array, slice(arguments, 1));
    }

    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See http://en.wikipedia.org/wiki/Symmetric_difference.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of values.
     * @example
     *
     * _.xor([1, 2, 3], [5, 2, 1, 4]);
     * // => [3, 5, 4]
     *
     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
     * // => [1, 4, 5]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
            : array;
        }
      }
      return result || [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second
     * elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @alias unzip
     * @category Arrays
     * @param {...Array} [array] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var array = arguments.length > 1 ? arguments : arguments[0],
          index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);

      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }

    /**
     * Creates an object composed from arrays of `keys` and `values`. Provide
     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};

      if (!values && length && !isArray(keys[0])) {
        values = [];
      }
      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that executes `func`, with  the `this` binding and
     * arguments of the created function, only after being called `n` times.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {number} n The number of times the function must be called before
     *  `func` is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('Done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'Done saving!', after all saves have completed
     */
    function after(n, func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * provided to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'fred' }, 'hi');
     * func();
     * // => 'hi fred'
     */
    function bind(func, thisArg) {
      return arguments.length > 2
        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
        : createWrapper(func, 1, null, null, thisArg);
    }

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all the function properties
     * of `object` will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...string} [methodName] The object method names to
     *  bind, specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs', when the button is clicked
     */
    function bindAll(object) {
      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
          index = -1,
          length = funcs.length;

      while (++index < length) {
        var key = funcs[index];
        object[key] = createWrapper(object[key], 1, null, null, object);
      }
      return object;
    }

    /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those provided to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'fred',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi fred'
     *
     * object.greet = function(greeting) {
     *   return greeting + 'ya ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      return arguments.length > 2
        ? createWrapper(key, 19, slice(arguments, 2), null, object)
        : createWrapper(key, 3, null, null, object);
    }

    /**
     * Creates a function that is the composition of the provided functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {...Function} [func] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var realNameMap = {
     *   'pebbles': 'penelope'
     * };
     *
     * var format = function(name) {
     *   name = realNameMap[name.toLowerCase()] || name;
     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
     * };
     *
     * var greet = function(formatted) {
     *   return 'Hiya ' + formatted + '!';
     * };
     *
     * var welcome = _.compose(greet, format);
     * welcome('pebbles');
     * // => 'Hiya Penelope!'
     */
    function compose() {
      var funcs = arguments,
          length = funcs.length;

      while (length--) {
        if (!isFunction(funcs[length])) {
          throw new TypeError;
        }
      }
      return function() {
        var args = arguments,
            length = funcs.length;

        while (length--) {
          args = [funcs[length].apply(this, args)];
        }
        return args[0];
      };
    }

    /**
     * Creates a function which accepts one or more arguments of `func` that when
     * invoked either executes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` can be specified
     * if `func.length` is not sufficient.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var curried = _.curry(function(a, b, c) {
     *   console.log(a + b + c);
     * });
     *
     * curried(1)(2)(3);
     * // => 6
     *
     * curried(1, 2)(3);
     * // => 6
     *
     * curried(1, 2, 3);
     * // => 6
     */
    function curry(func, arity) {
      arity = typeof arity == 'number' ? arity : (+arity || func.length);
      return createWrapper(func, 4, null, null, null, arity);
    }

    /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked.
     * Provide an options object to indicate that `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
     * to the debounced function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * var lazyLayout = _.debounce(calculateLayout, 150);
     * jQuery(window).on('resize', lazyLayout);
     *
     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * });
     *
     * // ensure `batchLog` is executed once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * source.addEventListener('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }, false);
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      wait = nativeMax(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    }

    /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) { console.log(text); }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    function defer(func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 1);
      return setTimeout(function() { func.apply(undefined, args); }, 1);
    }

    /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay execution.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) { console.log(text); }, 1000, 'later');
     * // => logs 'later' after one second
     */
    function delay(func, wait) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 2);
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it will be used to determine the cache key for storing the result
     * based on the arguments provided to the memoized function. By default, the
     * first argument provided to the memoized function is used as the cache key.
     * The `func` is executed with the `this` binding of the memoized function.
     * The result cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     *
     * fibonacci(9)
     * // => 34
     *
     * var data = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // modifying the result cache
     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
     * get('pebbles');
     * // => { 'name': 'pebbles', 'age': 1 }
     *
     * get.cache.pebbles.name = 'penelope';
     * get('pebbles');
     * // => { 'name': 'penelope', 'age': 1 }
     */
    function memoize(func, resolver) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

        return hasOwnProperty.call(cache, key)
          ? cache[key]
          : (cache[key] = func.apply(this, arguments));
      }
      memoized.cache = {};
      return memoized;
    }

    /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */
    function once(func) {
      var ran,
          result;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);

        // clear the `func` variable so the function may be garbage collected
        func = null;
        return result;
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those provided to the new function. This
     * method is similar to `_.bind` except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('fred');
     * // => 'hi fred'
     */
    function partial(func) {
      return createWrapper(func, 16, slice(arguments, 1));
    }

    /**
     * This method is like `_.partial` except that `partial` arguments are
     * appended to those provided to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */
    function partialRight(func) {
      return createWrapper(func, 32, null, slice(arguments, 1));
    }

    /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Provide an options object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle executions to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = wait;
      debounceOptions.trailing = trailing;

      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Additional arguments provided to the function are appended
     * to those provided to the wrapper function. The wrapper is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('Fred, Wilma, & Pebbles');
     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
     */
    function wrap(value, wrapper) {
      return createWrapper(wrapper, 16, [value]);
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var getter = _.constant(object);
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name the created callback will return the property value for a given element.
     * If `func` is an object the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(characters, 'age__gt38');
     * // => [{ 'name': 'fred', 'age': 40 }]
     */
    function createCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (func == null || type == 'function') {
        return baseCreateCallback(func, thisArg, argCount);
      }
      // handle "_.pluck" style callback shorthands
      if (type != 'object') {
        return property(func);
      }
      var props = keys(func),
          key = props[0],
          a = func[key];

      // handle "_.where" style callback shorthands
      if (props.length == 1 && a === a && !isObject(a)) {
        // fast path the common case of providing an object with a single
        // property containing a primitive value
        return function(object) {
          var b = object[key];
          return a === b && (a !== 0 || (1 / a == 1 / b));
        };
      }
      return function(object) {
        var length = props.length,
            result = false;

        while (length--) {
          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
            break;
          }
        }
        return result;
      };
    }

    /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('Fred, Wilma, & Pebbles');
     * // => 'Fred, Wilma, &amp; Pebbles'
     */
    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Adds function properties of a source object to the destination object.
     * If `object` is a function methods will be added to its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Function|Object} [object=lodash] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
     * @example
     *
     * function capitalize(string) {
     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     * }
     *
     * _.mixin({ 'capitalize': capitalize });
     * _.capitalize('fred');
     * // => 'Fred'
     *
     * _('fred').capitalize().value();
     * // => 'Fred'
     *
     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
     * _('fred').capitalize();
     * // => 'Fred'
     */
    function mixin(object, source, options) {
      var chain = true,
          methodNames = source && functions(source);

      if (!source || (!options && !methodNames.length)) {
        if (options == null) {
          options = source;
        }
        ctor = lodashWrapper;
        source = object;
        object = lodash;
        methodNames = functions(source);
      }
      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      var ctor = object,
          isFunc = isFunction(ctor);

      forEach(methodNames, function(methodName) {
        var func = object[methodName] = source[methodName];
        if (isFunc) {
          ctor.prototype[methodName] = function() {
            var chainAll = this.__chain__,
                value = this.__wrapped__,
                args = [value];

            push.apply(args, arguments);
            var result = func.apply(object, args);
            if (chain || chainAll) {
              if (value === result && isObject(result)) {
                return this;
              }
              result = new ctor(result);
              result.__chain__ = chainAll;
            }
            return result;
          };
        }
      });
    }

    /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // no operation performed
    }

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var stamp = _.now();
     * _.defer(function() { console.log(_.now() - stamp); });
     * // => logs the number of milliseconds it took for the deferred function to be called
     */
    var now = isNative(now = Date.now) && now || function() {
      return new Date().getTime();
    };

    /**
     * Converts the given value into an integer of the specified radix.
     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.io/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} value The value to parse.
     * @param {number} [radix] The radix used to interpret the value to parse.
     * @returns {number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */
    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };

    /**
     * Creates a "_.pluck" style function, which returns the `key` value of a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} key The name of the property to retrieve.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var characters = [
     *   { 'name': 'fred',   'age': 40 },
     *   { 'name': 'barney', 'age': 36 }
     * ];
     *
     * var getName = _.property('name');
     *
     * _.map(characters, getName);
     * // => ['barney', 'fred']
     *
     * _.sortBy(characters, getName);
     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
     */
    function property(key) {
      return function(object) {
        return object[key];
      };
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number will be
     * returned. If `floating` is truey or either `min` or `max` are floats a
     * floating-point number will be returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating=false] Specify returning a floating-point number.
     * @returns {number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (typeof min == 'boolean' && noMax) {
          floating = min;
          min = 1;
        }
        else if (!noMax && typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /**
     * Resolves the value of property `key` on `object`. If `key` is a function
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to resolve.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */
    function result(object, key) {
      if (object) {
        var value = object[key];
        return isFunction(value) ? object[key]() : value;
      }
    }

    /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * http://lodash.com/custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as local variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [variable] The data object variable name.
     * @returns {Function|string} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'fred' });
     * // => 'hello fred'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to generate HTML
     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'pebbles' });
     * // => 'hello pebbles'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
     * // => 'hello barney!'
     *
     * // using a custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{([\s\S]+?)}}/g
     * };
     *
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `imports` option to import jQuery
     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(text, data, options) {
      // based on John Resig's `tmpl` implementation
      // http://ejohn.org/blog/javascript-micro-templating/
      // and Laura Doktorova's doT.js
      // https://github.com/olado/doT
      var settings = lodash.templateSettings;
      text = String(text || '');

      // avoid missing dependencies when `iteratorTemplate` is not defined
      options = defaults({}, options, settings);

      var imports = defaults({}, options.imports, settings.imports),
          importsKeys = keys(imports),
          importsValues = values(imports);

      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // compile the regexp to match each delimiter
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // escape characters that cannot be included in string literals
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // replace delimiters with snippets
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // the JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value
        return match;
      });

      source += "';\n";

      // if `variable` is not specified, wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain
      var variable = options.variable,
          hasVariable = variable;

      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      // cleanup code by stripping empty strings
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // frame code as the function body
      source = 'function(' + variable + ') {\n' +
        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
        "var __t, __p = '', __e = _.escape" +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      // Use a sourceURL for easier debugging.
      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

      try {
        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
      } catch(e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      // provide the compiled function's source by its `toString` method, in
      // supported environments, or the `source` property as a convenience for
      // inlining compiled templates during the build process
      result.source = source;
      return result;
    }

    /**
     * Executes the callback `n` times, returning an array of the results
     * of each callback execution. The callback is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns an array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);

      callback = baseCreateCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }

    /**
     * The inverse of `_.escape` this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('Fred, Barney &amp; Pebbles');
     * // => 'Fred, Barney & Pebbles'
     */
    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps the given value with explicit
     * method chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(characters)
     *     .sortBy('age')
     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
     *     .first()
     *     .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      value = new lodashWrapper(value);
      value.__chain__ = true;
      return value;
    }

    /**
     * Invokes `interceptor` with the `value` as the first argument and then
     * returns `value`. The purpose of this method is to "tap into" a method
     * chain in order to perform operations on intermediate results within
     * the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .tap(function(array) { array.pop(); })
     *  .reverse()
     *  .value();
     * // => [3, 2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chaining
     * @returns {*} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(characters).first();
     * // => { 'name': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(characters).chain()
     *   .first()
     *   .pick('age')
     *   .value();
     * // => { 'age': 36 }
     */
    function wrapperChain() {
      this.__chain__ = true;
      return this;
    }

    /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {string} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return String(this.__wrapped__);
    }

    /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {*} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */
    function wrapperValueOf() {
      return this.__wrapped__;
    }

    /*--------------------------------------------------------------------------*/

    // add functions that return wrapped values when chaining
    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.chain = chain;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.createCallback = createCallback;
    lodash.curry = curry;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.pull = pull;
    lodash.range = range;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // add aliases
    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;
    lodash.unzip = zip;

    // add functions to `lodash.prototype`
    mixin(lodash);

    /*--------------------------------------------------------------------------*/

    // add functions that return unwrapped values when chaining
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;

    // add aliases
    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;

    mixin(function() {
      var source = {}
      forOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }(), false);

    /*--------------------------------------------------------------------------*/

    // add functions capable of returning wrapped and unwrapped values when chaining
    lodash.first = first;
    lodash.last = last;
    lodash.sample = sample;

    // add aliases
    lodash.take = first;
    lodash.head = first;

    forOwn(lodash, function(func, methodName) {
      var callbackable = methodName !== 'sample';
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName]= function(n, guard) {
          var chainAll = this.__chain__,
              result = func(this.__wrapped__, n, guard);

          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
            ? result
            : new lodashWrapper(result, chainAll);
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = '2.4.1';

    // add "Chaining" functions to the wrapper
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;

    // add `Array` functions that return unwrapped values
    forEach(['join', 'pop', 'shift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var chainAll = this.__chain__,
            result = func.apply(this.__wrapped__, arguments);

        return chainAll
          ? new lodashWrapper(result, chainAll)
          : result;
      };
    });

    // add `Array` functions that return the existing wrapped value
    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });

    // add `Array` functions that return new wrapped values
    forEach(['concat', 'slice', 'splice'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
      };
    });

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // expose Lo-Dash
  var _ = runInContext();

  // some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash is loaded with a RequireJS shim config.
    // See http://requirejs.org/docs/api.html#config-shim
    root._ = _;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define(function() {
      return _;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
    // in Node.js or RingoJS
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // in Narwhal or Rhino -require
    else {
      freeExports._ = _;
    }
  }
  else {
    // in a browser or Rhino
    root._ = _;
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])(1)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImluZGV4LmpzIiwibGliL2FmZmluaXR5L0F0dHJpYnV0ZS5qcyIsImxpYi9hZmZpbml0eS9CYXNlLmpzIiwibGliL2FmZmluaXR5L0ZvcmVpZ25LZXkuanMiLCJsaWIvYWZmaW5pdHkvRnVuY3Rpb24uanMiLCJsaWIvYWZmaW5pdHkvSGVhZGVyLmpzIiwibGliL2FmZmluaXR5L0luZGV4LmpzIiwibGliL2FmZmluaXR5L0tleS5qcyIsImxpYi9hZmZpbml0eS9SZWxhdGlvbi5qcyIsImxpYi9hZmZpbml0eS9TZXQuanMiLCJsaWIvYWZmaW5pdHkvVHVwbGUuanMiLCJsaWIvYWZmaW5pdHkvVHlwZS5qcyIsImxpYi9hZmZpbml0eS9hbGdlYnJhL0NvbXBvc2l0aW9uLmpzIiwibGliL2FmZmluaXR5L2FsZ2VicmEvRGlmZmVyZW5jZS5qcyIsImxpYi9hZmZpbml0eS9hbGdlYnJhL0V4dGVuc2lvbi5qcyIsImxpYi9hZmZpbml0eS9hbGdlYnJhL0dyb3VwLmpzIiwibGliL2FmZmluaXR5L2FsZ2VicmEvSW50ZXJzZWN0aW9uLmpzIiwibGliL2FmZmluaXR5L2FsZ2VicmEvSm9pbi5qcyIsImxpYi9hZmZpbml0eS9hbGdlYnJhL1Byb2R1Y3QuanMiLCJsaWIvYWZmaW5pdHkvYWxnZWJyYS9Qcm9qZWN0aW9uLmpzIiwibGliL2FmZmluaXR5L2FsZ2VicmEvUmVuYW1lLmpzIiwibGliL2FmZmluaXR5L2FsZ2VicmEvUmVzdHJpY3Rpb24uanMiLCJsaWIvYWZmaW5pdHkvYWxnZWJyYS9TZW1pRGlmZmVyZW5jZS5qcyIsImxpYi9hZmZpbml0eS9hbGdlYnJhL1NlbWlKb2luLmpzIiwibGliL2FmZmluaXR5L2FsZ2VicmEvU3VtbWFyaXplLmpzIiwibGliL2FmZmluaXR5L2FsZ2VicmEvVW5ncm91cC5qcyIsImxpYi9hZmZpbml0eS9hbGdlYnJhL1VuaW9uLmpzIiwibGliL2FmZmluaXR5L2FsZ2VicmEvVW53cmFwLmpzIiwibGliL2FmZmluaXR5L2FsZ2VicmEvV3JhcC5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvYWdncmVnYXRlL0FsbC5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvYWdncmVnYXRlL0FueS5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvYWdncmVnYXRlL0F2ZXJhZ2UuanMiLCJsaWIvYWZmaW5pdHkvZnVuY3Rpb25zL2FnZ3JlZ2F0ZS9Db3VudC5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvYWdncmVnYXRlL01heGltdW0uanMiLCJsaWIvYWZmaW5pdHkvZnVuY3Rpb25zL2FnZ3JlZ2F0ZS9NaW5pbXVtLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9hZ2dyZWdhdGUvU3RhbmRhcmREZXZpYXRpb24uanMiLCJsaWIvYWZmaW5pdHkvZnVuY3Rpb25zL2FnZ3JlZ2F0ZS9TdW0uanMiLCJsaWIvYWZmaW5pdHkvZnVuY3Rpb25zL2FnZ3JlZ2F0ZS9WYXJpYW5jZS5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvY29tcGFyYWJsZS9FcXVhbC5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvY29tcGFyYWJsZS9HcmVhdGVyVGhhbi5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvY29tcGFyYWJsZS9HcmVhdGVyVGhhbkVxdWFsLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9jb21wYXJhYmxlL1NtYWxsZXJUaGFuLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9jb21wYXJhYmxlL1NtYWxsZXJUaGFuRXF1YWwuanMiLCJsaWIvYWZmaW5pdHkvZnVuY3Rpb25zL2Nvbm5lY3RpdmUvQW5kLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9jb25uZWN0aXZlL05vdC5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvY29ubmVjdGl2ZS9Pci5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvZGF0ZS9EYXlPZk1vbnRoLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9kYXRlL0RheU9mV2Vlay5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvZGF0ZS9EYXlPZlllYXIuanMiLCJsaWIvYWZmaW5pdHkvZnVuY3Rpb25zL2RhdGUvSG91cnMuanMiLCJsaWIvYWZmaW5pdHkvZnVuY3Rpb25zL2RhdGUvTWlsbGlzZWNvbmRzLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9kYXRlL01pbnV0ZXMuanMiLCJsaWIvYWZmaW5pdHkvZnVuY3Rpb25zL2RhdGUvTW9udGguanMiLCJsaWIvYWZmaW5pdHkvZnVuY3Rpb25zL2RhdGUvU2Vjb25kcy5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvZGF0ZS9UaW1lc3RhbXAuanMiLCJsaWIvYWZmaW5pdHkvZnVuY3Rpb25zL2RhdGUvV2Vla09mWWVhci5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvZGF0ZS9ZZWFyLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL0Fic29sdXRlLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL0NlaWwuanMiLCJsaWIvYWZmaW5pdHkvZnVuY3Rpb25zL251bWVyaWMvQ29zaW5lLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL0RpdmlzaW9uLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL0V4cG9uZW50aWFsLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL0Zsb29yLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL01pbnVzLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL01vZHVsby5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvbnVtZXJpYy9NdWx0aXBsaWNhdGlvbi5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvbnVtZXJpYy9QbHVzLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL1Bvd2VyLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL1JvdW5kLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL1NpbmUuanMiLCJsaWIvYWZmaW5pdHkvZnVuY3Rpb25zL251bWVyaWMvU3F1YXJlUm9vdC5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvbnVtZXJpYy9UYW5nZW50LmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9zdHJpbmcvTGVuZ3RoLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9zdHJpbmcvTG93ZXJjYXNlLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9zdHJpbmcvU3Vic3RyaW5nLmpzIiwibGliL2FmZmluaXR5L2Z1bmN0aW9ucy9zdHJpbmcvVGVzdC5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvc3RyaW5nL1VwcGVyY2FzZS5qcyIsImxpYi9hZmZpbml0eS9mdW5jdGlvbnMvdHVwbGUvQXR0cmlidXRlLmpzIiwibGliL2FmZmluaXR5L2hlbHBlcnMvY2xvbmUuanMiLCJsaWIvYWZmaW5pdHkvaGVscGVycy9jb2VyY2UuanMiLCJsaWIvYWZmaW5pdHkvaGVscGVycy9jb21wYXJlLmpzIiwibGliL2FmZmluaXR5L2hlbHBlcnMvZGVidWcuanMiLCJsaWIvYWZmaW5pdHkvaGVscGVycy9lcXVhbC5qcyIsImxpYi9hZmZpbml0eS9oZWxwZXJzL3R5cGUuanMiLCJsaWIvYWZmaW5pdHkvaGVscGVycy92YWx1ZS5qcyIsImxpYi9hZmZpbml0eS9taXhpbnMvY29tcGFyYWJsZS5qcyIsImxpYi9hZmZpbml0eS9taXhpbnMvY29ubmVjdGFibGUuanMiLCJsaWIvYWZmaW5pdHkvbWl4aW5zL2RhdGUuanMiLCJsaWIvYWZmaW5pdHkvbWl4aW5zL25vdC5qcyIsImxpYi9hZmZpbml0eS9taXhpbnMvbnVtZXJpYy5qcyIsImxpYi9hZmZpbml0eS9taXhpbnMvc2l6ZS1jb21wYXJhYmxlLmpzIiwibGliL2FmZmluaXR5L21peGlucy9zdHJpbmcuanMiLCJsaWIvYWZmaW5pdHkvdHlwZXMvQm9vbGVhbi5qcyIsImxpYi9hZmZpbml0eS90eXBlcy9EYXRlLmpzIiwibGliL2FmZmluaXR5L3R5cGVzL0Zsb2F0LmpzIiwibGliL2FmZmluaXR5L3R5cGVzL0ludGVnZXIuanMiLCJsaWIvYWZmaW5pdHkvdHlwZXMvTnVtZXJpYy5qcyIsImxpYi9hZmZpbml0eS90eXBlcy9PYmplY3QuanMiLCJsaWIvYWZmaW5pdHkvdHlwZXMvU3RyaW5nLmpzIiwibGliL2FmZmluaXR5L3R5cGVzL1R5cGUuanMiLCJsaWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvZGlzdC9sb2Rhc2guanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3oyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1dkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25iQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9ZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzlKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDck9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliJyk7IiwidmFyIEJhc2UgPSByZXF1aXJlKCcuL0Jhc2UuanMnKTtcbnZhciBUeXBlID0gcmVxdWlyZSgnLi9UeXBlLmpzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG52YXIgQXR0cmlidXRlID0gQmFzZS5leHRlbmQoXG5cbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBBdHRyaWJ1dGVcbiAgICAgICAgICogQGV4dGVuZHMgQmFzZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ3xudWxsfSBbYXJncy5uYW1lXSBUaGUgbmFtZSBvZiB0aGUge0BsaW5rIEF0dHJpYnV0ZX1cbiAgICAgICAgICogQHBhcmFtIHtUeXBlfG51bGx9IFthcmdzLnR5cGVdIFRoZSB7QGxpbmsgVHlwZX0gb2YgdGhlIHtAbGluayBBdHRyaWJ1dGV9XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW2FyZ3MuZGVmYXVsdF0gVGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhlIEF0dHJpYnV0ZVxuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiBBIHtAbGluayBSZWxhdGlvbn0ncyB7QGxpbmsgSGVhZGVyfSBpcyBjb21wb3NlZCBvZiBBdHRyaWJ1dGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBbiB7QGxpbmsgQXR0cmlidXRlfSBpcyBzaW1wbHkgYW4gb3JkZXJlZCB7QGxpbmsgU2V0fSB7bmFtZSA6IFN0cmluZywgdHlwZSA6IHtAbGluayBUeXBlfX1cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHtAbGluayBUeXBlfSBvZiBhbiB7QGxpbmsgQXR0cmlidXRlfSBpcyBhIGNsYXNzIHRoYXQgaXMgbWFpbmx5IHVzZWQgdG8gY29tcGFyZSB0aGUgdmFsdWVzIG9mIHRoZVxuICAgICAgICAgKiBSZWxhdGlvbidzIHR1cGxlcyBmb3IgdGhpcyBhdHRpYnV0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIGV4YW1wbGUsXG4gICAgICAgICAqIHdoZW4gcnVubmluZyBhbiB7QGxpbmsgT3BlcmF0b3JzLlVuaW9ufSBvbiBhIHtAbGluayBSZWxhdGlvbn0sIHRoZSB7QGxpbmsgVHVwbGV9cyB3aWxsIGJlIHRlc3RlZCBmb3IgZXF1YWxpdHkgc28gdGhhdCB0aGVcbiAgICAgICAgICoge0BsaW5rIFJlbGF0aW9ufSBkb2VzIG5vdCBpbmNsdWRlIGR1cGxpY2F0ZXMgKGFzIHRoZSBtYXRoZW1hdGljYWwgZGVmaW5pdGlvbiBvZiBhIHtAbGluayBTZXR9IHRlbGxzIHVzKS5cbiAgICAgICAgICogVG8gZG8gdGhpcywgd2UgY29tcGFyZSB0d28ge0BsaW5rIFR1cGxlfSBieSBjb21wYXJpbmcgdGhlIHZhbHVlIG9mIHRoZWlyIHtAbGluayBBdHRyaWJ1dGV9cy4gSWYgZm9yIHRoZXNlIHR3b1xuICAgICAgICAgKiB7QGxpbmsgVHVwbGV9cywgYWxsIHRoZWlyIHtAbGluayBBdHRyaWJ1dGV9IHZhbHVlcyBhcmUgZXF1YWwsIHRoZSB0d28ge0BsaW5rIFR1cGxlfXMgYXJlIHNhaWQgdG8gYmUgZXF1YWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRvIHRlc3QgdGhlIGVxdWFsaXR5IG9mIHByaW1pdGl2ZSB7QGxpbmsgQXR0cmlidXRlfXMgKFN0cmluZywgQm9vbGVhbiwgSW50ZWdlci4uLiksIHRoaXMgaXMgZWFzeS5cbiAgICAgICAgICogV2UgdGVzdCB0aGUgZXF1YWxpdHkgb2YgdHdvIHtAbGluayBBdHRyaWJ1dGV9cyB3aXRoIHRoZSBlcXVhbGl0eSBvcGVyYXRvciBcIj09XCIuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRob3VnaCwgd2hlbiBpdCBjb21lcyB0byBPYmplY3Qge0BsaW5rIEF0dHJpYnV0ZX1zLCBpdCBpcyBub3QgcG9zc2libGUgdG8gdGVzdCB0aGUgZXF1YWxpdHkgd2l0aCB0aGUgZXF1YWxpdHkgb3BlcmF0b3JcbiAgICAgICAgICogXCI9PVwiLiBXZSBuZWVkIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHRlc3QgdGhlIHR3byBvYmplY3RzIGZvciBlcXVhbGl0eSBhbmQgdGhhdCB3aWxsIHJldHVybiB0cnVlL2ZhbHNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUbyByZXN1bWUsIHRoZSB7QGxpbmsgVHlwZX0gb2YgYW4ge0BsaW5rIEF0dHJpYnV0ZX0gbXVzdCBpbXBsZW1lbnQgdGhlIG1ldGhvZHMgdXNlZCB0byBjb21wYXJlIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICAgICAqIHtAbGluayBUdXBsZX0ge0BsaW5rIEF0dHJpYnV0ZX0gdmFsdWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3Ige0BsaW5rIFR5cGVzLk51bWVyaWN9IHtAbGluayBUeXBlfXMsIHRoZSB7QGxpbmsgVHlwZX0gd2lsbCBhbHNvIGltcGxlbWVudCBvdGhlciBjb21wYXJpc29uIG9wZXJhdG9ycyBzdWNoIGFzIExhcmdlclRoYW4gKC5sdCgpKSAuLi5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIHtAbGluayBUeXBlcy5EYXRlfSB7QGxpbmsgVHlwZX1zLCB0aGUge0BsaW5rIFR5cGV9IHdpbGwgYWxzbyBpbXBsZW1lbnQgb3RoZXIgb3BlcmF0b3JzIHN1Y2ggYXMgRGF5T2ZXZWVrLCAuLi5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBmbiA9IG5ldyBhZmZpbml0eS5BdHRyaWJ1dGUoe25hbWUgOiAnRmlyc3ROYW1lJywgdHlwZSA6ICdhZmZpbml0eS5TdHJpbmcnfSlcbiAgICAgICAgICogICAgIHZhciBsbiA9IG5ldyBhZmZpbml0eS5BdHRyaWJ1dGUoe25hbWUgOiAnTGFzdE5hbWUnLCB0eXBlIDogJ2FmZmluaXR5LlN0cmluZyd9KVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIChhcmdzKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGVsbHMgaWYgdGhlIGF0dHJpYnV0ZSB3YXMgX25lZ2F0ZWQgaW4gYW4gZXhwcmVzc2lvblxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9uZWdhdGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICogQHR5cGUge3VuZGVmaW5lZH1cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2RlZmF1bHQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGVsbHMgaWYgdGhlIGF0dHJpYnV0ZSBpcyBhbiBhdXRvIGluY3JlbWVudGluZyBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fYXV0b0luY3JlbWVudCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRlbGxzIGlmIHRoZSBhdHRyaWJ1dGUgaXMgYSBjYWxjdWxhdGVkIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVHlwZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICAgICAgICAgKiBAdHlwZSB7VHlwZX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy50eXBlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgYXJncyBhcmUgZ2l2ZW5cbiAgICAgICAgICAgIGlmIChhcmdzKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgbmFtZSBhcmcgaXMgZ2l2ZW5cbiAgICAgICAgICAgICAgICBpZiAoYXJncy5uYW1lKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG5hbWUgYXJnIGlzIG9mIGdvb2QgdHlwZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIV8uaXNTdHJpbmcoYXJncy5uYW1lKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbmFtZSBpcyBub3QgYSBzdHJpbmcsIHRocm93XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOYW1lIGlzIG9mIHdyb25nIHR5cGUnKTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOYW1lIGFyZyBzZWVtcyB0byBiZSBsZWdpdFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gYXJncy5uYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbmFtZSBhcmcgaXMgbm90IGdpdmVuLCBzZXQgaXQgdG8gbnVsbFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSB0eXBlIGFyZyBpcyBnaXZlblxuICAgICAgICAgICAgICAgIGlmIChhcmdzLnR5cGUpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgdHlwZSBhcmcgaXMgb2YgZ29vZCB0eXBlXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGFyZ3MudHlwZS5wcm90b3R5cGUgaW5zdGFuY2VvZiBUeXBlKSAmJiAhKGFyZ3MudHlwZS5fX3Byb3RvX18gaW5zdGFuY2VvZiBUeXBlKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdHlwZSBhcmcgaXMgbm90IG9mIHR5cGUgVHlwZSwgdGhyb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1R5cGUgaXMgb2Ygd3JvbmcgdHlwZScpXG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFR5cGUgYXJnIHNlZW1zIHRvIGJlIGxlZ2l0XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBhcmdzLnR5cGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF8uZm9ySW4oYXJncy50eXBlLnBheWxvYWQsIGZ1bmN0aW9uKG1peCl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmZvckluKG1peCwgZnVuY3Rpb24gKG1peGluLCBrZXkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBtaXhpbjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sdGhpcylcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSx0aGlzKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdHlwZSBhcmcgaXMgbm90IGdpdmVuLCBzZXQgaXQgdG8gbnVsbFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChhcmdzLmhhc093blByb3BlcnR5KCdkZWZhdWx0Jykpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWZhdWx0ID0gYXJncy5kZWZhdWx0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChhcmdzLmhhc093blByb3BlcnR5KCdhdXRvSW5jcmVtZW50Jykpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdXRvSW5jcmVtZW50ID0gYXJncy5hdXRvSW5jcmVtZW50O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBCYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bHRlZCBQcm9wZXJ0eSBnZXR0ZXIgc2V0dGVyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNDYWxjdWxhdGVkXG4gICAgICAgICAqIEByZXR1cm4ge3VuZGVmaW5lZHxCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY2FsY3VsYXRlZCA6IGZ1bmN0aW9uKGlzQ2FsY3VsYXRlZCl7XG5cbiAgICAgICAgICAgIGlmKF8uaXNCb29sZWFuKGlzQ2FsY3VsYXRlZCkpe1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZWQgPSBpc0NhbGN1bGF0ZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb25lcyB0aGUgQXR0cmlidXRlIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJuIHtBdHRyaWJ1dGV9IGNsb25lZCBhdHRyaWJ1dGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBmbiA9IG5ldyBhZmZpbml0eS5BdHRyaWJ1dGUoe25hbWUgOiAnRmlyc3ROYW1lJyxhZmZpbml0eS5TdHJpbmd9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBsbiA9IGF0dHJpYnV0ZS5jbG9uZSgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgbG4uZXF1YWwoZm4pIC8vIHRydWVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGxuLm5hbWUgPSAnTGFzdE5hbWUnO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgbG4uZXF1YWwoZm4pIC8vIGZhbHNlXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICB2YXIgYXR0ciA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHt0eXBlOiB0aGlzLnR5cGUsIG5hbWU6IHRoaXMubmFtZX0pO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5yZWxhdGlvbkhlYWRlcikge1xuICAgICAgICAgICAgICAgIGF0dHIucmVsYXRpb25IZWFkZXIgPSB0aGlzLnJlbGF0aW9uSGVhZGVyO1xuOyAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy53cmFwcGVkQXR0cmlidXRlcyl7XG4gICAgICAgICAgICAgICAgYXR0ci53cmFwcGVkQXR0cmlidXRlcyA9IHRoaXMud3JhcHBlZEF0dHJpYnV0ZXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF0dHIuY2FsY3VsYXRlZCh0aGlzLmNhbGN1bGF0ZWQoKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBhdHRyO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIGF0dHJpYnV0ZSBpcyBiZWluZyBfbmVnYXRlZCBpbiBhIHByZWRpY2F0ZVxuICAgICAgICAgKiBAcGFyYW0gZXhwcmVzc2lvblxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9jaGVja05lZ2F0ZWRBdHRyaWJ1dGU6IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9uZWdhdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmVnYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKHJlcXVpcmUoJy4vZnVuY3Rpb25zL2Nvbm5lY3RpdmUvTm90LmpzJykpKGV4cHJlc3Npb24pO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBhdHRyaWJ1dGUuIFVzZWQgdG8gcHJpbnQgYSBSZWxhdGlvbiBpbnRvIGNvbnNvbGVcbiAgICAgICAgICogYXMgYSBVbmljb2RlIFRhYmxlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgJyA6ICcgKyB0aGlzLnR5cGUudG9TdHJpbmcoKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgaWYgdHdvIGF0dHJpYnV0ZXMgYXJlIGVxdWFsXG4gICAgICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbCA6IGZ1bmN0aW9uKGF0dHJpYnV0ZSl7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLmVxdWFsKHRoaXMsIGF0dHJpYnV0ZSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBkZWZhdWx0IDogZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgaWYodGhpcy5fYXV0b0luY3JlbWVudCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyLnJlbGF0aW9uLmxlbmd0aCgpICsgdGhpcy5oZWFkZXIucmVsYXRpb24uX2RlbGV0ZWRDb3VudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHQ7XG4gICAgICAgIH1cblxuICAgIH0sIHtcblxuICAgICAgICB0eXBlIDogJ0F0dHJpYnV0ZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzc2VydHMgdGhhdCBhIGdpdmVuIG5hbWUgaXMgdmFsaWQgZm9yIGFuIGF0dHJpYnV0ZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gbmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgYXNzZXJ0VmFsaWROYW1lIDogZnVuY3Rpb24obmFtZSl7XG5cbiAgICAgICAgICAgIGlmKCFfLmlzU3RyaW5nKG5hbWUpKXtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05hbWUgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKG5hbWUgPT09ICcnKXtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSBuYW1lIGNhbm5vdCBiZSBlbXB0eSBzdHJpbmcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXN0cyBmb3IgZXF1YWxpdHkgYmV0d2VlbiB0d28gYXR0cmlidXRlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgQm9vbGVhbi4gSXQgY2Fubm90IGJlIHBhcnQgb2YgYSBwcmVkaWNhdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7QXR0cmlidXRlfSBhdHRyaWJ1dGUxXG4gICAgICAgICAqIEBwYXJhbSB7QXR0cmlidXRlfSBhdHRyaWJ1dGUyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKiBAc3RhdGljXG5cbiAgICAgICAgICovXG4gICAgICAgIGVxdWFsOiBmdW5jdGlvbiAoYXR0cmlidXRlMSwgYXR0cmlidXRlMikge1xuXG4gICAgICAgICAgICByZXR1cm4gKChhdHRyaWJ1dGUxLm5hbWUgPT09IGF0dHJpYnV0ZTIubmFtZSkgJiYgKGF0dHJpYnV0ZTEudHlwZSA9PT0gYXR0cmlidXRlMi50eXBlKSlcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2VyY2VzIGFuIGFyYml0cmFyeSBvYmplY3QgdG8gdHlwZSBBdHRyaWJ1dGVcbiAgICAgICAgICogQHBhcmFtIHtBdHRyaWJ1dGV8T2JqZWN0fSBhdHRyaWJ1dGVcbiAgICAgICAgICogQHJldHVybnMge0F0dHJpYnV0ZX1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGZuMSA9IG5ldyBhZmZpbml0eS5BdHRyaWJ1dGUoe25hbWUgOiAnRmlyc3ROYW1lJywgdHlwZSA6IGFmZmluaXR5LlN0cmluZ30pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGZuMiA9IHtuYW1lIDogJ0ZpcnN0TmFtZScgLCB0eXBlIDogYWZmaW5pdHkuU3RyaW5nfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgYWZmaW5pdHkuQXR0cmlidXRlLmNvZXJjZShmbjEpID09PSBmbjEgLy8gdHJ1ZSwgdGhlIG9iamVjdCB3YXMgYWxyZWFkeSBhbiBBdHRyaWJ1dGUuXG4gICAgICAgICAqICAgICBhZmZpbml0eS5BdHRyaWJ1dGUuY29lcmNlKGZuMikgPT09IGZuMiAvLyBmYWxzZSwgdGhlIG9iamVjdCBoYWQgdG8gYmUgY29lcmNlZFxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgYWZmaW5pdHkuQXR0cmlidXRlLmNvZXJjZShmbjIpLmVxdWFsKGZuMSkgLy8gdHJ1ZVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29lcmNlOiBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG5cblxuICAgICAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgICAgICB2YXIgdHlwZTtcbiAgICAgICAgICAgIHZhciBhdHRyO1xuICAgICAgICAgICAgdmFyIGtleXM7XG4gICAgICAgICAgICB2YXIgYXV0b0luY3JlbWVudDtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0VmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUgaW5zdGFuY2VvZiBBdHRyaWJ1dGUpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoXy5pc09iamVjdChhdHRyaWJ1dGUpKXtcblxuICAgICAgICAgICAgICAgIC8vIEF0dHJpYnV0ZSBpcyBvZiB0aGUgdHlwZSB7bmFtZSA6IDxuYW1lPiwgdHlwZSA6IDx0eXBlPn1cbiAgICAgICAgICAgICAgICBpZihhdHRyaWJ1dGUudHlwZSAmJiBhdHRyaWJ1dGUubmFtZSl7XG5cbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGF0dHJpYnV0ZS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gYXR0cmlidXRlLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGF1dG9JbmNyZW1lbnQgPSBhdHRyaWJ1dGUuYXV0b0luY3JlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gYXR0cmlidXRlLmRlZmF1bHQ7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEF0dHJpYnV0ZSBpcyBlaXRoZXJcbiAgICAgICAgICAgICAgICAgICAgLy8geyA8bmFtZT4gOiB7IHR5cGUgOiA8dHlwZT4gfSB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHsgPG5hbWU+IDogPEF0dHJpYnV0ZT4gfVxuXG4gICAgICAgICAgICAgICAgICAgIGtleXMgPSBfLmtleXMoYXR0cmlidXRlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5cy5sZW5ndGggIT09IDEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBBdHRyaWJ1dGUgZGVjbGFyYXRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5hbWUgb2YgdGhlIEF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICBuYW1lID0ga2V5c1swXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBdHRyaWJ1dGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIGF0dHIgPSBhdHRyaWJ1dGVbbmFtZV07XG5cblxuICAgICAgICAgICAgICAgICAgICBpZihhdHRyIGluc3RhbmNlb2YgQXR0cmlidXRlKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXR0cmlidXRlIGlzIHsgPG5hbWU+IDogPEF0dHJpYnV0ZT59XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIubmFtZSA9IG5hbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRyO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihhdHRyLnR5cGUpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdHRyaWJ1dGUgaXMgeyA8bmFtZT4gOiB7IHR5cGUgOiA8dHlwZT4gfSB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBhdHRyaWJ1dGVbbmFtZV0udHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9JbmNyZW1lbnQgPSBhdHRyaWJ1dGVbbmFtZV0uYXV0b0luY3JlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IGF0dHJpYnV0ZVtuYW1lXS5kZWZhdWx0O1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZSh7bmFtZSA6IG5hbWUsIHR5cGUgOiB0eXBlLCBhdXRvSW5jcmVtZW50IDogYXV0b0luY3JlbWVudCwgZGVmYXVsdCA6IGRlZmF1bHRWYWx1ZX0pO1xuXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF0dHJpYnV0ZTtcbiIsInZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29ycmVjdGx5IHNldCB1cCB0aGUgcHJvdG90eXBlIGNoYWluLCBmb3Igc3ViY2xhc3Nlcy5cbi8vIFNpbWlsYXIgdG8gYGdvb2cuaW5oZXJpdHNgLCBidXQgdXNlcyBhIGhhc2ggb2YgcHJvdG90eXBlIHByb3BlcnRpZXMgYW5kXG4vLyBjbGFzcyBwcm9wZXJ0aWVzIHRvIGJlIGV4dGVuZGVkLlxudmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuXG4gICAgdmFyIHBhcmVudCA9IHRoaXM7XG4gICAgdmFyIGNoaWxkO1xuXG4gICAgLy8gVGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgbmV3IHN1YmNsYXNzIGlzIGVpdGhlciBkZWZpbmVkIGJ5IHlvdVxuICAgIC8vICh0aGUgXCJjb25zdHJ1Y3RvclwiIHByb3BlcnR5IGluIHlvdXIgYGV4dGVuZGAgZGVmaW5pdGlvbiksIG9yIGRlZmF1bHRlZFxuICAgIC8vIGJ5IHVzIHRvIHNpbXBseSBjYWxsIHRoZSBwYXJlbnQncyBjb25zdHJ1Y3Rvci5cbiAgICBpZiAocHJvdG9Qcm9wcyAmJiBfLmhhcyhwcm90b1Byb3BzLCAnY29uc3RydWN0b3InKSkge1xuICAgICAgICBjaGlsZCA9IHByb3RvUHJvcHMuY29uc3RydWN0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQWRkIHN0YXRpYyBwcm9wZXJ0aWVzIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgaWYgc3VwcGxpZWQuXG4gICAgXy5leHRlbmQoY2hpbGQsIHBhcmVudCwgc3RhdGljUHJvcHMpO1xuXG4gICAgLy8gU2V0IHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gaW5oZXJpdCBmcm9tIGBwYXJlbnRgLCB3aXRob3V0IGNhbGxpbmdcbiAgICAvLyBgcGFyZW50YCdzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgIHZhciBTdXJyb2dhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDtcbiAgICB9O1xuICAgIFN1cnJvZ2F0ZS5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBTdXJyb2dhdGU7XG5cbiAgICAvLyBBZGQgcHJvdG90eXBlIHByb3BlcnRpZXMgKGluc3RhbmNlIHByb3BlcnRpZXMpIHRvIHRoZSBzdWJjbGFzcyxcbiAgICAvLyBpZiBzdXBwbGllZC5cbiAgICBpZiAocHJvdG9Qcm9wcykgXy5leHRlbmQoY2hpbGQucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcblxuICAgIC8vIFNldCBhIGNvbnZlbmllbmNlIHByb3BlcnR5IGluIGNhc2UgdGhlIHBhcmVudCdzIHByb3RvdHlwZSBpcyBuZWVkZWRcbiAgICAvLyBsYXRlci5cbiAgICBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlO1xuXG4gICAgcmV0dXJuIGNoaWxkO1xuXG59O1xuXG4vKipcbiAqIEBjbGFzcyBCYXNlXG4gKi9cbnZhciBCYXNlID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG4vKipcbiAqIEBtZW1iZXIgQmFzZVxuICogQG1ldGhvZCBleHRlbmRcbiAqL1xuQmFzZS5leHRlbmQgPSBleHRlbmQ7XG5cbi8qKlxuICogQG1lbWJlciBCYXNlXG4gKi9cbkJhc2UubWl4aW4gPSBmdW5jdGlvbihtaXhpbil7XG4gICAgXy5leHRlbmQodGhpcy5wcm90b3R5cGUsIG1peGluKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZTsiLCJ2YXIgQmFzZSA9IHJlcXVpcmUoJy4vQmFzZScpLFxuICAgIEluZGV4ID0gcmVxdWlyZSgnLi9JbmRleCcpLFxuICAgIEhlYWRlciA9IHJlcXVpcmUoJy4vSGVhZGVyJyksXG4gICAgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxuICAgIEF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4vQXR0cmlidXRlJyksXG4gICAgVHVwbGUgPSByZXF1aXJlKCcuL1R1cGxlJyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuL2hlbHBlcnMvZGVidWcnKSxcbiAgICBlcXVhbCA9IHJlcXVpcmUoJy4vaGVscGVycy9lcXVhbCcpO1xuXG52YXIgRm9yZWlnbktleSA9IEJhc2UuZXh0ZW5kKHtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBGb3JlaWduS2V5XG4gICAgICogQGV4dGVuZHMgQmFzZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSBwYXJhbXMucmVsYXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXXxIZWFkZXJ9IHBhcmFtcy5jb2x1bW5OYW1lc1xuICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHBhcmFtcy5yZWZlcmVuY2VkUmVsYXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXXxIZWFkZXJ9IHBhcmFtcy5yZWZlcmVuY2VkQ29sdW1uTmFtZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm9uVXBkYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5vbkRlbGV0ZVxuICAgICAqXG4gICAgICogVGhlIEZvcmVpZ25LZXkgY2xhc3MgcmVwcmVzZW50cyBmb3JlaWduIGtleXMgdG8gYSByZWxhdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBmb3JlaWduIGtleSBlbmZvcmNlcyB0aGUgcmVsYXRpb25hbCBpbnRlZ3JpdHkgb2YgZGlmZmVyZW50IHJlbGF0aW9ucy5cbiAgICAgKlxuICAgICAqXG4gICAgICogICAgIHZhciBkb2dzID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgKiAgICAgICAgICB7aWQgOiB7dHlwZSA6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgKiAgICAgICAgICB7b3duZXJJZCA6IHt0eXBlIDogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAqICAgICAgICAgIHtuYW1lIDoge3R5cGUgOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICogICAgICBdLFtcbiAgICAgKiAgICAgICAgICBbMCwgMCwgJ0ZpZG8nXSxcbiAgICAgKiAgICAgICAgICBbMSwgMCwgJ0JvYmJ5J10sXG4gICAgICogICAgICAgICAgWzIsIDEsICdTdGFjZXknXSxcbiAgICAgKiAgICAgICAgICBbMywgMiwgJ0NlYXNhciddLFxuICAgICAqICAgICAgXSx7XG4gICAgICogICAgICAgICAgcGsgOiBbJ2lkJ10sXG4gICAgICogICAgICAgICAgZmsgOiBbXG4gICAgICogICAgICAgICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgICAgICAgIGNvbHVtbk5hbWVzICAgICAgICAgICA6IFsnb3duZXJJZCddLFxuICAgICAqICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlZFJlbGF0aW9uICAgIDogcGVvcGxlLFxuICAgICAqICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlZENvbHVtbk5hbWVzIDogWydpZCddLFxuICAgICAqICAgICAgICAgICAgICAgICAgb25VcGRhdGUgICAgICAgICAgICAgIDogJ2Nhc2NhZGUnLFxuICAgICAqICAgICAgICAgICAgICAgICAgb25EZWxldGUgICAgICAgICAgICAgIDogJ3Jlc3RyaWN0J1xuICogICAgICAgICAgICAgICAgICB9LFxuICAgICAqICAgICAgICAgICAgICAuLi5cbiAgICAgKiAgICAgICAgICBdXG4gICAgICogICAgICB9KTtcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHBhcmFtcykge1xuXG4gICAgICAgIGRlYnVnLmZvcmVpZ25LZXkudHJhY2UoJyNjb25zdHJ1Y3RvcicpO1xuXG4gICAgICAgIC8vIHJlbGF0aW9uLCBjb2x1bW5OYW1lcywgcmVmZXJlbmNlZFJlbGF0aW9uLCByZWZlcmVuY2VkQ29sdW1uTmFtZXMsIG9uVXBkYXRlLCBvbkRlbGV0ZVxuXG4gICAgICAgIC8qKiBAcHJvcGVydHkge0hlYWRlcn0gY29sdW1ucyAqL1xuICAgICAgICB0aGlzLmNvbHVtbnMgPSBudWxsO1xuXG4gICAgICAgIC8qKiBAcHJvcGVydHkge0hlYWRlcn0gcmVmZXJlbmNlZENvbHVtbnMgKi9cbiAgICAgICAgdGhpcy5yZWZlcmVuY2VkQ29sdW1ucyA9IG51bGw7XG5cbiAgICAgICAgLyoqIEBwcm9wZXJ0eSB7UmVsYXRpb259IHJlbGF0aW9uICovXG4gICAgICAgIHRoaXMucmVsYXRpb24gPSBwYXJhbXMucmVsYXRpb247XG5cbiAgICAgICAgLyoqIEBwcm9wZXJ0eSB7UmVsYXRpb259IHJlZmVyZW5jZWRSZWxhdGlvbiAqL1xuICAgICAgICB0aGlzLnJlZmVyZW5jZWRSZWxhdGlvbiA9IHBhcmFtcy5zZWxmUmVmZXJlbmNpbmcgPyB0aGlzLnJlbGF0aW9uIDogcGFyYW1zLnJlZmVyZW5jZWRSZWxhdGlvbjtcblxuICAgICAgICAvLyBWYWxpZGF0ZSBjb2x1bW5OYW1lcyBwYXJhbWV0ZXJcblxuICAgICAgICBpZiAocGFyYW1zLmNvbHVtbk5hbWVzIGluc3RhbmNlb2YgSGVhZGVyKSB7XG5cbiAgICAgICAgICAgIC8vIGNvbHVtbk5hbWVzIGlzIGFscmVhZHkgYSBoZWFkZXJcbiAgICAgICAgICAgIGlmICghcGFyYW1zLmNvbHVtbk5hbWVzLmlzU3Vic2V0KHJlbGF0aW9uLmhlYWRlcigpKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmFtZXRlciBjb2x1bW5OYW1lcyBwYXNzZWQgYXMgaW52YWxpZCBIZWFkZXIuICcpO1xuXG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMgPSBwYXJhbXMuY29sdW1uTmFtZXM7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgaWYoIV8uaXNBcnJheShwYXJhbXMuY29sdW1uTmFtZXMpKXtcbiAgICAgICAgICAgICAgICBwYXJhbXMuY29sdW1uTmFtZXMgPSBbcGFyYW1zLmNvbHVtbk5hbWVzXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jb2x1bW5zID0gIHRoaXMucmVsYXRpb24uaGVhZGVyKCkuY2xvbmUoKS5wcm9qZWN0KHBhcmFtcy5jb2x1bW5OYW1lcyk7XG5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gVmFsaWRhdGUgcmVmZXJlbmNlZENvbHVtbk5hbWVzIHBhcmFtZXRlclxuXG4gICAgICAgIGlmIChwYXJhbXMucmVmZXJlbmNlZENvbHVtbk5hbWVzIGluc3RhbmNlb2YgSGVhZGVyKSB7XG5cbiAgICAgICAgICAgIC8vIHJlZmVyZW5jZWRDb2x1bW5OYW1lcyBpcyBhbHJlYWR5IGEgaGVhZGVyXG4gICAgICAgICAgICBpZiAoIXBhcmFtcy5yZWZlcmVuY2VkQ29sdW1uTmFtZXMuaXNTdWJzZXQocGFyYW1zLnJlZmVyZW5jZWRSZWxhdGlvbi5oZWFkZXIoKSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXIgcmVmZXJlbmNlZENvbHVtbk5hbWVzIHBhc3NlZCBhcyBpbnZhbGlkIEhlYWRlci4gJyk7XG5cbiAgICAgICAgICAgIHRoaXMucmVmZXJlbmNlZENvbHVtbnMgPSBwYXJhbXMucmVmZXJlbmNlZENvbHVtbk5hbWVzO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmKCFfLmlzQXJyYXkocGFyYW1zLnJlZmVyZW5jZWRDb2x1bW5OYW1lcykpe1xuICAgICAgICAgICAgICAgIHBhcmFtcy5yZWZlcmVuY2VkQ29sdW1uTmFtZXMgPSBbcGFyYW1zLnJlZmVyZW5jZWRDb2x1bW5OYW1lc107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlZmVyZW5jZWRDb2x1bW5zID0gdGhpcy5yZWZlcmVuY2VkUmVsYXRpb24uaGVhZGVyKCkuY2xvbmUoKS5wcm9qZWN0KHBhcmFtcy5yZWZlcmVuY2VkQ29sdW1uTmFtZXMpO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvL3RvZG8gOiBWZXJpZnkgb25VcGRhdGVcbiAgICAgICAgLy90b2RvIDogVmVyaWZ5IG9uRGVsZXRlXG5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG5cbiAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgYWRkZWQgdHVwbGUgcmVzcGVjdHMgdGhlIGZvcmVpZ24ga2V5IGNvbnN0cmFpbnQgYmVmb3JlIGFkZGluZyB0aGUgdHVwbGVcblxuICAgICAgICB0aGlzLnJlbGF0aW9uLmVlLm9uKCdhZnRlckFkZCcsIGZ1bmN0aW9uKHR1cGxlLCB0dXBsZUluZGV4KXtcblxuICAgICAgICAgICAgZGVidWcuZm9yZWlnbktleS50cmFjZSgnI2JlZm9yZUFkZCcpO1xuXG4gICAgICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICAgICAgdGhhdC5jaGVja0ZvcmVpZ25LZXlDb25zdHJhaW50KHR1cGxlKTtcblxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cbiAgICAgICAgICAgICAgICB0aGF0LnJlbGF0aW9uLnJlbW92ZUF0KHR1cGxlSW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgdGhyb3coZXJyKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGVuIGFkZCB0aGUgdHVwbGUgZnJvbSBpbmRleCBiZWZvcmUgdGhlIHR1cGxlIHVwZGF0ZVxuXG4gICAgICAgIHRoaXMucmVsYXRpb24uZWUub24oJ2JlZm9yZVVwZGF0ZScsIGZ1bmN0aW9uKHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSl7XG5cbiAgICAgICAgICAgIGRlYnVnLmZvcmVpZ25LZXkudHJhY2UoJyNiZWZvcmVVcGRhdGUnKTtcblxuICAgICAgICAgICAgdmFyIHByb2plY3RlZFR1cGxlID0gdHVwbGUuY2xvbmUoKTtcblxuICAgICAgICAgICAgcHJvamVjdGVkVHVwbGUuc2V0KGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcblxuICAgICAgICAgICAgdGhhdC5jaGVja0ZvcmVpZ25LZXlDb25zdHJhaW50KHByb2plY3RlZFR1cGxlKTtcblxuICAgICAgICB9KTtcblxuICAgIH0sXG5cbiAgICBjaGVja0ZvcmVpZ25LZXlDb25zdHJhaW50IDogZnVuY3Rpb24odHVwbGUpe1xuXG4gICAgICAgIGRlYnVnLmZvcmVpZ25LZXkudHJhY2UoJyNjaGVja0ZvcmVpZ25LZXlDb25zdHJhaW50Jyk7XG5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAga2V5VHVwbGUsXG4gICAgICAgICAgICB0ZW1wb3JhcnlSZWxhdGlvbixcbiAgICAgICAgICAgIFJlbGF0aW9uLFxuICAgICAgICAgICAgcHJvamVjdGVkUmVmZXJlbmNlZFJlbGF0aW9uLFxuICAgICAgICAgICAgaW50ZXJzZWN0ZWRSZWxhdGlvbjtcblxuXG4gICAgICAgIC8vLyBCdWlsZCBhIHR1cGxlIGNvbnRhaW5pbmcgdGhlIHJlcXVpcmVkIHZhbHVlcyBmb3IgdGhlIGdpdmVuIHJlZmVyZW5jZWQgY29sdW1uc1xuXG4gICAgICAgIGtleVR1cGxlID0gbmV3IFR1cGxlKCk7XG5cbiAgICAgICAgdGhhdC5yZWZlcmVuY2VkQ29sdW1ucy5lYWNoKGZ1bmN0aW9uKHJlZmVyZW5jZWRBdHRyaWJ1dGUsIGF0dHJpYnV0ZUluZGV4KXtcblxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IHRoYXQuY29sdW1ucy5hdEluZGV4KGF0dHJpYnV0ZUluZGV4KTtcblxuICAgICAgICAgICAga2V5VHVwbGUuc2V0KHJlZmVyZW5jZWRBdHRyaWJ1dGUubmFtZSwgdHVwbGUuZ2V0KGF0dHJpYnV0ZS5uYW1lKSk7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhhdC5yZWZlcmVuY2VkUmVsYXRpb24uZWFjaChmdW5jdGlvbih0dXBsZSwgaW5kZXgpe1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcblxuICAgICAgICAgICAga2V5VHVwbGUuZWFjaChmdW5jdGlvbihhdHRyaWJ1dGUpe1xuXG4gICAgICAgICAgICAgICAgaWYgKCFlcXVhbChudWxsLCBrZXlUdXBsZS5nZXQoYXR0cmlidXRlKSwgdHVwbGUuZ2V0KGF0dHJpYnV0ZSkpKXtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09IGZhbHNlKXtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvcmVpZ24ga2V5IGNvbnN0cmFpbnQgY2hlY2sgZmFpbCcpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbn0se1xuXG4gICAgY2FzY2FkZVZhbHVlcyA6IFsnY2FzY2FkZScsICdwcmV2ZW50J11cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRm9yZWlnbktleTsiLCJ2YXIgQmFzZSA9IHJlcXVpcmUoJy4vQmFzZS5qcycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBBdHRyaWJ1dGUgPSByZXF1aXJlKCcuL0F0dHJpYnV0ZScpO1xuXG52YXIgRnVuY3Rpb24gPSBCYXNlLmV4dGVuZChcblxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIEZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzXG4gICAgICAgICAqIEBwcm9wZXJ0eSBbQXJyYXldIHBhcmFtZXRlcnNcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAocGFyYW1ldGVycykge1xuXG4gICAgICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSBbXTtcblxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblxuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1ldGVycy5wdXNoKGFyZ3VtZW50c1tpXSk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGZ1bmN0aW9uJ3MgcGFyYW1ldGVyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbSBUaGUgcGFyYW1ldGVyIG9mIHRoZSBmdW5jdGlvbiB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoaXMgdG8gY2hhaW4gY2FsbFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAocGFyYW0pIHtcblxuICAgICAgICAgICAgZm9yICh2YXIgYSBpbiBwYXJhbSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbS5oYXNPd25Qcm9wZXJ0eShhKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpc1thXSA9IHBhcmFtW2FdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfLmZvckVhY2godGhpcy5hcmdzLCBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZy5zZXQocGFyYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdXNlZCB0byBjb252ZXJ0IGF0dHJpYnV0ZXMgb2JqZWN0cyBpbnRvIGZ1bmN0aW9ucyB0aGF0IHdpbGwgZ2V0IHRoZSB0dXBsZVxuICAgICAgICAgKiB2YWx1ZSBmb3IgdGhhdCBhdHRyaWJ1dGVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnZlcnRBdHRyaWJ1dGVUb1R1cGxlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIF8uZm9yRWFjaCh0aGlzLnBhcmFtZXRlcnMsIGZ1bmN0aW9uIChwYXJhbWV0ZXIsIGluZGV4KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHBhcmFtZXRlci5jb252ZXJ0QXR0cmlidXRlVG9UdXBsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyLmNvbnZlcnRBdHRyaWJ1dGVUb1R1cGxlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtZXRlciBpbnN0YW5jZW9mIEF0dHJpYnV0ZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdGdW5jID0gbmV3IChyZXF1aXJlKCcuL2Z1bmN0aW9ucy90dXBsZS9BdHRyaWJ1dGUnKSkocGFyYW1ldGVyLm5hbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIG5ld0Z1bmMudHlwZSA9IHBhcmFtZXRlci50eXBlO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyYW1ldGVyc1tpbmRleF0gPSBuZXdGdW5jO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhc3NpZ25UdXBsZSA6IGZ1bmN0aW9uKHR1cGxlKXtcblxuICAgICAgICAgICAgXy5mb3JFYWNoKHRoaXMucGFyYW1ldGVycywgZnVuY3Rpb24gKHBhcmFtZXRlciwgaW5kZXgpIHtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJhbWV0ZXIgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlci5hc3NpZ25UdXBsZSh0dXBsZSk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9LFxuXG5cbiAgICAgICAgdHlwZSA6IGZ1bmN0aW9uKHR5cGUpe1xuXG4gICAgICAgICAgICBpZih0eXBlKXtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuXG4gICAgICAgICAgICAgICAgXy5mb3JJbih0eXBlLnBheWxvYWQsIGZ1bmN0aW9uIChtaXgpIHtcblxuICAgICAgICAgICAgICAgICAgICBfLmZvckluKG1peCwgZnVuY3Rpb24obWl4aW4sIGtleSl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IG1peGluO1xuXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpXG5cbiAgICAgICAgICAgICAgICB9LCB0aGlzKVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uOyIsInZhciBBdHRyaWJ1dGUgPSByZXF1aXJlKCcuL0F0dHJpYnV0ZS5qcycpO1xudmFyIFNldCA9IHJlcXVpcmUoJy4vU2V0LmpzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIFRTdHJpbmcgPSByZXF1aXJlKCcuL3R5cGVzL1N0cmluZycpO1xudmFyIFRUeXBlID0gcmVxdWlyZSgnLi90eXBlcy9UeXBlJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCcuL2hlbHBlcnMvZGVidWcuanMnKTtcblxudmFyIEhlYWRlciA9IFNldC5leHRlbmQoXG5cbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhlYWRlciBvYmplY3QgY29uc3RydWN0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBjbGFzcyBIZWFkZXJcbiAgICAgICAgICogQGV4dGVuZHMgU2V0XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlc11cbiAgICAgICAgICogQHRocm93cyBUaGUgYXR0cmlidXRlcyBhcmUgbm90IHBhc3NlZCBpbiBBcnJheSBmb3JtYXRcbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogQSB7QGxpbmsgSGVhZGVyfSBpcyBvbmUgb2YgdGhlIHR3byBtYWluIHBhcnRzIG9mIGFcbiAgICAgICAgICoge0BsaW5rIFJlbGF0aW9ufSwgYWxvbmcgd2l0aCB0aGUgQm9keSAod2hpY2ggaXMgYSB7QGxpbmsgU2V0fSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEl0IGlzIGEge0BsaW5rIFNldH0gb2Yge0BsaW5rIEF0dHJpYnV0ZX1zLiBJdCBkZWZpbmVzIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlXG4gICAgICAgICAqIHtAbGluayBUdXBsZX1zIHRoYXQgd2lsbCBiZSBwYXJ0IG9mIHRoZSBib2R5IG9mIHRoZVxuICAgICAgICAgKiB7QGxpbmsgUmVsYXRpb259LiBFYWNoIHtAbGluayBUdXBsZX0gaW4gYVxuICAgICAgICAgKiB7QGxpbmsgUmVsYXRpb259IG11c3QgbWF0Y2ggaXRzIHtAbGluayBIZWFkZXJ9XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgaGVhZGVyID0gbmV3IGFmZmluaXR5LmhlYWRlcihbXG4gICAgICAgICAqICAgICAgICAgIHtmaXJzdG5hbWUgOiBhZmZpbml0eS5zdHJpbmd9LFxuICAgICAgICAgKiAgICAgICAgICB7bGFzdG5hbWUgOiBhZmZpbml0eS5zdHJpbmd9XG4gICAgICAgICAqICAgICBdKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uID0gbmV3IGFmZmluaXR5LnJlbGF0aW9uKCk7IC8vIGNyZWF0ZSBhbiBlbXB0eSByZWxhdGlvbiB3aXRob3V0IGEgaGVhZGVyIGFuZCB3aXRob3V0IGJvZHlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHJlbGF0aW9uLmhlYWRlcihoZWFkZXIpOyAvLyBzZXRzIHRoZSByZWxhdGlvbidzIGhlYWRlclxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgcmVsYXRpb24uYWRkKHtmaXJzdE5hbWUgOiAnSm9obicsIGxhc3ROYW1lIDogJ0RvZSd9KTsgLy8gQWRkIGEgdHVwbGUgaW4gdGhlIFJlbGF0aW9uIHRoYXQgbWF0Y2hlcyB0aGUgaGVhZGVyXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKGF0dHJpYnV0ZXMpIHtcblxuICAgICAgICAgICAgZGVidWcuaGVhZGVyLnRyYWNlKCcjY29uc3RydWN0b3InKTtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEF0dHJpYnV0ZXMgb2YgdGhlIHJlbGF0aW9uXG4gICAgICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fYXR0cmlidXRlcyA9IHt9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRlbGxzIGlmIHRoZSByZWxhdGlvbiB3YXMgZGVjbGFyZWQgaW4gYW4gb3JkZXJlZCB3YXkgb3Igbm90XG4gICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX29yZGVyZWREZWNsYXJhdGlvbiA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlcykge1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgYXJlIGF0dHJpYnV0ZXMgaW4gdGhlIGFyZ3VtZW50c1xuXG4gICAgICAgICAgICAgICAgaWYoXy5pc09iamVjdChhdHRyaWJ1dGVzKSl7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0cmlidXRlcyBpcyBlaXRoZXIgYW4gYXJyYXkgb3IgYW4gb2JqZWN0XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoIV8uaXNBcnJheShhdHRyaWJ1dGVzKSl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF0dHJpYnV0ZXMgaXMgYW4gT2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB7IDxuYW1lPiA6IHt0eXBlIDogPHR5cGU+fSwgPG5hbWU+IDoge3R5cGUgOiA8dHlwZT59LCAuLi4gfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8geyA8bmFtZT4gOiA8YXR0cmlidXRlPiwgPG5hbWU+IDogPGF0dHJpYnV0ZT4sIDxuYW1lPiA6IDxhdHRyaWJ1dGU+LCAuLi4gfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmZvck93bihhdHRyaWJ1dGVzLCBmdW5jdGlvbihhdHRyaWJ1dGUsIGtleSl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJba2V5XSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhdHRyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXR0cmlidXRlcyBpcyBhbiBBcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gWyB7IDxuYW1lPiA6IHt0eXBlIDogPHR5cGU+fSB9LCB7IDxuYW1lPiA6IHt0eXBlIDogPHR5cGU+fSB9LCAuLi4gXVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gW3sgPG5hbWU+IDogPGF0dHJpYnV0ZT59LCB7PG5hbWU+IDogPGF0dHJpYnV0ZT59LCB7PG5hbWU+IDogPGF0dHJpYnV0ZT59LCAuLi4gXVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcmRlcmVkRGVjbGFyYXRpb24gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2goYXR0cmlidXRlcywgZnVuY3Rpb24gKGF0dHJpYnV0ZSwga2V5KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhdHRyaWJ1dGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9LHRoaXMpXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5zdXBwb3J0ZWQgYXR0cmlidXRlIGRlY2xhcmF0aW9uIGZvcm1hdCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgU2V0LmNhbGwodGhpcywge3R5cGU6IEF0dHJpYnV0ZSwgZWxlbWVudHM6IHJlc3VsdH0pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJpbmRzIHRoZSBldmVudHMgZm9yIHRoZSBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIGJpbmRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgZGVidWcuaGVhZGVyLnRyYWNlKCcjYmluZEV2ZW50cycpO1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMuZWUub24oJ2JlZm9yZUFkZCcsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhhdC5fYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShlbGVtZW50Lm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0cmlidXRlIHdpdGggbmFtZSAnICsgZWxlbWVudC5uYW1lICsgJyBhbHJlYWR5IGV4aXN0cyBpbiBoZWFkZXInKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmVlLm9uKCdhZnRlckFkZCcsIGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCkge1xuXG4gICAgICAgICAgICAgICAgdGhhdC5fYXR0cmlidXRlc1tlbGVtZW50Lm5hbWVdID0gaW5kZXg7XG5cbiAgICAgICAgICAgICAgICBlbGVtZW50LmhlYWRlciA9IHRoYXQ7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmVlLm9uKCdhZnRlclJlbW92ZScsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoYXQuX2F0dHJpYnV0ZXNbZWxlbWVudC5uYW1lXTtcbiAgICAgICAgICAgICAgICB0aGF0LnJlZnJlc2hBdHRyaWJ1dGVzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmcmVzaGVzIHRoZSBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAgICAgICAgICovXG4gICAgICAgIHJlZnJlc2hBdHRyaWJ1dGVzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLmhlYWRlci50cmFjZSgnI3JlZnJlc2hBdHRyaWJ1dGVzJyk7XG5cbiAgICAgICAgICAgIHRoaXMuX2F0dHJpYnV0ZXMgPSB7fTtcblxuICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCkge1xuXG4gICAgICAgICAgICAgICAgaWYoIV8uaXNVbmRlZmluZWQoZWxlbWVudCkpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzW2VsZW1lbnQubmFtZV0gPSBpbmRleDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0sIHRoaXMpXG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBvbmUgb2YgdGhlIGhlYWRlciBhdHRyaWJ1dGVzXG4gICAgICAgICAqIEBwYXJhbSB7QXR0cmlidXRlfFN0cmluZ30ga2V5XG4gICAgICAgICAqIEByZXR1cm5zIHtBdHRyaWJ1dGV8bnVsbH1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKGtleSkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5oZWFkZXIudHJhY2UoJyNnZXQnKTtcblxuICAgICAgICAgICAgaWYoa2V5IGluc3RhbmNlb2YgQXR0cmlidXRlKXtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShrZXkubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGF0dHIgPSB0aGlzLmdldChrZXkubmFtZSk7XG5cbiAgICAgICAgICAgICAgICBpZighYXR0ci5lcXVhbHMoa2V5KSl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKGtleSkpe1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMoKVt0aGlzLl9hdHRyaWJ1dGVzW2tleV1dO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgaW5kZXggb2YgYW4gYXR0cmlidXRlIGluIHRoZSBoZWFkZXJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgICAgICogQHJldHVybnMge251bGx8QXR0cmlidXRlfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SW5kZXg6IGZ1bmN0aW9uIChuYW1lKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLmhlYWRlci50cmFjZSgnI2dldEluZGV4Jyk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXR0cmlidXRlc1tuYW1lXTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIGFuIGF0dHJpYnV0ZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAgICAgICAqIEBwYXJhbSBpbmRleFxuICAgICAgICAgKiBAcmV0dXJucyB7QXR0cmlidXRlfG51bGx9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRBdCA6IGZ1bmN0aW9uKGluZGV4KXtcblxuICAgICAgICAgICAgaWYodGhpcy5fZWxlbWVudHNbaW5kZXhdICE9PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50c1tpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGhlYWRlciBhdHRyaWJ1dGVzIGxpc3RcbiAgICAgICAgICogQHBhcmFtIHsqW119IGF0dHJpYnV0ZXNcbiAgICAgICAgICogQHJldHVybnMge3VuZGVmaW5lZHxudWxsfEFycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgYXR0cmlidXRlczogZnVuY3Rpb24gKGF0dHJpYnV0ZXMpIHtcblxuICAgICAgICAgICAgZGVidWcuaGVhZGVyLnRyYWNlKCcjYXR0cmlidXRlcycpO1xuXG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlcykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMoYXR0cmlidXRlcyk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50cygpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xvbmVzIGEgaGVhZGVyIGFuZCBpdHMgYXR0cmlidXRlc1xuICAgICAgICAgKiBAcmV0dXJucyB7SGVhZGVyfVxuICAgICAgICAgKi9cbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgZGVidWcuaGVhZGVyLnRyYWNlKCcjY2xvbmUnKTtcblxuICAgICAgICAgICAgdmFyIG5ld0hlYWRlciA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuXG4gICAgICAgICAgICAgICAgaWYoIV8uaXNVbmRlZmluZWQoZWxlbWVudCkpe1xuICAgICAgICAgICAgICAgICAgICBuZXdIZWFkZXIuYWRkKGVsZW1lbnQuY2xvbmUoKSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXdIZWFkZXI7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvamVjdCBvcGVyYXRpb24gb24gSGVhZGVyIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfEF0dHJpYnV0ZVtdfSBwcm9qZWN0ZWRBdHRyaWJ1dGVzXG4gICAgICAgICAqIEByZXR1cm5zIHtIZWFkZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0OiBmdW5jdGlvbiAocHJvamVjdGVkQXR0cmlidXRlcykge1xuXG4gICAgICAgICAgICBkZWJ1Zy5oZWFkZXIudHJhY2UoJyNwcm9qZWN0Jyk7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHRBdHRyaWJ1dGVzID0ge30sXG4gICAgICAgICAgICAgICAgYTtcblxuICAgICAgICAgICAgYSA9IHByb2plY3RlZEF0dHJpYnV0ZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICB3aGlsZSAoYS0tKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJvamVjdGVkQXR0cmlidXRlID0gcHJvamVjdGVkQXR0cmlidXRlc1thXTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHN0cmluZyBnaXZlbiwgZmluZCB0aGUgYXR0cmlidXRlIHdpdGggdGhpcyBuYW1lXG4gICAgICAgICAgICAgICAgaWYgKF8uaXNTdHJpbmcocHJvamVjdGVkQXR0cmlidXRlKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvamVjdGVkQXR0cmlidXRlO1xuXG4gICAgICAgICAgICAgICAgICAgIHByb2plY3RlZEF0dHJpYnV0ZSA9IHRoaXMuZ2V0KGF0dHJpYnV0ZU5hbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9qZWN0ZWRBdHRyaWJ1dGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignQXR0cmlidXRlIHdpdGggbmFtZSAnICsgYXR0cmlidXRlTmFtZSArICcgbm90IGZvdW5kIGluIGhlYWRlcicpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb2plY3RlZEF0dHJpYnV0ZSBpbnN0YW5jZW9mIEF0dHJpYnV0ZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgYXR0cmlidXRlIGluIHRoZSBoZWFkZXJcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSBfLmZpbmQodGhpcy5lbGVtZW50cygpLCBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0cmlidXRlID09PSBwcm9qZWN0ZWRBdHRyaWJ1dGU7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignQXR0cmlidXRlIG5vdCBmb3VuZCBpbiB0aGUgaGVhZGVyJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dyb25nIGZvcm1hdCBnaXZlbiBmb3IgYXR0cmlidXRlcyBpbiBIZWFkZXIgcHJvamVjdCBvcGVyYXRpb24nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXN1bHRBdHRyaWJ1dGVzW3Byb2plY3RlZEF0dHJpYnV0ZS5uYW1lXSA9IHByb2plY3RlZEF0dHJpYnV0ZS5jbG9uZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IEhlYWRlcihyZXN1bHRBdHRyaWJ1dGVzKTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtIGEgcmVtb3ZhbCBvcGVyYXRpb24gb24gdGhlIGhlYWRlclxuICAgICAgICAgKiBAcGFyYW0ge0F0dHJpYnV0ZVtdfFN0cmluZ1tdfEF0dHJpYnV0ZXxTdHJpbmd9IGF0dHJpYnV0ZXNUb1JlbW92ZSBhdHRyaWJ1dGVzIHRvIHJlbW92ZSBmcm9tIHRoZSBoZWFkZXJcbiAgICAgICAgICogQHJldHVybiB7SGVhZGVyfSB0aGUgcmVzdWx0aW5nIGhlYWRlclxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoYXR0cmlidXRlc1RvUmVtb3ZlKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLmhlYWRlci50cmFjZSgnI3JlbW92ZScpO1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0SGVhZGVyID0gdGhpcy5jbG9uZSgpLFxuICAgICAgICAgICAgICAgIGEsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU7XG5cbiAgICAgICAgICAgIC8vIENvZXJjZSB0aGUgYXJndW1lbnRzIHRvIGFuIGFycmF5XG4gICAgICAgICAgICBpZiAoXy5pc1N0cmluZyhhdHRyaWJ1dGVzVG9SZW1vdmUpIHx8IGF0dHJpYnV0ZXNUb1JlbW92ZSBpbnN0YW5jZW9mIEF0dHJpYnV0ZSkge1xuXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlc1RvUmVtb3ZlID0gW2F0dHJpYnV0ZXNUb1JlbW92ZV07XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIV8uaXNBcnJheShhdHRyaWJ1dGVzVG9SZW1vdmUpKSB7XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXcm9uZyBhcmd1bWVudCB0eXBlIGZvciByZW1vdmFsIG9wZXJhdGlvbicpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGEgPSBhdHRyaWJ1dGVzVG9SZW1vdmUubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBMb29wIHRocm91Z2ggZWFjaCBnaXZlbiBhdHRyaWJ1dGVzIHRvIHJlbW92ZVxuXG4gICAgICAgICAgICB3aGlsZSAoYS0tKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IGdpdmVuIGF0dHJpYnV0ZXNUb1JlbW92ZSBhcmUgaW4gdGhlIGhlYWRlclxuXG4gICAgICAgICAgICAgICAgaWYgKF8uaXNTdHJpbmcoYXR0cmlidXRlc1RvUmVtb3ZlW2FdKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFBhc3NlZCBhdHRyaWJ1dGUgaXMgYSBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHdpbGwgY2hlY2sgaWYgdGhlIGF0dHJpYnV0ZSBuYW1lIGV4aXN0cy5cblxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlc1RvUmVtb3ZlW2FdO1xuXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNUb1JlbW92ZVthXSA9IHRoaXMuZ2V0KGF0dHJpYnV0ZU5hbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignQXR0cmlidXRlIHdpdGggbmFtZSAnICsgYXR0cmlidXRlTmFtZSArICcgbm90IGZvdW5kIGluIGhlYWRlcicpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFBhc3NlZCBhdHRyaWJ1dGUgaXMgYW4gQXR0cmlidXRlIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSB3aWxsIGNoZWNrIGlmIGl0IGV4aXN0cyBpbiB0aGUgaGVhZGVyXG5cbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlID0gYXR0cmlidXRlc1RvUmVtb3ZlW2FdO1xuXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGUubmFtZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2F0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGF0dHJpYnV0ZSBuYW1lIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIGhlYWRlclxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ0F0dHJpYnV0ZSB3aXRoIG5hbWUgJyArIGF0dHJpYnV0ZU5hbWUgKyAnIG5vdCBmb3VuZCBpbiBoZWFkZXInKTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZ2V0KGF0dHJpYnV0ZU5hbWUpLmVxdWFsKGF0dHJpYnV0ZSkgPT09IGZhbHNlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBhdHRyaWJ1dGUgaXMgZm91bmQgYnV0IGRvZXNuJ3QgaGF2ZSB0aGUgc2FtZSB0eXBlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignQXR0cmlidXRlIG9iamVjdCBmb3VuZCBpbiB0aGUgaGVhZGVyIGJ1dCBub3Qgb2Ygc2FtZSB0eXBlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIERlbGV0ZSB0aGUgZm91bmQgYXR0cmlidXRlcyBmcm9tIHRoZSByZXN1bHRpbmcgaGVhZGVyXG5cbiAgICAgICAgICAgICAgICByZXN1bHRIZWFkZXIucmVtb3ZlQXQocmVzdWx0SGVhZGVyLmdldEluZGV4KGF0dHJpYnV0ZU5hbWUpKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0SGVhZGVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5hbWUgb3BlcmF0aW9uIG9uIHRoZSBoZWFkZXJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXNcbiAgICAgICAgICogQHJldHVybnMge0hlYWRlcn0gVGhlIG5ldyBzZXRcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBuZXdIZWFkZXIgPSBIZWFkZXIucmVuYW1lKCB7IG9sZE5hbWUgOiAnbmV3TmFtZScgfSApO1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgcmVuYW1lOiBmdW5jdGlvbiAoYXR0cmlidXRlcykge1xuXG4gICAgICAgICAgICBkZWJ1Zy5oZWFkZXIudHJhY2UoJyNyZW5hbWUnKTtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdEhlYWRlciA9IHRoaXMuY2xvbmUoKSxcbiAgICAgICAgICAgICAgICBrZXk7XG5cbiAgICAgICAgICAgIGlmIChfLmlzT2JqZWN0KGF0dHJpYnV0ZXMpKSB7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBhdHRyaWJ1dGVzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3TmFtZSA9IGF0dHJpYnV0ZXNba2V5XTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHNwZWNpZmllZCBuYW1lIGlzIGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV8uaXNTdHJpbmcobmV3TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOZXcgbmFtZSBmb3IgYXR0cmlidXRlICcgKyBrZXkgKyAnIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldEF0dHJpYnV0ZSA9IHRoaXMuZ2V0KGtleSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBrZXkgZXhpc3RzIGluIHRoZSBjdXJyZW50IGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldEF0dHJpYnV0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignQXR0cmlidXRlIHdpdGggbmFtZSAnICsga2V5ICsgJyBkb2VzblxcJ3QgZXhpc3QgaW4gaGVhZGVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSByZW5hbWVkIG9wZXJhdGlvbiBkb2VzIG5vdCBvdmVyd3JpdGUgYW4gZXhpc3Rpbmcga2V5IGluIHRoZSBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KG5ld05hbWUpICYmIG5ld05hbWUgIT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignTmV3IGF0dHJpYnV0ZSBuYW1lICcgKyBuZXdOYW1lICsgJyBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgaGVhZGVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBuZXcgbmFtZSBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIG9sZCBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3TmFtZSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcuaGVhZGVyLndhcm4oJ1VzZWxlc3MgcmVuYW1pbmcgb3BlcmF0aW9ucyA6ICcgKyBrZXkgKyAnIC0+ICcgKyBuZXdOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdHdvIHJlbmFtZWQgYXR0cmlidXRlcyBkb24ndCBoYXZlIHRoZSBzYW1lIHRhcmdldCBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShhKSAmJiBhICE9PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld05hbWUgPT09IGF0dHJpYnV0ZXNbYV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignVHdvIHJlbmFtZWQgYXR0cmlidXRlcyBoYXZlIHRoZSBzYW1lIHRhcmdldCBuYW1lJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdEhlYWRlci5fYXR0cmlidXRlc1tuZXdOYW1lXSA9IHJlc3VsdEhlYWRlci5fYXR0cmlidXRlc1trZXldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSBuZXdOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc3VsdEhlYWRlci5fYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRIZWFkZXIuZ2V0KG5ld05hbWUpLm5hbWUgPSBuZXdOYW1lO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXcm9uZyBhcmd1bWVudCB0eXBlIGZvciByZW5hbWUgb3BlcmF0aW9uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRIZWFkZXI7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge1JlbGF0aW9ufSBUaGUgcmVsYXRpb24gcmVwcmVzZW50YXRpb24gb2YgdGhlIGhlYWRlclxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGhlYWRlciA9IG5ldyBhZmZpbml0eS5IZWFkZXIoeyBhIDogYWZmaW5pdHkuU3RyaW5nLCBiIDogYWZmaW5pdHkuU3RyaW5nIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGhlYWRlclJlbGF0aW9uID0gaGVhZGVyLnRvUmVsYXRpb24oKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGhlYWRlclJlbGF0aW9uLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IG5hbWUgOiBTdHJpbmcgfCB0eXBlIDogVHlwZSB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IGEgICAgICAgICAgICAgfCBTdHJpbmcgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IGIgICAgICAgICAgICAgfCBTdHJpbmcgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0b1JlbGF0aW9uOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLmhlYWRlci50cmFjZSgnI3RvUmVsYXRpb24nKTtcblxuICAgICAgICAgICAgdmFyIHJlbCA9IG5ldyAocmVxdWlyZSgnLi9SZWxhdGlvbi5qcycpKShbXG4gICAgICAgICAgICAgICAge25hbWU6IHt0eXBlOiBUU3RyaW5nfX0sXG4gICAgICAgICAgICAgICAge3R5cGU6IHt0eXBlOiBUVHlwZX19XG4gICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICByZWwuYWRkKHtuYW1lOiBhdHRyaWJ1dGUubmFtZSwgdHlwZTogYXR0cmlidXRlLnR5cGV9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVsO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gQW4gYXJyYXkgY29udGFpbmluZyB0aGUgbmFtZXMgb2YgdGhlIGF0dHJpYnV0ZXNcbiAgICAgICAgICovXG4gICAgICAgIHRvTmFtZUFycmF5IDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGF0dHJpYnV0ZSl7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYXR0cmlidXRlLm5hbWUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQ29udmVydHMgYSByZWxhdGlvbiB0byBhIGhlYWRlci4gVGhlIHJlbGF0aW9uIG11c3QgaGF2ZSBhIG5hbWUgOiBzdHJpbmcgYW5kIHR5cGUgOiB0eXBlIHN0cnVjdHVyZS5cbiAgICAgICAgICogSW52ZXJzZSBvZiB7QGxpbmsgSGVhZGVyI3RvUmVsYXRpb259XG4gICAgICAgICAqIEBwYXJhbSByZWxhdGlvblxuICAgICAgICAgKiBAcmV0dXJucyB7SGVhZGVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZnJvbVJlbGF0aW9uIDogZnVuY3Rpb24ocmVsYXRpb24pe1xuXG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSByZWxhdGlvbiBoYXMgdGhlIHJpZ2h0IGhlYWRlclxuICAgICAgICAgICAgaWYoIXJlbGF0aW9uLmhlYWRlcigpLmV4aXN0cyh7bmFtZSA6ICduYW1lJywgdHlwZSA6IFRTdHJpbmd9KSB8fCAhcmVsYXRpb24uaGVhZGVyKCkuZXhpc3RzKHsgbmFtZSA6ICd0eXBlJywgdHlwZSA6IFRUeXBlfSkgfHwgIShyZWxhdGlvbi5oZWFkZXIoKS5sZW5ndGgoKT09Mikpe1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnZlcnQgcmVsYXRpb24gdG8gaGVhZGVyJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbGF0aW9uLmVhY2goZnVuY3Rpb24odHVwbGUpe1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKHtuYW1lIDogdHVwbGUuZ2V0KCduYW1lJyksIHR5cGUgOiB0dXBsZS5nZXQoJ3R5cGUnKX0sIGZhbHNlKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3BpZXMgYXR0cmlidXRlcyBmcm9tIGEgcmVsYXRpb24gdG8gYW5vdGhlclxuICAgICAgICAgKiBAcGFyYW0ge0hlYWRlcn0gaGVhZGVyXG4gICAgICAgICAqIEBwYXJhbSB7SGVhZGVyfHN0cmluZ1tdfFNldH0gW2F0dHJpYnV0ZXNBcmd1bWVudD1bXV1cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbZXhjbHVkZT1mYWxzZV1cbiAgICAgICAgICogQHJldHVybnMge0hlYWRlcn1cbiAgICAgICAgICovXG4gICAgICAgIGNvcHkgOiBmdW5jdGlvbihoZWFkZXIsIGF0dHJpYnV0ZXNBcmd1bWVudCwgZXhjbHVkZSl7XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgaWYoZXhjbHVkZSAhPT0gdHJ1ZSAmJiBleGNsdWRlICE9PSBmYWxzZSl7XG4gICAgICAgICAgICAgICAgZXhjbHVkZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlc0FyZ3VtZW50KXtcblxuICAgICAgICAgICAgICAgIC8vIENvZXJjZSB0aGUgYXR0cmlidXRlc0FyZ3VtZW50IGFyZ3VtZW50cyB0byBhIGhlYWRlciBhcmd1bWVudFxuXG4gICAgICAgICAgICAgICAgaWYoIShhdHRyaWJ1dGVzQXJndW1lbnQgaW5zdGFuY2VvZiBIZWFkZXIpKXtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcEhlYWRlciA9IG5ldyBIZWFkZXIoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZihhdHRyaWJ1dGVzQXJndW1lbnQgaW5zdGFuY2VvZiBTZXQpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzQXJndW1lbnQuZWFjaChmdW5jdGlvbihhdHRyaWJ1dGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKF8uaXNTdHJpbmcoYXR0cmlidXRlKSl7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IGhlYWRlci5nZXQoYXR0cmlidXRlKTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGF0dHIgPT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRyaWJ1dGUgd2l0aCBuYW1lIFwiJyArIGF0dHJpYnV0ZSArICdcIiBub3QgZm91bmQgaW4gdGhlIGhlYWRlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcEhlYWRlci5hZGQoaGVhZGVyLmdldChhdHRyaWJ1dGUpLmNsb25lKCkpO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoYXR0cmlidXRlIGluc3RhbmNlb2YgQXR0cmlidXRlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaGVhZGVyLmdldChhdHRyaWJ1dGUubmFtZSkgPT09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRyaWJ1dGUgd2l0aCBuYW1lIFwiJyArIGF0dHJpYnV0ZS5uYW1lICsgJ1wiIG5vdCBmb3VuZCBpbiB0aGUgaGVhZGVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wSGVhZGVyLmFkZChhdHRyaWJ1dGUuY2xvbmUoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc0FycmF5KGF0dHJpYnV0ZXNBcmd1bWVudCkpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2goYXR0cmlidXRlc0FyZ3VtZW50LCBmdW5jdGlvbihhdHRyaWJ1dGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKF8uaXNTdHJpbmcoYXR0cmlidXRlKSl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHIgPSBoZWFkZXIuZ2V0KGF0dHJpYnV0ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYXR0ciA9PT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSB3aXRoIG5hbWUgXCInICsgYXR0cmlidXRlICsgJ1wiIG5vdCBmb3VuZCBpbiB0aGUgaGVhZGVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wSGVhZGVyLmFkZChhdHRyLmNsb25lKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKGF0dHJpYnV0ZSBpbnN0YW5jZW9mIEF0dHJpYnV0ZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGhlYWRlci5nZXQoYXR0cmlidXRlLm5hbWUpID09PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0cmlidXRlIHdpdGggbmFtZSBcIicgKyBhdHRyaWJ1dGUubmFtZSArICdcIiBub3QgZm91bmQgaW4gdGhlIGhlYWRlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcEhlYWRlci5hZGQoYXR0cmlidXRlLmNsb25lKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcoYXR0cmlidXRlc0FyZ3VtZW50KSl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRyID0gaGVhZGVyLmdldChhdHRyaWJ1dGVzQXJndW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihhdHRyID09PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSB3aXRoIG5hbWUgJyArIGF0dHJpYnV0ZXNBcmd1bWVudCArICcgbm90IGZvdW5kIGluIHRoZSBoZWFkZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcEhlYWRlci5hZGQoYXR0cik7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNBcmd1bWVudCA9IHRlbXBIZWFkZXI7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNBcmd1bWVudC5lYWNoKGZ1bmN0aW9uKGF0dHJpYnV0ZSl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGhlYWRlci5nZXQoYXR0cmlidXRlLm5hbWUpID09PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSB3aXRoIG5hbWUgJyArIGF0dHJpYnV0ZS5uYW1lICsgJyBub3QgZm91bmQgaW4gdGhlIGhlYWRlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4Y2x1ZGUgJiYgYXR0cmlidXRlc0FyZ3VtZW50KXtcblxuICAgICAgICAgICAgICAgIGhlYWRlci5lYWNoKGZ1bmN0aW9uKGF0dHJpYnV0ZSl7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzRXhjbHVkZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzQXJndW1lbnQuZWFjaChmdW5jdGlvbihleGNsdWRlZEF0dHJpYnV0ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihhdHRyaWJ1dGUuZXF1YWwoZXhjbHVkZWRBdHRyaWJ1dGUpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0V4Y2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoIWlzRXhjbHVkZWQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQoYXR0cmlidXRlLmNsb25lKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9LCB0aGlzKVxuXG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWV4Y2x1ZGUgJiYgYXR0cmlidXRlc0FyZ3VtZW50KXtcblxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNBcmd1bWVudC5lYWNoKGZ1bmN0aW9uKGluY2x1ZGVkQXR0cmlidXRlKXtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZChoZWFkZXIuZ2V0KGluY2x1ZGVkQXR0cmlidXRlLm5hbWUpLmNsb25lKCkpO1xuXG4gICAgICAgICAgICAgICAgfSwgdGhpcylcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGhlYWRlci5lYWNoKGZ1bmN0aW9uKGF0dHJpYnV0ZSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKGF0dHJpYnV0ZS5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICB9LHRoaXMpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH1cblxuXG4gICAgfSwge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7SGVhZGVyfSBoZWFkZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmdbXXxBdHRyaWJ1dGVbXX0gYXR0cmlidXRlc1xuICAgICAgICAgKi9cbiAgICAgICAgYXNzZXJ0QXR0cmlidXRlc0V4aXN0IDogZnVuY3Rpb24oaGVhZGVyLCBhdHRyaWJ1dGVzKXtcblxuICAgICAgICAgICAgdmFyIG1pc21hdGNoID0gZmFsc2U7XG5cbiAgICAgICAgICAgIF8uZm9yRWFjaChhdHRyaWJ1dGVzLCBmdW5jdGlvbihhdHRyaWJ1dGUpe1xuXG4gICAgICAgICAgICAgICAgaWYoXy5pc1N0cmluZyhhdHRyaWJ1dGUpKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoaGVhZGVyLmdldChhdHRyaWJ1dGUpID09PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0cmlidXRlIHdpdGggbmFtZSAnICsgYXR0cmlidXRlICsgJyBkb2VzIG5vdCBleGlzdCBpbiB0aGUgaGVhZGVyJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZSBpbnN0YW5jZW9mIEF0dHJpYnV0ZSl7XG4gICAgICAgICAgICAgICAgICAgIGlmKCFoZWFkZXIuZXhpc3RzKGF0dHJpYnV0ZSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRyaWJ1dGUgd2l0aCBuYW1lICcgKyBhdHRyaWJ1dGUubmFtZSArICcgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGhlYWRlcicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRyaWJ1dGUgaXMgb2Ygd3JvbmcgdHlwZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge0hlYWRlcn0gaGVhZGVyMVxuICAgICAgICAgKiBAcGFyYW0ge0hlYWRlcn0gaGVhZGVyMlxuICAgICAgICAgKi9cbiAgICAgICAgYXNzZXJ0U2FtZU5hbWVTYW1lVHlwZSA6IGZ1bmN0aW9uKGhlYWRlcjEsIGhlYWRlcjIpe1xuXG4gICAgICAgICAgICBoZWFkZXIxLmVhY2goZnVuY3Rpb24oYXR0cmlidXRlMSl7XG5cbiAgICAgICAgICAgICAgICBoZWFkZXIyLmVhY2goZnVuY3Rpb24oYXR0cmlidXRlMil7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoYXR0cmlidXRlMS5uYW1lID09PSBhdHRyaWJ1dGUyLm5hbWUgJiYgYXR0cmlidXRlMS50eXBlICE9PSBhdHRyaWJ1dGUyLnR5cGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIZWFkZXJzIG11c3QgaGF2ZSBzYW1lIHR5cGUgb24gYXR0cmlidXRlcyBvZiBzYW1lIG5hZW0nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgfSlcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7SGVhZGVyfSBoZWFkZXIxXG4gICAgICAgICAqIEBwYXJhbSB7SGVhZGVyfSBoZWFkZXIyXG4gICAgICAgICAqL1xuICAgICAgICBhc3NlcnRVbmlvbkNvbXBhdGlibGUgOiBmdW5jdGlvbihoZWFkZXIxLCBoZWFkZXIyKXtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmVxdWFsKGhlYWRlcjEsIGhlYWRlcjIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWxhdGlvbnMgYXJlIG5vdCB1bmlvbiBjb21wYXRpYmxlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge0hlYWRlcn0gaGVhZGVyMVxuICAgICAgICAgKiBAcGFyYW0ge0hlYWRlcn0gaGVhZGVyMlxuICAgICAgICAgKi9cbiAgICAgICAgYXNzZXJ0RGlzam9pbnQgOiBmdW5jdGlvbihoZWFkZXIxLCBoZWFkZXIyKXtcblxuICAgICAgICAgICAgaWYoIXRoaXMuZGlzam9pbnQoaGVhZGVyMSwgaGVhZGVyMikpe1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSGVhZGVycyBtdXN0IGJlIGRpc2pvaW50Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge0hlYWRlcn0gaGVhZGVyMVxuICAgICAgICAgKiBAcGFyYW0ge0hlYWRlcn0gaGVhZGVyMlxuICAgICAgICAgKiBAcmV0dXJucyB7U2V0fCp9XG4gICAgICAgICAqL1xuICAgICAgICBjb21tb25BdHRyaWJ1dGVzIDogZnVuY3Rpb24oaGVhZGVyMSwgaGVhZGVyMil7XG5cbiAgICAgICAgICAgIHJldHVybiBoZWFkZXIxLnNldEludGVyc2VjdGlvbihoZWFkZXIyKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBhIHJlbGF0aW9uIGludG8gYSBoZWFkZXIuXG4gICAgICAgICAqIFRoZSByZWxhdGlvbiBtdXN0IGhhdmUgdGhlIGhlYWRlciBvbmx5IHdpdGggYXR0cmlidXRlcyBuYW1lIDogVFN0cmluZyBhbmQgdHlwZSA6IFRUeXBlLlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSByZWxhdGlvblxuICAgICAgICAgKiBAcmV0dXJucyB7SGVhZGVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZnJvbVJlbGF0aW9uIDogZnVuY3Rpb24ocmVsYXRpb24pe1xuXG4gICAgICAgICAgICB2YXIgaGVhZGVyID0gbmV3IEhlYWRlcigpO1xuXG4gICAgICAgICAgICByZXR1cm4gaGVhZGVyLmZyb21SZWxhdGlvbihyZWxhdGlvbik7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge0hlYWRlcn0gaGVhZGVyMVxuICAgICAgICAgKiBAcGFyYW0ge0hlYWRlcn0gaGVhZGVyMlxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGVxdWFsOiBmdW5jdGlvbiAoaGVhZGVyMSwgaGVhZGVyMikge1xuXG4gICAgICAgICAgICBkZWJ1Zy5oZWFkZXIudHJhY2UoJ0hlYWRlci5lcXVhbCcpO1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoaGVhZGVyMS5fYXR0cmlidXRlcykubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhoZWFkZXIyLl9hdHRyaWJ1dGVzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtaXNtYXRjaCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBoZWFkZXIxLmVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZTEpIHtcblxuICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUxTmFtZSA9IGF0dHJpYnV0ZTEubmFtZTtcblxuICAgICAgICAgICAgICAgIGlmICghaGVhZGVyMi5fYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGUxTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFBdHRyaWJ1dGUuZXF1YWwoYXR0cmlidXRlMSwgaGVhZGVyMi5nZXQoYXR0cmlidXRlMS5uYW1lKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gIW1pc21hdGNoO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtIZWFkZXJ9IGhlYWRlcjFcbiAgICAgICAgICogQHBhcmFtIHtIZWFkZXJ9IGhlYWRlcjJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBkaXNqb2ludDogZnVuY3Rpb24gKGhlYWRlcjEsIGhlYWRlcjIpIHtcblxuICAgICAgICAgICAgZGVidWcuaGVhZGVyLnRyYWNlKCdIZWFkZXIuZGlzam9pbnQnKTtcblxuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSBoZWFkZXIxLmxlbmd0aCgpID4gaGVhZGVyMi5sZW5ndGgoKSA/IFtoZWFkZXIxLGhlYWRlcjJdIDogW2hlYWRlcjIsaGVhZGVyMV07XG5cbiAgICAgICAgICAgIHZhciBkaWZmZXJlbnQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IGhlYWRlciBoYXZlIG5vIGNvbW1vbiBhdHRyaWJ1dGUgbmFtZXNcbiAgICAgICAgICAgIGhlYWRlcnNbMF0uZWFjaChmdW5jdGlvbiAoYXR0cmlidXRlMSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlcnNbMV0uZ2V0KGF0dHJpYnV0ZTEubmFtZSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlmZmVyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZGlmZmVyZW50O1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtIZWFkZXJ8Kn0gaGVhZGVyXG4gICAgICAgICAqIEByZXR1cm5zIHtIZWFkZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBjb2VyY2UgOiBmdW5jdGlvbihoZWFkZXIpe1xuXG4gICAgICAgICAgICBpZihoZWFkZXIgaW5zdGFuY2VvZiB0aGlzKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVhZGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEhlYWRlcihoZWFkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBIZWFkZXI7IiwidmFyIEJhc2UgPSByZXF1aXJlKCcuL0Jhc2UnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4vaGVscGVycy9kZWJ1ZycpO1xuXG52YXIgSW5kZXggPSBCYXNlLmV4dGVuZChcbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJbmRleCBjbGFzcyBpcyBhIHNpbXBsZSB1dGlsaXR5IGNsYXNzIGFsbG93aW5nIHR1cGxlcyB0byBiZSBpbmRleGVkLlxuICAgICAgICAgKiBJdCBzcGVlZHMgdXAgb3BlcmF0aW9ucyBvbiByZWxhdGlvbnMgYXMgaXRlcmF0aW9ucyBhcmUgcmVkdWNlZC5cbiAgICAgICAgICogQGNsYXNzIEluZGV4XG4gICAgICAgICAqIEBleHRlbmRzIEJhc2VcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoaGVhZGVyKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLmluZGV4LnRyYWNlKCcjY29uc3RydWN0b3InKTtcblxuICAgICAgICAgICAgLyoqIEBwcm9wZXJ0eSB7SGVhZGVyfSBoZWFkZXIgKi9cbiAgICAgICAgICAgIHRoaXMuaGVhZGVyID0gaGVhZGVyO1xuXG4gICAgICAgICAgICAvKiogQHByb3BlcnR5IHtudW1iZXJ9IGxldmVscyAqL1xuICAgICAgICAgICAgdGhpcy5sZXZlbHMgPSBoZWFkZXIubGVuZ3RoKCk7XG5cbiAgICAgICAgICAgIC8qKiBAcHJvcGVydHkge09iamVjdH0gZWxlbWVudHMgKi9cbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMgPSB7fTtcblxuICAgICAgICAgICAgLyoqIEBwcm9wZXJ0eSB7QXJyYXl9IGhlYWRlckxldmVscyAqL1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJMZXZlbHMgPSBbXTtcblxuICAgICAgICAgICAgLyogUmVjdXJzaXZlbHkgaXRlcmF0aW5nIHRocm91Z2ggdGhlIGhlYWRlciBhbmQgcG9wdWxhdGluZyB0aGUgaGVhZGVyTGV2ZWxzIGFycmF5Ki9cblxuICAgICAgICAgICAgdmFyIHRhcmdldEhlYWRlciA9IHRoaXMuaGVhZGVyLmNsb25lKCk7XG5cbiAgICAgICAgICAgIGZvcih2YXIgayA9IDA7IGsgPCB0aGlzLmxldmVsczsgaysrKXtcblxuICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVyTGV2ZWxzW2tdID0gdGFyZ2V0SGVhZGVyO1xuICAgICAgICAgICAgICAgIHRhcmdldEhlYWRlciA9IHRhcmdldEhlYWRlci5yZW1vdmUodGFyZ2V0SGVhZGVyLmZpcnN0KCkpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIHR1cGxlIHRvIHRoZSBpbmRleFxuICAgICAgICAgKiBAcGFyYW0ge1R1cGxlfSB0dXBsZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgICAgICovXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKHR1cGxlLCBpbmRleCkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5pbmRleC50cmFjZSgnI2FkZCcpO1xuXG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBoZWFkZXJDb3VudCA9IHRoaXMuaGVhZGVyLmxlbmd0aCgpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8PSBoZWFkZXJDb3VudCAtIDE7IGErKykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGNvbnRleHQuaGVhZGVyLmZpcnN0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHR1cGxlQXR0cmlidXRlVmFsdWU7XG5cbiAgICAgICAgICAgICAgICBpZighYXR0cmlidXRlLnR5cGUucHJpbWl0aXZlKXtcbiAgICAgICAgICAgICAgICAgICAgdHVwbGVBdHRyaWJ1dGVWYWx1ZSA9IGF0dHJpYnV0ZS50eXBlLnNlcmlhbGl6ZSh0dXBsZS5nZXQoYXR0cmlidXRlLm5hbWUpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0dXBsZUF0dHJpYnV0ZVZhbHVlID0gdHVwbGUuZ2V0KGF0dHJpYnV0ZS5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYSA9PT0gaGVhZGVyQ291bnQgLSAxKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5lbGVtZW50c1t0dXBsZUF0dHJpYnV0ZVZhbHVlXSA9IGluZGV4XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGV4dC5lbGVtZW50cy5oYXNPd25Qcm9wZXJ0eSh0dXBsZUF0dHJpYnV0ZVZhbHVlKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3SW5kZXggPSBuZXcgSW5kZXgodGhpcy5oZWFkZXJMZXZlbHNbYSsxXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZWxlbWVudHNbdHVwbGVBdHRyaWJ1dGVWYWx1ZV0gPSBuZXdJbmRleDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IG5ld0luZGV4O1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LmVsZW1lbnRzW3R1cGxlQXR0cmlidXRlVmFsdWVdO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgaW5kZXggZm9yIGEgdHVwbGVcbiAgICAgICAgICogQHBhcmFtIHtUdXBsZX0gdHVwbGVcbiAgICAgICAgICogQHJldHVybnMge251bWJlcnxudWxsfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SW5kZXg6IGZ1bmN0aW9uICh0dXBsZSkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5pbmRleC50cmFjZSgnI2dldEluZGV4Jyk7XG5cbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIGhlYWRlckNvdW50ID0gdGhpcy5oZWFkZXIubGVuZ3RoKCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDw9IGhlYWRlckNvdW50IC0gMTsgYSsrKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gY29udGV4dC5oZWFkZXIuZmlyc3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgdHVwbGVBdHRyaWJ1dGVWYWx1ZTtcblxuICAgICAgICAgICAgICAgIGlmKCFhdHRyaWJ1dGUudHlwZS5wcmltaXRpdmUpe1xuICAgICAgICAgICAgICAgICAgICB0dXBsZUF0dHJpYnV0ZVZhbHVlID0gYXR0cmlidXRlLnR5cGUuc2VyaWFsaXplKHR1cGxlLmdldChhdHRyaWJ1dGUubmFtZSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHR1cGxlQXR0cmlidXRlVmFsdWUgPSB0dXBsZS5nZXQoYXR0cmlidXRlLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChhID09PSBoZWFkZXJDb3VudCAtIDEpIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQuZWxlbWVudHMuaGFzT3duUHJvcGVydHkodHVwbGVBdHRyaWJ1dGVWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZWxlbWVudHNbdHVwbGVBdHRyaWJ1dGVWYWx1ZV07XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGV4dC5lbGVtZW50cy5oYXNPd25Qcm9wZXJ0eSh0dXBsZUF0dHJpYnV0ZVZhbHVlKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQuZWxlbWVudHNbdHVwbGVBdHRyaWJ1dGVWYWx1ZV07XG5cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYSB0dXBsZSBmcm9tIHRoZSBpbmRleFxuICAgICAgICAgKiBAcGFyYW0ge1R1cGxlfSB0dXBsZVxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiByZW1vdmVkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKHR1cGxlKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLmluZGV4LnRyYWNlKCcjcmVtb3ZlJyk7XG5cbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIGhlYWRlckNvdW50ID0gdGhpcy5oZWFkZXIubGVuZ3RoKCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDw9IGhlYWRlckNvdW50IC0gMTsgYSsrKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gY29udGV4dC5oZWFkZXIuZmlyc3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgdHVwbGVBdHRyaWJ1dGVWYWx1ZTtcblxuICAgICAgICAgICAgICAgIGlmKCFhdHRyaWJ1dGUudHlwZS5wcmltaXRpdmUpe1xuICAgICAgICAgICAgICAgICAgICB0dXBsZUF0dHJpYnV0ZVZhbHVlID0gYXR0cmlidXRlLnR5cGUuc2VyaWFsaXplKHR1cGxlLmdldChhdHRyaWJ1dGUubmFtZSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHR1cGxlQXR0cmlidXRlVmFsdWUgPSB0dXBsZS5nZXQoYXR0cmlidXRlLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChhID09PSBoZWFkZXJDb3VudCAtIDEpIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQuZWxlbWVudHMuaGFzT3duUHJvcGVydHkodHVwbGVBdHRyaWJ1dGVWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjb250ZXh0LmVsZW1lbnRzW3R1cGxlQXR0cmlidXRlVmFsdWVdO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQuZWxlbWVudHMuaGFzT3duUHJvcGVydHkodHVwbGVBdHRyaWJ1dGVWYWx1ZSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dC5lbGVtZW50c1t0dXBsZUF0dHJpYnV0ZVZhbHVlXTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZGV4OyIsInZhciBUeXBlID0gcmVxdWlyZSgnLi9UeXBlJyksXG4gICAgSW5kZXggPSByZXF1aXJlKCcuL0luZGV4JyksXG4gICAgSGVhZGVyID0gcmVxdWlyZSgnLi9IZWFkZXInKSxcbiAgICBfID0gcmVxdWlyZSgnbG9kYXNoJyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuL2hlbHBlcnMvZGVidWcnKTtcblxudmFyIEtleSA9IFR5cGUuZXh0ZW5kKHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIEtleVxuICAgICAgICAgKiBAZXh0ZW5kcyBCYXNlXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBLZXkgY2xhc3MgcmVwcmVzZW50cyBrZXlzIHRvIGEgcmVsYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4ga2V5cyBhcmUgbm90IGRlZmluZWQgb24gYSByZWxhdGlvbiwgYSBrZXkgaXMgYXNzdW1lZCBvbiBhbGwgYXR0cmlidXRlcyBvZiB0aGUgcmVsYXRpb24uXG4gICAgICAgICAqIFRob3VnaCwgd2hlbiBhIGtleSBpcyBkZWZpbmVkIG9uIGEgc3Vic2V0IG9mIGEgcmVsYXRpb24ncyBhdHRyaWJ1dGVzLCB0aGUgdW5pcXVlbmVzc1xuICAgICAgICAgKiBvZiB0aGUgdHVwbGVzIHdpbGwgYmUgY2FsY3VsYXRlZCBvbmx5IG9uIHRob3NlIGF0dHJpYnV0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEFsc28sIGEgS2V5IHdpbGwgaW5kZXggdGhlIHR1cGxlcyBmb3IgaXRzIGF0dHJpYnV0ZXMsIG1ha2luZyBvcGVyYXRpb25zIGEgbG90IGZhc3Rlci5cbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgIHthdHRyaWJ1dGUxIDoge3R5cGUgOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgIHthdHRyaWJ1dGUyIDoge3R5cGUgOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgIHthdHRyaWJ1dGUzIDoge3R5cGUgOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgIFsxLCAyLCAzXSxcbiAgICAgICAgICogICAgICAgICAgWzQsIDIsIDNdLCAvLyAtPiBXaWxsIGZhaWwgdG8gYmUgYWRkZWQsIGFzIGl0IGRvZXMgbm90IHJlc3BlY3RzIHRoZSB1bmlxdWUga2V5IGNvbnN0cmFpbnRcbiAgICAgICAgICogICAgICAgICAgWzEsIDgsIDldLCAvLyAtPiBXaWxsIGZhaWwgdG8gYmUgYWRkZWQsIGFzIGl0IGRvZXMgbm90IHJlc3BlY3RlZCB0aGUgcGsgY29uc3RyYWludFxuICAgICAgICAgKiAgICAgICAgICBbMTAsIDExLCAxMl0sXG4gICAgICAgICAqICAgICAgXSx7XG4gICAgICAgICAqICAgICAgICAgIHBrIDogWydhdHRyaWJ1dGUxJ10sXG4gICAgICAgICAqICAgICAgICAgIHVuaXF1ZSA6IFtbJ2F0dHJpYnV0ZTInLCAnYXR0cmlidXRlMyddXVxuICAgICAgICAgKiAgICAgIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIChyZWxhdGlvbiwgYXR0cmlidXRlcykge1xuXG4gICAgICAgICAgICBkZWJ1Zy5rZXkudHJhY2UoJyNjb25zdHJ1Y3RvcicpO1xuXG4gICAgICAgICAgICBpZighXy5pc0FycmF5KGF0dHJpYnV0ZXMpKXtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzID0gW2F0dHJpYnV0ZXNdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SGVhZGVyfSBoZWFkZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGhlYWRlciA9IHRoaXMuaGVhZGVyID0gbmV3IEhlYWRlcigpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBoZWFkZXIucmVsYXRpb24gPSByZWxhdGlvbjtcblxuICAgICAgICAgICAgaGVhZGVyLmNvcHkocmVsYXRpb24uaGVhZGVyKCksYXR0cmlidXRlcyk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtJbmRleH0gaW5kZXhcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCA9IG5ldyBJbmRleCh0aGlzLmhlYWRlcik7XG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgdHVwbGUgdG8gdGhlIGluZGV4IGFmdGVyIGl0IGlzIGFkZGVkIGluIHRoZSByZWxhdGlvblxuICAgICAgICAgICAgcmVsYXRpb24uZWUub24oJ2FmdGVyQWRkJywgZnVuY3Rpb24odHVwbGUsIHR1cGxlSW5kZXgpe1xuXG4gICAgICAgICAgICAgICAgZGVidWcua2V5LnRyYWNlKCcjYWZ0ZXJBZGQnKTtcblxuICAgICAgICAgICAgICAgIGluZGV4LmFkZCh0dXBsZSwgdHVwbGVJbmRleCk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHR1cGxlIGZyb20gdGhlIGJlZm9yZSBpdCBpcyBkZWxldGVkXG4gICAgICAgICAgICByZWxhdGlvbi5lZS5vbignYmVmb3JlRGVsZXRlJywgZnVuY3Rpb24odHVwbGUsIHR1cGxlSW5kZXgpe1xuXG4gICAgICAgICAgICAgICAgZGVidWcua2V5LnRyYWNlKCcjYmVmb3JlRGVsZXRlJyk7XG5cbiAgICAgICAgICAgICAgICBpbmRleC5yZW1vdmUodHVwbGUsIHR1cGxlSW5kZXgpO1xuXG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlbiBhZGQgdGhlIHR1cGxlIGZyb20gaW5kZXggYmVmb3JlIHRoZSB0dXBsZSB1cGRhdGVcblxuICAgICAgICAgICAgcmVsYXRpb24uZWUub24oJ2JlZm9yZVVwZGF0ZScsIGZ1bmN0aW9uKHR1cGxlLCBhdHRyaWJ1dGVOYW1lKXtcblxuICAgICAgICAgICAgICAgIGRlYnVnLmtleS50cmFjZSgnI2JlZm9yZVVwZGF0ZScpO1xuXG4gICAgICAgICAgICAgICAgaWYoaGVhZGVyLmdldChhdHRyaWJ1dGVOYW1lKSAhPT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0dXBsZUluZGV4ID0gaW5kZXguZ2V0SW5kZXgodHVwbGUpO1xuICAgICAgICAgICAgICAgICAgICBpbmRleC5yZW1vdmUodHVwbGUsIHR1cGxlSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJlbGF0aW9uLmVlLm9uKCdhZnRlclVwZGF0ZScsIGZ1bmN0aW9uKHR1cGxlLCBhdHRyaWJ1dGVOYW1lKXtcblxuICAgICAgICAgICAgICAgIGRlYnVnLmtleS50cmFjZSgnI2FmdGVyVXBkYXRlJyk7XG5cbiAgICAgICAgICAgICAgICBpZihoZWFkZXIuZ2V0KGF0dHJpYnV0ZU5hbWUpICE9PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR1cGxlSW5kZXggPSBpbmRleC5nZXRJbmRleCh0dXBsZSk7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4LmFkZCh0dXBsZSwgdHVwbGVJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9XG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXk7IiwidmFyIEhlYWRlciA9IHJlcXVpcmUoJy4vSGVhZGVyLmpzJyk7XG52YXIgVHVwbGUgPSByZXF1aXJlKCcuL1R1cGxlLmpzJyk7XG52YXIgVHlwZSA9IHJlcXVpcmUoJy4vVHlwZS5qcycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBTZXQgPSByZXF1aXJlKCcuL1NldCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnLi9oZWxwZXJzL2RlYnVnJyk7XG52YXIgY29lcmNlID0gcmVxdWlyZSgnLi9oZWxwZXJzL2NvZXJjZScpO1xudmFyIEtleSA9IHJlcXVpcmUoJy4vS2V5Jyk7XG52YXIgRm9yZWlnbktleSA9IHJlcXVpcmUoJy4vRm9yZWlnbktleScpO1xuXG52YXIgUmVsYXRpb24gPSBTZXQuZXh0ZW5kKFxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQGNsYXNzIFJlbGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7SGVhZGVyfE9iamVjdFtdfEF0dHJpYnV0ZVtdfSBoZWFkZXIgSGVhZGVyIG9mIHRoZSBSZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1R1cGxlW118T2JqZWN0W119IGJvZHkgQm9keSBvZiB0aGUgUmVsYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnN0cmFpbnRzIENvbnN0cmFpbnRzIGZvciB0aGUgcmVsYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gY29uc3RyYWludHMucGsgRmllbGRzIHRoYXQgd2lsbCBjb25zdGl0dXRlIHByaW1hcnkga2V5XG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW11bXX0gY29uc3RyYWludHMudW5pcXVlIFVuaXF1ZSBmaWVsZCBkZWZpbml0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGNvbnN0cmFpbnRzLmZrIEZvcmVpZ24ga2V5IGRlZmluaXRpb25zXG4gICAgICAgICAqIEBleHRlbmRzIFNldFxuICAgICAgICAgKlxuICAgICAgICAgKiBSZWxhdGlvbiBjb25zdHJ1Y3RvclxuICAgICAgICAgKlxuICAgICAgICAgKiBBIFJlbGF0aW9uIGlzIGJhc2ljYWxseSBhIHtAbGluayBTZXR9LCBpbXBsZW1lbnRpbmcgdGhlIGJhc2ljIHNldCBvcGVyYXRvcnMgKFVuaW9uLCBEaWZmZXJlbmNlLCBJbnRlcnNlY3Rpb24sIFByb2R1Y3QpXG4gICAgICAgICAqIGFuZCBhZGRpbmcgbW9yZSBvcGVyYXRvcnMuIEl0IGFsc28gaGFzIGEge0BsaW5rIEhlYWRlcn0sIGFuZCBhZGRzIGNvbnN0cmFpbnRzIHRvIHRoZSBiYXNpYyB7QGxpbmsgU2V0fSBiZWhhdmlvci5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgIHtpZCA6IHt0eXBlIDogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICB7bmFtZSA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX0sXG4gICAgICAgICAqICAgICAgICAgIHtib3JuIDoge3R5cGUgOiBhZmZpbml0eS5EYXRlfX0sXG4gICAgICAgICAqICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgWzEsICdKb2huIERvZScsIG5ldyBEYXRlKDE5MzQsIDEwLCAyMCldLFxuICAgICAgICAgKiAgICAgICAgICBbMiwgJ0pvaG4gV2lsc29uJywgbmV3IERhdGUoMTkyMiwgNywgNSldLFxuICAgICAgICAgKiAgICAgXSk7XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKGhlYWRlciwgYm9keSwgY29uc3RyYWludHMpIHtcblxuICAgICAgICAgICAgZGVidWcucmVsYXRpb24udHJhY2UoJyNjb25zdHJ1Y3RvcicpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7e3BrOiBTdHJpbmcsIHVuaXF1ZTogU3RyaW5nW11bXSwgZms6IE9iamVjdFtdfX0gX2NvbnN0cmFpbnRBcmd1bWVudHNcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2NvbnN0cmFpbnRBcmd1bWVudHMgPSBjb25zdHJhaW50cztcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0tleX0gX3BrIFRoZSBQcmltYXJ5IEtleSBmb3IgdGhlIFJlbGF0aW9uXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9wayA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge1NldH0gX3VrcyBUaGUgUHJpbWFyeSBLZXlzIGZvciB0aGUgUmVsYXRpb25cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX3VrcyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge1NldH0gX2ZrcyBUaGUgRm9yZWlnbiBLZXlzIGZvciB0aGUgUmVsYXRpb25cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2ZrcyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge0hlYWRlcn0gX2hlYWRlciBUaGUgcmVsYXRpb24gaGVhZGVyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmhlYWRlcihIZWFkZXIuY29lcmNlKGhlYWRlcikpO1xuXG4gICAgICAgICAgICBTZXQuY2FsbCh0aGlzLCB7dHlwZTogVHVwbGUsIGVsZW1lbnRzOiBib2R5fSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnJlbGF0aW9uLnRyYWNlKCcjYmluZEV2ZW50cycpO1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMuZWUub24oJ2JlZm9yZUdldEVsZW1lbnRzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoYXQuZWUuZW1pdCgnYmVmb3JlR2V0Qm9keScpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuZWUub24oJ2JlZm9yZUFkZCcsIGZ1bmN0aW9uICh0dXBsZSkge1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIGRlZmF1bHQgdmFsdWVzXG4gICAgICAgICAgICAgICAgdGhhdC5oZWFkZXIoKS5lYWNoKGZ1bmN0aW9uKGF0dHJpYnV0ZSl7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHR1cGxlQXR0cmlidXRlVmFsdWUgPSB0dXBsZS5nZXQoYXR0cmlidXRlLm5hbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKHR1cGxlQXR0cmlidXRlVmFsdWUgPT09IG51bGwgfHwgdHVwbGVBdHRyaWJ1dGVWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR1cGxlQXR0cmlidXRlVmFsdWUgPT09ICcnKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdHVwbGUuc2V0KGF0dHJpYnV0ZS5uYW1lLCBhdHRyaWJ1dGUuZGVmYXVsdCgpKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIENvZXJjZSB0dXBsZSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgdGhhdC5oZWFkZXIoKS5lYWNoKGZ1bmN0aW9uKGF0dHJpYnV0ZSl7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZVZhbHVlLCBhdHRyaWJ1dGVUeXBlO1xuXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZVZhbHVlID0gdHVwbGUuZ2V0KGF0dHJpYnV0ZS5uYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVUeXBlID0gYXR0cmlidXRlLnR5cGU7XG5cbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlVmFsdWUgPSBjb2VyY2UoYXR0cmlidXRlVHlwZSwgYXR0cmlidXRlVmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHR1cGxlLnNldChhdHRyaWJ1dGUubmFtZSwgYXR0cmlidXRlVmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSB0dXBsZSBpcyB1bmlvbi1jb21wYXRpYmxlIHdpdGggdGhlIHJlbGF0aW9uXG4gICAgICAgICAgICAgICAgaWYgKCF0aGF0LmlzQ29tcGF0aWJsZSh0dXBsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUdXBsZSBpcyBub3QgdW5pb24gY29tcGF0aWJsZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHR1cGxlLnJlbGF0aW9uID0gdGhhdDtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuZWUub25jZSgnYmVmb3JlR2V0RWxlbWVudHMnLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWludEFyZ3VtZW50cyA9IHRoYXQuX2NvbnN0cmFpbnRBcmd1bWVudHM7XG5cbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBjb25zdHJhaW50IGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgIGlmIChjb25zdHJhaW50QXJndW1lbnRzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgcHJpbWFyeSBrZXkgYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnRBcmd1bWVudHMucGspIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5wayhjb25zdHJhaW50QXJndW1lbnRzLnBrKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdW5pcXVlIGtleSBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnRBcmd1bWVudHMudW5pcXVlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaChjb25zdHJhaW50QXJndW1lbnRzLnVuaXF1ZSwgZnVuY3Rpb24gKHVuaXF1ZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC51a3MoKS5hZGQobmV3IEtleSh0aGF0LCB1bmlxdWUpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhhdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGZvcmVpZ24ga2V5IGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uc3RyYWludEFyZ3VtZW50cy5maykge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKGNvbnN0cmFpbnRBcmd1bWVudHMuZmssIGZ1bmN0aW9uIChma0FyZ3MpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZrQXJncy5yZWxhdGlvbiA9IHRoYXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmsgPSBuZXcgRm9yZWlnbktleShma0FyZ3MpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5ma3MoKS5hZGQobmV3IEZvcmVpZ25LZXkoZmtBcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG5cblxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy51a3MoKS5lZS5vbignYmVmb3JlQWRkJywgZnVuY3Rpb24oY29uc3RyYWludCl7XG5cbiAgICAgICAgICAgICAgICAvLyBJbnN1cmUgY29ycmVzcG9uZGluZyBrZXkgdHlwZXMgaGFzIHNlcmlhbGl6ZSBtZXRob2RcbiAgICAgICAgICAgICAgICB0aGF0Ll9hc3NlcnRLZXlTZXJpYWxpemUoY29uc3RyYWludCk7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBrZXlzIGFyZSB1bmlxdWVcbiAgICAgICAgICAgICAgICB0aGF0Ll9hc3NlcnRLZXlzVW5pcXVlKGNvbnN0cmFpbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUga2V5cyBhcmUgaXJyZWR1Y2libGVcbiAgICAgICAgICAgICAgICB0aGF0Ll9hc3NlcnRLZXlzSXJyZWR1Y2libGUoY29uc3RyYWludCk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmVlLm9uKCdhZnRlckFkZCcsIGZ1bmN0aW9uKHR1cGxlLCBpbmRleCl7XG4gICAgICAgICAgICAgICAgdHVwbGUuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICB0dXBsZS5yZWxhdGlvbiA9IHRoYXQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIF9hc3NlcnRLZXlTZXJpYWxpemUgOiBmdW5jdGlvbihuZXdLZXkpe1xuXG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IGlmIHRoZSBjb25zdHJhaW50IGFwcGxpZXMgb24gYW4gb2JqZWN0LCB0aGF0XG4gICAgICAgICAgICAvLyBpdHMgdHlwZSBoYXMgdGhlIHNlcmlhbGl6ZSBtZXRob2RcblxuICAgICAgICAgICAgbmV3S2V5LmhlYWRlci5lYWNoKFxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWF0dHJpYnV0ZS50eXBlLnByaW1pdGl2ZSAmJiAhXy5pc0Z1bmN0aW9uKGF0dHJpYnV0ZS50eXBlLnNlcmlhbGl6ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IGluZGV4IGF0dHJpYnV0ZSBcIicgKyBhdHRyaWJ1dGUubmFtZSArICdcIi4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0l0cyB0eXBlIFwiJyArIGF0dHJpYnV0ZS50eXBlLnR5cGUgKyAnXCIgbXVzdCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdoYXZlIGEgXCJzZXJpYWxpemVcIiBtZXRob2QgZm9yIGl0IHRvIGJlIGluZGV4YWJsZS4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgX2Fzc2VydEtleXNVbmlxdWUgOiBmdW5jdGlvbihuZXdLZXkpe1xuXG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdLZXlzID0gdGhpcy51a3MoKTtcblxuICAgICAgICAgICAgZXhpc3RpbmdLZXlzLmVhY2goZnVuY3Rpb24oa2V5KXtcblxuICAgICAgICAgICAgICAgIGlmIChrZXkuaGVhZGVyLmVxdWFsKG5ld0tleS5oZWFkZXIpKXtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25zdHJhaW50cyBtdXN0IGJlIHVuaXF1ZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBfYXNzZXJ0S2V5c0lycmVkdWNpYmxlIDogZnVuY3Rpb24obmV3S2V5KXtcblxuICAgICAgICAgICAgdmFyIGV4aXN0aW5nS2V5cyA9IHRoaXMudWtzKCk7XG5cbiAgICAgICAgICAgIGV4aXN0aW5nS2V5cy5lYWNoKGZ1bmN0aW9uKGtleSl7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV3S2V5LmhlYWRlci5zZXRJbnRlcnNlY3Rpb24oa2V5LmhlYWRlcikubGVuZ3RoKCkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25zdHJhaW50IG11c3QgYmUgaXJyZWR1Y2libGUnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbGV0ZSBvciBhZGQgdHVwbGVzIHRvIG1hdGNoIGEgZ2l2ZW4gcmVsYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtSZWxhdGlvbn0gcmVsYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIGFkanVzdFRvOiBmdW5jdGlvbihyZWxhdGlvbil7XG5cbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZSgpO1xuXG4gICAgICAgICAgICByZWxhdGlvbi5jb21wdXRlKCk7XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgLy8gMS4gRGVsZXRlIHR1cGxlcyB0aGF0IGRvIG5vdCBleGlzdCBpbiB0aGUgZ2l2ZW4gcmVsYXRpb25cblxuICAgICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGVhY2ggdHVwbGVcbiAgICAgICAgICAgIHRoYXQuZWFjaChmdW5jdGlvbih0dXBsZSwgaW5kZXgpe1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHR1cGxlIGV4aXN0cyBpbiB0aGUgZ2l2ZW4gcmVsYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoIXJlbGF0aW9uLmV4aXN0cyh0dXBsZSkpe1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnJlbW92ZUF0KGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyAyLiBBZGQgdHVwbGVzIHRoYXQgZG8gbm90IGV4aXN0IGluIHRoZSByZWxhdGlvblxuXG4gICAgICAgICAgICAvLyBMb29wIHRocm91Z2ggZWFjaCB0dXBsZSBvZiB0aGUgZ2l2ZW4gcmVsYXRpb25cbiAgICAgICAgICAgIHJlbGF0aW9uLmVhY2goZnVuY3Rpb24odHVwbGUpe1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHR1cGxlIGlzIHByZXNlbnQgaW4gdGhpcyByZWxhdGlvblxuICAgICAgICAgICAgICAgIGlmICghdGhhdC5leGlzdHModHVwbGUpKXtcblxuICAgICAgICAgICAgICAgICAgICB0aGF0LmFkZCh0dXBsZS5jbG9uZSgpKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBfaW5kZXg6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cbiAgICAgICAgICAgIC8vIExvb2sgZm9yIHRoZSB0dXBsZSBpbiB0aGUgUEsgaWYgaXQgZXhpc3RzXG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9waykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fcGsuaW5kZXguZ2V0SW5kZXgoZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcblxuICAgICAgICAgICAgdGhpcy51a3MoKS5hbnkoZnVuY3Rpb24gKHVuaXF1ZUNvbnN0cmFpbnQpIHtcblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHVuaXF1ZUNvbnN0cmFpbnQuaW5kZXguZ2V0SW5kZXgoZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2ZvdW5kIGJ5IHVrJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgc3BlY2lmaWVkIGF0dHJpYnV0ZSBvYmplY3QgYnkgbmFtZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlIEF0dHJpYnV0ZSBuYW1lXG4gICAgICAgICAqIEByZXR1cm5zIHtBdHRyaWJ1dGV8bnVsbH0gVGhlIGF0dHJpYnV0ZSBvciBudWxsIGlmIG5vdCBmb3VuZFxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGZuID0gbmV3IGFmZmluaXR5LkF0dHJpYnV0ZSh7bmFtZSA6ICdmaXJzdE5hbWUnLCB0eXBlIDogYWZmaW5pdHkuU3RyaW5nfSlcbiAgICAgICAgICogICAgIHZhciBsbiA9IG5ldyBhZmZpbml0eS5BdHRyaWJ1dGUoe25hbWUgOiAnbGFzdE5hbWUnLCB0eXBlIDogYWZmaW5pdHkuU3RyaW5nfSlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICBmbixcbiAgICAgICAgICogICAgICAgICAgICAgIGxuXG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWydKb2huJywnRG9lJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ0hlbGxvJywnV29ybGQnXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsnU3VwZXInLCdEdXBlciddLFxuICAgICAgICAgKiAgICAgICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHJlbGF0aW9uLmdldCgnZmlyc3ROYW1lJykgPT09IGZuIC8vIHRydWVcbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5yZWxhdGlvbi50cmFjZSgnI2dldCcpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXIoKS5nZXQoYXR0cmlidXRlKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHR1cGxlIGF0IHRoZSBnaXZlbiBpbmRleFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0dXBsZVxuICAgICAgICAgKiBAcmV0dXJucyB7KnxudWxsfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgICAgIHsgJ2ZpcnN0TmFtZScgOiB7dHlwZSA6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgICAgICAgICB7ICdMYXN0TmFtZScgIDoge3R5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsnSm9obicsJ0RvZSddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydIZWxsbycsJ1dvcmxkJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ1N1cGVyJywnRHVwZXInXSxcbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICByZWxhdGlvbi5lYWNoKGZ1bmN0aW9uKHR1cGxlLCBpbmRleCl7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgIGNvbnNvbGUubG9nKHJlbGF0aW9uLmF0SW5kZXgoaW5kZXgpID09PSB0dXBsZSkgLy8gdHJ1ZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgfSlcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2cocmVsYXRpb24uYXRJbmRleCgwKS5nZXQoJ2ZpcnN0TmFtZScpKSAvLyBKb2huXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhdEluZGV4OiBmdW5jdGlvbiAoaW5kZXgpIHtcblxuICAgICAgICAgICAgZGVidWcucmVsYXRpb24udHJhY2UoJyNhdEluZGV4Jyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzKClbaW5kZXhdO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7U2V0fSBbdHVwbGVzXSBUaGUgbmV3IHNldCBvZiBib2R5XG4gICAgICAgICAqIEByZXR1cm5zIHtTZXR8UmVsYXRpb259IFRoZSBib2R5L251bGwgaWYgZ2V0dGVyLCB0aGlzIGlmIHNldHRlclxuICAgICAgICAgKlxuICAgICAgICAgKiBHZXR0ZXIvU2V0dGVyIGZvciB0aGUgYm9keSBwcm9wZXJ0eVxuICAgICAgICAgKlxuICAgICAgICAgKiBZb3Ugd2lsbCBtb3JlIGxpa2VseSBhbHdheXMgdXNlIHRoZSBnZXR0ZXIgKFJlbGF0aW9uLmJvZHkoKSkgdGhhbiB0aGUgc2V0dGVyXG4gICAgICAgICAqIChSZWxhdGlvbi5ib2R5KGJvZHkpKSBwYXJ0IGZvciB0aGlzIG1ldGhvZC5cbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7ICdmaXJzdE5hbWUnIDoge3R5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICAgICAgeyAnTGFzdE5hbWUnICA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgc2V0ID0gbmV3IGFmZmluaXR5LlNldCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgc2V0LmFkZChuZXcgYWZmaW5pdHkuVHVwbGUoe2ZpcnN0TmFtZSA6ICdKb2huJywgbGFzdE5hbWUgOiAnRG9lJ30pKVxuICAgICAgICAgKiAgICAgc2V0LmFkZChuZXcgYWZmaW5pdHkuVHVwbGUoe2ZpcnN0TmFtZSA6ICdIZWxsbycsIGxhc3ROYW1lIDogJ1dvcmxkJ30pKVxuICAgICAgICAgKiAgICAgc2V0LmFkZChuZXcgYWZmaW5pdHkuVHVwbGUoe2ZpcnN0TmFtZSA6ICdKb2huJywgbGFzdE5hbWUgOiAnQ2FnZSd9KSlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHJlbGF0aW9uLmJvZHkoc2V0KTsgLy8gU2V0cyB0aGUgcmVsYXRpb24ncyBib2R5XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICByZWxhdGlvbi5ib2R5KCkgLy8gR2V0cyB0aGUgcmVsYXRpb24ncyBib2R5XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBjb25zb2xlLmxvZyhyZWxhdGlvbi5ib2R5KCkgPT09IHNldCkgLy8gdHJ1ZVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgYm9keTogZnVuY3Rpb24gKHR1cGxlcykge1xuXG4gICAgICAgICAgICBkZWJ1Zy5yZWxhdGlvbi50cmFjZSgnI2JvZHknKTtcblxuICAgICAgICAgICAgaWYgKHR1cGxlcykge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50cyh0dXBsZXMpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuZWUuZW1pdCgnYmVmb3JlR2V0Qm9keScpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge1JlbGF0aW9ufSBSZXR1cm5zIHRoaXMgZm9yIGNoYWluaW5nXG4gICAgICAgICAqXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIHJlbGF0aW9uLiBCZWNhdXNlIHRoZSByZWxhdGlvbnMgYXJlIG9ubHkgY2FsY3VsYXRlZCB3aGVuIHRoZWlyIGhlYWRlciBvciB0aGVpciBib2R5XG4gICAgICAgICAqIGFyZSByZXF1ZXN0ZWQsIHlvdSBtdXN0IGV4cGxpY2l0bHkgY2FsbCBjb21wdXRlKCkgaWYgeW91IHdhbnQgdG8gY2FsY3VsYXRlIGEgcmVsYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFlvdSBzaG91bGQgbm90IG5lZWQgdG8gdXNlIHRoaXMgZnVuY3Rpb24uIENhbGxpbmcgYm9keSgpIG9yIGhlYWRlcigpIGNhbGN1bGF0ZXMgdGhlIHJlbGF0aW9uXG4gICAgICAgICAqIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBwcm9kdWN0ID0gcmVsYXRpb24xLnByb2R1Y3QocmVsYXRpb24yKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIEF0IHRoaXMgcG9pbnQsIG5vdGhpbmcgaGFzIGJlZW4gY2FsY3VsYXRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHByb2R1Y3QuaGVhZGVyKCkgLy8gQmVjYXVzZSB3ZSByZXF1ZXN0ZWQgdGhlIGhlYWRlciwgaXQgaXMgY2FsY3VsYXRlZFxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgcHJvZHVjdC5ib2R5KCkgLy8gQmVjYXVzZSB3ZSByZXF1ZXN0ZWQgdGhlIGJvZHksIGl0IGlzIGNhbGN1bGF0ZWRcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBwcm9kdWN0MiA9IHJlbGF0aW9uMS5wcm9kdWN0KHJlbGF0aW9uMik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBwcm9kdWN0Mi5jb21wdXRlKCk7IC8vIENhbGN1bGF0ZXMgdGhlIGhlYWRlciBhbmQgdGhlIGJvZHk7XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjb21wdXRlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnJlbGF0aW9uLnRyYWNlKCcjY29tcHV0ZScpO1xuXG4gICAgICAgICAgICB0aGlzLmhlYWRlcigpO1xuICAgICAgICAgICAgdGhpcy5ib2R5KCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7SGVhZGVyfSBbaGVhZGVyXVxuICAgICAgICAgKiBAcmV0dXJucyB7bnVsbHx7SGVhZGVyfX1cbiAgICAgICAgICpcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSByZWxhdGlvbidzIGhlYWRlclxuICAgICAgICAgKi9cbiAgICAgICAgaGVhZGVyOiBmdW5jdGlvbiAoaGVhZGVyKSB7XG5cbiAgICAgICAgICAgIGlmIChoZWFkZXIpIHtcblxuICAgICAgICAgICAgICAgIGRlYnVnLnJlbGF0aW9uLnRyYWNlKCcjaGVhZGVyIChzZXQpJyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFkZXIgPSBoZWFkZXI7XG5cbiAgICAgICAgICAgICAgICBoZWFkZXIucmVsYXRpb24gPSB0aGlzO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgZGVidWcucmVsYXRpb24udHJhY2UoJyNoZWFkZXIgKGdldCknKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZWUuZW1pdCgnYmVmb3JlR2V0SGVhZGVyJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyAvIFNldHMgdGhlIHJlbGF0aW9uJ3MgcHJpbWFyeSBrZXlcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtwcmltYXJ5S2V5TmFtZV1cbiAgICAgICAgICovXG4gICAgICAgIHBrIDogZnVuY3Rpb24ocHJpbWFyeUtleU5hbWUpe1xuXG4gICAgICAgICAgICBpZiAocHJpbWFyeUtleU5hbWUpe1xuXG4gICAgICAgICAgICAgICAgaWYodGhpcy5fcGsgIT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudWtzKCkucmVtb3ZlKHRoaXMuX3BrKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9wayA9IG5ldyBLZXkodGhpcywgcHJpbWFyeUtleU5hbWUpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy51a3MoKS5hZGQodGhpcy5fcGspO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZm9yZWlnbiBrZXlzIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7U2V0fVxuICAgICAgICAgKi9cbiAgICAgICAgZmtzIDogZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2ZrcyA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgICAgICB0aGlzLl9ma3MgPSBuZXcgU2V0KHsgdHlwZSA6IEZvcmVpZ25LZXl9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZrcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgdW5pcXVlIGtleXMgc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtTZXR9XG4gICAgICAgICAqL1xuICAgICAgICB1a3MgOiBmdW5jdGlvbigpe1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fdWtzID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgICAgIHRoaXMuX3VrcyA9IG5ldyBTZXQoeyB0eXBlIDogS2V5fSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91a3M7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7VHVwbGV8T2JqZWN0fSB0dXBsZVxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICpcbiAgICAgICAgICogQ2hlY2sgaWYgYSB0dXBsZSBpcyBjb21wYXRpYmxlIHdpdGggdGhlIHJlbGF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBpc0NvbXBhdGlibGU6IGZ1bmN0aW9uICh0dXBsZSkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5yZWxhdGlvbi50cmFjZSgnI2lzQ29tcGF0aWJsZScpO1xuXG4gICAgICAgICAgICB0dXBsZSA9IFR1cGxlLmNvZXJjZSh0dXBsZSk7XG5cbiAgICAgICAgICAgIHZhciB0dXBsZUtleXMgPSBPYmplY3Qua2V5cyh0dXBsZS5hdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIHZhciB0dXBsZUtleUNvdW50ID0gdHVwbGVLZXlzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBoZWFkZXJLZXlzID0gT2JqZWN0LmtleXModGhpcy5oZWFkZXIoKS5fYXR0cmlidXRlcyk7XG4gICAgICAgICAgICB2YXIgaGVhZGVyS2V5Q291bnQgPSBoZWFkZXJLZXlzLmxlbmd0aDtcblxuXG4gICAgICAgICAgICAvLy8gQ2hlY2sgaWYgdGhlIGdpdmVuIHR1cGxlIGhhcyB0aGUgc2FtZSBoZWFkZXIgYXMgdGhlIHJlbGF0aW9uXG5cbiAgICAgICAgICAgIC8vIEhlYWRlciBhbmQgVHVwbGUgbXVzdCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBpZiAodHVwbGVLZXlDb3VudCAhPT0gaGVhZGVyS2V5Q291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhlYWRlciBhbmQgVHVwbGUgbXVzdCBoYXZlIHRoZSBzYW1lIGF0dHJpYnV0ZSBuYW1lc1xuICAgICAgICAgICAgcmV0dXJuICFfLnNvbWUoaGVhZGVyS2V5cywgZnVuY3Rpb24gKGhlYWRlckF0dHJpYnV0ZSkge1xuXG4gICAgICAgICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGVhY2ggYXR0cmlidXRlcyBvZiB0aGUgdHVwbGVcbiAgICAgICAgICAgICAgICByZXR1cm4gIV8uc29tZSh0dXBsZUtleXMsIGZ1bmN0aW9uICh0dXBsZUF0dHJpYnV0ZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvdW5kIGEgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0dXBsZUF0dHJpYnV0ZSA9PT0gaGVhZGVyQXR0cmlidXRlICYmICh0dXBsZS5nZXQodHVwbGVBdHRyaWJ1dGUpICE9PSB1bmRlZmluZWQpICYmICh0dXBsZS5nZXQodHVwbGVBdHRyaWJ1dGUpICE9PSBudWxsKSk7XG5cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtSZWxhdGlvbn0gcmVsYXRpb24gVGhlIHJlbGF0aW9uIHRvIGNvbXBhcmUgdG9cbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IElmIHRoZSByZWxhdGlvbnMgYXJlIGVxdWFsIG9yIG5vdFxuICAgICAgICAgKlxuICAgICAgICAgKiBUZXN0cyBpZiB0aGUgcmVsYXRpb24gaXMgZXF1YWwgdG8gYW5vdGhlciBvbmVcbiAgICAgICAgICovXG4gICAgICAgIGVxdWFsOiBmdW5jdGlvbiAocmVsYXRpb24pIHtcblxuICAgICAgICAgICAgZGVidWcucmVsYXRpb24udHJhY2UoJyNlcXVhbCcpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5lcXVhbCh0aGlzLCByZWxhdGlvbik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb25lcyBhIHJlbGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3dpdGhUdXBsZXM9dHJ1ZV0gQ29waWVzIHRoZSB0dXBsZXNcbiAgICAgICAgICogQHJldHVybnMge1JlbGF0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgY2xvbmUgOiBmdW5jdGlvbih3aXRoVHVwbGVzKXtcblxuICAgICAgICAgICAgd2l0aFR1cGxlcyA9ICEhKHdpdGhUdXBsZXMgPT09IHVuZGVmaW5lZCB8fCB3aXRoVHVwbGVzID09PSBudWxsKTtcblxuICAgICAgICAgICAgdmFyIG5ld0hlYWRlciA9IHRoaXMuaGVhZGVyKCkuY2xvbmUoKTtcblxuICAgICAgICAgICAgdmFyIG5ld1JlbGF0aW9uID0gbmV3IFJlbGF0aW9uKG5ld0hlYWRlcik7XG5cbiAgICAgICAgICAgIC8vIENsb25lIHRoZSBwa1xuXG4gICAgICAgICAgICAvL3RvZG8gUEsgQ2xvbmVcblxuICAgICAgICAgICAgLy8gQ2xvbmUgdGhlIHVrc1xuXG4gICAgICAgICAgICAvL3RvZG8gVUtTIGNsb25lXG5cbiAgICAgICAgICAgIC8vIENsb25lIHRoZSBma3NcblxuICAgICAgICAgICAgLy90b2RvIEZLUyBjbG9uZVxuXG4gICAgICAgICAgICBpZiAod2l0aFR1cGxlcyl7XG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKHR1cGxlKXtcbiAgICAgICAgICAgICAgICAgICAgbmV3UmVsYXRpb24uYWRkKHR1cGxlLmNsb25lKCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3UmVsYXRpb247XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJpbnRzIHRoZSBwcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIFJlbGF0aW9uIHRvIGNvbnNvbGVcbiAgICAgICAgICovXG4gICAgICAgIHByaW50OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnJlbGF0aW9uLnRyYWNlKCcjcHJpbnQnKTtcblxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy50b1N0cmluZygpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZWxhdGlvblxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc3RyaW5nIHByaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZWxhdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgdmFyIGhzcGFjaW5nID0gMSxcbiAgICAgICAgICAgICAgICB2c3BhY2luZyA9IDEsXG4gICAgICAgICAgICAgICAgYXJyID0gdGhpcy5hcnIgPSBbXSxcbiAgICAgICAgICAgICAgICBoZWFkZXJSb3cgPSBbXSxcbiAgICAgICAgICAgICAgICBtYXhXaWR0aHMgPSBbXSxcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHRzID0gW107XG5cbiAgICAgICAgICAgIGRlYnVnLnJlbGF0aW9uLnRyYWNlKCcjZ2V0UHJpbnRTdHJpbmcnKTtcblxuICAgICAgICAgICAgdGhpcy5jb21wdXRlKCk7XG5cbiAgICAgICAgICAgIHRoaXMuaGVhZGVyKCkuZWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG5cbiAgICAgICAgICAgICAgICBoZWFkZXJSb3cucHVzaCh7IHdpZHRoOiBudWxsLCBoZWlnaHQ6IG51bGwsIGxpbmVzOiBudWxsLCBhdHRyaWJ1dGU6IGF0dHJpYnV0ZSwgc3RyaW5nOiBhdHRyaWJ1dGUudG9TdHJpbmcoKX0pXG5cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBbIHt3aWR0aCwgaGVpZ2h0LCBsaW5lcywgc3RyaW5nfSx7d2lkdGgsIGhlaWdodCwgbGluZXMsIHN0cmluZ30sLi4uIF0gXVxuXG4gICAgICAgICAgICBhcnIucHVzaChoZWFkZXJSb3cpO1xuXG4gICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKHR1cGxlKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgdHVwbGVSb3cgPSBbXTtcblxuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChoZWFkZXJSb3csIGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHR1cGxlUm93LnB1c2goeyB3aWR0aDogbnVsbCwgaGVpZ2h0OiBudWxsLCBsaW5lczogbnVsbCwgc3RyaW5nOiB0dXBsZS5nZXQoYXR0ci5hdHRyaWJ1dGUubmFtZSkudG9TdHJpbmcoKX0pXG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICBhcnIucHVzaCh0dXBsZVJvdyk7XG5cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBmaW5kSGVpZ2h0KHN0cmluZykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5zcGxpdChcIlxcblwiKS5sZW5ndGg7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZmluZFdpZHRoKHN0cmluZykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGxpbmVzID0gc3RyaW5nLnNwbGl0KCdcXG4nKSxcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gMDtcblxuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChsaW5lcywgZnVuY3Rpb24gKGxpbmUpIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZUxlbmd0aCA9IGxpbmUubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lTGVuZ3RoID4gbWF4KVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gbGluZUxlbmd0aDtcblxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1heDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBmaW5kTWF4V2lkdGgoYXJyKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWF4ID0gMDtcblxuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChhcnIsIGZ1bmN0aW9uIChvYmopIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gb2JqLndpZHRoO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPiBtYXgpXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXggPSBsaW5lV2lkdGg7XG5cbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBtYXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRNYXhIZWlnaHQoYXJyKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWF4ID0gMDtcblxuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChhcnIsIGZ1bmN0aW9uIChvYmopIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZUhlaWdodCA9IG9iai5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVIZWlnaHQgPiBtYXgpXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXggPSBsaW5lSGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbWF4O1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlTGluZXMoc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gW1xuICAgICAgICAgICAgLy8gICBbe3dpZHRoLCBoZWlnaHQsIGxpbmVzLCBzdHJpbmd9LHt3aWR0aCwgaGVpZ2h0LCBsaW5lcywgc3RyaW5nfSwuLi4gXSxcbiAgICAgICAgICAgIC8vICAgW3t3aWR0aCwgaGVpZ2h0LCBsaW5lcywgc3RyaW5nfSx7d2lkdGgsIGhlaWdodCwgbGluZXMsIHN0cmluZ30sLi4uIF0sXG4gICAgICAgICAgICAvLyAgIFt7d2lkdGgsIGhlaWdodCwgbGluZXMsIHN0cmluZ30se3dpZHRoLCBoZWlnaHQsIGxpbmVzLCBzdHJpbmd9LC4uLiBdLFxuICAgICAgICAgICAgLy8gICAuLi5cbiAgICAgICAgICAgIC8vIF1cblxuXG4gICAgICAgICAgICBfLmZvckVhY2goYXJyLCBmdW5jdGlvbiAocm93LCByb3dJbmRleCkge1xuXG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKHJvdywgZnVuY3Rpb24gKGNvbCwgY29sSW5kZXgpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb2wud2lkdGggPSBmaW5kV2lkdGgoY29sLnN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbC5oZWlnaHQgPSBmaW5kSGVpZ2h0KGNvbC5zdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICBjb2wubGluZXMgPSBwYXJzZUxpbmVzKGNvbC5zdHJpbmcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF4V2lkdGhzW2NvbEluZGV4XSB8fCBtYXhXaWR0aHNbY29sSW5kZXhdIDwgY29sLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aHNbY29sSW5kZXhdID0gY29sLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXhIZWlnaHRzW3Jvd0luZGV4XSB8fCBtYXhIZWlnaHRzW3Jvd0luZGV4XSA8IGNvbC5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEhlaWdodHNbcm93SW5kZXhdID0gY29sLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gJ1xcbic7XG5cblxuICAgICAgICAgICAgLy8gUHJpbnRpbmcgdGhlIHRvcCBib3JkZXJcblxuICAgICAgICAgICAgcmVzdWx0ICs9ICcrJztcblxuICAgICAgICAgICAgXy5mb3JFYWNoKG1heFdpZHRocywgZnVuY3Rpb24gKG1heFdpZHRoLCBpbmRleCkge1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCBtYXhXaWR0aHNbaW5kZXhdICsgaHNwYWNpbmcgKiAyICsgMjsgYSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnLSdcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJysnXG5cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XG5cbiAgICAgICAgICAgIC8vIFByaW50aW5nIHRoZSBhdHRyaWJ1dGVzXG5cbiAgICAgICAgICAgIF8uZm9yRWFjaChhcnIsIGZ1bmN0aW9uIChyb3csIHJvd0luZGV4KSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWF4SGVpZ2h0ID0gbWF4SGVpZ2h0c1tyb3dJbmRleF07XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IG1heEhlaWdodDsgYSsrKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICd8JztcblxuICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2gocm93LCBmdW5jdGlvbiAoY29sLCBjb2xJbmRleCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4V2lkdGggPSBtYXhXaWR0aHNbY29sSW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGluZSA9IGNvbC5saW5lc1thXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsaW5lKSBsaW5lID0gJyc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaHNwYWNpbmc7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnICc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaW5lTGVuZ3RoID0gbGluZS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGhzcGFjaW5nOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IG1heFdpZHRoIC0gbGluZUxlbmd0aCArIDIgKiBoc3BhY2luZzsgYisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcgJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICd8JztcblxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJysnO1xuXG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKG1heFdpZHRocywgZnVuY3Rpb24gKG1heFdpZHRoLCBpbmRleCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgbWF4V2lkdGhzW2luZGV4XSArIGhzcGFjaW5nICogMiArIDI7IGErKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd0luZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICc9J1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJy0nXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnKydcblxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuXG5cbiAgICAgICAgICAgICAgICBpZiAocm93SW5kZXggIT0gYXJyLmxlbmd0aCAtIDEpIHJlc3VsdCArPSAnXFxuJztcblxuXG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgdHVwbGVzIGluIHRoZSByZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0gcHJlZGljYXRlXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZXNcbiAgICAgICAgICpcbiAgICAgICAgICogRXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgcmVsYXRpb24udXBkYXRlKGFnZS5ndCgyMCksIHsgYWdlIDogYWdlLm9sZCgpLnBsdXMoMTApLCBuYW1lIDogbmFtZS5vbGQoKS5zdWJzdHIoMCwxKSB9KTtcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZSA6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgdmFsdWVzKXtcblxuICAgICAgICAgICAgcHJlZGljYXRlLmNvbnZlcnRBdHRyaWJ1dGVUb1R1cGxlKCk7XG5cbiAgICAgICAgICAgIF8uZm9yRWFjaCh2YWx1ZXMsIGZ1bmN0aW9uKHZhbHVlKXtcblxuICAgICAgICAgICAgICAgIGlmKF8uaXNGdW5jdGlvbih2YWx1ZSkpe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5jb252ZXJ0QXR0cmlidXRlVG9UdXBsZSgpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKHR1cGxlKXtcblxuICAgICAgICAgICAgICAgIGlmKHByZWRpY2F0ZS5hc3NpZ25UdXBsZSh0dXBsZSkudmFsdWUoKSA9PT0gdHJ1ZSl7XG5cbiAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKHZhbHVlcywgZnVuY3Rpb24oZXhwcmVzc2lvbiwga2V5KXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gXy5pc0Z1bmN0aW9uKGV4cHJlc3Npb24pID8gZXhwcmVzc2lvbi5hc3NpZ25UdXBsZSh0dXBsZSkudmFsdWUoKSA6IGV4cHJlc3Npb247XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHR1cGxlLnNldChrZXksIHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgdHVwbGVzIGZyb20gYSByZWxhdGlvbiBiYXNlZCBvbiBhIHByZWRpY2F0ZVxuICAgICAgICAgKiBAcGFyYW0gcHJlZGljYXRlXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVXaGVyZSA6IGZ1bmN0aW9uKHByZWRpY2F0ZSl7XG5cbiAgICAgICAgICAgIHByZWRpY2F0ZS5jb252ZXJ0QXR0cmlidXRlVG9UdXBsZSgpO1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbih0dXBsZSwgaW5kZXgpe1xuXG4gICAgICAgICAgICAgICAgaWYocHJlZGljYXRlLmFzc2lnblR1cGxlKHR1cGxlKS52YWx1ZSgpID09PSB0cnVlKXtcblxuICAgICAgICAgICAgICAgICAgICB0aGF0LnJlbW92ZUF0KGluZGV4KTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSlcblxuICAgICAgICB9LFxuXG5cbiAgICAgICAgLy9yZWdpb24gT3BlcmF0aW9uc1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvbiBUaGUgcmVsYXRpb24gdG8gY29tcHV0ZSBkaWZmZXJlbmNlIGFnYWluc3RcbiAgICAgICAgICogQHJldHVybnMge09wZXJhdG9ycy5EaWZmZXJlbmNlfSBUaGUgcmVzdWx0aW5nIHJlbGF0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNob3J0Y3V0IHRvIGNyZWF0ZSBhIERpZmZlcmVuY2UgcmVsYXRpb24gYmFzZWQgb24gdGhpcyByZWxhdGlvbiBhbmQgdGhlIHNwZWNpZmllZCBvbmVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbjEgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge2ZpcnN0TmFtZSA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgICAgIHtsYXN0TmFtZSA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ0pvaG4nLCdEb2UnXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsnTHVjaW5vJywnVmVvJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ01hcnknLCdQb3BwaW5zJ10sXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uMiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7Zmlyc3ROYW1lIDoge3R5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICAgICAge2xhc3ROYW1lIDoge3R5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsnSm9obicsJ0RvZSddXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGRpZmYgPSByZWxhdGlvbjEuZGlmZmVyZW5jZShyZWxhdGlvbjIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgZmlyc3ROYW1lIDogVFN0cmluZyB8IGxhc3ROYW1lIDogVFN0cmluZyB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBMdWNpbm8gICAgICAgICAgICAgIHwgVmVvICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IE1hcnkgICAgICAgICAgICAgICAgfCBQb3BwaW5zICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICovXG4gICAgICAgIGRpZmZlcmVuY2U6IGZ1bmN0aW9uIChyZWxhdGlvbikge1xuXG4gICAgICAgICAgICBkZWJ1Zy5yZWxhdGlvbi50cmFjZSgnI2RpZmZlcmVuY2UnKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyAocmVxdWlyZSgnLi9hbGdlYnJhL0RpZmZlcmVuY2UnKSkodGhpcywgcmVsYXRpb24pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvbiBUaGUgcmVsYXRpb24gdG8gY29tcHV0ZSBpbnRlcnNlY3Rpb24gYWdhaW5zdFxuICAgICAgICAgKiBAcmV0dXJucyB7T3BlcmF0b3JzLkludGVyc2VjdGlvbn0gVGhlIHJlc3VsdGluZyByZWxhdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBTaG9ydGN1dCB0byBjcmVhdGUgYW4gSW50ZXJzZWN0IHJlbGF0aW9uIGJhc2VkIG9uIHRoaXMgcmVsYXRpb24gYW5kIHRoZSBzcGVjaWZpZWQgb25lXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb24xID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgICAgIHtmaXJzdE5hbWUgOiB7dHlwZSA6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgICAgICAgICB7bGFzdE5hbWUgOiB7dHlwZSA6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWydKb2huJywnRG9lJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ0x1Y2lubycsJ1ZlbyddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydNYXJ5JywnUG9wcGlucyddLFxuICAgICAgICAgKiAgICAgICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbjIgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge2ZpcnN0TmFtZSA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgICAgIHtsYXN0TmFtZSA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ0pvaG4nLCdEb2UnXVxuICAgICAgICAgKiAgICAgICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBpbnRlcnNlY3Rpb24gPSByZWxhdGlvbjEuaW50ZXJzZWN0KHJlbGF0aW9uMik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBmaXJzdE5hbWUgOiBUU3RyaW5nIHwgbGFzdE5hbWUgOiBUU3RyaW5nIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IEpvaG4gICAgICAgICAgICAgICAgfCBEb2UgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICovXG4gICAgICAgIGludGVyc2VjdDogZnVuY3Rpb24gKHJlbGF0aW9uKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnJlbGF0aW9uLnRyYWNlKCcjaW50ZXJzZWN0Jyk7XG5cbiAgICAgICAgICAgIHZhciBJbnRlcnNlY3Rpb24gPSByZXF1aXJlKCcuL2FsZ2VicmEvSW50ZXJzZWN0aW9uJyk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJzZWN0aW9uKHRoaXMsIHJlbGF0aW9uKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtSZWxhdGlvbn0gcmVsYXRpb24gVGhlIHJlbGF0aW9uIHRvIGNvbXB1dGUgdGhlIGpvaW4gYWdhaW5zdFxuICAgICAgICAgKiBAcmV0dXJucyB7T3BlcmF0b3JzLkpvaW59IFRoZSByZXN1bHRpbmcgcmVsYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogU2hvcnRjdXQgdG8gY3JlYXRlIGEgSm9pbiByZWxhdGlvbiBiYXNlZCBvbiB0aGlzIHJlbGF0aW9uIGFuZCB0aGUgc3BlY2lmaWVkIG9uZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uMSA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7Zmlyc3ROYW1lIDoge3R5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICAgICAge2xhc3ROYW1lIDoge3R5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsnSm9obicsJ0RvZSddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydMdWNpbm8nLCdWZW8nXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsnTWFyeScsJ1BvcHBpbnMnXSxcbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb24yID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgICAgIHtMYXN0TmFtZSA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgICAgIHtUaXRsZSAgICA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ0RvZScsJ01yJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ1BvcHBpbnMnLCdMYWR5J11cbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgam9pbiA9IHJlbGF0aW9uMS5qb2luKHJlbGF0aW9uMik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBmaXJzdE5hbWUgOiBUU3RyaW5nIHwgbGFzdE5hbWUgOiBUU3RyaW5nIHwgVGl0bGUgOiBUU3RyaW5nIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IEpvaG4gICAgICAgICAgICAgICAgfCBEb2UgICAgICAgICAgICAgICAgfCBNciAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgTWFyeSAgICAgICAgICAgICAgICB8IFBvcHBpbnMgICAgICAgICAgICB8IExhZHkgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKi9cbiAgICAgICAgam9pbjogZnVuY3Rpb24gKHJlbGF0aW9uKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnJlbGF0aW9uLnRyYWNlKCcjam9pbicpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IChyZXF1aXJlKCcuL2FsZ2VicmEvSm9pbicpKSh0aGlzLCByZWxhdGlvbik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uIFRoZSByZWxhdGlvbiB0byBjb21wdXRlIHByb2R1Y3QgYWdhaW5zdFxuICAgICAgICAgKiBAcmV0dXJucyB7T3BlcmF0b3JzLlByb2R1Y3R9IFRoZSByZXN1bHRpbmcgcmVsYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogU2hvcnRjdXQgdG8gY3JlYXRlIGEgUHJvZHVjdCByZWxhdGlvbiBiYXNlZCBvbiB0aGlzIHJlbGF0aW9uIGFuZCB0aGUgc3BlY2lmaWVkIG9uZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uMSA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7Zmlyc3ROYW1lIDoge3R5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICAgICAge2xhc3ROYW1lIDoge3R5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsnSm9obicsJ0RvZSddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydMdWNpbm8nLCdWZW8nXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsnTWFyeScsJ1BvcHBpbnMnXSxcbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb24yID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgICAgIHt0aXRsZSA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ0xhZHknXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsnTXInXVxuICAgICAgICAgKiAgICAgICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBwcm9kdWN0ID0gcmVsYXRpb24xLnByb2R1Y3QocmVsYXRpb24yKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IGZpcnN0TmFtZSA6IFRTdHJpbmcgfCBsYXN0TmFtZSA6IFRTdHJpbmcgfCBUaXRsZSA6IFRTdHJpbmcgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgSm9obiAgICAgICAgICAgICAgICB8IERvZSAgICAgICAgICAgICAgICB8IExhZHkgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBKb2huICAgICAgICAgICAgICAgIHwgRG9lICAgICAgICAgICAgICAgIHwgTXIgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IEx1Y2lubyAgICAgICAgICAgICAgfCBWZW8gICAgICAgICAgICAgICAgfCBMYWR5ICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgTHVjaW5vICAgICAgICAgICAgICB8IFZlbyAgICAgICAgICAgICAgICB8IE1yICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBNYXJ5ICAgICAgICAgICAgICAgIHwgUG9wcGlucyAgICAgICAgICAgIHwgTGFkeSAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IE1hcnkgICAgICAgICAgICAgICAgfCBQb3BwaW5zICAgICAgICAgICAgfCBNciAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICovXG4gICAgICAgIHByb2R1Y3Q6IGZ1bmN0aW9uIChyZWxhdGlvbikge1xuXG4gICAgICAgICAgICBkZWJ1Zy5yZWxhdGlvbi50cmFjZSgnI3Byb2R1Y3QnKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyAocmVxdWlyZSgnLi9hbGdlYnJhL1Byb2R1Y3QnKSkodGhpcywgcmVsYXRpb24pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBhdHRyaWJ1dGVOYW1lcyBUaGUgcmVsYXRpb24gdG8gY29tcHV0ZSBpbnRlcnNlY3Rpb24gYWdhaW5zdFxuICAgICAgICAgKiBAcmV0dXJucyB7T3BlcmF0b3JzLlByb2plY3Rpb259IFRoZSByZXN1bHRpbmcgcmVsYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogU2hvcnRjdXQgdG8gY3JlYXRlIGEgUHJvamVjdCByZWxhdGlvbiBiYXNlZCBvbiB0aGlzIHJlbGF0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBhdHRyaWJ1dGVOYW1lcyBwYXJhbWV0ZXIgbXVzdCBiZSBpbiB0aGUgZm9ybWF0IDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHJlbGF0aW9uLnByb2plY3QoWydhcmd1bWVudDEnLCAnYXJndW1lbnQyJ10pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uMSA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7Zmlyc3ROYW1lIDoge3R5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICAgICAge2xhc3ROYW1lIDoge3R5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsnSm9obicsJ0RvZSddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydMdWNpbm8nLCdWZW8nXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsnTWFyeScsJ1BvcHBpbnMnXSxcbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgaW50ZXJzZWN0aW9uID0gcmVsYXRpb24xLnByb2plY3QoWydmaXJzdE5hbWUnXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBmaXJzdE5hbWUgOiBUU3RyaW5nIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IEpvaG4gICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgTHVjaW5vICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBNYXJ5ICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0OiBmdW5jdGlvbiAoYXR0cmlidXRlTmFtZXMpIHtcblxuICAgICAgICAgICAgZGVidWcucmVsYXRpb24udHJhY2UoJyNwcm9qZWN0Jyk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgKHJlcXVpcmUoJy4vYWxnZWJyYS9Qcm9qZWN0aW9uJykpKHRoaXMsIGF0dHJpYnV0ZU5hbWVzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5ld05hbWVzIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuZXcgYXR0cmlidXRlIG5hbWVzLlxuICAgICAgICAgKiBAcmV0dXJucyB7T3BlcmF0b3JzLlJlbmFtZX0gVGhlIHJlc3VsdGluZyByZWxhdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBTaG9ydGN1dCB0byBjcmVhdGUgYSBSZW5hbWUgcmVsYXRpb24gYmFzZWQgb24gdGhpcyByZWxhdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uMSA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7Zmlyc3ROYW1lIDoge3R5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICAgICAge2xhc3ROYW1lIDoge3R5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsnSm9obicsJ0RvZSddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydMdWNpbm8nLCdWZW8nXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsnTWFyeScsJ1BvcHBpbnMnXSxcbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVuYW1lID0gcmVsYXRpb24xLnJlbmFtZSh7bGFzdE5hbWUgOiAnQm9vZ2llJ30pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgZmlyc3ROYW1lIDogVFN0cmluZyB8IEJvb2dpZSA6IFRTdHJpbmcgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBKb2huICAgICAgICAgICAgICAgIHwgRG9lICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IEx1Y2lubyAgICAgICAgICAgICAgfCBWZW8gICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgTWFyeSAgICAgICAgICAgICAgICB8IFBvcHBpbnMgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKi9cbiAgICAgICAgcmVuYW1lOiBmdW5jdGlvbiAobmV3TmFtZXMpIHtcblxuICAgICAgICAgICAgZGVidWcucmVsYXRpb24udHJhY2UoJyNyZW5hbWUnKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyAocmVxdWlyZSgnLi9hbGdlYnJhL1JlbmFtZScpKSh0aGlzLCBuZXdOYW1lcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIHRlc3QgdGhlIHR1cGxlcyBhZ2FpbnN0XG4gICAgICAgICAqIEByZXR1cm5zIHtPcGVyYXRvcnMuUmVzdHJpY3Rpb259IFRoZSByZXN1bHRpbmcgcmVsYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogU2hvcnRjdXQgdG8gY3JlYXRlIGEgUmVzdHJpY3QgcmVsYXRpb24gYmFzZWQgb24gdGhpcyByZWxhdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgICAgIHtmaXJzdE5hbWUgOiB7dHlwZSA6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgICAgICAgICB7bGFzdE5hbWUgOiB7dHlwZSA6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWydKb2huJywnRG9lJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ0x1Y2lubycsJ1ZlbyddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydNYXJ5JywnUG9wcGlucyddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydSb2JlcnQnLCdSb2JlcnQnXVxuICAgICAgICAgKiAgICAgICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIE11bHRpcGxlIHdheXMgdG8gYnVpbGQgYSBwcmVkaWNhdGU6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBDb21wYXJlIHdpdGggc3RhdGljIHZhbHVlXG4gICAgICAgICAqICAgICByZWxhdGlvbi5yZXN0cmljdChyZWxhdGlvbi5nZXQoJ2ZpcnN0TmFtZScpLmVxdWFsKCdKb2huJykpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgZmlyc3ROYW1lIDogVFN0cmluZyB8IEJvb2dpZSA6IFRTdHJpbmcgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBKb2huICAgICAgICAgICAgICAgIHwgRG9lICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBDb21wYXJlIHR3byBhdHRyaWJ1dGVzXG4gICAgICAgICAqICAgICByZWxhdGlvbi5yZXN0cmljdChyZWxhdGlvbi5nZXQoJ2ZpcnN0TmFtZScpLmVxdWFsKHJlbGF0aW9uLmdldCgnbGFzdE5hbWUnKSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBmaXJzdE5hbWUgOiBUU3RyaW5nIHwgQm9vZ2llIDogVFN0cmluZyAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IFJvYmVydCAgICAgICAgICAgICAgfCBSb2JlcnQgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIENvbWJpbmUgd2l0aCBhbmQsIG9yLCBub3RcbiAgICAgICAgICogICAgIHJlbGF0aW9uLnJlc3RyaWN0KCAocmVsYXRpb24uZ2V0KCdmaXJzdE5hbWUnKS5ub3QoKS5lcXVhbCgnSm9obicpKSAuYW5kKCByZWxhdGlvbi5nZXQoJ2xhc3ROYW1lJykubm90KCkuZXF1YWwoJ1ZlbycpICkgKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgZmlyc3ROYW1lIDogVFN0cmluZyB8IEJvb2dpZSA6IFRTdHJpbmcgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBNYXJ5ICAgICAgICAgICAgICAgIHwgUG9wcGlucyAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IFJvYmVydCAgICAgICAgICAgICAgfCBSb2JlcnQgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICovXG4gICAgICAgIHJlc3RyaWN0OiBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnJlbGF0aW9uLnRyYWNlKCcjcmVzdHJpY3QnKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyAocmVxdWlyZSgnLi9hbGdlYnJhL1Jlc3RyaWN0aW9uJykpKHRoaXMsIHByZWRpY2F0ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3J0Y3V0IHRvIGNyZWF0ZSBhIFVuaW9uIHJlbGF0aW9uIGJhc2VkIG9uIHRoaXMgcmVsYXRpb24gYW5kIHRoZSBzcGVjaWZpZWQgb25lXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uIFRoZSByZWxhdGlvbiB0byBwZXJmb3JtIFVuaW9uIHdpdGhcbiAgICAgICAgICogQHJldHVybnMge09wZXJhdG9ycy5Vbmlvbn0gVGhlIHJlc3VsdGluZyByZWxhdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdW5pb246IGZ1bmN0aW9uIChyZWxhdGlvbikge1xuXG4gICAgICAgICAgICBkZWJ1Zy5yZWxhdGlvbi50cmFjZSgnI3VuaW9uJyk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgKHJlcXVpcmUoJy4vYWxnZWJyYS9VbmlvbicpKSh0aGlzLCByZWxhdGlvbik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHtPcGVyYXRvcnMuQ29tcG9zaXRpb259IFRoZSByZXN1bHRpbmcgcmVsYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIGNvbXBvc2U6IGZ1bmN0aW9uIChyZWxhdGlvbikge1xuXG4gICAgICAgICAgICBkZWJ1Zy5yZWxhdGlvbi50cmFjZSgnI2NvbXBvc2UnKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyAocmVxdWlyZSgnLi9hbGdlYnJhL0NvbXBvc2l0aW9uJykpKHRoaXMsIHJlbGF0aW9uKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBpbmdBdHRyaWJ1dGVOYW1lXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGdyb3VwZWRBdHRyaWJ1dGVOYW1lc1xuICAgICAgICAgKiBAcmV0dXJuIHtPcGVyYXRvcnMuR3JvdXB9XG4gICAgICAgICAqL1xuICAgICAgICBncm91cDogZnVuY3Rpb24gKGdyb3VwaW5nQXR0cmlidXRlTmFtZSwgZ3JvdXBlZEF0dHJpYnV0ZU5hbWVzKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnJlbGF0aW9uLnRyYWNlKCcjZ3JvdXAnKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyAocmVxdWlyZSgnLi9hbGdlYnJhL0dyb3VwJykpKHRoaXMsIGdyb3VwaW5nQXR0cmlidXRlTmFtZSwgZ3JvdXBlZEF0dHJpYnV0ZU5hbWVzKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBncm91cGVkQXR0cmlidXRlTmFtZXNcbiAgICAgICAgICogQHJldHVybnMge09wZXJhdG9ycy5Vbmdyb3VwfVxuICAgICAgICAgKi9cbiAgICAgICAgdW5ncm91cDogZnVuY3Rpb24gKGdyb3VwZWRBdHRyaWJ1dGVOYW1lcykge1xuXG4gICAgICAgICAgICBkZWJ1Zy5yZWxhdGlvbi50cmFjZSgnI3VuZ3JvdXAnKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyAocmVxdWlyZSgnLi9hbGdlYnJhL1VuZ3JvdXAnKSkodGhpcywgZ3JvdXBlZEF0dHJpYnV0ZU5hbWVzKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZW1pRGlmZmVyZW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7T3BlcmF0b3JzLlNlbWlEaWZmZXJlbmNlfSBUaGUgcmVzdWx0aW5nIHJlbGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSByZWxhdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgc2RpZmZlcmVuY2U6IGZ1bmN0aW9uIChyZWxhdGlvbikge1xuXG4gICAgICAgICAgICBkZWJ1Zy5yZWxhdGlvbi50cmFjZSgnI3NkaWZmZXJlbmNlJyk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgKHJlcXVpcmUoJy4vYWxnZWJyYS9TZW1pZGlmZmVyZW5jZScpKSh0aGlzLCByZWxhdGlvbik7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2VtaUpvaW5cbiAgICAgICAgICogQHJldHVybnMge09wZXJhdG9ycy5TZW1pSm9pbn0gVGhlIFJlc3VsdGluZyBSZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0gcmVsYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHNqb2luOiBmdW5jdGlvbiAocmVsYXRpb24pIHtcblxuICAgICAgICAgICAgZGVidWcucmVsYXRpb24udHJhY2UoJyNzam9pbicpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IChyZXF1aXJlKCcuL2FsZ2VicmEvU2VtaWpvaW4nKSkodGhpcywgcmVsYXRpb24pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3J0Y3V0IHRvIGV4ZWN1dGUgYSBXcmFwIG9wZXJhdGlvblxuICAgICAgICAgKiBAcGFyYW0gd3JhcHBpbmdBdHRyaWJ1dGVOYW1lIFRoZSBuYW1lIG9mIHRoZSBuZXcgd3JhcHBpbmcgYXR0cmlidXRlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHdyYXBwZWRBdHRyaWJ1dGVzIFRoZSBhdHRyaWJ1dGUgbmFtZXMgdG8gYmUgd3JhcHBlZFxuICAgICAgICAgKiBAcmV0dXJucyB7T3BlcmF0b3JzLldyYXB9IFRoZSByZXN1bHRpbmcgcmVsYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHdyYXA6IGZ1bmN0aW9uICh3cmFwcGluZ0F0dHJpYnV0ZU5hbWUsIHdyYXBwZWRBdHRyaWJ1dGVzKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnJlbGF0aW9uLnRyYWNlKCcjd3JhcCcpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IChyZXF1aXJlKCcuL2FsZ2VicmEvV3JhcCcpKSh0aGlzLCB3cmFwcGluZ0F0dHJpYnV0ZU5hbWUsIHdyYXBwZWRBdHRyaWJ1dGVzKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG9ydGN1dCB0byBleGVjdXRlIGFuIFVud3JhcCBvcGVyYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gd3JhcHBlZEF0dHJpYnV0ZU5hbWVzIFRoZSBuYW1lcyBvZiB0aGUgd3JhcHBlZCBhdHRyaWJ1dGVzIHRvIHVud3JhcFxuICAgICAgICAgKiBAcmV0dXJucyB7T3BlcmF0b3JzLlVud3JhcH0gVGhlIHJlc3VsdGluZyByZWxhdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdW53cmFwOiBmdW5jdGlvbiAod3JhcHBlZEF0dHJpYnV0ZU5hbWVzKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnJlbGF0aW9uLnRyYWNlKCcjdW53cmFwJyk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgKHJlcXVpcmUoJy4vYWxnZWJyYS9VbndyYXAnKSkodGhpcywgd3JhcHBlZEF0dHJpYnV0ZU5hbWVzKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG9ydGN1dCB0byBjcmVhdGUgYW4gRXh0ZW5kIG9wZXJhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBleHByZXNzaW9ucyBUaGUgZXhwcmVzc2lvbnMgdG8gZXZhbHVhdGVcbiAgICAgICAgICogQHJldHVybnMge09wZXJhdG9ycy5FeHRlbnNpb259IFRoZSByZXN1bHRpbmcgcmVsYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIGV4dGVuZDogZnVuY3Rpb24gKGV4cHJlc3Npb25zKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnJlbGF0aW9uLnRyYWNlKCcjZXh0ZW5kJyk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgKHJlcXVpcmUoJy4vYWxnZWJyYS9FeHRlbnNpb24nKSkodGhpcywgZXhwcmVzc2lvbnMpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3J0Y3V0IHRvIHRoZSBTdW1tYXJpemUgb3BlcmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW118QXR0cmlidXRlW119IGF0dHJpYnV0ZXMgVGhlIGF0dHJpYnV0ZXMgdG8gc3VtbWFyaXplXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdW1tYXJpZXMgU3VtbWFyeSBleHByZXNzaW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgc3VtbWFyaXplIDogZnVuY3Rpb24oYXR0cmlidXRlcywgc3VtbWFyaWVzKXtcbiAgICAgICAgICAgIGRlYnVnLnJlbGF0aW9uLnRyYWNlKCcjc3VtbWFyaXplJyk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgKHJlcXVpcmUoJy4vYWxnZWJyYS9TdW1tYXJpemUnKSkodGhpcywgYXR0cmlidXRlcywgc3VtbWFyaWVzKTtcblxuICAgICAgICB9LFxuXG5cbiAgICAgICAgLy9lbmRyZWdpb25cblxuICAgICAgICAvL3JlZ2lvbiBBZ2dyZWdhdGVzXG5cbiAgICAgICAgYWxsIDogZnVuY3Rpb24ocHJlZGljYXRlKXtcblxuICAgICAgICAgICAgdmFyIEFsbCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2FnZ3JlZ2F0ZS9BbGwuanMnKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGwodGhpcywgcHJlZGljYXRlKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGFueSA6IGZ1bmN0aW9uKHByZWRpY2F0ZSl7XG5cbiAgICAgICAgICAgIHZhciBBbnkgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9hZ2dyZWdhdGUvQW55LmpzJyk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgQW55KHRoaXMsIHByZWRpY2F0ZSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBjb3VudCA6IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgIHZhciBDb3VudCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2FnZ3JlZ2F0ZS9Db3VudC5qcycpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvdW50KHRoaXMpO1xuXG4gICAgICAgIH1cbiAgICAgICAgLy9lbmRyZWdpb25cblxuICAgIH0sIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBSZWxhdGlvbiB0eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG5cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnUmVsYXRpb24nXG4gICAgICAgIH0sXG5cbiAgICAgICAgdHlwZTogJ1JlbGF0aW9uJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdHMgZm9yIGVxdWFsaXR5IGJldHdlZW4gdHdvIHJlbGF0aW9uc1xuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWwxXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbDJcblxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgZXF1YWw6IGZ1bmN0aW9uIChyZWwxLCByZWwyKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnJlbGF0aW9uLnRyYWNlKCdSZWxhdGlvbi5lcXVhbCcpO1xuXG4gICAgICAgICAgICBpZiAoIXJlbDEuaGVhZGVyKCkuZXF1YWwocmVsMi5oZWFkZXIoKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbDEuY29tcHV0ZSgpO1xuICAgICAgICAgICAgcmVsMi5jb21wdXRlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBTZXQuZXF1YWwocmVsMSwgcmVsMik7XG5cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBSZWxhdGlvbjtcbiIsInZhciBUeXBlID0gcmVxdWlyZSgnLi9UeXBlLmpzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIGNvZXJjZSA9IHJlcXVpcmUoJy4vaGVscGVycy9jb2VyY2UnKTtcbnZhciBlcXVhbCA9IHJlcXVpcmUoJy4vaGVscGVycy9lcXVhbCcpO1xudmFyIGNsb25lID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Nsb25lJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRlbWl0dGVyMycpLkV2ZW50RW1pdHRlcjM7XG52YXIgZGVidWcgPSByZXF1aXJlKCcuL2hlbHBlcnMvZGVidWcuanMnKTtcblxuXG52YXIgU2V0ID0gVHlwZS5leHRlbmQoXG5cbiAgICB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgU2V0XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnc10gQ29uc3RydWN0b3IgYXJndW1lbnRzXG4gICAgICAgICAqIEBwYXJhbSB7VHlwZX0gW2FyZ3MudHlwZV0gVHlwZSBvZiB0aGUgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZSBzZXRcbiAgICAgICAgICogQGV4dGVuZHMgVHlwZVxuICAgICAgICAgKiBBIFNldCBpcyBhbiB1bm9yZGVyZWQgY29sbGVjdGlvbiBvZiBkaXN0aW5jdCBvYmplY3RzIChubyBkdXBsaWNhdGVzKS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoYXJncykge1xuXG4gICAgICAgICAgICBkZWJ1Zy5zZXQudHJhY2UoJyNjb25zdHJ1Y3RvcicpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7RXZlbnRFbWl0dGVyfSBlZVxuICAgICAgICAgICAgICogQGV4dGVybmFsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZWUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAgICAgICAgIHRoaXMuZWUuc2V0TWF4TGlzdGVuZXJzKDApO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7VHlwZX0gX3R5cGVcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX3R5cGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IF9lbGVtZW50c1xuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudHMgPSBbXTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gX2RlbGV0ZWRDb3VudFxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fZGVsZXRlZENvdW50ID0gMDtcblxuXG4gICAgICAgICAgICAvLyBDYWxsIGJpbmRFdmVudHMgaWYgaXMgZGVmaW5lZFxuXG4gICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHRoaXMuYmluZEV2ZW50cykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFyZ3MpIHtcblxuICAgICAgICAgICAgICAgIGlmIChhcmdzLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlKGFyZ3MudHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MuZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50cyhhcmdzLmVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuXG5cbiAgICAgICAgICAgIC8vIENhbGwgcGFyZW50IGNvbnN0cnVjdG9yXG5cbiAgICAgICAgICAgIFR5cGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGJpbmRFdmVudHMgOiBmdW5jdGlvbigpe1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtTZXR9XG4gICAgICAgICAqXG4gICAgICAgICAqIENsb25lcyBhIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgZGVidWcuc2V0LnRyYWNlKCcjY2xvbmUnKTtcblxuICAgICAgICAgICAgdmFyIG5ld1NldCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHt0eXBlIDogdGhpcy50eXBlKCl9KTtcblxuICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgbmV3U2V0LmFkZChlbGVtZW50LCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ld1NldDtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXN0cm95cyB0aGUgc2V0XG4gICAgICAgICAqL1xuICAgICAgICBkZXN0cm95IDogZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgLy8gRGVsZXRlcyB0aGUgZWxlbWVudHNcbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihlbGVtZW50LCBpbmRleCl7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUF0KGluZGV4KTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIERlbGV0ZXMgdGhlIGV2ZW50IGVtaXR0ZXJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmVlO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZWxlbWVudHMgb2YgdGhlIHNldFxuICAgICAgICAgKiBAcGFyYW0ge1NldH0gW2VsZW1lbnRzXSBlbGVtZW50cyBvZiB0aGUgc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8bnVsbHxBcnJheX1cbiAgICAgICAgICogQHRocm93cyBXaWxsIHRocm93IGlmIHRoZSB0eXBlIG9mIHRoZSBTZXQgaGFzIG5vdCBiZWVuIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZWxlbWVudHM6IGZ1bmN0aW9uIChlbGVtZW50cykge1xuXG4gICAgICAgICAgICBkZWJ1Zy5zZXQudHJhY2UoJyNlbGVtZW50cycpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy50eXBlKCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgZGVmaW5lIHRoZSB0eXBlIG9mIHRoZSBzZXQgZmlyc3QnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIV8uaXNBcnJheShlbGVtZW50cykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZWxlbWVudHMgbXVzdCBiZSBpbiBhcnJheSBmb3JtYXQnKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZWUuZW1pdCgnYmVmb3JlU2V0RWxlbWVudHMnLCBlbGVtZW50cyk7XG5cbiAgICAgICAgICAgICAgICBfLmZvckVhY2goZWxlbWVudHMsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQoZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZWUuZW1pdCgnYWZ0ZXJTZXRFbGVtZW50cycsIGVsZW1lbnRzKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuZWUuZW1pdCgnYmVmb3JlR2V0RWxlbWVudHMnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge1R5cGV9IFt0eXBlXSBUaGUgdHlwZSBvZiB0aGUgU2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtudWxsfFR5cGV9XG4gICAgICAgICAqXG4gICAgICAgICAqIEdldHRlci9TZXR0ZXIgZm9yIHRoZSB0eXBlIHBhcmFtZXRlci4gV2hlbiB1c2VkIHdpdGhvdXQgcGFyYW1ldGVyLCB3aWxsIHJldHVyblxuICAgICAgICAgKiB0aGUgdHlwZSBvZiB0aGUgU2V0LiBXaGVuIHVzZWQgd2l0aCBhIHBhcmFtZXRlciwgd2lsbCBzZXQgdGhlIHNldCdzIHR5cGUuXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiBmdW5jdGlvbiAodHlwZSkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5zZXQudHJhY2UoJyN0eXBlJyk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIFRoZSBcInRoaXNcIiBjb250ZXh0IGZvciB0aGUgY2FsbGJhY2tcbiAgICAgICAgICpcbiAgICAgICAgICogSXRlcmF0b3IgZnVuY3Rpb24uIE9ubHkgYW4gYWxpYXMgZm9yIGxvZGFzaCBfLmZvckVhY2hcbiAgICAgICAgICovXG4gICAgICAgIGVhY2g6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5zZXQudHJhY2UoJyNlYWNoJyk7XG5cbiAgICAgICAgICAgIF8uZm9yRWFjaCh0aGlzLmVsZW1lbnRzKCksIGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KXtcblxuICAgICAgICAgICAgICAgIGlmKGVsZW1lbnQgIT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgICAgIGlmKGNhbGxiYWNrLmNhbGwoY29udGV4dCwgZWxlbWVudCwgaW5kZXgpID09PSBmYWxzZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIFRoZSBcInRoaXNcIiBjb250ZXh0IGZvciB0aGUgY2FsbGJhY2tcbiAgICAgICAgICpcbiAgICAgICAgICogSXRlcmF0b3IgZnVuY3Rpb24uIE9ubHkgYW4gYWxpYXMgZm9yIGxvZGFzaCBfLmFueVxuICAgICAgICAgKi9cbiAgICAgICAgYW55IDogZnVuY3Rpb24oY2FsbGJhY2ssIGNvbnRleHQpe1xuXG4gICAgICAgICAgICBkZWJ1Zy5zZXQudHJhY2UoJyNhbnknKTtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBfLmFueSh0aGlzLmVsZW1lbnRzKCksIGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KXtcblxuICAgICAgICAgICAgICAgcmV0dXJuIChlbGVtZW50ICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2suY2FsbChjb250ZXh0LCBlbGVtZW50LCBpbmRleCkpO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0geyp9IGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbY2hlY2tEdXBsaWNhdGU9dHJ1ZV0gVGVzdHMgZm9yIGR1cGxpY2F0ZSBlbGVtZW50cyBpbiB0aGUgc2V0LiBTZXQgdG8gZmFsc2UgdG8gc2tpcCB0aGlzXG4gICAgICAgICAqIHZlcmlmaWNhdGlvbiBpZiB5b3UgYXJlIHN1cmUgdGhlIGVsZW1lbnQgaXMgbm90IGluIHRoZSBzZXRcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGVsZW1lbnQgd2FzIGFkZGVkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgICAgICpcbiAgICAgICAgICogRGlyZWN0bHkgYWRkIGFuIGVsZW1lbnQgdG8gdGhlIHNldC5cbiAgICAgICAgICovXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKGVsZW1lbnQsIGNoZWNrRHVwbGljYXRlKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnNldC50cmFjZSgnI2FkZCcpO1xuXG4gICAgICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZChjaGVja0R1cGxpY2F0ZSkpIHtcbiAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG5cbiAgICAgICAgICAgICAgICBkZWJ1Zy5zZXQudHJhY2UoJyNhZGQgY29lcmNpbmcgZWxlbWVudCcpO1xuXG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGNvZXJjZSh0aGlzLnR5cGUoKSwgZWxlbWVudCwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoKGNoZWNrRHVwbGljYXRlICYmICF0aGlzLmV4aXN0cyhlbGVtZW50KSkgfHwgIWNoZWNrRHVwbGljYXRlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZS5lbWl0KCdiZWZvcmVBZGQnLCBlbGVtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3SW5kZXggPSB0aGlzLmVsZW1lbnRzKCkucHVzaChlbGVtZW50KSAtIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZS5lbWl0KCdhZnRlckFkZCcsIGVsZW1lbnQsIG5ld0luZGV4KTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0geyp9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gcmVtb3ZlXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGVsZW1lbnQgd2FzIHJlbW92ZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAgICAgKlxuICAgICAgICAgKiBSZW1vdmVzIGFuIGVsZW1lbnQgZnJvbSB0aGUgc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5zZXQudHJhY2UoJyNyZW1vdmUnKTtcblxuICAgICAgICAgICAgZWxlbWVudCA9IGNvZXJjZSh0aGlzLnR5cGUoKSwgZWxlbWVudCk7XG5cbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgoZWxlbWVudCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUF0KGluZGV4KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IGF0IHdoaWNoIHRvIHJlbW92ZSB0aGUgZWxlbWVudFxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiBkZWxldGVkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgICAgICpcbiAgICAgICAgICogUmVtb3ZlcyBhbiBlbGVtZW50IGZyb20gdGhlIHNldCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQXQ6IGZ1bmN0aW9uIChpbmRleCkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5zZXQudHJhY2UoJyNyZW1vdmVBdCcpO1xuXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuYXRJbmRleChpbmRleCk7XG5cbiAgICAgICAgICAgIGlmKGVsZW1lbnQgPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmVlLmVtaXQoJ2JlZm9yZVJlbW92ZScsIGVsZW1lbnQsIGluZGV4KTtcblxuICAgICAgICAgICAgdGhpcy5lbGVtZW50cygpW2luZGV4XSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgdGhpcy5fZGVsZXRlZENvdW50Kys7XG5cbiAgICAgICAgICAgIHRoaXMuZWUuZW1pdCgnYWZ0ZXJSZW1vdmUnLCBlbGVtZW50LCBpbmRleCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtudWxsfCp9IFRoZSBmaXJzdCBlbGVtZW50IG9yIG51bGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEdldHMgdGhlIGZpcnN0IGVsZW1lbnQgZnJvbSB0aGUgc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgZmlyc3QgOiBmdW5jdGlvbigpe1xuXG4gICAgICAgICAgICBkZWJ1Zy5zZXQudHJhY2UoJyNmaXJzdCcpO1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gXy5maW5kKHRoaXMuZWxlbWVudHMoKSwgZnVuY3Rpb24oZWxlbWVudCl7XG5cbiAgICAgICAgICAgICAgICBpZighXy5pc1VuZGVmaW5lZChlbGVtZW50KSl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmKF8uaXNVbmRlZmluZWQocmVzdWx0KSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHsqfSBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge251bWJlcnxudWxsfSBJbmRleCBvZiBvYmplY3QgaWYgZm91bmQsIG51bGwgb3RoZXJ3aXNlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEZpbmQgdGhlIGluZGV4IG9mIGFuIGVsZW1lbnQgd2l0aCBkZWZpbmVkIHR5cGUgZXF1YWxpdHkgbWV0aG9kc1xuICAgICAgICAgKi9cbiAgICAgICAgX2luZGV4QnlFcXVhbGl0eTogZnVuY3Rpb24gKG9iamVjdCkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5zZXQudHJhY2UoJyNpbmRleEJ5RXF1YWxpdHknKTtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoZWxlbWVudCwga2V5KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXF1YWwodGhpcy50eXBlKCksIGVsZW1lbnQsIG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBzZWFyY2ggZm9yXG4gICAgICAgICAqIEByZXR1cm5zIHtudWxsfG51bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IGlmIGZvdW5kLCBudWxsIG90aGVyd2lzZVxuICAgICAgICAgKlxuICAgICAgICAgKiBHZXRzIHRoZSBpbmRleCBvZiBhbiBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBpbmRleDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcblxuICAgICAgICAgICAgZGVidWcuc2V0LnRyYWNlKCcjaW5kZXgnKTtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG5cbiAgICAgICAgICAgIGVsZW1lbnQgPSBjb2VyY2UodGhpcy50eXBlKCksIGVsZW1lbnQpO1xuXG4gICAgICAgICAgICBpZih0aGlzLl9pbmRleCl7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5faW5kZXgoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbmRleEJ5RXF1YWxpdHkoZWxlbWVudCk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnRcbiAgICAgICAgICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgYXRJbmRleDogZnVuY3Rpb24gKGluZGV4KSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnNldC50cmFjZSgnI2F0SW5kZXgnKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMoKVtpbmRleF07XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHsqfSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGZpbmRcbiAgICAgICAgICogQHJldHVybnMge251bGx8Kn0gdGhlIHJlc3VsdGluZyBlbGVtZW50IG9yIG51bGwgaWYgbm90IGZvdW5kXG4gICAgICAgICAqXG4gICAgICAgICAqIEZpbmRzIGFuIGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnNldC50cmFjZSgnI2ZpbmQnKTtcblxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleChlbGVtZW50KTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXRJbmRleChpbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBjaGVjayBmb3JcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGVsZW1lbnQgZXhpc3RzLCBmYWxzZSBpZiBub3RcbiAgICAgICAgICpcbiAgICAgICAgICogQ2hlY2tzIGlmIGFuIGVsZW1lbnQgZXhpc3RzIGluIHRoZSBzZXQuXG4gICAgICAgICAqL1xuICAgICAgICBleGlzdHM6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnNldC50cmFjZSgnI2V4aXN0cycpO1xuXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuaW5kZXgoZWxlbWVudCkgIT09IG51bGwpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgc2V0XG4gICAgICAgICAqL1xuICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgZGVidWcuc2V0LnRyYWNlKCcjbGVuZ3RoJyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzKCkubGVuZ3RoLXRoaXMuX2RlbGV0ZWRDb3VudDtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge1NldH0gc2V0MiBUaGUgc2V0IHRvIHBlcmZvcm0gdW5pb24gd2l0aFxuICAgICAgICAgKiBAcmV0dXJucyB7U2V0fSBUaGUgcmVzdWx0aW5nIHNldFxuICAgICAgICAgKlxuICAgICAgICAgKiBVbmlvbiBvZiB0d28gc2V0cy4gUmV0dXJucyBhIHNldCBjb250YWluaW5nIGFsbCB0aGUgZWxlbWVudHMgZnJvbSBBIGFuZCBCLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHNldDEgPSBuZXcgYWZmaW5pdHkuU2V0KGFmZmluaXR5LkludGVnZXIsIFsxLCAyLCAzXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgc2V0MiA9IG5ldyBhZmZpbml0eS5TZXQoYWZmaW5pdHkuSW50ZWdlciwgWzMsIDQsIDVdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZXN1bHQgPSBzZXQxLnNldFVuaW9uKHNldDIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gU2V0IGhhcyBlbGVtZW50cyBbMSwgMiwgMywgNCwgNV0gKG5vdGUgbm8gZHVwbGljYXRlcylcbiAgICAgICAgICovXG4gICAgICAgIHNldFVuaW9uOiBmdW5jdGlvbiAoc2V0Mikge1xuXG4gICAgICAgICAgICBkZWJ1Zy5zZXQudHJhY2UoJyN1bmlvbicpO1xuXG4gICAgICAgICAgICB2YXIgdGhpc1R5cGUgPSB0aGlzLnR5cGUoKTtcbiAgICAgICAgICAgIHZhciBvdGhlclR5cGUgPSBzZXQyLnR5cGUoKTtcblxuICAgICAgICAgICAgdmFyIHR5cGUgPSAodGhpc1R5cGUgPT09IG90aGVyVHlwZSkgPyB0aGlzVHlwZSA6IG51bGw7XG5cbiAgICAgICAgICAgIHZhciBuZXdTZXQgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXG4gICAgICAgICAgICBuZXdTZXQudHlwZSh0eXBlKTtcblxuICAgICAgICAgICAgXy5mb3JFYWNoKFt0aGlzLCBzZXQyXSwgZnVuY3Rpb24gKGFTZXQpIHtcblxuICAgICAgICAgICAgICAgIGFTZXQuZWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTZXQuYWRkKGNsb25lKGVsZW1lbnQpKTtcbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ld1NldDtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1NldH0gc2V0MiBUaGUgc2V0IGFjdGluZyBhcyBhIHBhc3RyeSBjdXR0ZXJcbiAgICAgICAgICogQHJldHVybnMge1NldH1cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIFBlcmZvcm0gYSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIHNldHMuIFJldHVybnMgYSBzZXQgd2l0aCB0aGUgZWxlbWVudHMgb2YgQSB3aXRob3V0XG4gICAgICAgICAqICAgICB0aG9zZSB0aGF0IEEgYW5kIEIgaGF2ZSBpbiBjb21tb24uXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgdmFyIHNldDEgPSBuZXcgYWZmaW5pdHkuU2V0KGFmZmluaXR5LkludGVnZXIsIFsxLCAyLCAzXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgdmFyIHNldDIgPSBuZXcgYWZmaW5pdHkuU2V0KGFmZmluaXR5LkludGVnZXIsIFszLCA0LCA1XSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgdmFyIHJlc3VsdCA9IHNldDEuc2V0RGlmZmVyZW5jZShzZXQyKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAgICAvLyBTZXQgaGFzIGVsZW1lbnRzIFsxLCAyXVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0RGlmZmVyZW5jZTogZnVuY3Rpb24gKHNldDIpIHtcblxuICAgICAgICAgICAgZGVidWcuc2V0LnRyYWNlKCcjZGlmZmVyZW5jZScpO1xuXG4gICAgICAgICAgICB2YXIgbmV3U2V0ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKTtcbiAgICAgICAgICAgIG5ld1NldC50eXBlKHRoaXMudHlwZSgpKTtcblxuICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cbiAgICAgICAgICAgICAgICBpZighc2V0Mi5leGlzdHMoZWxlbWVudCkpe1xuICAgICAgICAgICAgICAgICAgICBuZXdTZXQuYWRkKGNsb25lKGVsZW1lbnQpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ld1NldDtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1NldH0gc2V0MiBUaGUgc2V0IHRvIHBlcmZvcm0gcHJvZHVjdCB3aXRoXG4gICAgICAgICAqIEByZXR1cm5zIHtTZXR9XG4gICAgICAgICAqXG4gICAgICAgICAqIFBlcmZvcm1zIGEgcHJvZHVjdCBvZiB0d28gc2V0cy4gUmV0dXJucyBhIHNldCB3aXRoIGFsbCB0aGUgcG9zc2libGUgY29tYmluYXRpb25zXG4gICAgICAgICAqIG9mIGVsZW1lbnRzIGZyb20gQSBjb21iaW5lZCB3aXRoIHRob3NlIG9mIEIuIFRoaXMgb3BlcmF0aW9uIHdpbGwgcmV0dXJuIGEgc2V0IGNvbnRhaW5pbmdcbiAgICAgICAgICogdHVwbGVzIHdpdGggYXR0cmlidXRlcyB7IDAgOiBhdHRyMSwgMSA6IGF0dHIyfS4gMCBpcyB0aGUgbGVmdCBzZXQgZWxlbWVudCwgMSBpcyB0aGVcbiAgICAgICAgICogcmlnaHQgc2V0IGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgc2V0MSA9IG5ldyBhZmZpbml0eS5TZXQoYWZmaW5pdHkuSW50ZWdlciwgWzEsIDJdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBzZXQyID0gbmV3IGFmZmluaXR5LlNldChhZmZpbml0eS5JbnRlZ2VyLCBbMywgNF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlc3VsdCA9IHNldDEuc2V0UHJvZHVjdChzZXQyKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIFNldCBoYXMgZWxlbWVudHMgW1R1cGxlKDAgOiAxLCAxIDogMyksVHVwbGUoMCA6IDEsIDEgOiA0KSxUdXBsZSgwIDogMiwgMSA6IDIpLFR1cGxlKDAgOiAyLCAxIDogNCldXG4gICAgICAgICAqL1xuICAgICAgICBzZXRQcm9kdWN0OiBmdW5jdGlvbiAoc2V0Mikge1xuXG4gICAgICAgICAgICBkZWJ1Zy5zZXQudHJhY2UoJyNwcm9kdWN0Jyk7XG5cbiAgICAgICAgICAgIHZhciBUdXBsZSA9IHJlcXVpcmUoJy4vVHVwbGUuanMnKTtcblxuICAgICAgICAgICAgdmFyIG5ld1NldCA9IG5ldyBTZXQoe3R5cGU6IFR1cGxlfSk7XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoZWxlbWVudDEpIHtcblxuICAgICAgICAgICAgICAgIHNldDIuZWFjaChmdW5jdGlvbiAoZWxlbWVudDIpIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdHVwbGUgPSBuZXcgVHVwbGUoezA6IGVsZW1lbnQxLCAxOiBlbGVtZW50Mn0pO1xuICAgICAgICAgICAgICAgICAgICBuZXdTZXQuYWRkKHR1cGxlLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXdTZXQ7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTZXR9IHNldDIgVGhlIHNldCB0byBiZSBpbnRlcnNlY3RlZCB3aXRoXG4gICAgICAgICAqIEByZXR1cm5zIHtTZXR9IFRoZSByZXN1bHRpbmcgc2V0XG4gICAgICAgICAqXG4gICAgICAgICAqIFBlcmZvcm1zIGFuIGludGVyc2VjdGlvbiB3aXRoIGFub3RoZXIgc2V0LiBSZXR1cm5zIGEgc2V0IHdpdGhcbiAgICAgICAgICogdGhlIGVsZW1lbnRzIHRoYXQgQSBhbmQgQiBoYXZlIGluIGNvbW1vbi5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBzZXQxID0gbmV3IGFmZmluaXR5LlNldChhZmZpbml0eS5JbnRlZ2VyLCBbMSwgMiwgM10pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHNldDIgPSBuZXcgYWZmaW5pdHkuU2V0KGFmZmluaXR5LkludGVnZXIsIFszLCA0LCA1XSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVzdWx0ID0gc2V0MS5zZXRJbnRlcnNlY3Rpb24oc2V0Mik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBTZXQgaGFzIGVsZW1lbnRzIFszXVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0SW50ZXJzZWN0aW9uOiBmdW5jdGlvbiAoc2V0Mikge1xuXG4gICAgICAgICAgICBkZWJ1Zy5zZXQudHJhY2UoJyNpbnRlcnNlY3Rpb24nKTtcblxuICAgICAgICAgICAgdmFyIG5ld1NldCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cbiAgICAgICAgICAgIG5ld1NldC50eXBlKHRoaXMudHlwZSgpKTtcblxuICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChlbGVtZW50MSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHNldDIuZXhpc3RzKGVsZW1lbnQxKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTZXQuYWRkKGNsb25lKGVsZW1lbnQxKSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXdTZXQ7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTZXR9IHNldDIgVGhlIHNldCB0byBwZWZvcm0gc3ltbWV0cmljIGRpZmZlcmVuY2UgYWdhaW5zdFxuICAgICAgICAgKiBAcmV0dXJucyB7U2V0fSBUaGUgcmVzdWx0aW5nIHNldFxuICAgICAgICAgKlxuICAgICAgICAgKiBQZXJmb3JtcyBhIHN5bW1ldHJpYyBkaWZmZXJlbmNlLiBSZXR1cm5zIGEgc2V0IHdpdGggdGhlIGVsZW1lbnRzIHRoYXQgQVxuICAgICAgICAgKiBhbmQgQiBkbyBub3QgaGF2ZSBpbiBjb21tb24uXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgc2V0MSA9IG5ldyBhZmZpbml0eS5TZXQoYWZmaW5pdHkuSW50ZWdlciwgWzEsIDIsIDNdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBzZXQyID0gbmV3IGFmZmluaXR5LlNldChhZmZpbml0eS5JbnRlZ2VyLCBbMywgNCwgNV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlc3VsdCA9IHNldDEuc2V0U3ltbWV0cmljRGlmZmVyZW5jZShzZXQyKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIFNldCBoYXMgZWxlbWVudHMgWzEsIDIsIDQsIDVdXG4gICAgICAgICAqL1xuICAgICAgICBzZXRTeW1tZXRyaWNEaWZmZXJlbmNlOiBmdW5jdGlvbiAoc2V0Mikge1xuXG4gICAgICAgICAgICBkZWJ1Zy5zZXQudHJhY2UoJyNzeW1tZXRyaWNEaWZmZXJlbmNlJyk7XG5cbiAgICAgICAgICAgIHZhciBuZXdTZXQgPSBuZXcgKHRoaXMuY29uc3RydWN0b3IpKHt0eXBlOiB0aGlzLnR5cGUoKX0pO1xuXG4gICAgICAgICAgICB2YXIgc2V0MSA9IHRoaXM7XG5cbiAgICAgICAgICAgIHNldDEuZWFjaChmdW5jdGlvbiAoZWxlbWVudDEpIHtcblxuICAgICAgICAgICAgICAgIGlmICghc2V0Mi5leGlzdHMoZWxlbWVudDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NldC5hZGQoY2xvbmUoZWxlbWVudDEpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzZXQyLmVhY2goZnVuY3Rpb24gKGVsZW1lbnQyKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNldDEuZXhpc3RzKGVsZW1lbnQyKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTZXQuYWRkKGNsb25lKGVsZW1lbnQyKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ld1NldDtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gYVNldFxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICpcbiAgICAgICAgICogRGV0ZXJtaW5lIGlmIHRoZSBzZXQgaXMgYSBzdWJzZXQgb2YgYW5vdGhlciBzZXQuXG4gICAgICAgICAqL1xuICAgICAgICBpc1N1YnNldCA6IGZ1bmN0aW9uKGFTZXQpe1xuXG4gICAgICAgICAgICBkZWJ1Zy5zZXQudHJhY2UoJyNpc1N1YnNldCcpO1xuXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oZWxlbWVudCl7XG4gICAgICAgICAgICAgICAgaWYoIWFTZXQuZXhpc3RzKGVsZW1lbnQpKXtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGFTZXRcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqXG4gICAgICAgICAqIERldGVybWluZSBpZiB0aGUgc2V0IGlzIGEgc3VwZXJzZXQgb2YgYW5vdGhlciBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGlzU3VwZXJzZXQgOiBmdW5jdGlvbihhU2V0KXtcblxuICAgICAgICAgICAgZGVidWcuc2V0LnRyYWNlKCcjaXNTdXBlcnNldCcpO1xuXG4gICAgICAgICAgICByZXR1cm4gIWFTZXQuaXNTdWJzZXQodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBhU2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBzZXQgaXMgYSBwcm9wZXIgc3Vic2V0IG9mIGFub3RoZXIgc2V0XG4gICAgICAgICAqL1xuICAgICAgICBpc1Byb3BlclN1YnNldCA6IGZ1bmN0aW9uKGFTZXQpe1xuXG4gICAgICAgICAgICBkZWJ1Zy5zZXQudHJhY2UoJyNpc1Byb3BlclN1YnNldCcpO1xuXG4gICAgICAgICAgICBpZih0aGlzLmxlbmd0aCgpID49IGFTZXQubGVuZ3RoKCkpe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzU3Vic2V0KGFTZXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gYVNldFxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICpcbiAgICAgICAgICogRGV0ZXJtaW5lIGlmIHRoZSBzZXQgaXMgYSBwcm9wZXIgc3VwZXJzZXQgb2YgYW5vdGhlciBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGlzUHJvcGVyU3VwZXJzZXQgOiBmdW5jdGlvbihhU2V0KXtcblxuICAgICAgICAgICAgZGVidWcuc2V0LnRyYWNlKCcjaXNQcm9wZXJTdXBlcnNldCcpO1xuXG4gICAgICAgICAgICByZXR1cm4gIWFTZXQuaXNQcm9wZXJTdWJzZXQodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7U2V0fSBhbm90aGVyU2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKlxuICAgICAgICAgKiBDaGVja3MgaWYgdHdvIHNldHMgYXJlIGVxdWFsXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbDogZnVuY3Rpb24gKGFub3RoZXJTZXQpIHtcblxuICAgICAgICAgICAgZGVidWcuc2V0LnRyYWNlKCcjZXF1YWwnKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuZXF1YWwodGhpcywgYW5vdGhlclNldCk7XG5cbiAgICAgICAgfVxuXG5cblxuXG4gICAgfSwge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1NldH0gc2V0MSBUaGUgZmlyc3Qgc2V0IHRvIGNvbXBhcmVcbiAgICAgICAgICogQHBhcmFtIHtTZXR9IHNldDIgVGhlIHNlY29uZCBzZXQgdG8gY29tcGFyZVxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc2V0cyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqXG4gICAgICAgICAqIENoZWNrcyBpZiB0d28gc2V0cyBhcmUgZXF1YWxcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGVxdWFsOiBmdW5jdGlvbiAoc2V0MSwgc2V0Mikge1xuXG4gICAgICAgICAgICBkZWJ1Zy5zZXQudHJhY2UoJy5lcXVhbCcpO1xuXG4gICAgICAgICAgICB2YXIgc2V0TGVuZ3RoMSA9IHNldDEubGVuZ3RoKCksXG4gICAgICAgICAgICAgICAgc2V0TGVuZ3RoMiA9IHNldDIubGVuZ3RoKCksXG4gICAgICAgICAgICAgICAgbWlzbWF0Y2ggPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCBib3RoIHNldHMgYXJlIG9mIHRoZSBzYW1lIHR5cGVcblxuICAgICAgICAgICAgaWYgKHNldDEudHlwZSgpICYmIHNldDIudHlwZSgpICYmIChzZXQxLnR5cGUoKSAhPT0gc2V0Mi50eXBlKCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IGJvdGggc2V0cyBhcmUgb2YgdGhlIHNhbWUgbGVuZ3RoXG4gICAgICAgICAgICBpZiAoc2V0TGVuZ3RoMSAhPT0gc2V0TGVuZ3RoMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmluZCBlYWNoIHNldDEgaXRlbXMgaW4gc2V0MlxuICAgICAgICAgICAgc2V0MS5lYWNoKGZ1bmN0aW9uIChlbGVtZW50MSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4MiA9IHNldDIuaW5kZXgoZWxlbWVudDEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4MiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBtaXNtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gIW1pc21hdGNoO1xuXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDsiLCJ2YXIgVHlwZSA9IHJlcXVpcmUoJy4vVHlwZS5qcycpO1xudmFyIEhlYWRlciA9IHJlcXVpcmUoJy4vVHlwZS5qcycpO1xudmFyIFRTdHJpbmcgPSByZXF1aXJlKCcuL3R5cGVzL1N0cmluZy5qcycpO1xudmFyIEF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4vQXR0cmlidXRlLmpzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIGVxdWFsID0gcmVxdWlyZSgnLi9oZWxwZXJzL2VxdWFsJyk7XG52YXIgdmFsdWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvdmFsdWUnKTtcbnZhciBTZXQgPSByZXF1aXJlKCcuL1NldC5qcycpO1xudmFyIFR1cGxlID0gVHlwZS5leHRlbmQoXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgVHVwbGVcbiAgICAgICAgICogQHBhcmFtIGF0dHJpYnV0ZXNcbiAgICAgICAgICogQGV4dGVuZHMgVHlwZVxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoYXR0cmlidXRlcykge1xuXG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcblxuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcblxuICAgICAgICAgICAgICAgIGlmICghXy5pc09iamVjdChhdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUdXBsZSBhdHRyaWJ1dGVzIGluIHdyb25nIGZvcm1hdCcpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGE7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGEgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShhKSkgdGhpcy5zZXQoYSwgYXR0cmlidXRlc1thXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBUeXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdGVyYXRvciBmdW5jdGlvbiB0aGF0IGxvb3BzIHRocm91Z2ggZWFjaCBvZiB0aGUgdHVwbGUgYXR0cmlidXRlc1xuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBFeGVjdXRpb24gY29udGV4dCBvZiB0aGUgY2FsbGJhY2tcbiAgICAgICAgICovXG4gICAgICAgIGVhY2ggOiBmdW5jdGlvbihjYWxsYmFjaywgY29udGV4dCl7XG4gICAgICAgICAgICBfLmZvckluKHRoaXMuYXR0cmlidXRlcywgY2FsbGJhY2ssIGNvbnRleHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3BpZXMgYXR0cmlidHVlcyBmcm9tIGFub3RoZXIgdHVwbGVcbiAgICAgICAgICogQHBhcmFtIHtUdXBsZX0gdHVwbGUgVHVwbGUgdG8gY29weSBhdHRyaWJ1dGVzIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtIZWFkZXJ8QXR0cmlidXRlW118U2V0fFN0cmluZ1tdfSBbYXR0cmlidXRlc0FyZ3VtZW50PVtdXSBBdHRyaWJ1dGVzIHRvIGNvcHlcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbZXhjbHVkZT1mYWxzZV0gRG8gd2UgZXhjbHVkZSBvciBpbmNsdWRlIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzXG4gICAgICAgICAqL1xuICAgICAgICBjb3B5IDogZnVuY3Rpb24odHVwbGUsIGF0dHJpYnV0ZXNBcmd1bWVudCwgZXhjbHVkZSl7XG5cbiAgICAgICAgICAgIGlmIChleGNsdWRlICE9PSB0cnVlICYmIGV4Y2x1ZGUgIT09IGZhbHNlKXtcbiAgICAgICAgICAgICAgICBleGNsdWRlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChhdHRyaWJ1dGVzQXJndW1lbnQpICYmICFfLmlzTnVsbChhdHRyaWJ1dGVzQXJndW1lbnQpKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFNldCh7dHlwZTogVFN0cmluZ30pO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29lcmNlIHRoZSBhdHRyaWJ1dGVzIGFyZ3VtZW50IHRvIFNldCBvZiBzdHJpbmdcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlc0FyZ3VtZW50IGluc3RhbmNlb2YgSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNBcmd1bWVudC5lYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoYXR0cmlidXRlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXR0cmlidXRlc0FyZ3VtZW50IGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNBcmd1bWVudC5lYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVBcmd1bWVudCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlQXJndW1lbnQgaW5zdGFuY2VvZiBBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkKGF0dHJpYnV0ZUFyZ3VtZW50Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKGF0dHJpYnV0ZUFyZ3VtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoYXR0cmlidXRlQXJndW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfLmlzQXJyYXkoYXR0cmlidXRlc0FyZ3VtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBfLmZvckVhY2goYXR0cmlidXRlc0FyZ3VtZW50LCBmdW5jdGlvbiAoYXR0cmlidXRlQXJndW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVBcmd1bWVudCBpbnN0YW5jZW9mIEF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoYXR0cmlidXRlQXJndW1lbnQubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcoYXR0cmlidXRlQXJndW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChhdHRyaWJ1dGVBcmd1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKGF0dHJpYnV0ZXNBcmd1bWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChhdHRyaWJ1dGVzQXJndW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNBcmd1bWVudCA9IHJlc3VsdDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihhdHRyaWJ1dGVzQXJndW1lbnQgJiYgZXhjbHVkZSA9PT0gZmFsc2Upe1xuXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlc0FyZ3VtZW50LmVhY2goZnVuY3Rpb24oY29waWVkQXR0cmlidXRlKXtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldCh2YWx1ZShjb3BpZWRBdHRyaWJ1dGUpLCB0dXBsZS5nZXQodmFsdWUoY29waWVkQXR0cmlidXRlKSkpO1xuXG4gICAgICAgICAgICAgICAgfSwgdGhpcylcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIF8uZm9yRWFjaCh0dXBsZS5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAodHVwbGVBdHRyaWJ1dGUsIHR1cGxlQXR0cmlidXRlS2V5KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXNBcmd1bWVudCAmJiBleGNsdWRlID09PSB0cnVlKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzRXhjbHVkZWRBdHRyaWJ1dGUgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc0FyZ3VtZW50LmVhY2goZnVuY3Rpb24oZXhjbHVkZWRBdHRyaWJ1dGUpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVxdWFsKFRTdHJpbmcsIGV4Y2x1ZGVkQXR0cmlidXRlLCB0dXBsZUF0dHJpYnV0ZUtleSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0V4Y2x1ZGVkQXR0cmlidXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFpc0V4Y2x1ZGVkQXR0cmlidXRlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KHR1cGxlQXR0cmlidXRlS2V5LCB0dXBsZUF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KHR1cGxlQXR0cmlidXRlS2V5LCB0dXBsZUF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0sIHRoaXMpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXN0IGZvciBlcXVhbGl0eSB3aXRoIGFub3RoZXIgdHVwbGVcbiAgICAgICAgICogQHBhcmFtIHtUdXBsZX0gdHVwbGVcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbHM6IGZ1bmN0aW9uICh0dXBsZSkge1xuICAgICAgICAgICAgcmV0dXJuIFR1cGxlLmVxdWFsKHRoaXMsIHR1cGxlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyBhbiBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgTmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSwgdmFsdWUpIHtcblxuICAgICAgICAgICAgaWYodGhpcy5yZWxhdGlvbil7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2xvbmUgPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG5cbiAgICAgICAgICAgICAgICB2YXIgZm91bmRJbmRleCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5yZWxhdGlvbi5oZWFkZXIoKS5nZXQoYXR0cmlidXRlTmFtZSkudHlwZS5jb2VyY2UodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgY2xvbmUuYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9IHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgLy8gTGV0J3MgY2hlY2sgaWYgdXBkYXRpbmcgdGhlIHR1cGxlJ3MgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBjYXVzZSBhIGR1cGxpY2F0ZSB0dXBsZSBpbiB0aGUgcmVsYXRpb25cblxuICAgICAgICAgICAgICAgIGlmKChmb3VuZEluZGV4ID0gdGhpcy5yZWxhdGlvbi5pbmRleChjbG9uZSkpICE9PSBudWxsICYmICh0aGlzLnJlbGF0aW9uLmF0SW5kZXgoZm91bmRJbmRleCkgIT09IHRoaXMpKXtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aW9uLnJlbW92ZSh0aGlzKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGlvbi5lZS5lbWl0KCdiZWZvcmVVcGRhdGUnLCB0aGlzLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID0gdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGlvbi5lZS5lbWl0KCdhZnRlclVwZGF0ZScsIHRoaXMsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPSB2YWx1ZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgYW5kIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAgICAgKiBAcGFyYW0ge0F0dHJpYnV0ZXxTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgTmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbGV0ZXMgYW4gYXR0cmlidXRlIGZyb20gdGhlIHR1cGxlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0byBkZWxldGVcbiAgICAgICAgICovXG4gICAgICAgIGRlbGV0ZTogZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb25lcyBhIHR1cGxlXG4gICAgICAgICAqIEByZXR1cm5zIHtUdXBsZX1cbiAgICAgICAgICovXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHZhciBhdHRyLFxuICAgICAgICAgICAgICAgIG5ld1R1cGxlID0gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKSgpO1xuXG4gICAgICAgICAgICBfLmZvckVhY2godGhpcy5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAoYXR0cmlidXRlLCBrZXkpIHtcblxuICAgICAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24oYXR0cmlidXRlLmNsb25lKSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRyID0gYXR0cmlidXRlLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ciA9IGF0dHJpYnV0ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuZXdUdXBsZS5zZXQoa2V5LCBhdHRyKTtcblxuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXdUdXBsZTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHR1cGxlXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0b1N0cmluZyA6IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICAgICAgICAgIHZhciBhdHRyTGVuZ3RoID0gT2JqZWN0LmtleXModGhpcy5hdHRyaWJ1dGVzKS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgYXR0cnMgPSBbJ1R1cGxlKHsnXTtcblxuICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGF0dHJpYnV0ZSwga2V5KXtcblxuICAgICAgICAgICAgICAgIGF0dHJzLnB1c2goa2V5LnRvU3RyaW5nKCkrICcgOiAnICsgYXR0cmlidXRlLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgICAgICAgICAgaWYoY291bnQgIT09IGF0dHJMZW5ndGgtMSl7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzLnB1c2goJywgJylcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb3VudCsrO1xuXG4gICAgICAgICAgICB9LHRoaXMpO1xuXG4gICAgICAgICAgICBhdHRycy5wdXNoKCd9KScpO1xuXG4gICAgICAgICAgICByZXR1cm4gYXR0cnMuam9pbignJyk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICB0b09iamVjdCA6IGZ1bmN0aW9uKHJlY3Vyc2l2ZSl7XG5cbiAgICAgICAgICAgIHJlY3Vyc2l2ZSA9IHR5cGVvZihyZWN1cnNpdmUpICE9PSAndW5kZWZpbmVkJyA/IHJlY3Vyc2l2ZSA6IGZhbHNlO1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihhdHRyaWJ1dGUsIGtleSkge1xuXG4gICAgICAgICAgICAgICAgaWYocmVjdXJzaXZlICYmICEhdGhpcy5yZWxhdGlvbiAmJiAhIXRoaXMucmVsYXRpb24uZ2V0KGtleSkgJiYgKHRoaXMucmVsYXRpb24uZ2V0KGtleSkudHlwZSA9PT0gVHVwbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gYXR0cmlidXRlLnRvT2JqZWN0KHRydWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gYXR0cmlidXRlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgfVxuXG5cbiAgICB9LCB7XG5cbiAgICAgICAgdHlwZTogJ1R1cGxlJyxcblxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdUdXBsZSdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVzdCBmb3IgZXF1YWxpdHkgYmV0d2VlbiB0d28gdHVwbGVzXG4gICAgICAgICAqIEBwYXJhbSB7VHVwbGV9IHR1cGxlMVxuICAgICAgICAgKiBAcGFyYW0ge1R1cGxlfSB0dXBsZTJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqIEBzdGF0aWNcblxuICAgICAgICAgKi9cbiAgICAgICAgZXF1YWw6IGZ1bmN0aW9uICh0dXBsZTEsIHR1cGxlMikge1xuXG4gICAgICAgICAgICB2YXIga2V5O1xuXG4gICAgICAgICAgICBpZiAoISh0dXBsZTEgaW5zdGFuY2VvZiBUdXBsZSkgfHwgISh0dXBsZTIgaW5zdGFuY2VvZiBUdXBsZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVkIHR1cGxlcyBhcmUgb2YgdGhlIHdyb25nIHR5cGUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1hdGNoID0gdHJ1ZTtcblxuICAgICAgICAgICAgdHVwbGUxLmVhY2goZnVuY3Rpb24oYXR0ciwga2V5KXtcblxuICAgICAgICAgICAgICAgIGlmKHR1cGxlMi5nZXQoa2V5KSA9PT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZighZXF1YWwobnVsbCwgYXR0ciwgdHVwbGUyLmdldChrZXkpKSl7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgdGhhdCB0d28gdHVwbGVzIG1hdGNoIG9uIHRoZSBnaXZlbiBhdHRyaWJ1dGVzXG4gICAgICAgICAqIEBwYXJhbSB7VHVwbGV9IHR1cGxlMVxuICAgICAgICAgKiBAcGFyYW0ge1R1cGxlfSB0dXBsZTJcbiAgICAgICAgICogQHBhcmFtIHtBdHRyaWJ1dGVbXX0gYXR0cmlidXRlc1xuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICogQHN0YXRpY1xuXG4gICAgICAgICAqL1xuICAgICAgICBtYXRjaE9uQXR0cmlidXRlcyA6IGZ1bmN0aW9uKHR1cGxlMSwgdHVwbGUyLCBhdHRyaWJ1dGVzKXtcblxuICAgICAgICAgICAgdmFyIG1hdGNoID0gdHJ1ZTtcblxuICAgICAgICAgICAgYXR0cmlidXRlcy5lYWNoKGZ1bmN0aW9uKGF0dHJpYnV0ZSl7XG5cbiAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlLm5hbWU7XG5cbiAgICAgICAgICAgICAgICBpZighZXF1YWwobnVsbCwgdHVwbGUxLmdldChhdHRyaWJ1dGVOYW1lKSwgdHVwbGUyLmdldChhdHRyaWJ1dGVOYW1lKSkpe1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvZXJjZXMgYW4gYXJiaXRyYXJ5IG9iamVjdCB0byB0eXBlIFR1cGxlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fFR1cGxlfSB0dXBsZVxuICAgICAgICAgKiBAcGFyYW0gcmVsYXRpb24gVGhlIFJlbGF0aW9uIHRvIHdoaWNoIGJlbG9uZ3MgdGhlIHR1cGxlLlxuICAgICAgICAgKiBAcmV0dXJucyB7VHVwbGV9XG4gICAgICAgICAqIEBzdGF0aWNcblxuICAgICAgICAgKi9cbiAgICAgICAgY29lcmNlOiBmdW5jdGlvbiAodHVwbGUsIHJlbGF0aW9uKSB7XG5cblxuICAgICAgICAgICAgaWYodHVwbGUgaW5zdGFuY2VvZiBUdXBsZSl7XG5cbiAgICAgICAgICAgICAgICAvLyBHaXZlbiB0dXBsZSBpcyBvZiB0eXBlIFR1cGxlLlxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR1cGxlO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgaWYoIV8uaXNPYmplY3QodHVwbGUpKXtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJdCBpcyBub3QgYW4gb2JqZWN0LiBJdCBjYW4ndCBiZSBjb2VyY2VkLlxuXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dyb25nIHBhcmFtZXRlciB0eXBlLiBFeHBlY3RlZCBhbiBvYmplY3Qgb3IgYSBUdXBsZScpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSXQgaXMgbm90IGEgVHVwbGUgaW5zdGFuY2UuIENoZWNrIGlmIGl0IG1pZ2h0IGJlIGNvZXJjZWQuXG4gICAgICAgICAgICAgICAgaWYgKF8uaXNBcnJheSh0dXBsZSkpIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZChyZWxhdGlvbikgfHwgXy5pc051bGwocmVsYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb2VyY2UgYXJyYXktZGVjbGFyZWQgdHVwbGUgaWYgbm8gcmVsYXRpb24gaXMgc3BlY2lmaWVkJylcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24ocmVsYXRpb24uaGVhZGVyKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb2xsZWN0aW9uIGhhcyBoZWFkZXJcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWRlciA9IHJlbGF0aW9uLmhlYWRlcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlckNvdW50ID0gaGVhZGVyLmxlbmd0aCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGVyQ291bnQgPiAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIZWFkZXIgaGFzIG9uZSBvciBtb3JlIGF0dHJpYnV0ZXNcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFoZWFkZXIuX29yZGVyZWREZWNsYXJhdGlvbil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvZXJjZSBhbiBhcnJheSBkZWNsYXJlZCB0dXBsZSBpZiB0aGUgaGVhZGVyIGhhcyBub3QgYmVlbiBkZWNsYXJlZCBpbiBhcnJheSBmb3JtYXQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGhlYWRlckNvdW50ICE9PSB0dXBsZS5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb2VyY2UgVHVwbGUsIGl0IGRvZXMgbm90IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGF0dHJpYnV0ZXMgYXMgdGhlIGhlYWRlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdUdXBsZSA9IG5ldyBUdXBsZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2ggYXR0cmlidXRlcyBvZiB0aGUgaGVhZGVyIGluIG9yZGVyXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIuZWFjaChmdW5jdGlvbihhdHRyaWJ1dGUsIGluZGV4KXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGNvcnJlc3BvbmRpbmcgdHVwbGUgYXR0cmlidXRlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VHVwbGUuc2V0KGF0dHJpYnV0ZS5uYW1lLCB0dXBsZVtpbmRleF0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3VHVwbGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0dXBsZSA9IG5ldyBUdXBsZSh0dXBsZSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHVwbGU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUdXBsZTsiLCJ2YXIgQmFzZSA9IHJlcXVpcmUoJy4vQmFzZS5qcycpO1xuXG52YXIgVHlwZSA9IEJhc2UuZXh0ZW5kKFxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIFR5cGVcbiAgICAgICAgICogQGV4dGVuZHMgQmFzZVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgICAgICAgICAvL3RoaXMuX3ZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgICAgIEJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbG9uZXMgdGhlIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7VHlwZX1cbiAgICAgICAgICovXG4gICAgICAgIGNsb25lIDogZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuX3ZhbHVlKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXN0cm95cyB0aGUgb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBkZXN0cm95IDogZnVuY3Rpb24oKXtcblxuICAgICAgICB9XG5cbiAgICB9LCB7XG5cbiAgICAgICAgdHlwZSA6ICdUeXBlJyxcblxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdUeXBlJ1xuICAgICAgICB9XG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUeXBlOyIsInZhciBSZWxhdGlvbiA9IHJlcXVpcmUoJy4vLi4vUmVsYXRpb24uanMnKTtcbnZhciBIZWFkZXIgPSByZXF1aXJlKCcuLy4uL0hlYWRlci5qcycpO1xudmFyIFR1cGxlID0gcmVxdWlyZSgnLi8uLi9UdXBsZS5qcycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9kZWJ1ZycpO1xuXG52YXIgQ29tcG9zaXRpb24gPSBSZWxhdGlvbi5leHRlbmQoXG5cbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBPcGVyYXRvcnMuQ29tcG9zaXRpb25cbiAgICAgICAgICogQGV4dGVuZHMgUmVsYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtSZWxhdGlvbn0gcmVsYXRpb25BIFRoZSByZWxhdGlvbiBBXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uQiBUaGUgcmVsYXRpb24gQlxuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgQ29tcG9zaXRpb24gb3BlcmF0b3Igd2lsbCBwZXJmb3JtIGEgbmF0dXJhbCBqb2luIGJldHdlZW4gQSBhbmQgQiB3aGlsZSByZW1vdmluZyB0aGUgY29tbW9uIGF0dHJpYnV0ZXNcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkEgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge2NoYXJhY3RlcklkOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtmaXJzdE5hbWU6IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7bGFzdE5hbWU6IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbMSwgJ0pvaG4nLCAnRG9lJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbMiwgJ01hcnknLCAnUG9wcGlucyddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzMsICdMdWNreScsICdMdWtlJ11cbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgY2hhcmFjdGVySWQgOiBUSW50ZWdlciB8IGZpcnN0TmFtZSA6IFRTdHJpbmcgfCBsYXN0TmFtZSA6IFRTdHJpbmcgfFxuICAgICAgICAgKiAgICAgLy8gKz09PT09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAvLyB8IDEgICAgICAgICAgICAgICAgICAgICAgfCBKb2huICAgICAgICAgICAgICAgIHwgRG9lICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAyICAgICAgICAgICAgICAgICAgICAgIHwgTWFyeSAgICAgICAgICAgICAgICB8IFBvcHBpbnMgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMyAgICAgICAgICAgICAgICAgICAgICB8IEx1Y2t5ICAgICAgICAgICAgICAgfCBMdWtlICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25CID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgICAgIHtjaGFyYWN0ZXJJZDogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7ZmFuOiB7IHR5cGU6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWzEsICdNciBYJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbMSwgJ01pc3MgRGliYmxlJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbMiwgJ05hdCBCaWJibGUnXVxuICAgICAgICAgKiAgICAgICAgICBdKTtcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBjaGFyYWN0ZXJJZCA6IFRJbnRlZ2VyIHwgZmFuIDogVFN0cmluZyB8XG4gICAgICAgICAqICAgICAvLyArPT09PT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgIC8vIHwgMSAgICAgICAgICAgICAgICAgICAgICB8IE1yIFggICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDEgICAgICAgICAgICAgICAgICAgICAgfCBNaXNzIERpYmJsZSAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAyICAgICAgICAgICAgICAgICAgICAgIHwgTmF0IEJpYmJsZSAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkMgPSByZWxhdGlvbkEuY29tcG9zZShyZWxhdGlvbkIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gb3JcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkMgPSBuZXcgYWZmaW5pdHkuQ29tcG9zaXRpb24ocmVsYXRpb25BLCByZWxhdGlvbkIpXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgZmlyc3ROYW1lIDogVFN0cmluZyB8IGxhc3ROYW1lIDogVFN0cmluZyB8IGZhbiA6IFRTdHJpbmcgfFxuICAgICAgICAgKiAgICAgLy8gKz09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAvLyB8IEpvaG4gICAgICAgICAgICAgICAgfCBEb2UgICAgICAgICAgICAgICAgfCBNciBYICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBKb2huICAgICAgICAgICAgICAgIHwgRG9lICAgICAgICAgICAgICAgIHwgTWlzcyBEaWJibGUgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgTWFyeSAgICAgICAgICAgICAgICB8IFBvcHBpbnMgICAgICAgICAgICB8IE5hdCBCaWJibGUgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvL1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIChyZWxhdGlvbkEsIHJlbGF0aW9uQikge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBhcmdzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge1JlbGF0aW9ufSBhcmdzLmxlZnRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7UmVsYXRpb259IGFyZ3MucmlnaHRcbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICBkZWJ1Zy5jb21wb3NlLnRyYWNlKCcjY29uc3RydWN0b3InKTtcblxuICAgICAgICAgICAgdGhpcy5hcmdzID0ge307XG5cbiAgICAgICAgICAgIHRoaXMuYXJncy5sZWZ0ID0gcmVsYXRpb25BO1xuXG4gICAgICAgICAgICB0aGlzLmFyZ3MucmlnaHQgPSByZWxhdGlvbkI7XG5cbiAgICAgICAgICAgIFJlbGF0aW9uLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIHRoaXMuY29tbW9uQXR0cmlidXRlcyA9IG51bGw7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLmNvbXBvc2UudHJhY2UoJyNiaW5kRXZlbnRzJyk7XG5cbiAgICAgICAgICAgIC8vIENhbGxpbmcgdGhlIHBhcmVudCBiaW5kRXZlbnRzXG4gICAgICAgICAgICBDb21wb3NpdGlvbi5fX3N1cGVyX18uYmluZEV2ZW50cy5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBsZWZ0ID0gdGhhdC5hcmdzLmxlZnQ7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGF0LmFyZ3MucmlnaHQ7XG5cbiAgICAgICAgICAgIC8vIGJlZm9yZUdldEhlYWRlclxuICAgICAgICAgICAgdGhpcy5lZS5vbmNlKCdiZWZvcmVHZXRIZWFkZXInLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbGVmdEhlYWRlciA9IGxlZnQuaGVhZGVyKCk7XG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0SGVhZGVyID0gcmlnaHQuaGVhZGVyKCk7XG5cbiAgICAgICAgICAgICAgICBkZWJ1Zy5jb21wb3NlLnRyYWNlKCdiZWZvcmVHZXRIZWFkZXInKTtcblxuICAgICAgICAgICAgICAgIEhlYWRlci5hc3NlcnRTYW1lTmFtZVNhbWVUeXBlKGxlZnRIZWFkZXIsIHJpZ2h0SGVhZGVyKTtcblxuICAgICAgICAgICAgICAgIHRoYXQuY29tbW9uQXR0cmlidXRlcyA9IEhlYWRlci5jb21tb25BdHRyaWJ1dGVzKGxlZnRIZWFkZXIsIHJpZ2h0SGVhZGVyKTtcblxuICAgICAgICAgICAgICAgIHRoYXQubGVmdEF0dHJpYnV0ZXMgPSBsZWZ0SGVhZGVyLnNldERpZmZlcmVuY2UodGhhdC5jb21tb25BdHRyaWJ1dGVzKTtcblxuICAgICAgICAgICAgICAgIHRoYXQucmlnaHRBdHRyaWJ1dGVzID0gcmlnaHRIZWFkZXIuc2V0RGlmZmVyZW5jZSh0aGF0LmNvbW1vbkF0dHJpYnV0ZXMpO1xuXG4gICAgICAgICAgICAgICAgdGhhdC5oZWFkZXIoKS5jb3B5KGxlZnRIZWFkZXIuc2V0VW5pb24ocmlnaHRIZWFkZXIpLnNldERpZmZlcmVuY2UodGhhdC5jb21tb25BdHRyaWJ1dGVzKSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBiZWZvcmVHZXRCb2R5XG4gICAgICAgICAgICB0aGlzLmVlLm9uY2UoJ2JlZm9yZUdldEJvZHknLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICBkZWJ1Zy5jb21wb3NlLnRyYWNlKCdiZWZvcmVHZXRCb2R5Jyk7XG5cbiAgICAgICAgICAgICAgICBsZWZ0LmVhY2goZnVuY3Rpb24gKHR1cGxlKSB7IHRoYXQuZG9BZnRlckFkZChsZWZ0LCB0dXBsZSk7IH0pO1xuXG4gICAgICAgICAgICAgICAgcmlnaHQuZWFjaChmdW5jdGlvbiAodHVwbGUpIHsgdGhhdC5kb0FmdGVyQWRkKHJpZ2h0LCB0dXBsZSk7fSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsZWZ0LmVlLm9uKCdhZnRlckFkZCcsIGZ1bmN0aW9uKHR1cGxlKXtcblxuICAgICAgICAgICAgICAgIHRoYXQuZG9BZnRlckFkZChsZWZ0LCB0dXBsZSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByaWdodC5lZS5vbignYWZ0ZXJBZGQnLCBmdW5jdGlvbih0dXBsZSl7XG5cbiAgICAgICAgICAgICAgICB0aGF0LmRvQWZ0ZXJBZGQocmlnaHQsIHR1cGxlKTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGxlZnQuZWUub24oJ2FmdGVyUmVtb3ZlJywgZnVuY3Rpb24odHVwbGUsIGluZGV4KXtcblxuICAgICAgICAgICAgICAgIHRoYXQuZG9BZnRlclJlbW92ZShsZWZ0LCB0dXBsZSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByaWdodC5lZS5vbignYWZ0ZXJSZW1vdmUnLCBmdW5jdGlvbih0dXBsZSwgaW5kZXgpe1xuXG4gICAgICAgICAgICAgICAgdGhhdC5kb0FmdGVyUmVtb3ZlKHJpZ2h0LCB0dXBsZSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsZWZ0LmVlLm9uKCdhZnRlclVwZGF0ZScsIGZ1bmN0aW9uKHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSl7XG5cbiAgICAgICAgICAgICAgICB0aGF0LmRvQWZ0ZXJVcGRhdGUobGVmdCwgdHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlKTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJpZ2h0LmVlLm9uKCdhZnRlclVwZGF0ZScsIGZ1bmN0aW9uKHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSl7XG5cbiAgICAgICAgICAgICAgICB0aGF0LmRvQWZ0ZXJVcGRhdGUocmlnaHQsIHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGhhbmRsZXIgd2hlbiB0dXBsZXMgYXJlIGFkZGVkIHRvIHRoZSBiYXNlIHJlbGF0aW9uc1xuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvbiByZWxhdGlvbiBpbiB3aGljaCB0aGUgdHVwbGUgd2FzIGFkZGVkXG4gICAgICAgICAqIEBwYXJhbSB7VHVwbGV9IHR1cGxlMSB0aGUgdHVwbGUgdGhhdCB3YXMgYWRkZWRcbiAgICAgICAgICovXG4gICAgICAgIGRvQWZ0ZXJBZGQgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUxKXtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgb3RoZXJSZWxhdGlvbiA9IChyZWxhdGlvbiA9PT0gdGhhdC5hcmdzLmxlZnQgPyB0aGF0LmFyZ3MucmlnaHQgOiB0aGF0LmFyZ3MubGVmdCk7XG5cbiAgICAgICAgICAgIG90aGVyUmVsYXRpb24uZWFjaChmdW5jdGlvbih0dXBsZTIpe1xuXG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gVHVwbGUubWF0Y2hPbkF0dHJpYnV0ZXModHVwbGUxLCB0dXBsZTIsIHRoYXQuY29tbW9uQXR0cmlidXRlcyk7XG5cbiAgICAgICAgICAgICAgICBpZihtYXRjaCl7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbWJpbmVkVHVwbGUgPSBfLmV4dGVuZCh7fSwgdHVwbGUxLmF0dHJpYnV0ZXMsIHR1cGxlMi5hdHRyaWJ1dGVzKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VHVwbGUgPSBuZXcgVHVwbGUoKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGF0LmhlYWRlcigpLmVhY2goZnVuY3Rpb24oY29tcG9zZUF0dHJpYnV0ZSl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21wb3NlQXR0cmlidXRlTmFtZSA9IGNvbXBvc2VBdHRyaWJ1dGUubmFtZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VHVwbGUuc2V0KGNvbXBvc2VBdHRyaWJ1dGVOYW1lLCBjb21iaW5lZFR1cGxlW2NvbXBvc2VBdHRyaWJ1dGVOYW1lXSlcblxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB0aGF0LmFkZChuZXdUdXBsZSk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBoYW5kbGVyIHdoZW4gdHVwbGVzIGFyZSByZW1vdmVkIGZyb20gdGhlIGJhc2UgcmVsYXRpb25zLlxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvbiBSZWxhdGlvbiBpbiB3aGljaCB0aGUgdHVwbGUgd2FzIHJlbW92ZWRcbiAgICAgICAgICogQHBhcmFtIHtUdXBsZX0gcmVtb3ZlZFR1cGxlIFRoZSB0dXBsZSB0aGF0IHdhcyByZW1vdmVkXG4gICAgICAgICAqL1xuICAgICAgICBkb0FmdGVyUmVtb3ZlIDogZnVuY3Rpb24ocmVsYXRpb24sIHJlbW92ZWRUdXBsZSl7XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIG5vbkNvbW1vbkF0dHJpYnV0ZXMgPSAocmVsYXRpb24gPT09IHRoYXQuYXJncy5sZWZ0ID8gdGhhdC5sZWZ0QXR0cmlidXRlcyA6IHRoYXQucmlnaHRBdHRyaWJ1dGVzKTtcblxuICAgICAgICAgICAgLy8gRmluZCB0dXBsZXMgd2hpY2ggbWF0Y2ggdGhlIHJlbW92ZWQgdHVwbGUgb24gaXRzIGF0dHJpYnV0ZXNcblxuICAgICAgICAgICAgdGhhdC5lYWNoKGZ1bmN0aW9uKHR1cGxlLCBpbmRleCl7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBUdXBsZS5tYXRjaE9uQXR0cmlidXRlcyh0dXBsZSwgcmVtb3ZlZFR1cGxlLCBub25Db21tb25BdHRyaWJ1dGVzKTtcblxuICAgICAgICAgICAgICAgIGlmKG1hdGNoKXtcblxuICAgICAgICAgICAgICAgICAgICB0aGF0LnJlbW92ZUF0KGluZGV4KTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgaGFuZGxlciB3aGVuIHR1cGxlcyBhcmUgdXBkYXRlZCBpbiB0aGUgYmFzZSByZWxhdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHtSZWxhdGlvbn0gcmVsYXRpb24gVGhlIHJlbGF0aW9uIHdoZXJlIHRoZSB0dXBsZSB3YXMgdXBkYXRlZFxuICAgICAgICAgKiBAcGFyYW0ge1R1cGxlfSB0dXBsZSBUaGUgdHVwbGUgdGhhdCB3YXMgdXBkYXRlZFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlTmFtZSBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHRoYXQgd2FzIHVwZGF0ZWRcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgbmV3IHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgICovXG4gICAgICAgIGRvQWZ0ZXJVcGRhdGUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSl7XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIG90aGVyUmVsYXRpb24gPSAocmVsYXRpb24gPT09IHRoYXQuYXJncy5sZWZ0ID8gdGhhdC5hcmdzLnJpZ2h0IDogdGhhdC5hcmdzLmxlZnQpO1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5hcmdzLmxlZnQuY29tcG9zZSh0aGlzLmFyZ3MucmlnaHQpO1xuXG4gICAgICAgICAgICB0aGF0LmFkanVzdFRvKHJlc3VsdCk7XG5cbiAgICAgICAgfVxuXG4gICAgfSwge1xuXG4gICAgICAgIHR5cGUgOiAnQ29tcG9zaXRpb24nXG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb3NpdGlvbjsiLCJ2YXIgUmVsYXRpb24gPSByZXF1aXJlKCcuLy4uL1JlbGF0aW9uLmpzJyk7XG52YXIgSGVhZGVyID0gcmVxdWlyZSgnLi8uLi9IZWFkZXIuanMnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvZGVidWcnKTtcblxudmFyIERpZmZlcmVuY2UgPSBSZWxhdGlvbi5leHRlbmQoXG5cblxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIE9wZXJhdG9ycy5EaWZmZXJlbmNlXG4gICAgICAgICAqIEBleHRlbmRzIFJlbGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IGxlZnQgVGhlIHJlbGF0aW9uIGZyb20gd2hpY2ggdG8gcmVtb3ZlIHRoZSB0dXBsZXNcbiAgICAgICAgICogQHBhcmFtIHtSZWxhdGlvbn0gcmlnaHQgVGhlIHJlbGF0aW9uIHRoYXQgd2lsbCBiZSBzdWJzdHJhY3RlZCBmcm9tIHRoZSBvdGhlclxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgRGlmZmVyZW5jZSBvcGVyYXRpb24gZ2l2ZXMgdGhlIGZpcnN0IHJlbGF0aW9uJ3MgdHVwbGVzIG1pbnVzIHRob3NlIHRoYXQgYXJlIGluIHRoZSBzZWNvbmQgcmVsYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgbGVmdCA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7YTogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7YjogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7YzogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbMSwgMiwgM10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbNCwgNSwgNl0sXG4gICAgICAgICAqICAgICAgICAgICAgICBbNywgOCwgOV1cbiAgICAgICAgICogICAgICAgICAgXSk7XG5cbiAgICAgICAgICogICAgIHZhciByaWdodCA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7YTogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7YjogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7YzogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX1cbiAgICAgICAgICogICAgICAgICAgXSwgW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWzEsIDIsIDNdXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbDMgPSBsZWZ0LmRpZmZlcmVuY2UocmlnaHQpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gb3JcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWw0ID0gbmV3IGFmZmluaXR5LkRpZmZlcmVuY2UobGVmdCwgcmlnaHQpXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IGEgOiBUSW50ZWdlciB8IGIgOiBUSW50ZWdlciB8IGMgOiBUSW50ZWdlciB8XG4gICAgICAgICAqICAgICAvLyArPT09PT09PT09PT09PT0rPT09PT09PT09PT09PT0rPT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAvLyB8IDQgICAgICAgICAgICB8IDUgICAgICAgICAgICB8IDYgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDcgICAgICAgICAgICB8IDggICAgICAgICAgICB8IDkgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG5cbiAgICAgICAgICAgIGRlYnVnLmRpZmZlcmVuY2UudHJhY2UoJyNjb25zdHJ1Y3RvcicpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBhcmdzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuYXJncyA9IHt9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7UmVsYXRpb259IGxlZnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5hcmdzLmxlZnQgPSBsZWZ0O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7UmVsYXRpb259IHJpZ2h0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuYXJncy5yaWdodCA9IHJpZ2h0O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7UmVsYXRpb25bXX0gcmVsYXRpb25zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuYXJncy5yZWxhdGlvbnMgPSBbbGVmdCwgcmlnaHRdO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gY29tcHV0ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5jb21wdXRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBDYWxscyB0aGUgcGFyZW50IGNvbnN0cnVjdG9yXG4gICAgICAgICAgICBSZWxhdGlvbi5jYWxsKHRoaXMpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLmRpZmZlcmVuY2UudHJhY2UoJyNiaW5kRXZlbnRzJyk7XG5cbiAgICAgICAgICAgIERpZmZlcmVuY2UuX19zdXBlcl9fLmJpbmRFdmVudHMuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgbGVmdCA9IHRoYXQuYXJncy5sZWZ0O1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhhdC5hcmdzLnJpZ2h0O1xuXG4gICAgICAgICAgICAvLyBCZWZvcmVHZXRIZWFkZXJcbiAgICAgICAgICAgIHRoaXMuZWUub25jZSgnYmVmb3JlR2V0SGVhZGVyJywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGxlZnRIZWFkZXIgPSBsZWZ0LmhlYWRlcigpO1xuICAgICAgICAgICAgICAgIHZhciByaWdodEhlYWRlciA9IHJpZ2h0LmhlYWRlcigpO1xuXG4gICAgICAgICAgICAgICAgZGVidWcuZGlmZmVyZW5jZS50cmFjZSgnYmVmb3JlR2V0SGVhZGVyJyk7XG5cbiAgICAgICAgICAgICAgICBIZWFkZXIuYXNzZXJ0VW5pb25Db21wYXRpYmxlKGxlZnRIZWFkZXIsIHJpZ2h0SGVhZGVyKTtcblxuICAgICAgICAgICAgICAgIHRoYXQuaGVhZGVyKCkuY29weShsZWZ0SGVhZGVyKTtcblxuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgLy8gQmVmb3JlR2V0Qm9keVxuICAgICAgICAgICAgdGhpcy5lZS5vbmNlKCdiZWZvcmVHZXRCb2R5JywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgZGVidWcuZGlmZmVyZW5jZS50cmFjZSgnYmVmb3JlR2V0Qm9keScpO1xuXG4gICAgICAgICAgICAgICAgbGVmdC5lYWNoKGZ1bmN0aW9uICh0dXBsZTEpIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHQuaW5kZXgodHVwbGUxKSA9PT0gbnVsbCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmFkZCh0dXBsZTEuY2xvbmUoKSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhhdC5jb21wdXRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsZWZ0LmVlLm9uKCdhZnRlckFkZCcsIGZ1bmN0aW9uKHR1cGxlLCBpbmRleCl7XG4gICAgICAgICAgICAgICAgdGhhdC5hZnRlckxlZnRBZGQobGVmdCwgdHVwbGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJpZ2h0LmVlLm9uKCdhZnRlckFkZCcsIGZ1bmN0aW9uKHR1cGxlLCBpbmRleCl7XG4gICAgICAgICAgICAgICAgdGhhdC5hZnRlclJpZ2h0QWRkKGxlZnQsIHR1cGxlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsZWZ0LmVlLm9uKCdhZnRlclJlbW92ZScsIGZ1bmN0aW9uKHR1cGxlLCBpbmRleCl7XG4gICAgICAgICAgICAgICAgdGhhdC5hZnRlckxlZnRSZW1vdmUocmlnaHQsIHR1cGxlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByaWdodC5lZS5vbignYWZ0ZXJSZW1vdmUnLCBmdW5jdGlvbih0dXBsZSwgaW5kZXgpe1xuICAgICAgICAgICAgICAgIHRoYXQuYWZ0ZXJSaWdodFJlbW92ZShyaWdodCwgdHVwbGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGxlZnQuZWUub24oJ2FmdGVyVXBkYXRlJywgZnVuY3Rpb24odHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSl7XG4gICAgICAgICAgICAgICAgdGhhdC5hZnRlckxlZnRVcGRhdGUobGVmdCwgdHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmlnaHQuZWUub24oJ2FmdGVyVXBkYXRlJywgZnVuY3Rpb24odHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSl7XG4gICAgICAgICAgICAgICAgdGhhdC5hZnRlclJpZ2h0VXBkYXRlKHJpZ2h0LCB0dXBsZSwgYXR0cmlidXRlTmFtZSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHR1cGxlcyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBsZWZ0IHJlbGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7VHVwbGV9IHJlbW92ZWRUdXBsZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgYWZ0ZXJMZWZ0UmVtb3ZlIDogZnVuY3Rpb24ocmVsYXRpb24sIHJlbW92ZWRUdXBsZSl7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSB0dXBsZSBpcyBub3QgcHJlc2VudCBpbiB0aGUgcmlnaHQgcmVsYXRpb24sXG4gICAgICAgICAgICAvLyByZW1vdmUgaXRcbiAgICAgICAgICAgIGlmKHRoaXMuY29tcHV0ZWQgJiYgdGhpcy5hcmdzLnJpZ2h0LmluZGV4KHJlbW92ZWRUdXBsZSkgPT09IG51bGwpe1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKHJlbW92ZWRUdXBsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gdHVwbGVzIGFyZSByZW1vdmVkIGZyb20gdGhlIHJpZ2h0IHJlbGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7VHVwbGV9IHJlbW92ZWRUdXBsZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgYWZ0ZXJSaWdodFJlbW92ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCByZW1vdmVkVHVwbGUpe1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgdHVwbGUgaXMgcHJlc2VudCBpbiB0aGUgbGVmdCByZWxhdGlvbixcbiAgICAgICAgICAgIC8vIGFkZCBpdC5cbiAgICAgICAgICAgIGlmKHRoaXMuY29tcHV0ZWQgJiYgdGhpcy5hcmdzLmxlZnQuaW5kZXgocmVtb3ZlZFR1cGxlKSAhPT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQocmVtb3ZlZFR1cGxlLmNsb25lKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHR1cGxlcyBhcmUgYWRkZWQgdG8gdGhlIGxlZnQgYmFzZSByZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1R1cGxlfSBhZGRlZFR1cGxlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBhZnRlckxlZnRBZGQgOiBmdW5jdGlvbihyZWxhdGlvbiwgYWRkZWRUdXBsZSl7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSB0dXBsZSBpcyBub3QgaW4gdGhlIHJpZ2h0XG4gICAgICAgICAgICAvLyByZWxhdGlvbiwgYWRkIGl0LlxuICAgICAgICAgICAgaWYodGhpcy5jb21wdXRlZCAmJiB0aGlzLmFyZ3MucmlnaHQuaW5kZXgoYWRkZWRUdXBsZSkgPT09IG51bGwpe1xuXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoYWRkZWRUdXBsZS5jbG9uZSgpKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHR1cGxlcyBhcmUgYWRkZWQgdG8gdGhlIHJpZ2h0IGJhc2UgcmVsYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtSZWxhdGlvbn0gcmVsYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtUdXBsZX0gYWRkZWRUdXBsZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgYWZ0ZXJSaWdodEFkZCA6IGZ1bmN0aW9uKHJlbGF0aW9uLCBhZGRlZFR1cGxlKXtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIHR1cGxlIGlzIHByZXNlbnQgaW4gdGhlIGxlZnRcbiAgICAgICAgICAgIC8vIHJlbGF0aW9uLCByZW1vdmUgaXQuXG4gICAgICAgICAgICBpZih0aGlzLmNvbXB1dGVkICYmIHRoaXMuYXJncy5sZWZ0LmluZGV4KGFkZGVkVHVwbGUpICE9PSBudWxsKXtcblxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKGFkZGVkVHVwbGUpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gdHVwbGVzIGFyZSB1cGRhdGVkIG9uIHRoZSBsZWZ0IHJlbGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259cmVsYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtUdXBsZX0gdHVwbGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWVcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAgICAgKiBAcGFyYW0geyp9IG9sZFZhbHVlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBhZnRlckxlZnRVcGRhdGUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSl7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuY29tcHV0ZWQpe1xuXG4gICAgICAgICAgICAgICAgdmFyIG9sZFJpZ2h0SW5kZXgsIHJpZ2h0SW5kZXgsIG9sZFR1cGxlO1xuXG4gICAgICAgICAgICAgICAgb2xkVHVwbGUgPSB0dXBsZS5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgb2xkVHVwbGUuYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9IG9sZFZhbHVlO1xuXG4gICAgICAgICAgICAgICAgb2xkUmlnaHRJbmRleCA9IHRoaXMuYXJncy5yaWdodC5pbmRleChvbGRUdXBsZSk7XG4gICAgICAgICAgICAgICAgcmlnaHRJbmRleCA9IHRoaXMuYXJncy5yaWdodC5pbmRleCh0dXBsZSk7XG5cbiAgICAgICAgICAgICAgICBpZihvbGRSaWdodEluZGV4ID09PSBudWxsICYmIHJpZ2h0SW5kZXggPT09IG51bGwpe1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZChvbGRUdXBsZSkuc2V0KGF0dHJpYnV0ZU5hbWUsIHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2xkUmlnaHRJbmRleCA9PT0gbnVsbCAmJiByaWdodEluZGV4ICE9PSBudWxsKXtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShvbGRUdXBsZSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9sZFJpZ2h0SW5kZXggIT09IG51bGwgJiYgcmlnaHRJbmRleCA9PT0gbnVsbCl7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQodHVwbGUuY2xvbmUoKSk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHR1cGxlcyBhcmUgdXBkYXRlZCBvbiB0aGUgcmlnaHQgcmVsYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtSZWxhdGlvbn1yZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1R1cGxlfSB0dXBsZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlTmFtZVxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gb2xkVmFsdWVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGFmdGVyUmlnaHRVcGRhdGUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSl7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuY29tcHV0ZWQpe1xuXG4gICAgICAgICAgICAgICAgdmFyIG9sZExlZnRJbmRleCwgbGVmdEluZGV4LCBvbGRUdXBsZTtcblxuICAgICAgICAgICAgICAgIG9sZFR1cGxlID0gdHVwbGUuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIG9sZFR1cGxlLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPSBvbGRWYWx1ZTtcblxuICAgICAgICAgICAgICAgIG9sZExlZnRJbmRleCA9IHRoaXMuYXJncy5sZWZ0LmluZGV4KG9sZFR1cGxlKTtcbiAgICAgICAgICAgICAgICBsZWZ0SW5kZXggPSB0aGlzLmFyZ3MubGVmdC5pbmRleCh0dXBsZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAob2xkTGVmdEluZGV4ID09PSBudWxsICYmIGxlZnRJbmRleCAhPT0gbnVsbCl7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUodHVwbGUpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvbGRMZWZ0SW5kZXggIT09IG51bGwgJiYgbGVmdEluZGV4ICE9PSBudWxsKXtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZChvbGRUdXBsZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUodHVwbGUpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvbGRMZWZ0SW5kZXggIT09IG51bGwgJiYgbGVmdEluZGV4ID09PSBudWxsKXtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZChvbGRUdXBsZSk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sIHtcblxuICAgICAgICB0eXBlIDogJ0RpZmZlcmVuY2UnXG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEaWZmZXJlbmNlOyIsInZhciBSZWxhdGlvbiA9IHJlcXVpcmUoJy4vLi4vUmVsYXRpb24uanMnKTtcbnZhciBIZWFkZXIgPSByZXF1aXJlKCcuLy4uL0hlYWRlci5qcycpO1xudmFyIEF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4vLi4vQXR0cmlidXRlLmpzJyk7XG52YXIgVHVwbGUgPSByZXF1aXJlKCcuLy4uL1R1cGxlLmpzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2RlYnVnJyk7XG5cbnZhciBFeHRlbmQgPSBSZWxhdGlvbi5leHRlbmQoXG4gICAge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAocmVsYXRpb24sIGV4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBjbGFzcyBPcGVyYXRvcnMuRXh0ZW5zaW9uXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyBSZWxhdGlvblxuICAgICAgICAgICAgICogQHBhcmFtIHtSZWxhdGlvbn0gcmVsYXRpb24gVHtoZSByZWxhdGlvbiBmcm9tIHdoaWNoIHRvIHJlbW92ZSB0aGUgdHVwbGVzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBleHByZXNzaW9ucyBUaGUgYXJndW1lbnRzIGZyb20gd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSBuZXcgYXR0cmlidXRlIHZhbHVlLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRoZSBFeHRlbmQgb3BlcmF0aW9uIGFsbG93cyB0aGUgYWRkaXRpb24gb2YgY2FsY3VsYXRlZCB7QGxpbmsgSGVhZGVyfSB7QGxpbmsgQXR0cmlidXRlfXNcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQSA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAgICAgKiAgICAgICAgICAgICAge25hbWU6IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX0sXG4gICAgICAgICAgICAgKiAgICAgICAgICAgICAge2Jvcm46IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgICAgICogICAgICAgICAgICAgIHtkaWVkOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fVxuICAgICAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAgICAgKiAgICAgICAgICAgICAgWydBcmlzdG90bGUnLCAtMzg0LCAtMzIyXSxcbiAgICAgICAgICAgICAqICAgICAgICAgICAgICBbJ1BsYXRvJywgICAgIC00MjgsIC0zNDhdLFxuICAgICAgICAgICAgICogICAgICAgICAgICAgIFsnU29jcmF0ZXMnLCAgLTQ3MCwgLTM5OV1cbiAgICAgICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICB2YXIgYm9ybiA9IHJlbGF0aW9uQS5nZXQoJ2Jvcm4nKTtcbiAgICAgICAgICAgICAqICAgICB2YXIgZGllZCA9IHJlbGF0aW9uQS5nZXQoJ2RpZWQnKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQiA9IHJlbGF0aW9uQS5leHRlbmQoW3sgbGl2ZWQgOiBkaWVkLm1pbnVzKGJvcm4pIH1dKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgLy9vclxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICAvLyBMSVZFRCA9IERJRUQgLSBCT1JOXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgIHZhciByZWxhdGlvbkIgPSBuZXcgYWZmaW5pdHkuRXh0ZW5kKHJlbGF0aW9uQSwgW3sgbGl2ZWQgOiBkaWVkLm1pbnVzKGJvcm4pIH1dKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC1FWFRFTkRFRCBBVFRSLS0+XG4gICAgICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgICAgICogICAgIC8vIHwgbmFtZSA6IFRTdHJpbmcgfCBib3JuIDogVEludGVnZXIgfCBkaWVkIDogVEludGVnZXIgfCBsaXZlZCA6IFRJbnRlZ2VyIHxcbiAgICAgICAgICAgICAqICAgICAvLyArPT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAgICAgKiAgICAgLy8gfCBBcmlzdG90bGUgICAgICB8IC0zODQgICAgICAgICAgICB8IC0zMjIgICAgICAgICAgICB8IDYyICAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICAgICAqICAgICAvLyB8IFBsYXRvICAgICAgICAgIHwgLTQyOCAgICAgICAgICAgIHwgLTM0OCAgICAgICAgICAgIHwgODAgICAgICAgICAgICAgICB8XG4gICAgICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgICAgICogICAgIC8vIHwgU29jcmF0ZXMgICAgICAgfCAtNDcwICAgICAgICAgICAgfCAtMzk5ICAgICAgICAgICAgfCA3MSAgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAgICAgKiAgICAgLy9cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgLy8gUG9zc2libGUgdG8gYWRkIG11bHRpcGxlIGF0dHJpYnV0ZXMgaW4gb25lIGNhbGwgOlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICAvLyBMSVZFRCA9IERJRUQgLSBCT1JOLCBTSU5DRSA9IFlFQVIoTk9XKCkpLURJRURcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQiA9IG5ldyBhZmZpbml0eS5FeHRlbmQocmVsYXRpb25BLCBbXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IGxpdmVkIDogZGllZC5taW51cyhib3JuKSB9LFxuICAgICAgICAgICAgICogICAgICAgICAgeyBzaW5jZTogYWZmaW5pdHkueWVhcihhZmZpbml0eS5ub3coKSkubWludXMoZGllZCkgfVxuICAgICAgICAgICAgICogICAgIF0pO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8LUVYVEVOREVEIEFUVFItLT4gPC1FWFRFTkRFRCBBVFRSLS0+XG4gICAgICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICAgICAqICAgICAvLyB8IG5hbWUgOiBUU3RyaW5nIHwgYm9ybiA6IFRJbnRlZ2VyIHwgZGllZCA6IFRJbnRlZ2VyIHwgbGl2ZWQgOiBUSW50ZWdlciB8IHNpbmNlIDogVEludGVnZXIgfFxuICAgICAgICAgICAgICogICAgIC8vICs9PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAgICAgKiAgICAgLy8gfCBBcmlzdG90bGUgICAgICB8IC0zODQgICAgICAgICAgICB8IC0zMjIgICAgICAgICAgICB8IDYyICAgICAgICAgICAgICAgfCAyMzM1ICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgICAgICogICAgIC8vIHwgUGxhdG8gICAgICAgICAgfCAtNDI4ICAgICAgICAgICAgfCAtMzQ4ICAgICAgICAgICAgfCA4MCAgICAgICAgICAgICAgIHwgMjM2MiAgICAgICAgICAgICB8XG4gICAgICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICAgICAqICAgICAvLyB8IFNvY3JhdGVzICAgICAgIHwgLTQ3MCAgICAgICAgICAgIHwgLTM5OSAgICAgICAgICAgIHwgNzEgICAgICAgICAgICAgICB8IDI0MTMgICAgICAgICAgICAgfFxuICAgICAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAgICAgKiAgICAgLy9cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgLy8gUG9zc2libGUgdG8gaGF2ZSBjdXN0b20gZGVmaW5lZCBmdW5jdGlvbnNcbiAgICAgICAgICAgICAqICAgICAvLyBCZXdhcmUgdGhvdWdoIHRvIHJldHVybiB0aGUgcmlnaHQgZGF0YSB0eXBlIChkaXZpc2lvbnMgYnkgemVybywgdGFuKM+ALzIpLCAuLi4pXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgIC8vIFlvdSBtYXkgYXMgd2VsbCB1c2UgdGhpcyBmZWF0dXJlLCBidXQgc2luY2UgYWZmaW5pdHkgd2lsbCBsYXRlciBiZSBhIFNRTCBwYXJzZXIgdG9vLFxuICAgICAgICAgICAgICogICAgIC8vIGl0IHdpbGwgb2J2aW91c2x5IG5vdCBzdXBwb3J0IHRoZSB0cmFuc2xhdGlvbiBvZiBjdXN0b20gZGVmaW5lZCBmdW5jdGlvbnMgaW50byBTUUwgY29kZS5cbiAgICAgICAgICAgICAqICAgICAvLyBJZiB5b3UgcGxhbiBoYXZlIHVzZSBvZiBhZmZpbml0eSdzIGZ1dHVyZSBTUUwgcGFyc2VyLCBiZXdhcmUgdGhhdCB0aGVzZSBjdXN0b20gZnVuY3Rpb25zXG4gICAgICAgICAgICAgKiAgICAgLy8gd2lsbCBvbmx5IHJ1biBpbiBqYXZhc2NyaXB0LCBiZWNhdXNlIHdlIG5lZWQgdGhlIEFTVCBzbyB3ZSBjYW4gY29udmVydCBpdCB0byBTUUwuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgIC8vIEkgd291bGQgaGF2ZSBsb3ZlZCBqYXZhc2NyaXB0IHRvIHN1cHBvcnQgb3ZlcmxvYWRpbmcgb2Ygb3BlcmF0b3JzLCBidXQgdGhhdCB3b24ndFxuICAgICAgICAgICAgICogICAgIC8vIGhhcHBlbiBhbnl0aW1lIHNvb24uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgIHZhciByZWxhdGlvbkIgPSByZWxhdGlvbi5leHRlbmQoW1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICAgICAgIHsnbGl2ZWQnIDoge2Z1bmN0aW9uKHR1cGxlKXtcbiAgICAgICAgICAgICAqICAgICAgICAgICAgICByZXR1cm4gdHVwbGUuZ2V0KCdkaWVkJyktdHVwbGUuZ2V0KCdib3JuJyk7XG4gICAgICAgICAgICAgKiAgICAgICAgICB9LCB0eXBlIDogYWZmaW5pdHkuSW50ZWdlcn0sXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgICAgICAgeydkaWVkJyA6IHtmdW5jdGlvbih0dXBsZSl7XG4gICAgICAgICAgICAgKiAgICAgICAgICAgICAgcmV0dXJuIDIwMTQgLSB0dXBsZS5nZXQoJ2RpZWQnKVxuICAgICAgICAgICAgICogICAgICAgICAgfSwgdHlwZSA6IGFmZmluaXR5LkludGVnZXJ9LFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICBdKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgZGVidWcuZXh0ZW5kLnRyYWNlKCcjY29uc3RydWN0b3InKTtcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IGFyZ3NcbiAgICAgICAgICAgICogQHByb3BlcnR5IHtSZWxhdGlvbn0gYXJncy5yZWxhdGlvblxuICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5fSBhcmdzLmV4cHJlc3Npb25zXG4gICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB0aGlzLmFyZ3MgPSB7fTtcblxuICAgICAgICAgICAgdGhpcy5hcmdzLnJlbGF0aW9uID0gcmVsYXRpb247XG5cbiAgICAgICAgICAgIHRoaXMuYXJncy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuXG4gICAgICAgICAgICAvLyBDb2VyY2UgdGhlIGFyZ3VtZW50IHRvIGFuIGFycmF5IGlmIGl0IGlzIG5vdCBhbHJlYWR5XG5cbiAgICAgICAgICAgIGlmICghXy5pc0FycmF5KHRoaXMuYXJncy5leHByZXNzaW9ucykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFyZ3MuZXhwcmVzc2lvbnMgPSBbdGhpcy5hcmdzLmV4cHJlc3Npb25zXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhyb3cgYW4gZXJyb3IgaWYgdGhlIGV4cHJlc3Npb24gYXJyYXkgaXMgb2YgbGVuZ3RoIDBcbiAgICAgICAgICAgIGlmICh0aGlzLmFyZ3MuZXhwcmVzc2lvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBkZWZpbmUgZXhwcmVzc2lvbnMhJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlbGF0aW9uLmNhbGwodGhpcyk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLmV4dGVuZC50cmFjZSgnI2JpbmRFdmVudHMnKTtcblxuICAgICAgICAgICAgLy8gQ2FsbGluZyB0aGUgcGFyZW50IGJpbmRFdmVudHNcbiAgICAgICAgICAgIEV4dGVuZC5fX3N1cGVyX18uYmluZEV2ZW50cy5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBleHByZXNzaW9ucyA9IHRoYXQuYXJncy5leHByZXNzaW9ucztcblxuICAgICAgICAgICAgdmFyIHJlbGF0aW9uID0gdGhhdC5hcmdzLnJlbGF0aW9uO1xuXG4gICAgICAgICAgICAvLy8gQmVmb3JlR2V0SGVhZGVyXG5cbiAgICAgICAgICAgIHRoaXMuZWUub25jZSgnYmVmb3JlR2V0SGVhZGVyJywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgZGVidWcuZXh0ZW5kLnRyYWNlKCdiZWZvcmVHZXRIZWFkZXInKTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgYmFzZSByZWxhdGlvblxuXG4gICAgICAgICAgICAgICAgdGhhdC5oZWFkZXIoKS5jb3B5KHJlbGF0aW9uLmhlYWRlcigpKTtcblxuICAgICAgICAgICAgICAgIC8vLyBQYXJzZSBleHRlbnNpb24gYXR0cmlidXRlc1xuXG4gICAgICAgICAgICAgICAgXy5mb3JPd24oZXhwcmVzc2lvbnMsIGZ1bmN0aW9uIChleHByZXNzaW9uLCBrZXkpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBFeHByZXNzaW9uIG11c3QgYmUgYW4gb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIGlmICghXy5pc09iamVjdChleHByZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignV3JvbmcgZXhwcmVzc2lvbiBmb3JtYXQnKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhleHByZXNzaW9uKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBFeHByZXNzaW9uIG11c3QgaGF2ZSBvbmx5IG9uZSBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuaGFuZGxlZCBleHByZXNzaW9uIGRlY2xhcmF0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gYWRkXG4gICAgICAgICAgICAgICAgICAgIHZhciBleHRlbnNpb25OYW1lID0ga2V5c1swXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIHZhciBleHRlbnNpb25QYXJhbSA9IGV4cHJlc3Npb25bZXh0ZW5zaW9uTmFtZV07XG5cblxuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgcGFyYW0gaXMgb25seSBhbiBBdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgaWYoZXh0ZW5zaW9uUGFyYW0gaW5zdGFuY2VvZiBBdHRyaWJ1dGUpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNhbWUgdHlwZSBhcyB0aGUgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gZXh0ZW5zaW9uUGFyYW0udHlwZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgYXR0cmlidXRlIHRvIFR1cGxlQXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uc1trZXldW2V4dGVuc2lvbk5hbWVdID0gZXh0ZW5zaW9uUGFyYW0gPSBuZXcgKHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL3R1cGxlL0F0dHJpYnV0ZScpKShleHRlbnNpb25QYXJhbS5uYW1lKTtcblxuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGF0dHJpYnV0ZXMgb2JqZWN0cyB0byBmdW5jdGlvbnMgdGhhdCBpdGVyYXRlIHRocm91Z2ggdHVwbGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25QYXJhbS5jb252ZXJ0QXR0cmlidXRlVG9UdXBsZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJldHVybiB0eXBlIG9mIHRoZSBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gZXh0ZW5zaW9uUGFyYW0udHlwZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBLZXkgbXVzdCBub3QgYWxyZWFkeSBleGlzdCBpbiB0aGUgY3VycmVudCBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuaGVhZGVyKCkuZ2V0KGV4dGVuc2lvbk5hbWUpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbGF0aW9uIGV4dGVuc2lvbiBuYW1lIGFscmVhZHkgZXhpc3RzIGluIHRoZSBoZWFkZXInKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgbmV3IGhlYWRlciBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4dGVuc2lvbkF0dHJpYnV0ZSA9IG5ldyBBdHRyaWJ1dGUoe3R5cGU6IHR5cGUsIG5hbWU6IGV4dGVuc2lvbk5hbWV9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYXR0cmlidXRlIGlzIGEgY2FsY3VsYXRlZCBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlLmNhbGN1bGF0ZWQodHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBhdHRyaWJ1dGUgaW4gdGhlIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICB0aGF0LmhlYWRlcigpLmFkZChleHRlbnNpb25BdHRyaWJ1dGUpO1xuXG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgLy8vIEJlZm9yZUdldEJvZHlcblxuICAgICAgICAgICAgdGhpcy5lZS5vbmNlKCdiZWZvcmVHZXRCb2R5JywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgZGVidWcuZXh0ZW5kLnRyYWNlKCdiZWZvcmVHZXRCb2R5Jyk7XG5cbiAgICAgICAgICAgICAgICByZWxhdGlvbi5lYWNoKGZ1bmN0aW9uICh0dXBsZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYWZ0ZXJBZGQocmVsYXRpb24sIHR1cGxlKTtcblxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZWxhdGlvbi5lZS5vbignYWZ0ZXJBZGQnLCBmdW5jdGlvbih0dXBsZSwgaW5kZXgpe1xuICAgICAgICAgICAgICAgIHRoYXQuYWZ0ZXJBZGQodGhhdC5hcmdzLnJlbGF0aW9uLCB0dXBsZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmVsYXRpb24uZWUub24oJ2FmdGVyUmVtb3ZlJywgZnVuY3Rpb24odHVwbGUsIGluZGV4KXtcbiAgICAgICAgICAgICAgICB0aGF0LmFmdGVyUmVtb3ZlKHRoYXQuYXJncy5yZWxhdGlvbiwgdHVwbGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJlbGF0aW9uLmVlLm9uKCdhZnRlclVwZGF0ZScsIGZ1bmN0aW9uKHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpe1xuICAgICAgICAgICAgICAgIHRoYXQuYWZ0ZXJVcGRhdGUodGhhdC5hcmdzLnJlbGF0aW9uLCB0dXBsZSwgYXR0cmlidXRlTmFtZSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGV4dGVuZCBleHByZXNzaW9ucyB2YWx1ZXMgZm9yIGEgdHVwbGVcbiAgICAgICAgICogQHBhcmFtIHtUdXBsZX0gdHVwbGUgVGhlIHR1cGxlIHRvIGNhbGN1bGF0ZSBleHByZXNzaW9ucyBhZ2FpbnN0XG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xvbmUgZWl0aGVyIHRvIHJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgdHVwbGUsIG9yIHRoZSBwYXNzZWQgaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge1R1cGxlfSBUaGUgYnVpbHQgdHVwbGVcbiAgICAgICAgICovXG4gICAgICAgIGJ1aWxkVHVwbGUgOiBmdW5jdGlvbih0dXBsZSwgY2xvbmUpe1xuXG4gICAgICAgICAgICBpZiAoXy5pc0Jvb2xlYW4oY2xvbmUpKXtcbiAgICAgICAgICAgICAgICAvLyBjbG9uZSA9IGNsb25lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbG9uZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBuZXdUdXBsZTtcblxuICAgICAgICAgICAgaWYgKGNsb25lKXtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgdHVwbGUgd2UgYXJlIGdvaW5nIHRvIGFkZFxuICAgICAgICAgICAgICAgIG5ld1R1cGxlID0gbmV3IFR1cGxlKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBDb3B5IHRoZSBhdHRyaWJ1dGVzIGZyb20gdGhlIGJhc2UgdHVwbGVcbiAgICAgICAgICAgICAgICBuZXdUdXBsZS5jb3B5KHR1cGxlKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIG5ld1R1cGxlID0gdHVwbGU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgXy5mb3JFYWNoKHRoYXQuYXJncy5leHByZXNzaW9ucywgZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIG5ldyBhdHRyaWJ1dGUgbmFtZVxuICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gT2JqZWN0LmtleXMoZXhwcmVzc2lvbilbMF07XG5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBldmFsdWF0aW9uIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlRXhwcmVzc2lvbiA9IGV4cHJlc3Npb25bYXR0cmlidXRlTmFtZV07XG5cbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVFeHByZXNzaW9uLmFzc2lnblR1cGxlKG5ld1R1cGxlKTtcblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIG5ldyB2YWx1ZVxuICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uVmFsdWUgPSBhdHRyaWJ1dGVFeHByZXNzaW9uLnZhbHVlKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBMZXQncyBzZXQgdGhlIG5ldyB2YWx1ZSBpbiB0aGUgdHVwbGVcbiAgICAgICAgICAgICAgICBuZXdUdXBsZS5zZXQoYXR0cmlidXRlTmFtZSwgZXhwcmVzc2lvblZhbHVlKTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXdUdXBsZTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlckFkZCA6IGZ1bmN0aW9uKHJlbGF0aW9uLCBhZGRlZFR1cGxlKXtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGF0LmFkZCh0aGF0LmJ1aWxkVHVwbGUoYWRkZWRUdXBsZSkpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJSZW1vdmUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUsIGluZGV4KXtcblxuICAgICAgICAgICAgdmFyIG15VHVwbGUgPSB0aGlzLmJ1aWxkVHVwbGUodHVwbGUpO1xuXG4gICAgICAgICAgICB0aGlzLnJlbW92ZShteVR1cGxlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlclVwZGF0ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSwgYXR0cmlidXRlTmFtZSwgdmFsdWUsIG9sZFZhbHVlKXtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgdHVwbGVDbG9uZSA9IHR1cGxlLmNsb25lKCk7XG5cbiAgICAgICAgICAgIHR1cGxlQ2xvbmUuc2V0KGF0dHJpYnV0ZU5hbWUsIG9sZFZhbHVlKTtcblxuICAgICAgICAgICAgdHVwbGVDbG9uZSA9IHRoYXQuYnVpbGRUdXBsZSh0dXBsZUNsb25lKTtcblxuICAgICAgICAgICAgdmFyIG15VHVwbGUgPSAgdGhhdC5maW5kKHR1cGxlQ2xvbmUpO1xuXG4gICAgICAgICAgICBteVR1cGxlID0gdGhhdC5maW5kKG15VHVwbGUpO1xuXG4gICAgICAgICAgICBteVR1cGxlLnNldChhdHRyaWJ1dGVOYW1lLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgIHRoYXQuYnVpbGRUdXBsZShteVR1cGxlLCBmYWxzZSk7XG5cbiAgICAgICAgfVxuXG4gICAgfSwge1xuXG4gICAgICAgIHR5cGUgOiAnRXh0ZW5zaW9uJ1xuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRXh0ZW5kOyIsInZhciBSZWxhdGlvbiA9IHJlcXVpcmUoJy4vLi4vUmVsYXRpb24uanMnKTtcbnZhciBIZWFkZXIgPSByZXF1aXJlKCcuLy4uL0hlYWRlci5qcycpO1xudmFyIFR1cGxlID0gcmVxdWlyZSgnLi8uLi9UdXBsZS5qcycpO1xudmFyIEF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4vLi4vQXR0cmlidXRlLmpzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2RlYnVnJyk7XG5cblxuXG5cbnZhciBHcm91cCA9IFJlbGF0aW9uLmV4dGVuZChcblxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIE9wZXJhdG9ycy5Hcm91cFxuICAgICAgICAgKiBAZXh0ZW5kcyBSZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvbiBUaGUgcmVsYXRpb24gdG8gZ3JvdXBcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgVGhlIG5ldyBncm91cGVkIGF0dHJpYnV0ZSBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGF0dHJpYnV0ZXMgVGhlIGF0dHJpYnV0ZXMgdG8gZ3JvdXBcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIEdyb3VwIG9wZXJhdGlvbiB3aWxsIGdyb3VwIHRoZSBzcGVjaWZpZWQgdHVwbGUncyBhdHRyaWJ1dGVzIGludG8gb25lLlxuICAgICAgICAgKiBUaGUgcmVzdWx0aW5nIHR1cGxlcyB3aWxsIGhhdmUgYW4ge0BsaW5rIEF0dHJpYnV0ZX0gd2hvc2Uge0BsaW5rIFR5cGV9IHdpbGwgYmUgYSB7QGxpbmsgUmVsYXRpb259LiBTZWUgZXhhbXBsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkEgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge2E6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2I6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2M6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19XG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWzEsIDIsIDNdLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzQsIDUsIDZdLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzQsIDksIDldLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzcsIDgsIDldXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQiA9IHJlbGF0aW9uQS5ncm91cCgnZ3JvdXBlZEF0dHJpYnV0ZScsIFsnYicsICdjJ10pXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvL29yXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25CID0gbmV3IGFmZmluaXR5Lkdyb3VwKHJlbGF0aW9uQSwgJ2dyb3VwZWRBdHRyaWJ1dGUnLCBbJ2InLCdjJ10pXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyAgICAgICAgICAgICAgICAgPC0tLS1HUk9VUElORyBBVFRSSUJVVEUtLS0tLS0tLS0tPlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgYSA6IFRJbnRlZ2VyIHwgZ3JvdXBlZEF0dHJpYnV0ZSA6IFJlbGF0aW9uICAgICB8XG4gICAgICAgICAqICAgICAvLyArPT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgLy8gfCAxICAgICAgICAgICAgfCArLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgICogICAgIC8vIHwgICAgICAgICAgICAgIHwgfCBiIDogVEludGVnZXIgfCBjIDogVEludGVnZXIgfCB8XG4gICAgICAgICAqICAgICAvLyB8ICAgICAgICAgICAgICB8ICs9PT09PT09PT09PT09PSs9PT09PT09PT09PT09PSsgfFxuICAgICAgICAgKiAgICAgLy8gfCAgICAgICAgICAgICAgfCB8IDIgICAgICAgICAgICB8IDMgICAgICAgICAgICB8IHxcbiAgICAgICAgICogICAgIC8vIHwgICAgICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKyB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCA0ICAgICAgICAgICAgfCArLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgICogICAgIC8vIHwgICAgICAgICAgICAgIHwgfCBiIDogVEludGVnZXIgfCBjIDogVEludGVnZXIgfCB8XG4gICAgICAgICAqICAgICAvLyB8ICAgICAgICAgICAgICB8ICs9PT09PT09PT09PT09PSs9PT09PT09PT09PT09PSsgfFxuICAgICAgICAgKiAgICAgLy8gfCAgICAgICAgICAgICAgfCB8IDUgICAgICAgICAgICB8IDYgICAgICAgICAgICB8IHxcbiAgICAgICAgICogICAgIC8vIHwgICAgICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKyB8XG4gICAgICAgICAqICAgICAvLyB8ICAgICAgICAgICAgICB8IHwgOSAgICAgICAgICAgIHwgOSAgICAgICAgICAgIHwgfFxuICAgICAgICAgKiAgICAgLy8gfCAgICAgICAgICAgICAgfCArLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDcgICAgICAgICAgICB8ICstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLSsgfFxuICAgICAgICAgKiAgICAgLy8gfCAgICAgICAgICAgICAgfCB8IGIgOiBUSW50ZWdlciB8IGMgOiBUSW50ZWdlciB8IHxcbiAgICAgICAgICogICAgIC8vIHwgICAgICAgICAgICAgIHwgKz09PT09PT09PT09PT09Kz09PT09PT09PT09PT09KyB8XG4gICAgICAgICAqICAgICAvLyB8ICAgICAgICAgICAgICB8IHwgOCAgICAgICAgICAgIHwgOSAgICAgICAgICAgIHwgfFxuICAgICAgICAgKiAgICAgLy8gfCAgICAgICAgICAgICAgfCArLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHJlbGF0aW9uLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVzKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IGFyZ3NcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7UmVsYXRpb259IGFyZ3MucmVsYXRpb25cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBhcmdzLmdyb3VwaW5nQXR0cmlidXRlTmFtZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtTdHJpbmdbXX0gYXJncy5ncm91cGVkQXR0cmlidXRlTmFtZXNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXR0cmlidXRlW119IGFyZ3MuZ3JvdXBlZEF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXR0cmlidXRlfSBhcmdzLmdyb3VwaW5nQXR0cmlidXRlXG4gICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgZGVidWcuZ3JvdXAudHJhY2UoJyNjb25zdHJ1Y3RvcicpO1xuXG4gICAgICAgICAgICB0aGlzLmFyZ3MgPSB7fTtcblxuICAgICAgICAgICAgdGhpcy5hcmdzLnJlbGF0aW9uID0gcmVsYXRpb247XG5cbiAgICAgICAgICAgIHRoaXMuYXJncy5ncm91cGluZ0F0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xuXG4gICAgICAgICAgICB0aGlzLmFyZ3MuZ3JvdXBlZEF0dHJpYnV0ZU5hbWVzID0gYXR0cmlidXRlcztcblxuICAgICAgICAgICAgdGhpcy5hcmdzLmdyb3VwZWRBdHRyaWJ1dGVzID0gW107XG5cbiAgICAgICAgICAgIHRoaXMuYXJncy5ncm91cGluZ0F0dHJpYnV0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIENhbGxpbmcgdGhlIHBhcmVudCBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgUmVsYXRpb24uY2FsbCh0aGlzKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGJpbmRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgZGVidWcuZ3JvdXAudHJhY2UoJyNiaW5kRXZlbnRzJyk7XG5cbiAgICAgICAgICAgIC8vIENhbGxpbmcgdGhlIHBhcmVudCBiaW5kRXZlbnRzXG4gICAgICAgICAgICBHcm91cC5fX3N1cGVyX18uYmluZEV2ZW50cy5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZ3JvdXBlZEF0dHJpYnV0ZU5hbWVzID0gdGhpcy5hcmdzLmdyb3VwZWRBdHRyaWJ1dGVOYW1lcyxcbiAgICAgICAgICAgICAgICBncm91cGluZ0F0dHJpYnV0ZU5hbWUgPSB0aGlzLmFyZ3MuZ3JvdXBpbmdBdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgICAgIHJlbGF0aW9uID0gdGhpcy5hcmdzLnJlbGF0aW9uLFxuICAgICAgICAgICAgICAgIGdyb3VwZWRBdHRyaWJ1dGVzID0gdGhhdC5hcmdzLmdyb3VwZWRBdHRyaWJ1dGVzO1xuXG4gICAgICAgICAgICAvLyBCZWZvcmVHZXRIZWFkZXJcbiAgICAgICAgICAgIHRoYXQuZWUub25jZSgnYmVmb3JlR2V0SGVhZGVyJywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBoYXZlIHRoaXMga2luZCBvZiByZWxhdGlvblxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgICAgICAgIC8vIHwgYXR0cjMgOiA8dHlwZT4gfCBhdHRyNCA6IDx0eXBlPiB8IGdyb3VwZWRBdHRyIDogUmVsYXRpb24gICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAvLyArPT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBXaGVyZSBhdHRyMyBhbmQgYXR0cjQgYXJlIG5vbiBncm91cGVkIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAvLyBhbmQgZ3JvdXBlZEF0dHIgd2lsbCBjb250YWluIHRoZSBncm91cGVkIGF0dHJpYnV0ZXMgcmVsYXRpb25zXG4gICAgICAgICAgICAgICAgLy9cblxuICAgICAgICAgICAgICAgIHZhciBoZWFkZXIgPSByZWxhdGlvbi5oZWFkZXIoKTtcblxuICAgICAgICAgICAgICAgIGRlYnVnLmdyb3VwLnRyYWNlKCdiZWZvcmVHZXRIZWFkZXInKTtcblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIGF0dHJpYnV0ZXMgc3BlY2lmaWVkIGluIGdyb3VwZWRBdHRyaWJ1dGVOYW1lcyBleGlzdHMgaW4gdGhlIGJhc2UgaGVhZGVyXG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKGdyb3VwZWRBdHRyaWJ1dGVOYW1lcywgZnVuY3Rpb24oZ3JvdXBlZEF0dHJpYnV0ZU5hbWUpe1xuICAgICAgICAgICAgICAgICAgICBpZihoZWFkZXIuZ2V0KGdyb3VwZWRBdHRyaWJ1dGVOYW1lKSA9PT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSB3aXRoIG5hbWUgXCInK2dyb3VwZWRBdHRyaWJ1dGVOYW1lKydcIiBkb2VzIG5vdCBleGlzdCBpbiB0aGUgaGVhZGVyJylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGVhY2ggb2YgdGhlIHJlbGF0aW9uJ3MgaGVhZGVyIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICBoZWFkZXIuZWFjaChmdW5jdGlvbihhdHRyaWJ1dGUpe1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBhdHRyaWJ1dGUgaXMgcGFydCBvZiB0aGUgZ3JvdXBlZCBhdHRyaWJ1dGVzXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXNlbnQgPSBfLmFueShncm91cGVkQXR0cmlidXRlTmFtZXMsIGZ1bmN0aW9uKGdyb3VwZWRBdHRyaWJ1dGVOYW1lKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBncm91cGVkQXR0cmlidXRlTmFtZSA9PT0gYXR0cmlidXRlLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKCFwcmVzZW50KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0IGlzIG5vdCBwcmVzZW50LCBhZGQgaXQgdG8gdGhlIGhlYWRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuaGVhZGVyKCkuYWRkKGF0dHJpYnV0ZS5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0IGlzIHByZXNlbnQsIHN0b3JlIGl0IGluIHRoZSBncm91cGVkQXR0cmlidXRlTmFtZXMgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwZWRBdHRyaWJ1dGVzLnB1c2goYXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBMZXQncyBjcmVhdGUgdGhlIGdyb3VwaW5nQXR0cmlidXRlTmFtZSBhbmQgYWRkIGl0IHRvIHRoZSBoZWFkZXJcblxuICAgICAgICAgICAgICAgIHRoYXQuYXJncy5ncm91cGluZ0F0dHJpYnV0ZSA9IG5ldyBBdHRyaWJ1dGUoe25hbWUgOiBncm91cGluZ0F0dHJpYnV0ZU5hbWUsIHR5cGUgOiBSZWxhdGlvbn0pO1xuXG4gICAgICAgICAgICAgICAgdGhhdC5oZWFkZXIoKS5hZGQodGhhdC5hcmdzLmdyb3VwaW5nQXR0cmlidXRlKTtcblxuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgLy8gQmVmb3JlR2V0Qm9keVxuICAgICAgICAgICAgdGhhdC5lZS5vbmNlKCdiZWZvcmVHZXRCb2R5JywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgZGVidWcuZ3JvdXAudHJhY2UoJ2JlZm9yZUdldEJvZHknKTtcblxuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBoZWFkZXIgaXMgY29tcHV0ZWRcblxuICAgICAgICAgICAgICAgIHRoYXQuaGVhZGVyKCk7XG5cblxuICAgICAgICAgICAgICAgIC8vIExldCdzIGxvb3AgdGhyb3VnaCBlYWNoIG9mIHRoZSByZWxhdGlvbidzIHR1cGxlc1xuXG4gICAgICAgICAgICAgICAgcmVsYXRpb24uZWFjaChmdW5jdGlvbih0dXBsZSl7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB2YXJpYWJsZSB3aWxsIHN0b3JlIHRoZSB0dXBsZSBncm91cGVkIGF0dHJpYnV0ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwZWRBdHRyaWJ1dGVWYWx1ZXMgPSB7fTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHZhcmlhYmxlIHdpbGwgc3RvcmUgdGhlIHR1cGxlIG5vbi1ncm91cGVkIGF0dHJpYnV0ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vbkdyb3VwZWRBdHRyaWJ1dGVWYWx1ZXMgPSB7fTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBOb3csIHdlIHdpbGwgYnVpbGQgdGhlc2UgdmFyaWFibGVzXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTGV0J3MgbG9vcCB0aHJvdWdoIGVhY2ggb2YgdGhlIHR1cGxlJ3MgYXR0cmlidXRlIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICB0dXBsZS5lYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY3VycmVudCB0dXBsZSBhdHRyaWJ1dGUgaXMgZ3JvdXBlZCBvciBub3QgZ3JvdXBlZFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwZWQgPSBfLmFueSh0aGF0LmFyZ3MuZ3JvdXBlZEF0dHJpYnV0ZXMsIGZ1bmN0aW9uKGdyb3VwZWRBdHRyaWJ1dGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXkgPT09IGdyb3VwZWRBdHRyaWJ1dGUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihncm91cGVkKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFR1cGxlIGF0dHJpYnV0ZSBpcyBwYXJ0IG9mIHRoZSBncm91cGVkIGF0dHJpYnV0ZXNcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwZWRBdHRyaWJ1dGVWYWx1ZXNba2V5XSA9IHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHVwbGUgYXR0cmlidXRlIGlzIG5vdCBwYXJ0IG9mIHRoZSBncm91cGVkIGF0dHJpYnV0ZXNcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vbkdyb3VwZWRBdHRyaWJ1dGVWYWx1ZXNba2V5XSA9IHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZ3JvdXBlZEF0dHJpYnV0ZVZhbHVlcyBhbmQgbm9uR3JvdXBlZEF0dHJpYnV0ZVZhbHVlcyBhcmUgbm93IGJ1aWx0XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHN0YXJ0ZWQgd2l0aCBhIHR1cGxlIGxpa2VcbiAgICAgICAgICAgICAgICAgICAgLy8geyBhdHRyMSA6IHZhbHVlLCBhdHRyMiA6IHZhbHVlLCBhdHRyMzogdmFsdWUsIGF0dHI0IDogdmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGdyb3VwZWQgJ2F0dHIxJyBhbmQgJ2F0dHIyJ1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBBbmQgd2Ugc2ltcGx5IGRpdmlkZWQgdGhlIHR1cGxlcyBpbnRvIHR3byBvYmplY3RzLCBvbmUgY29udGFpbmluZyB0aGUgYXR0cmlidXRlIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IGFyZSBzdXBwb3NlZCB0byBiZSBncm91cGVkLCBhbmQgYW5vdGhlciB0aGF0IGlzIG5vdCBzdXBwb3NlZCB0byBiZSBncm91cGVkXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXkgc2hvdWxkIGxvb2sgc29tZXdoYXQgbGlrZSA6XG4gICAgICAgICAgICAgICAgICAgIC8vIGdyb3VwZWRBdHRyaWJ1dGVWYWx1ZXMgOiB7IGF0dHIxIDogdmFsdWUsIGF0dHIyIDogdmFsdWUsIC4uLiB9XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vbkdyb3VwZWRBdHRyaWJ1dGVWYWx1ZXMgOiB7IGF0dHIzIDogdmFsdWUsIGF0dHI0IDogdmFsdWUsIC4uLn1cblxuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHR3byB0dXBsZXMgaGF2ZSB0aGUgc2FtZSBub24gZ3JvdXBlZCBhdHRyaWJ1dGUgdmFsdWVzLCB3aGF0IHdlIHdpbGwgZG9cbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgbWVyZ2UgdGhlaXIgbm9uR3JvdXBlZEF0dHJpYnV0ZVZhbHVlcyBpbnRvIGEgXCJuZXN0ZWQgcmVsYXRpb25cIiwgbWVhbmluZ1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IHdlIHdpbGwgaGF2ZSBhIHJlbGF0aW9uIHRoYXQgd2lsbCBjb250YWluIHJlbGF0aW9ucy5cblxuXG4gICAgICAgICAgICAgICAgICAgIC8vIExldCdzIGxvb3AgdGhyb3VnaCBlYWNoIHR1cGxlIG9mIHRoZSBiZWluZy1idWlsdCByZWxhdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgc2VlIGlmIGEgdHVwbGUgYWxyZWFkeSBleGlzdHMgd2l0aCB0aGUgc2FtZSBub25Hcm91cGVkQXR0cmlidXRlVmFsdWVzXG5cblxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hpbmdUdXBsZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhhdC5lYWNoKGZ1bmN0aW9uKHR1cGxlKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgXy5mb3JPd24obm9uR3JvdXBlZEF0dHJpYnV0ZVZhbHVlcywgZnVuY3Rpb24odmFsdWUsIGtleSl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0dXBsZS5nZXQoa2V5KSAhPT0gdmFsdWUpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG1hdGNoKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZ1R1cGxlID0gdHVwbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoaW5nVHVwbGUgPT09IG51bGwpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHR1cGxlIHdpdGggdGhlIHNhbWUgbm9uIGdyb3VwZWQgYXR0cmlidXRlIHZhbHVlcyBoYXMgbm90IGJlZW4gZm91bmQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSB3aWxsIGNyZWF0ZSBpdCBhbmQgY3JlYXRlIHRoZSBuZXN0ZWQgcmVsYXRpb24gdG9vLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VHVwbGUgPSBuZXcgVHVwbGUobm9uR3JvdXBlZEF0dHJpYnV0ZVZhbHVlcyk7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB0dXBsZSBzaG91bGQgbG9vayBsaWtlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gfCBhdHRyMyA6IDx0eXBlPiB8IGF0dHI0IDogPHR5cGU+IHxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICs9PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT0rXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB8IHZhbHVlICAgICAgICAgIHwgdmFsdWUgICAgICAgICAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLStcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGluZyB0aGUgcmVsYXRpb25cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1JlbGF0aW9uID0gbmV3IFJlbGF0aW9uKCk7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkaW5nIHRoZSBncm91cGVkIGF0dHJpYnV0ZXMgdG8gdGhlIG5ldyBuZXN0ZWQgcmVsYXRpb24gaGVhZGVyXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF8uZm9yT3duKGdyb3VwZWRBdHRyaWJ1dGVzLCBmdW5jdGlvbihhdHRyaWJ1dGUpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UmVsYXRpb24uaGVhZGVyKCkuYWRkKGF0dHJpYnV0ZS5jbG9uZSgpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHdpbGwgc3RvcmUgdGhlIHJlbGF0aW9uIGhlYWRlciBpbiB0aGUgcm9vdCByZWxhdGlvbiBoZWFkZXIgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTbyB0aGF0IHdlIHdpbGwga25vdyB3aGF0IGtpbmQgb2YgcmVsYXRpb24gdGhpcyBpcyB3aXRob3V0IGhhdmluZyB0byBhY2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBib2R5XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYXJncy5ncm91cGluZ0F0dHJpYnV0ZS5yZWxhdGlvbkhlYWRlciA9IG5ld1JlbGF0aW9uLmhlYWRlcigpLmNsb25lKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcmVsYXRpb24gc2hvdWxkIGxvb2sgbGlrZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHwgYXR0cjEgOiA8dHlwZT4gfCBhdHRyMiA6IDx0eXBlPiB8XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyArPT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09K1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldHRpbmcgdGhlIHJlbGF0aW9uIGluIHRoZSB0dXBsZSBncm91cGVkIGF0dHJpYnV0ZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdUdXBsZS5zZXQoZ3JvdXBpbmdBdHRyaWJ1dGVOYW1lLCBuZXdSZWxhdGlvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0dXBsZSB3aWxsIG5vdyBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gfCBhdHRyMyA6IDx0eXBlPiB8IGF0dHI0IDogPHR5cGU+IHwgZ3JvdXBlZEF0dHIgOiBSZWxhdGlvbiAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKz09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gfCB2YWx1ZSAgICAgICAgICB8IHZhbHVlICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLSsgfFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gfCAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgIHwgfCBhdHRyMSA6IDx0eXBlPiB8IGF0dHIyIDogPHR5cGU+IHwgfFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gfCAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgIHwgKz09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PSsgfFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuXG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkaW5nIHRoZSB0dXBsZSB0byB0aGUgcmVsYXRpb25cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5hZGQobmV3VHVwbGUsIGZhbHNlKTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBIG1hdGNoaW5nIHR1cGxlIG5vdyBleGlzdHMgYmVjYXVzZSB3ZSBqdXN0IGNyZWF0ZWQgaXRcblxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmdUdXBsZSA9IG5ld1R1cGxlO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjcmVhdGUgdGhlIHR1cGxlIHRoYXQgd2lsbCBiZSBpbnNlcnRlZCBpbiB0aGUgbmVzdGVkIHJlbGF0aW9uXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5lc3RlZFR1cGxlID0gbmV3IFR1cGxlKGdyb3VwZWRBdHRyaWJ1dGVWYWx1ZXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFkZCB0aGlzIHR1cGxlIHRvIHRoZSBuZXN0ZWQgcmVsYXRpb25cblxuICAgICAgICAgICAgICAgICAgICBtYXRjaGluZ1R1cGxlLmdldChncm91cGluZ0F0dHJpYnV0ZU5hbWUpLmFkZChuZXN0ZWRUdXBsZSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFuZCB2b2lsw6AhXG5cbiAgICAgICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQmluZHMgdGhlIGJhc2UgcmVsYXRpb24gYWZ0ZXJBZGQgZXZlbnRcbiAgICAgICAgICAgIHRoYXQuYXJncy5yZWxhdGlvbi5lZS5vbignYWZ0ZXJBZGQnLCBmdW5jdGlvbih0dXBsZSwgaW5kZXgpe1xuICAgICAgICAgICAgICAgIHRoYXQuYWZ0ZXJBZGQocmVsYXRpb24sIHR1cGxlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBCaW5kcyB0aGUgYmFzZSByZWxhdGlvbiBhZnRlclJlbW92ZSBldmVudFxuICAgICAgICAgICAgdGhhdC5hcmdzLnJlbGF0aW9uLmVlLm9uKCdhZnRlclJlbW92ZScsIGZ1bmN0aW9uKHR1cGxlLCBpbmRleCl7XG4gICAgICAgICAgICAgICAgdGhhdC5hZnRlclJlbW92ZShyZWxhdGlvbiwgdHVwbGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEJpbmRzIHRoZSBiYXNlIHJlbGF0aW9uIGFmdGVyVXBkYXRlIGV2ZW50XG4gICAgICAgICAgICB0aGF0LmFyZ3MucmVsYXRpb24uZWUub24oJ2FmdGVyVXBkYXRlJywgZnVuY3Rpb24odHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSl7XG4gICAgICAgICAgICAgICAgdGhhdC5hZnRlclVwZGF0ZShyZWxhdGlvbiwgdHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBoYW5kbGVyIHdoZW4gYSB0dXBsZSBoYXMgYmVlbiBhZGRlZCB0byB0aGUgYmFzZSByZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1R1cGxlfSB0dXBsZVxuICAgICAgICAgKi9cbiAgICAgICAgYWZ0ZXJBZGQgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUpe1xuICAgICAgICAgICAgZGVidWcuZ3JvdXAudHJhY2UoJ0dyb3VwI2FmdGVyQWRkJyk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5hcmdzLnJlbGF0aW9uLmdyb3VwKHRoaXMuYXJncy5ncm91cGluZ0F0dHJpYnV0ZU5hbWUsIHRoaXMuYXJncy5ncm91cGVkQXR0cmlidXRlTmFtZXMpO1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RUbyhyZXN1bHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBoYW5kbGVyIHdoZW4gYSB0dXBsZSBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIGJhc2UgcmVsYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtSZWxhdGlvbn0gcmVsYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtUdXBsZX0gdHVwbGVcbiAgICAgICAgICovXG4gICAgICAgIGFmdGVyUmVtb3ZlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcbiAgICAgICAgICAgIGRlYnVnLmdyb3VwLnRyYWNlKCdHcm91cCNhZnRlclJlbW92ZScpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuYXJncy5yZWxhdGlvbi5ncm91cCh0aGlzLmFyZ3MuZ3JvdXBpbmdBdHRyaWJ1dGVOYW1lLCB0aGlzLmFyZ3MuZ3JvdXBlZEF0dHJpYnV0ZU5hbWVzKTtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0VG8ocmVzdWx0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgaGFuZGxlciB3aGVuIGEgdHVwbGUgaGFzIGJlZW4gdXBkYXRlZCBmcm9tIHRoZSBiYXNlIHJlbGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7VHVwbGV9IHR1cGxlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVOYW1lXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYWZ0ZXJVcGRhdGUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSl7XG4gICAgICAgICAgICBkZWJ1Zy5ncm91cC50cmFjZSgnR3JvdXAjYWZ0ZXJVcGRhdGUnKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmFyZ3MucmVsYXRpb24uZ3JvdXAodGhpcy5hcmdzLmdyb3VwaW5nQXR0cmlidXRlTmFtZSwgdGhpcy5hcmdzLmdyb3VwZWRBdHRyaWJ1dGVOYW1lcyk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFRvKHJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgIH0sIHtcblxuICAgICAgICB0eXBlIDogJ0dyb3VwJ1xuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gR3JvdXA7IiwidmFyIFJlbGF0aW9uID0gcmVxdWlyZSgnLi8uLi9SZWxhdGlvbi5qcycpO1xudmFyIEhlYWRlciA9IHJlcXVpcmUoJy4vLi4vSGVhZGVyLmpzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2RlYnVnJyk7XG5cblxudmFyIEludGVyc2VjdGlvbiA9IFJlbGF0aW9uLmV4dGVuZChcblxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIE9wZXJhdG9ycy5JbnRlcnNlY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtSZWxhdGlvbn0gcmVsYXRpb25BXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uQlxuICAgICAgICAgKiBAZXh0ZW5kcyBSZWxhdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgaW50ZXJzZWN0aW9uIGNyZWF0ZXMgYSBuZXcgcmVsYXRpb24gd2l0aCB0dXBsZXMgY29tbW9uIGluIHJlbGF0aW9uQSBhbmQgcmVsYXRpb25CXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsMSA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICB7YTogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgICB7YjogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgICB7YzogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX1cbiAgICAgICAgICogICAgICAgXSwgW1xuICAgICAgICAgKiAgICAgICAgICAgWzEsIDIsIDNdLFxuICAgICAgICAgKiAgICAgICAgICAgWzQsIDUsIDZdLFxuICAgICAgICAgKiAgICAgICAgICAgWzcsIDgsIDldXG4gICAgICAgICAqICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbDIgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICB7YTogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgIHtiOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgICAgICAge2M6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19XG4gICAgICAgICAqICAgICAgXSwgW1xuICAgICAgICAgKiAgICAgICAgICBbMSwgMiwgM11cbiAgICAgICAgICogICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICp2ICAgIGFyIHJlbDMgPSBuZXcgYWZmaW5pdHkuSW50ZXJzZWN0aW9uKHJlbDEsIHJlbDIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBhIDogVEludGVnZXIgfCBiIDogVEludGVnZXIgfCBjIDogVEludGVnZXIgfFxuICAgICAgICAgKiAgICAgLy8gKz09PT09PT09PT09PT09Kz09PT09PT09PT09PT09Kz09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgLy8gfCAxICAgICAgICAgICAgfCAyICAgICAgICAgICAgfCAzICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKi9cblxuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHJlbGF0aW9uQSwgcmVsYXRpb25CKSB7XG5cbiAgICAgICAgICAgIHRoaXMucmVscyA9IFtyZWxhdGlvbkEsIHJlbGF0aW9uQl07XG5cbiAgICAgICAgICAgIFJlbGF0aW9uLmNhbGwodGhpcyk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLmludGVyc2VjdGlvbi50cmFjZSgnI2JpbmRFdmVudHMnKTtcblxuICAgICAgICAgICAgSW50ZXJzZWN0aW9uLl9fc3VwZXJfXy5iaW5kRXZlbnRzLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIHJlbDEgPSB0aGF0LnJlbHNbMF0sXG4gICAgICAgICAgICAgICAgcmVsMiA9IHRoYXQucmVsc1sxXTtcblxuXG4gICAgICAgICAgICAvLyBCZWZvcmVHZXRIZWFkZXJcblxuICAgICAgICAgICAgdGhpcy5lZS5vbmNlKCdiZWZvcmVHZXRIZWFkZXInLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVyMSA9IHJlbDEuaGVhZGVyKCk7XG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlcjIgPSByZWwyLmhlYWRlcigpO1xuXG4gICAgICAgICAgICAgICAgZGVidWcuaW50ZXJzZWN0aW9uLnRyYWNlKCdiZWZvcmVHZXRIZWFkZXInKTtcblxuICAgICAgICAgICAgICAgIEhlYWRlci5hc3NlcnRVbmlvbkNvbXBhdGlibGUoaGVhZGVyMSwgaGVhZGVyMik7XG5cbiAgICAgICAgICAgICAgICB0aGF0LmhlYWRlcigpLmNvcHkoaGVhZGVyMSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgIC8vIEJlZm9yZUdldEJvZHlcblxuICAgICAgICAgICAgdGhpcy5lZS5vbmNlKCdiZWZvcmVHZXRCb2R5JywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgZGVidWcuaW50ZXJzZWN0aW9uLnRyYWNlKCdiZWZvcmVHZXRCb2R5Jyk7XG5cbiAgICAgICAgICAgICAgICByZWwxLmVhY2goZnVuY3Rpb24gKHR1cGxlMSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWwyLmluZGV4KHR1cGxlMSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYWRkKHR1cGxlMS5jbG9uZSgpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJMZWZ0QWRkIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyTGVmdFJlbW92ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSl7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlckxlZnRVcGRhdGUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSl7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlclJpZ2h0QWRkIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyUmlnaHRSZW1vdmUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUpe1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJSaWdodFVwZGF0ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSwgYXR0cmlidXRlTmFtZSwgdmFsdWUsIG9sZFZhbHVlKXtcblxuICAgICAgICB9XG5cbiAgICB9LCB7XG5cbiAgICAgICAgdHlwZSA6ICdJbnRlcnNlY3Rpb24nXG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcnNlY3Rpb247IiwidmFyIFJlbGF0aW9uID0gcmVxdWlyZSgnLi8uLi9SZWxhdGlvbi5qcycpO1xudmFyIEhlYWRlciA9IHJlcXVpcmUoJy4vLi4vSGVhZGVyLmpzJyk7XG52YXIgVHVwbGUgPSByZXF1aXJlKCcuLy4uL1R1cGxlLmpzJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvZGVidWcnKTtcblxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxuXG5cbnZhciBKb2luID0gUmVsYXRpb24uZXh0ZW5kKFxuXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgT3BlcmF0b3JzLkpvaW5cbiAgICAgICAgICogQHBhcmFtIHtSZWxhdGlvbn0gcmVsYXRpb25BXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uQlxuICAgICAgICAgKiBAZXh0ZW5kcyBSZWxhdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgSm9pbiBvcGVyYXRpb24gcmV0dXJucyBhbGwgcG9zc2libGUgY29tYmluYXRpb25zIG9mIHR1cGxlcyBmcm9tIHJlbGF0aW9uQSBhbmQgcmVsYXRpb25CIHdoZXJlXG4gICAgICAgICAqIHRoZSB0dXBsZXMgaGF2ZSB0aGUgc2FtZSB2YWx1ZSBmb3IgdGhlaXIgY29tbW9uIGF0dHJpYnV0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25BID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgICAgIHtjaGFyYWN0ZXJJZDogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7Zmlyc3ROYW1lOiB7IHR5cGU6IGFmZmluaXR5LlN0cmluZ319LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2xhc3ROYW1lOiB7IHR5cGU6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWzEsICdKb2huJywgJ0RvZSddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzIsICdNYXJ5JywgJ1BvcHBpbnMnXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFszLCAnTHVja3knLCAnTHVrZSddXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7Y2hhcmFjdGVySWQ6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2ZhbjogeyB0eXBlOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsxLCAnTXIgWCddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzEsICdNaXNzIERpYmJsZSddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzIsICdOYXQgQmliYmxlJ11cbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25DID0gcmVsYXRpb25BLmpvaW4ocmVsYXRpb25CKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG9yXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25DID0gbmV3IGFmZmluaXR5LkpvaW4ocmVsYXRpb25BLCByZWxhdGlvbkIpXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyA8LS0tQ09NTU9OIEFUVFJJQlVURS0tLS0+XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IGNoYXJhY3RlcklkIDogVEludGVnZXIgfCBmaXJzdE5hbWUgOiBUU3RyaW5nIHwgbGFzdE5hbWUgOiBUU3RyaW5nIHwgZmFuIDogVFN0cmluZyB8XG4gICAgICAgICAqICAgICAvLyArPT09PT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAvLyB8IDEgICAgICAgICAgICAgICAgICAgICAgfCBKb2huICAgICAgICAgICAgICAgIHwgRG9lICAgICAgICAgICAgICAgIHwgTXIgWCAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDIgICAgICAgICAgICAgICAgICAgICAgfCBKb2huICAgICAgICAgICAgICAgIHwgRG9lICAgICAgICAgICAgICAgIHwgTWlzcyBEaWJibGUgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDMgICAgICAgICAgICAgICAgICAgICAgfCBNYXJ5ICAgICAgICAgICAgICAgIHwgUG9wcGlucyAgICAgICAgICAgIHwgTmF0IEJpYmJsZSAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvL1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIChyZWxhdGlvbkEsIHJlbGF0aW9uQikge1xuXG4gICAgICAgICAgICB0aGlzLnJlbHMgPSBbcmVsYXRpb25BLCByZWxhdGlvbkJdO1xuICAgICAgICAgICAgdGhpcy5fY29tbW9uQXR0cmlidXRlcyA9IFtdO1xuXG4gICAgICAgICAgICBSZWxhdGlvbi5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLmpvaW4udHJhY2UoJyNiaW5kRXZlbnRzJyk7XG5cbiAgICAgICAgICAgIEpvaW4uX19zdXBlcl9fLmJpbmRFdmVudHMuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgcmVsMSA9IHRoYXQucmVsc1swXTtcbiAgICAgICAgICAgIHZhciByZWwyID0gdGhhdC5yZWxzWzFdO1xuXG4gICAgICAgICAgICAvLyBCZWZvcmVHZXRIZWFkZXJcblxuICAgICAgICAgICAgdGhpcy5lZS5vbmNlKCdiZWZvcmVHZXRIZWFkZXInLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICBkZWJ1Zy5qb2luLnRyYWNlKCdiZWZvcmVHZXRIZWFkZXInKTtcblxuICAgICAgICAgICAgICAgIHZhciBoZWFkZXIxID0gcmVsMS5oZWFkZXIoKTtcbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVyMiA9IHJlbDIuaGVhZGVyKCk7XG5cbiAgICAgICAgICAgICAgICBIZWFkZXIuYXNzZXJ0U2FtZU5hbWVTYW1lVHlwZShoZWFkZXIxLCBoZWFkZXIyKTtcblxuICAgICAgICAgICAgICAgIHRoYXQuY29tbW9uQXR0cmlidXRlcyA9IEhlYWRlci5jb21tb25BdHRyaWJ1dGVzKGhlYWRlcjEsIGhlYWRlcjIpO1xuXG4gICAgICAgICAgICAgICAgdGhhdC5oZWFkZXIoKS5jb3B5KGhlYWRlcjEpO1xuICAgICAgICAgICAgICAgIHRoYXQuaGVhZGVyKCkuY29weShoZWFkZXIyKTtcblxuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgLy8gQmVmb3JlR2V0Qm9keVxuXG4gICAgICAgICAgICB0aGlzLmVlLm9uY2UoJ2JlZm9yZUdldEJvZHknLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICB0aGF0LmhlYWRlcigpO1xuXG4gICAgICAgICAgICAgICAgZGVidWcuam9pbi50cmFjZSgnYmVmb3JlR2V0Qm9keScpO1xuXG4gICAgICAgICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGVhY2ggYm9keSBvZiB0aGUgZmlyc3QgcmVsYXRpb25cbiAgICAgICAgICAgICAgICByZWwxLmVhY2goZnVuY3Rpb24gKHR1cGxlMSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIHR1cGxlcyBvZiB0aGUgc2Vjb25kIHJlbGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJlbDIuZWFjaChmdW5jdGlvbiAodHVwbGUyKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IFR1cGxlLm1hdGNoT25BdHRyaWJ1dGVzKHR1cGxlMSwgdHVwbGUyLCB0aGF0LmNvbW1vbkF0dHJpYnV0ZXMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIG1hdGNoIHdhcyBkZXRlY3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDbG9uZSB0aGUgZmlyc3QgdHVwbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VHVwbGUgPSBuZXcgVHVwbGUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvcHkgdGhlIGpvaW5lZCB0dXBsZSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VHVwbGUuY29weSh0dXBsZTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1R1cGxlLmNvcHkodHVwbGUyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZW4gYWRkIGl0IHRvIHRoZSByZWxhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYWRkKG5ld1R1cGxlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhhdCk7XG5cbiAgICAgICAgICAgICAgICB9LCB0aGF0KVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhhdC5yZWxzWzBdLmVlLm9uKCdhZnRlckFkZCcsIGZ1bmN0aW9uKHR1cGxlLCBpbmRleCl7XG4gICAgICAgICAgICAgICAgdGhhdC5hZnRlckxlZnRBZGQodGhhdC5yZWxzWzBdLCB0dXBsZSwgaW5kZXgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoYXQucmVsc1sxXS5lZS5vbignYWZ0ZXJBZGQnLCBmdW5jdGlvbih0dXBsZSwgaW5kZXgpe1xuICAgICAgICAgICAgICAgIHRoYXQuYWZ0ZXJSaWdodEFkZCh0aGF0LnJlbHNbMV0sIHR1cGxlLCBpbmRleCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhhdC5yZWxzWzBdLmVlLm9uKCdhZnRlclJlbW92ZScsIGZ1bmN0aW9uKHR1cGxlLCBpbmRleCl7XG4gICAgICAgICAgICAgICAgdGhhdC5hZnRlckxlZnRSZW1vdmUodGhhdC5yZWxzWzBdLCB0dXBsZSwgaW5kZXgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoYXQucmVsc1sxXS5lZS5vbignYWZ0ZXJSZW1vdmUnLCBmdW5jdGlvbih0dXBsZSwgaW5kZXgpe1xuICAgICAgICAgICAgICAgIHRoYXQuYWZ0ZXJSaWdodFJlbW92ZSh0aGF0LnJlbHNbMF0sIHR1cGxlLCBpbmRleCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhhdC5yZWxzWzBdLmVlLm9uKCdhZnRlclVwZGF0ZScsIGZ1bmN0aW9uKHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpe1xuICAgICAgICAgICAgICAgIHRoYXQuYWZ0ZXJMZWZ0VXBkYXRlKHRoYXQucmVsc1swXSwgdHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhhdC5yZWxzWzFdLmVlLm9uKCdhZnRlclVwZGF0ZScsIGZ1bmN0aW9uKHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpe1xuICAgICAgICAgICAgICAgIHRoYXQuYWZ0ZXJMZWZ0VXBkYXRlKHRoYXQucmVsc1swXSwgdHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJMZWZ0QWRkIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcbiAgICAgICAgICAgIGRlYnVnLmdyb3VwLnRyYWNlKCdKb2luI2FmdGVyTGVmdEFkZCcpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVsc1swXS5qb2luKHRoaXMucmVsc1sxXSk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFRvKHJlc3VsdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJMZWZ0UmVtb3ZlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcbiAgICAgICAgICAgIGRlYnVnLmdyb3VwLnRyYWNlKCdKb2luI2FmdGVyTGVmdFJlbW92ZScpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVsc1swXS5qb2luKHRoaXMucmVsc1sxXSk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFRvKHJlc3VsdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJMZWZ0VXBkYXRlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpe1xuICAgICAgICAgICAgZGVidWcuZ3JvdXAudHJhY2UoJ0pvaW4jYWZ0ZXJMZWZ0VXBkYXRlJyk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZWxzWzBdLmpvaW4odGhpcy5yZWxzWzFdKTtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0VG8ocmVzdWx0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlclJpZ2h0QWRkIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcbiAgICAgICAgICAgIGRlYnVnLmdyb3VwLnRyYWNlKCdKb2luI2FmdGVyUmlnaHRBZGQnKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlbHNbMF0uam9pbih0aGlzLnJlbHNbMV0pO1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RUbyhyZXN1bHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyUmlnaHRSZW1vdmUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUpe1xuICAgICAgICAgICAgZGVidWcuZ3JvdXAudHJhY2UoJ0pvaW4jYWZ0ZXJSaWdodFJlbW92ZScpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVsc1swXS5qb2luKHRoaXMucmVsc1sxXSk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFRvKHJlc3VsdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJSaWdodFVwZGF0ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSwgYXR0cmlidXRlTmFtZSwgdmFsdWUsIG9sZFZhbHVlKXtcbiAgICAgICAgICAgIGRlYnVnLmdyb3VwLnRyYWNlKCdKb2luI2FmdGVyUmlnaHRVcGRhdGUnKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlbHNbMF0uam9pbih0aGlzLnJlbHNbMV0pO1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RUbyhyZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICB9LCB7XG5cbiAgICAgICAgdHlwZSA6ICdKb2luJ1xuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSm9pbjsiLCJ2YXIgUmVsYXRpb24gPSByZXF1aXJlKCcuLy4uL1JlbGF0aW9uLmpzJyk7XG52YXIgSGVhZGVyID0gcmVxdWlyZSgnLi8uLi9IZWFkZXIuanMnKTtcbnZhciBUdXBsZSA9IHJlcXVpcmUoJy4vLi4vVHVwbGUuanMnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvZGVidWcnKTtcblxuXG5cbnZhciBQcm9kdWN0ID0gUmVsYXRpb24uZXh0ZW5kKFxuXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgT3BlcmF0b3JzLlByb2R1Y3RcbiAgICAgICAgICogQHBhcmFtIHtSZWxhdGlvbn0gcmVsYXRpb25BXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uQlxuICAgICAgICAgKiBAZXh0ZW5kcyBSZWxhdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBFeGFtcGxlIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkEgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge2NoYXJhY3RlcklkOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtmaXJzdE5hbWU6IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7bGFzdE5hbWU6IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbMSwgJ0pvaG4nLCAnRG9lJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbMiwgJ01hcnknLCAnUG9wcGlucyddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzMsICdMdWNreScsICdMdWtlJ11cbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25CID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgICAgIHtwcm9kdWN0OiB7IHR5cGU6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWydEb2xsJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ1BsYXlNb2JpbGUnXSxcbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25DID0gcmVsYXRpb25BLnByb2R1Y3QocmVsYXRpb25CKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG9yXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25DID0gbmV3IGFmZmluaXR5LlByb2R1Y3QocmVsYXRpb25BLCByZWxhdGlvbkIpXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBjaGFyYWN0ZXJJZCA6IFRJbnRlZ2VyIHwgZmlyc3ROYW1lIDogVFN0cmluZyB8IGxhc3ROYW1lIDogVFN0cmluZyB8IHByb2R1Y3QgOiBUU3RyaW5nIHxcbiAgICAgICAgICogICAgIC8vICs9PT09PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAvLyB8IDEgICAgICAgICAgICAgICAgICAgICAgfCBKb2huICAgICAgICAgICAgICAgIHwgRG9lICAgICAgICAgICAgICAgIHwgRG9sbCAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMiAgICAgICAgICAgICAgICAgICAgICB8IEpvaG4gICAgICAgICAgICAgICAgfCBEb2UgICAgICAgICAgICAgICAgfCBQbGF5TW9iaWxlICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAxICAgICAgICAgICAgICAgICAgICAgIHwgTWFyeSAgICAgICAgICAgICAgICB8IFBvcHBpbnMgICAgICAgICAgICB8IERvbGwgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDIgICAgICAgICAgICAgICAgICAgICAgfCBNYXJ5ICAgICAgICAgICAgICAgIHwgUG9wcGlucyAgICAgICAgICAgIHwgUGxheU1vYmlsZSAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMSAgICAgICAgICAgICAgICAgICAgICB8IEx1Y2t5ICAgICAgICAgICAgICAgfCBMdWtlICAgICAgICAgICAgICAgfCBEb2xsICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAyICAgICAgICAgICAgICAgICAgICAgIHwgTHVja3kgICAgICAgICAgICAgICB8IEx1a2UgICAgICAgICAgICAgICB8IFBsYXlNb2JpbGUgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvL1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIChyZWxhdGlvbkEsIHJlbGF0aW9uQikge1xuXG4gICAgICAgICAgICBkZWJ1Zy5wcm9kdWN0LnRyYWNlKCcjY29uc3RydWN0b3InKTtcblxuICAgICAgICAgICAgdGhpcy5yZWxzID0gW3JlbGF0aW9uQSwgcmVsYXRpb25CXTtcblxuICAgICAgICAgICAgUmVsYXRpb24uY2FsbCh0aGlzKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGJpbmRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgZGVidWcucHJvZHVjdC50cmFjZSgnI2JpbmRFdmVudHMnKTtcblxuICAgICAgICAgICAgUHJvZHVjdC5fX3N1cGVyX18uYmluZEV2ZW50cy5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciByZWwxID0gdGhpcy5yZWxzWzBdO1xuICAgICAgICAgICAgdmFyIHJlbDIgPSB0aGlzLnJlbHNbMV07XG5cbiAgICAgICAgICAgIC8vIEJlZm9yZUdldEhlYWRlclxuXG4gICAgICAgICAgICB0aGF0LmVlLm9uY2UoJ2JlZm9yZUdldEhlYWRlcicsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIGRlYnVnLnByb2R1Y3QudHJhY2UoJ2JlZm9yZUdldEhlYWRlcicpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlcjEgPSByZWwxLmhlYWRlcigpO1xuICAgICAgICAgICAgICAgIHZhciBoZWFkZXIyID0gcmVsMi5oZWFkZXIoKTtcblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIHR3byByZWxhdGlvbnMgaGF2ZSBkaXNqb2ludCBoZWFkZXJzXG4gICAgICAgICAgICAgICAgSGVhZGVyLmFzc2VydERpc2pvaW50KGhlYWRlcjEsIGhlYWRlcjIpO1xuXG4gICAgICAgICAgICAgICAgdGhhdC5oZWFkZXIoKS5jb3B5KGhlYWRlcjEuc2V0VW5pb24oaGVhZGVyMikpO1xuXG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICAvLyBCZWZvcmVHZXRCb2R5XG5cbiAgICAgICAgICAgIHRoYXQuZWUub25jZSgnYmVmb3JlR2V0Qm9keScsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIGRlYnVnLnByb2R1Y3QudHJhY2UoJ2JlZm9yZUdldEJvZHknKTtcblxuICAgICAgICAgICAgICAgIHZhciB0dXBsZVNldCA9IHJlbDEuc2V0UHJvZHVjdChyZWwyKTtcblxuICAgICAgICAgICAgICAgIHR1cGxlU2V0LmVhY2goZnVuY3Rpb24gKHR1cGxlUGFpcikge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdUdXBsZSA9IG5ldyBUdXBsZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIG5ld1R1cGxlLmNvcHkodHVwbGVQYWlyLmdldCgnMCcpKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3VHVwbGUuY29weSh0dXBsZVBhaXIuZ2V0KCcxJykpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYWRkKG5ld1R1cGxlLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICB9LCB0aGF0KTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlckxlZnRBZGQgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUpe1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJMZWZ0UmVtb3ZlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyTGVmdFVwZGF0ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSwgYXR0cmlidXRlTmFtZSwgdmFsdWUsIG9sZFZhbHVlKXtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyUmlnaHRBZGQgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUpe1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJSaWdodFJlbW92ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSl7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlclJpZ2h0VXBkYXRlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpe1xuXG4gICAgICAgIH1cblxuICAgIH0sIHtcblxuICAgICAgICB0eXBlIDogJ1Byb2R1Y3QnXG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9kdWN0OyIsInZhciBSZWxhdGlvbiA9IHJlcXVpcmUoJy4vLi4vUmVsYXRpb24uanMnKTtcbnZhciBIZWFkZXIgPSByZXF1aXJlKCcuLy4uL0hlYWRlci5qcycpO1xudmFyIFR1cGxlID0gcmVxdWlyZSgnLi8uLi9UdXBsZS5qcycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9kZWJ1ZycpO1xuXG5cblxudmFyIFByb2plY3Rpb24gPSBSZWxhdGlvbi5leHRlbmQoXG5cbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBPcGVyYXRvcnMuUHJvamVjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBhcmdzXG4gICAgICAgICAqIEBleHRlbmRzIFJlbGF0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEV4YW1wbGUgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQSA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7Y2hhcmFjdGVySWQ6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2ZpcnN0TmFtZTogeyB0eXBlOiBhZmZpbml0eS5TdHJpbmd9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtsYXN0TmFtZTogeyB0eXBlOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsxLCAnSm9obicsICdEb2UnXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsyLCAnTWFyeScsICdQb3BwaW5zJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbMywgJ0x1Y2t5JywgJ0x1a2UnXVxuICAgICAgICAgKiAgICAgICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBjaGFyYWN0ZXJJZCA6IFRJbnRlZ2VyIHwgZmlyc3ROYW1lIDogVFN0cmluZyB8IGxhc3ROYW1lIDogVFN0cmluZyB8XG4gICAgICAgICAqICAgICAvLyArPT09PT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgIC8vIHwgMSAgICAgICAgICAgICAgICAgICAgICB8IEpvaG4gICAgICAgICAgICAgICAgfCBEb2UgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDIgICAgICAgICAgICAgICAgICAgICAgfCBNYXJ5ICAgICAgICAgICAgICAgIHwgUG9wcGlucyAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAzICAgICAgICAgICAgICAgICAgICAgIHwgTHVja3kgICAgICAgICAgICAgICB8IEx1a2UgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkIgPSByZWxhdGlvbkEucHJvamVjdChbJ2ZpcnN0TmFtZSddKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG9yXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25DID0gbmV3IGFmZmluaXR5LlByb2plY3Rpb24ocmVsYXRpb25BLCBbJ2ZpcnN0TmFtZSddKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IGZpcnN0TmFtZSA6IFRTdHJpbmcgfFxuICAgICAgICAgKiAgICAgLy8gKz09PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgIC8vIHwgSm9obiAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBNYXJ5ICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IEx1Y2t5ICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAocmVsYXRpb24sIGFyZ3MpIHtcblxuICAgICAgICAgICAgdGhpcy5yZWwgPSByZWxhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG5cbiAgICAgICAgICAgIFJlbGF0aW9uLmNhbGwodGhpcyk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnByb2plY3Rpb24udHJhY2UoJyNiaW5kRXZlbnRzJyk7XG5cbiAgICAgICAgICAgIFByb2plY3Rpb24uX19zdXBlcl9fLmJpbmRFdmVudHMuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgcmVsYXRpb24gPSB0aGlzLnJlbDtcblxuICAgICAgICAgICAgdGhhdC5lZS5vbmNlKCdiZWZvcmVHZXRCb2R5JywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgZGVidWcucHJvamVjdGlvbi50cmFjZSgnYmVmb3JlR2V0Qm9keScpO1xuXG4gICAgICAgICAgICAgICAgcmVsYXRpb24uZWFjaChmdW5jdGlvbiAodHVwbGUpIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VHVwbGUgPSBuZXcgVHVwbGUoKTtcblxuICAgICAgICAgICAgICAgICAgICBuZXdUdXBsZS5jb3B5KHR1cGxlLCB0aGF0LmFyZ3MpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYWRkKG5ld1R1cGxlKTtcblxuICAgICAgICAgICAgICAgIH0sIHRoYXQpXG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGF0LmVlLm9uY2UoJ2JlZm9yZUdldEhlYWRlcicsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIGRlYnVnLnByb2plY3Rpb24udHJhY2UoJ2JlZm9yZUdldEhlYWRlcicpO1xuXG4gICAgICAgICAgICAgICAgdGhhdC5oZWFkZXIoKS5jb3B5KHJlbGF0aW9uLmhlYWRlcigpLnByb2plY3QodGhhdC5hcmdzKSlcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEJpbmRzIHRoZSBiYXNlIHJlbGF0aW9uIGFmdGVyQWRkIGV2ZW50XG4gICAgICAgICAgICByZWxhdGlvbi5lZS5vbignYWZ0ZXJBZGQnLCBmdW5jdGlvbih0dXBsZSwgaW5kZXgpe1xuICAgICAgICAgICAgICAgIHRoYXQuYWZ0ZXJBZGQocmVsYXRpb24sIHR1cGxlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBCaW5kcyB0aGUgYmFzZSByZWxhdGlvbiBhZnRlclJlbW92ZSBldmVudFxuICAgICAgICAgICAgcmVsYXRpb24uZWUub24oJ2FmdGVyUmVtb3ZlJywgZnVuY3Rpb24odHVwbGUsIGluZGV4KXtcbiAgICAgICAgICAgICAgICB0aGF0LmFmdGVyUmVtb3ZlKHJlbGF0aW9uLCB0dXBsZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQmluZHMgdGhlIGJhc2UgcmVsYXRpb24gYWZ0ZXJVcGRhdGUgZXZlbnRcbiAgICAgICAgICAgIHJlbGF0aW9uLmVlLm9uKCdhZnRlclVwZGF0ZScsIGZ1bmN0aW9uKHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpe1xuICAgICAgICAgICAgICAgIHRoYXQuYWZ0ZXJVcGRhdGUocmVsYXRpb24sIHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlckFkZCA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSl7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVsYXRpb24ucHJvamVjdCh0aGlzLmFyZ3MpO1xuICAgICAgICAgICAgZGVidWcuZ3JvdXAudHJhY2UoJ1Byb2plY3Rpb24jYWZ0ZXJBZGQnKTtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0VG8ocmVzdWx0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlclJlbW92ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSl7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVsYXRpb24ucHJvamVjdCh0aGlzLmFyZ3MpO1xuICAgICAgICAgICAgZGVidWcuZ3JvdXAudHJhY2UoJ1Byb2plY3Rpb24jYWZ0ZXJSZW1vdmUnKTtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0VG8ocmVzdWx0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlclVwZGF0ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSwgYXR0cmlidXRlTmFtZSwgdmFsdWUsIG9sZFZhbHVlKXtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSByZWxhdGlvbi5wcm9qZWN0KHRoaXMuYXJncyk7XG4gICAgICAgICAgICBkZWJ1Zy5ncm91cC50cmFjZSgnUHJvamVjdGlvbiNhZnRlclVwZGF0ZScpO1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RUbyhyZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICB9LCB7XG5cbiAgICAgICAgdHlwZSA6ICdQcm9qZWN0aW9uJ1xuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvamVjdGlvbjsiLCJ2YXIgUmVsYXRpb24gPSByZXF1aXJlKCcuLy4uL1JlbGF0aW9uLmpzJyk7XG52YXIgVHVwbGUgPSByZXF1aXJlKCcuLy4uL1R1cGxlLmpzJyk7XG52YXIgU2V0ID0gcmVxdWlyZSgnLi8uLi9TZXQuanMnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvZGVidWcnKTtcblxuXG5cbnZhciBSZW5hbWUgPSBSZWxhdGlvbi5leHRlbmQoXG5cbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBPcGVyYXRvcnMuUmVuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXG4gICAgICAgICAqIEBleHRlbmRzIFJlbGF0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEV4YW1wbGUgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQSA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7Y2hhcmFjdGVySWQ6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2ZpcnN0TmFtZTogeyB0eXBlOiBhZmZpbml0eS5TdHJpbmd9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtsYXN0TmFtZTogeyB0eXBlOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsxLCAnSm9obicsICdEb2UnXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsyLCAnTWFyeScsICdQb3BwaW5zJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbMywgJ0x1Y2t5JywgJ0x1a2UnXVxuICAgICAgICAgKiAgICAgICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkIgPSByZWxhdGlvbkEucmVuYW1lKHsnZmlyc3ROYW1lJzonZmFtaWx5TmFtZSd9KVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gb3JcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkMgPSBuZXcgYWZmaW5pdHkuUHJvamVjdGlvbihyZWxhdGlvbkEsIHsnbGFzdE5hbWUnOidmYW1pbHlOYW1lJ30pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8LS1SRU5BTUVEIEFUVFJJQlVURS0tLT5cbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IGNoYXJhY3RlcklkIDogVEludGVnZXIgfCBmaXJzdE5hbWUgOiBUU3RyaW5nIHwgZmFtaWx5TmFtZSA6IFRTdHJpbmcgfFxuICAgICAgICAgKiAgICAgLy8gKz09PT09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgIC8vIHwgMSAgICAgICAgICAgICAgICAgICAgICB8IEpvaG4gICAgICAgICAgICAgICAgfCBEb2UgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAyICAgICAgICAgICAgICAgICAgICAgIHwgTWFyeSAgICAgICAgICAgICAgICB8IFBvcHBpbnMgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDMgICAgICAgICAgICAgICAgICAgICAgfCBMdWNreSAgICAgICAgICAgICAgIHwgTHVrZSAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAocmVsYXRpb24sIGFyZ3MpIHtcblxuICAgICAgICAgICAgdGhpcy5yZWxhdGlvbiA9IHJlbGF0aW9uO1xuICAgICAgICAgICAgdGhpcy5hcmdzID0gYXJncztcblxuICAgICAgICAgICAgUmVsYXRpb24uY2FsbCh0aGlzKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGJpbmRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgZGVidWcucmVuYW1lLnRyYWNlKCcjYmluZEV2ZW50cycpO1xuXG4gICAgICAgICAgICBSZW5hbWUuX19zdXBlcl9fLmJpbmRFdmVudHMuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGF0LmVlLm9uY2UoJ2JlZm9yZUdldEJvZHknLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICBkZWJ1Zy5yZW5hbWUudHJhY2UoJ2JlZm9yZUdldEJvZHknKTtcblxuICAgICAgICAgICAgICAgIC8vdmFyIGEsIGIsIHR1cGxlQ291bnQsIHR1cGxlLCB0dXBsZXMsIGtleXMsIGtleUNvdW50LCBrZXksIG5ld05hbWU7XG5cbiAgICAgICAgICAgICAgICAvL3RoYXQuX2JvZHkgPSBuZXcgU2V0KHt0eXBlOiBUdXBsZX0pO1xuXG4gICAgICAgICAgICAgICAgLy90dXBsZXMgPSB0aGF0LnJlbGF0aW9uLmJvZHkoKTtcbiAgICAgICAgICAgICAgICAvL3R1cGxlQ291bnQgPSB0dXBsZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIC8va2V5cyA9IE9iamVjdC5rZXlzKHRoYXQuYXJncyk7XG4gICAgICAgICAgICAgICAgLy9rZXlDb3VudCA9IGtleXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgdGhhdC5yZWxhdGlvbi5lYWNoKGZ1bmN0aW9uKHR1cGxlKXtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VHVwbGUgPSB0dXBsZS5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIF8uZm9ySW4odGhhdC5hcmdzLCBmdW5jdGlvbih2YWx1ZSwga2V5KXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodmFsdWUgIT09IGtleSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VHVwbGUuc2V0KHZhbHVlLCBuZXdUdXBsZS5nZXQoa2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG5ld1R1cGxlLmF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB0aGF0LmFkZChuZXdUdXBsZSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGF0LmVlLm9uY2UoJ2JlZm9yZUdldEhlYWRlcicsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIGRlYnVnLnJlbmFtZS50cmFjZSgnYmVmb3JlR2V0SGVhZGVyJyk7XG5cbiAgICAgICAgICAgICAgICB0aGF0LmhlYWRlcigpLmNvcHkodGhhdC5yZWxhdGlvbi5oZWFkZXIoKS5yZW5hbWUodGhhdC5hcmdzKSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJBZGQgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUpe1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVsYXRpb24ucmVuYW1lKHRoaXMuYXJncyk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFRvKHJlc3VsdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJSZW1vdmUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUpe1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVsYXRpb24ucmVuYW1lKHRoaXMuYXJncyk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFRvKHJlc3VsdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJVcGRhdGUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSl7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZWxhdGlvbi5yZW5hbWUodGhpcy5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0VG8ocmVzdWx0KTtcbiAgICAgICAgfVxuXG4gICAgfSwge1xuXG5cblxuICAgIH0sIHtcblxuICAgICAgICB0eXBlIDogJ1JlbmFtZSdcblxuICAgIH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmFtZTsiLCJ2YXIgUmVsYXRpb24gPSByZXF1aXJlKCcuLy4uL1JlbGF0aW9uLmpzJyk7XG52YXIgSGVhZGVyID0gcmVxdWlyZSgnLi8uLi9IZWFkZXIuanMnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvZGVidWcnKTtcbnZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vRnVuY3Rpb24uanMnKTtcblxuXG5cbnZhciBSZXN0cmljdGlvbiA9IFJlbGF0aW9uLmV4dGVuZChcblxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIE9wZXJhdG9ycy5SZXN0cmljdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGVcbiAgICAgICAgICogQGV4dGVuZHMgUmVsYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogRXhhbXBsZSA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25BID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgICAgIHtjaGFyYWN0ZXJJZDogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7Zmlyc3ROYW1lOiB7IHR5cGU6IGFmZmluaXR5LlN0cmluZ319LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2xhc3ROYW1lOiB7IHR5cGU6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWzEsICdKb2huJywgJ0RvZSddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzIsICdNYXJ5JywgJ1BvcHBpbnMnXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFszLCAnTHVja3knLCAnTHVrZSddXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGNoYXJhY3RlcklkID0gcmVsYXRpb25BLmdldCgnY2hhcmFjdGVySWQnKVxuICAgICAgICAgKiAgICAgdmFyIGZpcnN0TmFtZSA9IHJlbGF0aW9uQS5nZXQoJ2ZpcnN0TmFtZScpXG4gICAgICAgICAqICAgICB2YXIgbGFzdE5hbWUgPSByZWxhdGlvbkEuZ2V0KCdsYXN0TmFtZScpXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25DID0gcmVsYXRpb25BLnJlc3RyaWN0KGNoYXJhY3RlcklkLmVxdWFscygxKSlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG9yXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25DID0gbmV3IGFmZmluaXR5LlByb2plY3Rpb24ocmVsYXRpb25BLCBjaGFyYWN0ZXJJZC5lcXVhbHMoMSkpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IGNoYXJhY3RlcklkIDogVEludGVnZXIgfCBmaXJzdE5hbWUgOiBUU3RyaW5nIHwgbGFzdE5hbWUgOiBUU3RyaW5nIHxcbiAgICAgICAgICogICAgIC8vICs9PT09PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgLy8gfCAxICAgICAgICAgICAgICAgICAgICAgIHwgSm9obiAgICAgICAgICAgICAgICB8IERvZSAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAocmVsYXRpb24sIHByZWRpY2F0ZSkge1xuXG4gICAgICAgICAgICB0aGlzLnJlbCA9IHJlbGF0aW9uO1xuICAgICAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgICAgICBSZWxhdGlvbi5jYWxsKHRoaXMpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYmluZEV2ZW50czogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5yZXN0cmljdGlvbi50cmFjZSgnI2JpbmRFdmVudHMnKTtcblxuICAgICAgICAgICAgUmVzdHJpY3Rpb24uX19zdXBlcl9fLmJpbmRFdmVudHMuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG5cbiAgICAgICAgICAgIHRoYXQuZWUub25jZSgnYmVmb3JlR2V0SGVhZGVyJywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgZGVidWcucmVzdHJpY3Rpb24udHJhY2UoJ2JlZm9yZUdldEhlYWRlcicpO1xuXG4gICAgICAgICAgICAgICAgdGhhdC5oZWFkZXIoKS5jb3B5KHRoYXQucmVsLmhlYWRlcigpKTtcblxuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgdGhhdC5lZS5vbmNlKCdiZWZvcmVHZXRCb2R5JywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgdGhhdC5yZWwuZWFjaCggZnVuY3Rpb24gKHR1cGxlKSB7IHRoYXQuYWZ0ZXJBZGQodHVwbGUpOyB9KVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhhdC5yZWwuZWUub24oJ2FmdGVyQWRkJywgZnVuY3Rpb24odHVwbGUpe1xuICAgICAgICAgICAgICAgIHRoYXQuYWZ0ZXJBZGQodHVwbGUpO1xuICAgICAgICAgICAgfSlcblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyQWRkIDogZnVuY3Rpb24odHVwbGUpe1xuXG4gICAgICAgICAgICBkZWJ1Zy5yZXN0cmljdGlvbi50cmFjZSgnYWZ0ZXJBZGQnKTtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGF0LmhlYWRlcigpO1xuXG4gICAgICAgICAgICBpZih0aGF0LnByZWRpY2F0ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKXtcblxuICAgICAgICAgICAgICAgIHRoYXQucHJlZGljYXRlLmNvbnZlcnRBdHRyaWJ1dGVUb1R1cGxlKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhhdC5wcmVkaWNhdGUuYXNzaWduVHVwbGUodHVwbGUpLnZhbHVlKCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5hZGQodHVwbGUuY2xvbmUoKSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIGlmIChfLmlzRnVuY3Rpb24odGhhdC5wcmVkaWNhdGUpKSB7XG5cbiAgICAgICAgICAgICAgICBpZih0aGF0LnByZWRpY2F0ZSh0dXBsZSkpe1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmFkZCh0dXBsZS5jbG9uZSgpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vuc3VwcG9ydGVkIHByZWRpY2F0ZSB0eXBlJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyUmVtb3ZlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlbGF0aW9uLnJlc3RyaWN0KHRoaXMucHJlZGljYXRlKTtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0VG8ocmVzdWx0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlclVwZGF0ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSwgYXR0cmlidXRlTmFtZSwgdmFsdWUsIG9sZFZhbHVlKXtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlbGF0aW9uLnJlc3RyaWN0KHRoaXMucHJlZGljYXRlKTtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0VG8ocmVzdWx0KTtcbiAgICAgICAgfVxuXG4gICAgfSwge1xuXG4gICAgICAgIHR5cGUgOiAnUmVzdHJpY3Rpb24nXG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZXN0cmljdGlvbjsiLCJ2YXIgUmVsYXRpb24gPSByZXF1aXJlKCcuLy4uL1JlbGF0aW9uLmpzJyk7XG52YXIgSGVhZGVyID0gcmVxdWlyZSgnLi8uLi9IZWFkZXIuanMnKTtcbnZhciBUdXBsZSA9IHJlcXVpcmUoJy4vLi4vVHVwbGUuanMnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvZGVidWcnKTtcbnZhciBlcXVhbCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9lcXVhbCcpO1xuXG5cblxudmFyIFNlbWlEaWZmZXJlbmNlID0gUmVsYXRpb24uZXh0ZW5kKFxuXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgT3BlcmF0b3JzLlNlbWlEaWZmZXJlbmNlXG4gICAgICAgICAqIEBleHRlbmRzIFJlbGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uQSBUaGUgcmVsYXRpb24gZnJvbSB3aGljaCB0byBzZWVrIHR1cGxlcyB3aXRoIG5vIGNvdW50ZXJwYXJ0XG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uQiBUaGUgcmVsYXRpb24gY29udGFpbmluZyB0aGUgY291bnRlcnBhcnRzXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBTZW1pRGlmZmVyZW5jZSB3aWxsIGZpbmQgYWxsIHR1cGxlcyBpbiBBIHRoYXQgZG8gbm90IGhhdmUgYSBjb3VudGVycGFydCBpbiBCIG9uIHRoZWlyIGNvbW1vbiBhdHRyaWJ1dGVzXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBGaW5kIHRoZSBjaGFyYWN0ZXJzIHRoYXQgZG8gbm90IGhhdmUgZmFuc1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQSA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7Y2hhcmFjdGVySWQ6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2ZpcnN0TmFtZTogeyB0eXBlOiBhZmZpbml0eS5TdHJpbmd9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtsYXN0TmFtZTogeyB0eXBlOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsxLCAnSm9obicsICdEb2UnXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsyLCAnTWFyeScsICdQb3BwaW5zJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbMywgJ0x1Y2t5JywgJ0x1a2UnXVxuICAgICAgICAgKiAgICAgICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkIgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge2NoYXJhY3RlcklkOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtmYW46IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbMSwgJ01yIFgnXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsxLCAnTWlzcyBEaWJibGUnXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsyLCAnTmF0IEJpYmJsZSddXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQyA9IHJlbGF0aW9uQS5zZGlmZmVyZW5jZShyZWxhdGlvbkIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gb3JcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkMgPSBuZXcgYWZmaW5pdHkuU2VtaURpZmZlcmVuY2UocmVsYXRpb25BLCByZWxhdGlvbkIpXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgY2hhcmFjdGVySWQgOiBUSW50ZWdlciB8IGZpcnN0TmFtZSA6IFRTdHJpbmcgfCBsYXN0TmFtZSA6IFRTdHJpbmcgfFxuICAgICAgICAgKiAgICAgLy8gKz09PT09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAvLyB8IDMgICAgICAgICAgICAgICAgICAgICAgfCBMdWNreSAgICAgICAgICAgICAgIHwgTHVrZSAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy9cbiAgICAgICAgICogICAgIC8vIEx1Y2t5IEx1a2UgaXMgdGhlIG9ubHkgY2hhcmFjdGVyIHdpdGhvdXQgYSBmYW5cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAocmVsYXRpb25BLCByZWxhdGlvbkIpIHtcblxuICAgICAgICAgICAgZGVidWcuc2VtaURpZmZlcmVuY2UudHJhY2UoJyNjb25zdHJ1Y3RvcicpO1xuXG4gICAgICAgICAgICB0aGlzLnJlbHMgPSBbcmVsYXRpb25BLCByZWxhdGlvbkJdO1xuXG4gICAgICAgICAgICBSZWxhdGlvbi5jYWxsKHRoaXMpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYmluZEV2ZW50czogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5zZW1pRGlmZmVyZW5jZS50cmFjZSgnI2JpbmRFdmVudHMnKTtcblxuICAgICAgICAgICAgLy8gQ2FsbGluZyB0aGUgcGFyZW50IGJpbmRFdmVudHNcbiAgICAgICAgICAgIFNlbWlEaWZmZXJlbmNlLl9fc3VwZXJfXy5iaW5kRXZlbnRzLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgLy8gQmVmb3JlR2V0SGVhZGVyXG4gICAgICAgICAgICB0aGlzLmVlLm9uY2UoJ2JlZm9yZUdldEhlYWRlcicsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIGRlYnVnLnNlbWlEaWZmZXJlbmNlLnRyYWNlKCdiZWZvcmVHZXRIZWFkZXInKTtcblxuICAgICAgICAgICAgICAgIEhlYWRlci5hc3NlcnRTYW1lTmFtZVNhbWVUeXBlKHRoYXQucmVsc1swXS5oZWFkZXIoKSwgdGhhdC5yZWxzWzFdLmhlYWRlcigpKTtcblxuICAgICAgICAgICAgICAgIHRoYXQuY29tbW9uQXR0cmlidXRlcyA9IHRoYXQucmVsc1swXS5oZWFkZXIoKS5zZXRJbnRlcnNlY3Rpb24odGhhdC5yZWxzWzFdLmhlYWRlcigpKTtcblxuICAgICAgICAgICAgICAgIHRoYXQuaGVhZGVyKCkuY29weSh0aGF0LnJlbHNbMF0uaGVhZGVyKCkpO1xuXG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICAvLyBCZWZvcmVHZXRCb2R5XG4gICAgICAgICAgICB0aGlzLmVlLm9uY2UoJ2JlZm9yZUdldEJvZHknLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICB0aGF0LmhlYWRlcigpO1xuXG4gICAgICAgICAgICAgICAgZGVidWcuc2VtaURpZmZlcmVuY2UudHJhY2UoJ2JlZm9yZUdldEJvZHknKTtcblxuICAgICAgICAgICAgICAgIHZhciByZWwxID0gdGhhdC5yZWxzWzBdO1xuICAgICAgICAgICAgICAgIHZhciByZWwyID0gdGhhdC5yZWxzWzFdO1xuXG4gICAgICAgICAgICAgICAgcmVsMS5lYWNoKGZ1bmN0aW9uKHR1cGxlMSl7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ZXJwYXJ0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYodGhhdC5jb21tb25BdHRyaWJ1dGVzLmxlbmd0aCgpID4gMCl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbDIuZWFjaChmdW5jdGlvbih0dXBsZTIpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdHVwbGUxIGhhcyBzYW1lIGNvbW1vbiBhdHRyaWJ1dGVzIGFzIHR1cGxlMlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gVHVwbGUubWF0Y2hPbkF0dHJpYnV0ZXModHVwbGUxLCB0dXBsZTIsIHRoYXQuY29tbW9uQXR0cmlidXRlcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihtYXRjaCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJwYXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKCFjb3VudGVycGFydCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmFkZCh0dXBsZTEuY2xvbmUoKSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyTGVmdEFkZCA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSl7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlckxlZnRSZW1vdmUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUpe1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJMZWZ0VXBkYXRlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpe1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJSaWdodEFkZCA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSl7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlclJpZ2h0UmVtb3ZlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyUmlnaHRVcGRhdGUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSl7XG5cbiAgICAgICAgfVxuXG4gICAgfSwge1xuXG4gICAgICAgIHR5cGUgOiAnU2VtaURpZmZlcmVuY2UnXG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZW1pRGlmZmVyZW5jZTsiLCJ2YXIgUmVsYXRpb24gPSByZXF1aXJlKCcuLy4uL1JlbGF0aW9uLmpzJyk7XG52YXIgSGVhZGVyID0gcmVxdWlyZSgnLi8uLi9IZWFkZXIuanMnKTtcbnZhciBUdXBsZSA9IHJlcXVpcmUoJy4vLi4vVHVwbGUuanMnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvZGVidWcnKTtcbnZhciBlcXVhbCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9lcXVhbCcpO1xuXG5cblxudmFyIFNlbWlKb2luID0gUmVsYXRpb24uZXh0ZW5kKFxuXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgT3BlcmF0b3JzLlNlbWlKb2luXG4gICAgICAgICAqIEBleHRlbmRzIFJlbGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uQSBUaGUgcmVsYXRpb24gZnJvbSB3aGljaCB0byBzZWVrIHR1cGxlcyB3aXRoIHRoZWlyIGNvdW50ZXJwYXJ0cyBpbiBCXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uQiBUaGUgcmVsYXRpb24gY29udGFpbmluZyB0aGUgY291bnRlcnBhcnRzXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBTZW1pSm9pbiB3aWxsIGZpbmQgYWxsIHR1cGxlcyBpbiBBIHRoYXQgaGF2ZSBhIGNvdW50ZXJwYXJ0IGluIEIgb24gdGhlaXIgY29tbW9uIGF0dHJpYnV0ZXNcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIEZpbmQgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGZhbnNcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkEgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge2NoYXJhY3RlcklkOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtmaXJzdE5hbWU6IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7bGFzdE5hbWU6IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbMSwgJ0pvaG4nLCAnRG9lJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbMiwgJ01hcnknLCAnUG9wcGlucyddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzMsICdMdWNreScsICdMdWtlJ11cbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25CID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgICAgIHtjaGFyYWN0ZXJJZDogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7ZmFuOiB7IHR5cGU6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWzEsICdNciBYJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbMSwgJ01pc3MgRGliYmxlJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbMiwgJ05hdCBCaWJibGUnXVxuICAgICAgICAgKiAgICAgICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkMgPSByZWxhdGlvbkEuc2pvaW4ocmVsYXRpb25CKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG9yXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25DID0gbmV3IGFmZmluaXR5LlNlbWlKb2luKHJlbGF0aW9uQSwgcmVsYXRpb25CKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IGNoYXJhY3RlcklkIDogVEludGVnZXIgfCBmaXJzdE5hbWUgOiBUU3RyaW5nIHwgbGFzdE5hbWUgOiBUU3RyaW5nIHxcbiAgICAgICAgICogICAgIC8vICs9PT09PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgLy8gfCAxICAgICAgICAgICAgICAgICAgICAgIHwgSm9obiAgICAgICAgICAgICAgICB8IERvZSAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMiAgICAgICAgICAgICAgICAgICAgICB8IE1hcnkgICAgICAgICAgICAgICAgfCBQb3BwaW5zICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvL1xuICAgICAgICAgKiAgICAgLy8gSm9obiBEb2UgYW5kIE1hcnkgUG9wcGlucyBoYXZlIGZhbnNcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAocmVsYXRpb25BLCByZWxhdGlvbkIpIHtcblxuICAgICAgICAgICAgZGVidWcuc2VtaUpvaW4udHJhY2UoJyNjb25zdHJ1Y3RvcicpO1xuXG4gICAgICAgICAgICB0aGlzLnJlbHMgPSBbcmVsYXRpb25BLCByZWxhdGlvbkJdO1xuXG4gICAgICAgICAgICBSZWxhdGlvbi5jYWxsKHRoaXMpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYmluZEV2ZW50czogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBkZWJ1Zy5zZW1pSm9pbi50cmFjZSgnI2JpbmRFdmVudHMnKTtcblxuICAgICAgICAgICAgLy8gQ2FsbGluZyB0aGUgcGFyZW50IGJpbmRFdmVudHNcbiAgICAgICAgICAgIFNlbWlKb2luLl9fc3VwZXJfXy5iaW5kRXZlbnRzLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgLy8gQmVmb3JlR2V0SGVhZGVyXG4gICAgICAgICAgICB0aGlzLmVlLm9uY2UoJ2JlZm9yZUdldEhlYWRlcicsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIGRlYnVnLnNlbWlKb2luLnRyYWNlKCdiZWZvcmVHZXRIZWFkZXInKTtcblxuICAgICAgICAgICAgICAgIEhlYWRlci5hc3NlcnRTYW1lTmFtZVNhbWVUeXBlKHRoYXQucmVsc1swXS5oZWFkZXIoKSwgdGhhdC5yZWxzWzFdLmhlYWRlcigpKTtcblxuICAgICAgICAgICAgICAgIHRoYXQuY29tbW9uQXR0cmlidXRlcyA9IHRoYXQucmVsc1swXS5oZWFkZXIoKS5zZXRJbnRlcnNlY3Rpb24odGhhdC5yZWxzWzFdLmhlYWRlcigpKTtcblxuICAgICAgICAgICAgICAgIHRoYXQuaGVhZGVyKCkuY29weSh0aGF0LnJlbHNbMF0uaGVhZGVyKCkpO1xuXG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICAvLyBCZWZvcmVHZXRCb2R5XG4gICAgICAgICAgICB0aGlzLmVlLm9uY2UoJ2JlZm9yZUdldEJvZHknLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICBkZWJ1Zy5zZW1pSm9pbi50cmFjZSgnYmVmb3JlR2V0Qm9keScpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlbGF0aW9uMSA9IHRoYXQucmVsc1swXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVsYXRpb24yID0gdGhhdC5yZWxzWzFdO1xuXG4gICAgICAgICAgICAgICAgcmVsYXRpb24xLmVhY2goZnVuY3Rpb24odHVwbGUxKXtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnRlcnBhcnQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5jb21tb25BdHRyaWJ1dGVzLmxlbmd0aCgpID4gMCl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aW9uMi5lYWNoKGZ1bmN0aW9uKHR1cGxlMil7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBUdXBsZS5tYXRjaE9uQXR0cmlidXRlcyh0dXBsZTEsIHR1cGxlMiwgdGhhdC5jb21tb25BdHRyaWJ1dGVzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG1hdGNoKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnBhcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoY291bnRlcnBhcnQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5hZGQodHVwbGUxLmNsb25lKCksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlckxlZnRBZGQgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUpe1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJMZWZ0UmVtb3ZlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyTGVmdFVwZGF0ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSwgYXR0cmlidXRlTmFtZSwgdmFsdWUsIG9sZFZhbHVlKXtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyUmlnaHRBZGQgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUpe1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJSaWdodFJlbW92ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSl7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlclJpZ2h0VXBkYXRlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpe1xuXG4gICAgICAgIH1cblxuICAgIH0sIHtcblxuICAgICAgICB0eXBlIDogJ1NlbWlKb2luJ1xuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2VtaUpvaW47IiwidmFyIFJlbGF0aW9uID0gcmVxdWlyZSgnLi8uLi9SZWxhdGlvbi5qcycpO1xudmFyIEhlYWRlciA9IHJlcXVpcmUoJy4vLi4vSGVhZGVyLmpzJyk7XG52YXIgVHVwbGUgPSByZXF1aXJlKCcuLy4uL1R1cGxlLmpzJyk7XG52YXIgQXR0cmlidXRlID0gcmVxdWlyZSgnLi8uLi9BdHRyaWJ1dGUuanMnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvZGVidWcnKTtcblxudmFyIFN1bW1hcml6ZSA9IFJlbGF0aW9uLmV4dGVuZCh7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgT3BlcmF0b3JzLlN1bW1hcml6ZVxuICAgICAqIEBleHRlbmRzIFJlbGF0aW9uXG4gICAgICpcbiAgICAgKiBUaGUgU3VtbWFyaXplIG9wZXJhdGlvbiB3aWxsIGJlIHRoZSBwcm9qZWN0aW9uIHJlc3VsdCBvZiBnaXZlbiByZWxhdGlvbiBhdHRyaWJ1dGVzXG4gICAgICogd2hpbGUgZXh0ZW5kaW5nIHRoaXMgcmVzdWx0aW5nIHJlbGF0aW9uIHdpdGggY2FsY3VsYXRlZCBhdHRyaWJ1dGVzLlxuICAgICAqXG4gICAgICogRXhhbXBsZSA6XG4gICAgICpcbiAgICAgKiAgICAgdmFyIHJlbGF0aW9uID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgKiAgICAgICAgIHsgaWQgOiB7dHlwZSA6IGFmZmluaXR5LkludGVnZXJ9IH0sXG4gICAgICogICAgICAgICB7IG5hbWUgOiB7dHlwZSA6IGFmZmluaXR5LlN0cmluZ30gfSxcbiAgICAgKiAgICAgICAgIHsgYWdlIDoge3R5cGUgOiBhZmZpbml0eS5JbnRlZ2VyfSB9LFxuICAgICAqICAgICBdLFtcbiAgICAgKiAgICAgICAgIFsxLCAnSm9obiBEb2UnLCAyM10sXG4gICAgICogICAgICAgICBbMiwgJ0pvaG4gRG9lJywgMzVdLFxuICAgICAqICAgICAgICAgWzMsICdKb2huIERvZScsIDI3XSxcbiAgICAgKiAgICAgICAgIFs0LCAnQm8gRGVyZWsnLCAxMl0sXG4gICAgICogICAgICAgICBbNSwgJ0JvIERlcmVrJywgN10sXG4gICAgICogICAgICAgICBbNiwgJ01hcmlseW4gTW9ucm9lJywgMTZdLFxuICAgICAqICAgICBdKTtcbiAgICAgKlxuICAgICAqICAgICB2YXIgYWdlID0gcmVsYXRpb24uZ2V0KCdhZ2UnKTtcbiAgICAgKlxuICAgICAqICAgICB2YXIgc3VtbWFyaXplZCA9IHJlbGF0aW9uLnN1bW1hcml6ZShcbiAgICAgKiAgICAgICAgIFsnbmFtZSddLFxuICAgICAqICAgICAgICAgW1xuICAgICAqICAgICAgICAgICAgIHsgXCJhZ2UuYXZnKClcIiA6IGFnZS5hdmcoKSAgICAgICAgfSxcbiAgICAgKiAgICAgICAgICAgICB7IFwiYWdlLnN1bSgpXCIgOiBhZ2Uuc3VtKCkgICAgICAgIH0sXG4gICAgICogICAgICAgICAgICAgeyBcImNvdW50KClcIiAgIDogYWZmaW5pdHkuY291bnQoKSB9XG4gICAgICogICAgICAgICBdXG4gICAgICogICAgICk7XG4gICAgICpcbiAgICAgKiAgICAgc3VtbWFyaXplZC5wcmludCgpO1xuICAgICAqXG4gICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAqICAgICAvLyB8IG5hbWUgOiBTdHJpbmcgICAgfCBhZ2UuYXZnKCkgOiBGbG9hdCAgICB8IGFnZS5zdW0oKSA6IEZsb2F0ICAgfCBjb3VudCgpIDogSW50ZWdlciAgIHxcbiAgICAgKiAgICAgLy8gKz09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT0rXG4gICAgICogICAgIC8vIHwgSm9obiBEb2UgICAgICAgICB8IDI4LjMzMzMzMzMzMzMzMzMzMiAgIHwgODUgICAgICAgICAgICAgICAgICB8IDMgICAgICAgICAgICAgICAgICAgfFxuICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKiAgICAgLy8gfCBCbyBEZXJlayAgICAgICAgIHwgOS41ICAgICAgICAgICAgICAgICAgfCAxOSAgICAgICAgICAgICAgICAgIHwgMiAgICAgICAgICAgICAgICAgICB8XG4gICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAqICAgICAvLyB8IE1hcmlseW4gTW9ucm9lICAgfCAxNiAgICAgICAgICAgICAgICAgICB8IDE2ICAgICAgICAgICAgICAgICAgfCAxICAgICAgICAgICAgICAgICAgIHxcbiAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgU3VtbWFyeSByZWxhdGlvblxuICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uIFRoZSByZWxhdGlvbiB0byBzdW1tYXJpemVcbiAgICAgKiBAcGFyYW0ge0F0dHJpYnV0ZVtdfFN0cmluZ1tdfSBhdHRyaWJ1dGVzIFRoZSBhdHRyaWJ1dGVzIHRvIGtlZXBcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBzdW1tYXJpZXMgVGhlIHN1bW1hcnkgZXhwcmVzc2lvbnNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciA6IGZ1bmN0aW9uKHJlbGF0aW9uLCBhdHRyaWJ1dGVzLCBzdW1tYXJpZXMpe1xuXG4gICAgICAgIHRoaXMuYXJncyA9IHt9O1xuXG4gICAgICAgIHRoaXMuYXJncy5yZWxhdGlvbiA9IHJlbGF0aW9uO1xuXG4gICAgICAgIHRoaXMuYXJncy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcblxuICAgICAgICB0aGlzLmFyZ3Muc3VtbWFyaWVzID0gc3VtbWFyaWVzO1xuXG4gICAgICAgIFJlbGF0aW9uLmNhbGwodGhpcyk7XG5cbiAgICB9LFxuXG4gICAgYmluZEV2ZW50cyA6IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgZGVidWcuc2VtaUpvaW4udHJhY2UoJyNiaW5kRXZlbnRzJyk7XG5cbiAgICAgICAgLy8gQ2FsbGluZyB0aGUgcGFyZW50IGJpbmRFdmVudHNcbiAgICAgICAgU3VtbWFyaXplLl9fc3VwZXJfXy5iaW5kRXZlbnRzLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIHRoYXQuZWUub25jZSgnYmVmb3JlR2V0SGVhZGVyJywgZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgdmFyIHJlbGF0aW9uID0gdGhhdC5hcmdzLnJlbGF0aW9uO1xuXG4gICAgICAgICAgICB2YXIgaGVhZGVyID0gcmVsYXRpb24uaGVhZGVyKCk7XG5cbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhhdC5hcmdzLmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgIHZhciBzdW1tYXJpZXMgPSB0aGF0LmFyZ3Muc3VtbWFyaWVzO1xuXG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBnaXZlbiBhdHRyaWJ1dGVzIGV4aXN0IGluIHRoZVxuICAgICAgICAgICAgLy8gYmFzZSBoZWFkZXIuXG4gICAgICAgICAgICBIZWFkZXIuYXNzZXJ0QXR0cmlidXRlc0V4aXN0KGhlYWRlciwgYXR0cmlidXRlcyk7XG5cbiAgICAgICAgICAgIC8vIENvcHkgdGhlIGdpdmVuIGF0dHJpYnV0ZXMgZnJvbSB0aGUgYmFzZSBoZWFkZXJcbiAgICAgICAgICAgIHRoYXQuaGVhZGVyKCkuY29weShyZWxhdGlvbi5oZWFkZXIoKSwgYXR0cmlidXRlcyk7XG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgc3VtbWFyaWVzIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIF8uZm9yRWFjaChzdW1tYXJpZXMsIGZ1bmN0aW9uKHN1bW1hcnkpe1xuXG4gICAgICAgICAgICAgICAgdmFyIHN1bW1hcnlOYW1lID0gT2JqZWN0LmtleXMoc3VtbWFyeSlbMF07XG5cbiAgICAgICAgICAgICAgICB2YXIgc3VtbWFyeUV4cHJlc3Npb24gPSBzdW1tYXJ5W3N1bW1hcnlOYW1lXTtcblxuICAgICAgICAgICAgICAgIHZhciBzdW1tYXJ5VHlwZSA9IHN1bW1hcnlFeHByZXNzaW9uLnR5cGUoKTtcblxuICAgICAgICAgICAgICAgIHZhciBuZXdBdHRyaWJ1dGUgPSBuZXcgQXR0cmlidXRlKHtuYW1lIDogc3VtbWFyeU5hbWUsIHR5cGUgOiBzdW1tYXJ5VHlwZX0pO1xuXG4gICAgICAgICAgICAgICAgdGhhdC5oZWFkZXIoKS5hZGQobmV3QXR0cmlidXRlKTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhhdC5lZS5vbmNlKCdiZWZvcmVHZXRCb2R5JywgZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgdmFyIHJlbGF0aW9uID0gdGhhdC5hcmdzLnJlbGF0aW9uO1xuXG4gICAgICAgICAgICB2YXIgaGVhZGVyID0gcmVsYXRpb24uaGVhZGVyKCk7XG5cbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhhdC5hcmdzLmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgIHZhciBzdW1tYXJpZXMgPSB0aGF0LmFyZ3Muc3VtbWFyaWVzO1xuXG4gICAgICAgICAgICB2YXIgaW5zdGFuY2VBdHRyaWJ1dGVzID0gbmV3IEhlYWRlcigpO1xuXG4gICAgICAgICAgICBpbnN0YW5jZUF0dHJpYnV0ZXMuY29weShoZWFkZXIsIGF0dHJpYnV0ZXMpO1xuXG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgdGhlIGF0dHJpYnV0ZXMgdGhhdCB3aWxsIGJlIGdyb3VwZWRcbiAgICAgICAgICAgIHZhciBvdGhlckF0dHJpYnV0ZXMgPSBoZWFkZXIuc2V0RGlmZmVyZW5jZShpbnN0YW5jZUF0dHJpYnV0ZXMpO1xuXG4gICAgICAgICAgICB2YXIgb3RoZXJBdHRyaWJ1dGVOYW1lcyA9IFtdO1xuXG4gICAgICAgICAgICBvdGhlckF0dHJpYnV0ZXMuZWFjaChmdW5jdGlvbihvdGhlckF0dHJpYnV0ZSl7XG4gICAgICAgICAgICAgICAgb3RoZXJBdHRyaWJ1dGVOYW1lcy5wdXNoKG90aGVyQXR0cmlidXRlLm5hbWUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBhbiBpbnRlcm1lZGlhcnkgZ3JvdXAgcmVsYXRpb25cbiAgICAgICAgICAgIHZhciBncm91cGVkID0gcmVsYXRpb24uZ3JvdXAoJ19fX2dyb3VwZWRfX18nLCBvdGhlckF0dHJpYnV0ZU5hbWVzKTtcblxuICAgICAgICAgICAgZ3JvdXBlZC5lYWNoKGZ1bmN0aW9uKGdyb3VwZWRUdXBsZSl7XG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHR1cGxlIHRoYXQgd2lsbCBiZSBpbnNlcnRlZFxuICAgICAgICAgICAgICAgIHZhciBuZXdUdXBsZSA9IG5ldyBUdXBsZSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29weSB0aGUgbm9uLWdyb3VwZWQgYXR0cmlidXRlcyBpbnRvIHRoZSBuZXcgdHVwbGVcbiAgICAgICAgICAgICAgICBuZXdUdXBsZS5jb3B5KGdyb3VwZWRUdXBsZSwgYXR0cmlidXRlcyk7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGdyb3VwZWQgcmVsYXRpb25cbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBlZFJlbGF0aW9uID0gZ3JvdXBlZFR1cGxlLmdldCgnX19fZ3JvdXBlZF9fXycpO1xuXG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKHN1bW1hcmllcywgZnVuY3Rpb24oc3VtbWFyeSl7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1bW1hcnlOYW1lID0gT2JqZWN0LmtleXMoc3VtbWFyeSlbMF07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1bW1hcnlFeHByZXNzaW9uID0gc3VtbWFyeVtzdW1tYXJ5TmFtZV07XG5cbiAgICAgICAgICAgICAgICAgICAgc3VtbWFyeUV4cHJlc3Npb24ucmVsYXRpb24gPSBncm91cGVkUmVsYXRpb247XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1bW1hcnlWYWx1ZSA9IHN1bW1hcnlFeHByZXNzaW9uLnZhbHVlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbmV3VHVwbGUuc2V0KHN1bW1hcnlOYW1lLCBzdW1tYXJ5VmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGF0LmFkZChuZXdUdXBsZSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pXG5cbiAgICB9LFxuXG4gICAgYWZ0ZXJBZGQgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUpe1xuXG4gICAgfSxcblxuICAgIGFmdGVyUmVtb3ZlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcblxuICAgIH0sXG5cbiAgICBhZnRlclVwZGF0ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSwgYXR0cmlidXRlTmFtZSwgdmFsdWUsIG9sZFZhbHVlKXtcblxuICAgIH1cblxufSwge1xuXG4gICAgdHlwZSA6ICdTdW1tYXJpemUnXG5cbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3VtbWFyaXplOyIsInZhciBSZWxhdGlvbiA9IHJlcXVpcmUoJy4vLi4vUmVsYXRpb24uanMnKTtcbnZhciBIZWFkZXIgPSByZXF1aXJlKCcuLy4uL0hlYWRlci5qcycpO1xudmFyIFR1cGxlID0gcmVxdWlyZSgnLi8uLi9UdXBsZS5qcycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9kZWJ1ZycpO1xuXG5cblxudmFyIFVuZ3JvdXAgPSBSZWxhdGlvbi5leHRlbmQoXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgT3BlcmF0b3JzLlVuZ3JvdXBcbiAgICAgICAgICogQGV4dGVuZHMgUmVsYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtSZWxhdGlvbn0gcmVsYXRpb24gVGhlIHJlbGF0aW9uIHRvIHVuZ3JvdXBcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gZ3JvdXBlZEF0dHJpYnV0ZXMgVGhlIGdyb3VwZWQgYXR0cmlidXRlIG5hbWVzIHRvIHVuZ3JvdXBcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIFVuZ3JvdXAgb3BlcmF0aW9uIHdpbGwgdW5ncm91cCB0aGUgc3BlY2lmaWVkIGdyb3VwZWQgYXR0cmlidXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkEgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge2E6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2I6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2M6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19XG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWzEsIDIsIDNdLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzQsIDUsIDZdLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzQsIDksIDldLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzcsIDgsIDldXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQiA9IHJlbGF0aW9uQS5ncm91cCgnZ3JvdXBlZEF0dHJpYnV0ZScsIFsnYicsICdjJ10pXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBhIDogVEludGVnZXIgfCBncm91cGVkQXR0cmlidXRlIDogUmVsYXRpb24gICAgIHxcbiAgICAgICAgICogICAgIC8vICs9PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAvLyB8IDEgICAgICAgICAgICB8ICstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLSsgfFxuICAgICAgICAgKiAgICAgLy8gfCAgICAgICAgICAgICAgfCB8IGIgOiBUSW50ZWdlciB8IGMgOiBUSW50ZWdlciB8IHxcbiAgICAgICAgICogICAgIC8vIHwgICAgICAgICAgICAgIHwgKz09PT09PT09PT09PT09Kz09PT09PT09PT09PT09KyB8XG4gICAgICAgICAqICAgICAvLyB8ICAgICAgICAgICAgICB8IHwgMiAgICAgICAgICAgIHwgMyAgICAgICAgICAgIHwgfFxuICAgICAgICAgKiAgICAgLy8gfCAgICAgICAgICAgICAgfCArLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDQgICAgICAgICAgICB8ICstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLSsgfFxuICAgICAgICAgKiAgICAgLy8gfCAgICAgICAgICAgICAgfCB8IGIgOiBUSW50ZWdlciB8IGMgOiBUSW50ZWdlciB8IHxcbiAgICAgICAgICogICAgIC8vIHwgICAgICAgICAgICAgIHwgKz09PT09PT09PT09PT09Kz09PT09PT09PT09PT09KyB8XG4gICAgICAgICAqICAgICAvLyB8ICAgICAgICAgICAgICB8IHwgNSAgICAgICAgICAgIHwgNiAgICAgICAgICAgIHwgfFxuICAgICAgICAgKiAgICAgLy8gfCAgICAgICAgICAgICAgfCArLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgICogICAgIC8vIHwgICAgICAgICAgICAgIHwgfCA5ICAgICAgICAgICAgfCA5ICAgICAgICAgICAgfCB8XG4gICAgICAgICAqICAgICAvLyB8ICAgICAgICAgICAgICB8ICstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLSsgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgNyAgICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKyB8XG4gICAgICAgICAqICAgICAvLyB8ICAgICAgICAgICAgICB8IHwgYiA6IFRJbnRlZ2VyIHwgYyA6IFRJbnRlZ2VyIHwgfFxuICAgICAgICAgKiAgICAgLy8gfCAgICAgICAgICAgICAgfCArPT09PT09PT09PT09PT0rPT09PT09PT09PT09PT0rIHxcbiAgICAgICAgICogICAgIC8vIHwgICAgICAgICAgICAgIHwgfCA4ICAgICAgICAgICAgfCA5ICAgICAgICAgICAgfCB8XG4gICAgICAgICAqICAgICAvLyB8ICAgICAgICAgICAgICB8ICstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLSsgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkMgPSByZWxhdGlvbkIudW5ncm91cChbJ2dyb3VwZWRBdHRyaWJ1dGUnXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyAgICAgICAgICAgICAgICAgPC0tLS1VTkdST1VQRUQgQVRUUklCVVRFUy0tLS0+XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IGEgOiBUSW50ZWdlciB8IGIgOiBUSW50ZWdlciB8IGMgOiBUSW50ZWdlciB8XG4gICAgICAgICAqICAgICAvLyArPT09PT09PT09PT09PT0rPT09PT09PT09PT09PT0rPT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAvLyB8IDEgICAgICAgICAgICB8IDIgICAgICAgICAgICB8IDMgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDQgICAgICAgICAgICB8IDUgICAgICAgICAgICB8IDYgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDQgICAgICAgICAgICB8IDkgICAgICAgICAgICB8IDkgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDcgICAgICAgICAgICB8IDggICAgICAgICAgICB8IDkgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICByZWxhdGlvbkMuZXF1YWwocmVsYXRpb25BKSAvLyB0cnVlXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHJlbGF0aW9uLCBncm91cGVkQXR0cmlidXRlcykge1xuXG4gICAgICAgICAgICBkZWJ1Zy51bmdyb3VwLnRyYWNlKCcjY29uc3RydWN0b3InKTtcblxuICAgICAgICAgICAgdGhpcy5yZWxhdGlvbiA9IHJlbGF0aW9uO1xuICAgICAgICAgICAgdGhpcy5ncm91cGVkQXR0cmlidXRlTmFtZXMgPSBncm91cGVkQXR0cmlidXRlcztcblxuICAgICAgICAgICAgUmVsYXRpb24uY2FsbCh0aGlzKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGJpbmRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgZGVidWcudW5ncm91cC50cmFjZSgnI2JpbmRFdmVudHMnKTtcblxuICAgICAgICAgICAgLy8gQ2FsbGluZyB0aGUgcGFyZW50IGJpbmRFdmVudHNcbiAgICAgICAgICAgIFVuZ3JvdXAuX19zdXBlcl9fLmJpbmRFdmVudHMuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBCZWZvcmVHZXRIZWFkZXJcbiAgICAgICAgICAgIHRoaXMuZWUub25jZSgnYmVmb3JlR2V0SGVhZGVyJywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgZGVidWcudW5ncm91cC50cmFjZSgnYmVmb3JlR2V0SGVhZGVyJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBMZXQncyBcImZsYXR0ZW5cIiB0aGUgaGVhZGVycy4gV2Ugd2lsbCBhZGQgdGhlIG5lc3RlZCByZWxhdGlvbiBoZWFkZXIgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIC8vIHRvIHRoaXMgcmVsYXRpb25cblxuICAgICAgICAgICAgICAgIF8uZm9yRWFjaCh0aGF0Lmdyb3VwZWRBdHRyaWJ1dGVOYW1lcywgZnVuY3Rpb24oZ3JvdXBlZEF0dHJpYnV0ZU5hbWUpe1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgUlZBIChyZWxhdGlvbi12YWx1ZWQgYXR0cmlidXRlKSBzdG9yZXMgYSBjb3B5IG9mIHRoZSBoZWFkZXIgb2YgaXQncyBuZXN0ZWQgcmVsYXRpb25zXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSBhdHRyaWJ1dGUucmVsYXRpb25IZWFkZXIgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWxhdGlvbkhlYWRlciA9IHRoYXQucmVsYXRpb24uaGVhZGVyKCkuZ2V0KGdyb3VwZWRBdHRyaWJ1dGVOYW1lKS5yZWxhdGlvbkhlYWRlcjtcblxuICAgICAgICAgICAgICAgICAgICB0aGF0LmhlYWRlcigpLmNvcHkocmVsYXRpb25IZWFkZXIpO1xuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBMZXQncyBhZGQgYWxsIHRoZSBvdGhlciBub24tZ3JvdXBlZCBhdHRyaWJ1dGVzIHRvIHRoZSBoZWFkZXJcblxuICAgICAgICAgICAgICAgIHRoYXQucmVsYXRpb24uaGVhZGVyKCkuZWFjaChmdW5jdGlvbihhdHRyaWJ1dGUpe1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cGVkID0gXy5hbnkodGhhdC5ncm91cGVkQXR0cmlidXRlTmFtZXMsIGZ1bmN0aW9uKGdyb3VwZWRBdHRyaWJ1dGVOYW1lKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdyb3VwZWRBdHRyaWJ1dGVOYW1lID09PSBhdHRyaWJ1dGUubmFtZTtcblxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZighZ3JvdXBlZCl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuaGVhZGVyKCkuYWRkKGF0dHJpYnV0ZS5jbG9uZSgpKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEJlZm9yZUdldEJvZHlcbiAgICAgICAgICAgIHRoaXMuZWUub25jZSgnYmVmb3JlR2V0Qm9keScsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIGRlYnVnLnVuZ3JvdXAudHJhY2UoJ2JlZm9yZUdldEJvZHknKTtcblxuICAgICAgICAgICAgICAgIHRoYXQucmVsYXRpb24uZWFjaChmdW5jdGlvbih0dXBsZSl7XG5cbiAgICAgICAgICAgICAgICAgICAgXy5mb3JFYWNoKHRoYXQuZ3JvdXBlZEF0dHJpYnV0ZU5hbWVzLCBmdW5jdGlvbihncm91cGVkQXR0cmlidXRlTmFtZSl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHR1cGxlLmdldChncm91cGVkQXR0cmlidXRlTmFtZSkuZWFjaChmdW5jdGlvbihuZXN0ZWRUdXBsZSl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VHVwbGUgPSBuZXcgVHVwbGUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvcHkgdGhlIG5vbiBncm91cGVkIGF0dHJpYnV0ZXMgZnJvbSB0aGUgcm9vdCB0dXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1R1cGxlLmNvcHkodHVwbGUsIHRoYXQuZ3JvdXBlZEF0dHJpYnV0ZU5hbWVzLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvcHkgdGhlIGF0dHJpYnV0ZXMgZnJvbSB0aGUgbmVzdGVkIHR1cGxlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdUdXBsZS5jb3B5KG5lc3RlZFR1cGxlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYWRkKG5ld1R1cGxlLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJBZGQgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUpe1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVsYXRpb24udW5ncm91cCh0aGlzLmdyb3VwZWRBdHRyaWJ1dGVOYW1lcyk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFRvKHJlc3VsdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJSZW1vdmUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUpe1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVsYXRpb24udW5ncm91cCh0aGlzLmdyb3VwZWRBdHRyaWJ1dGVOYW1lcyk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFRvKHJlc3VsdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJVcGRhdGUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSl7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZWxhdGlvbi51bmdyb3VwKHRoaXMuZ3JvdXBlZEF0dHJpYnV0ZU5hbWVzKTtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0VG8ocmVzdWx0KTtcbiAgICAgICAgfVxuXG4gICAgfSwge1xuXG4gICAgICAgIHR5cGUgOiAnVW5ncm91cCdcblxuICAgIH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVuZ3JvdXA7IiwidmFyIFJlbGF0aW9uID0gcmVxdWlyZSgnLi8uLi9SZWxhdGlvbi5qcycpO1xudmFyIEhlYWRlciA9IHJlcXVpcmUoJy4vLi4vSGVhZGVyLmpzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2RlYnVnJyk7XG5cblxuXG52YXIgVW5pb24gPSBSZWxhdGlvbi5leHRlbmQoXG5cbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBPcGVyYXRvcnMuVW5pb25cbiAgICAgICAgICogQHBhcmFtIHtSZWxhdGlvbn0gcmVsYXRpb25BXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uQlxuICAgICAgICAgKiBAZXh0ZW5kcyBSZWxhdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBFeGFtcGxlIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkEgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge2NoYXJhY3RlcklkOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtmaXJzdE5hbWU6IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7bGFzdE5hbWU6IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbMSwgJ0pvaG4nLCAnRG9lJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbMiwgJ01hcnknLCAnUG9wcGlucyddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzMsICdMdWNreScsICdMdWtlJ11cbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25CID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgICAgIHtjaGFyYWN0ZXJJZDogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7Zmlyc3ROYW1lOiB7IHR5cGU6IGFmZmluaXR5LlN0cmluZ319LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2xhc3ROYW1lOiB7IHR5cGU6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWzEsICdNcicsICdYJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbMiwgJ0xhZHknLCAnR2FnYSddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzMsICdCbycsICdWcmlsJ11cbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25DID0gcmVsYXRpb25BLnVuaW9uKHJlbGF0aW9uQilcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG9yXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25DID0gbmV3IGFmZmluaXR5LlVuaW9uKHJlbGF0aW9uQSwgcmVsYXRpb25CKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBjaGFyYWN0ZXJJZCA6IFRJbnRlZ2VyIHwgZmlyc3ROYW1lIDogVFN0cmluZyB8IGxhc3ROYW1lIDogVFN0cmluZyB8XG4gICAgICAgICAqICAgICAvLyArPT09PT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PSsgICAtXG4gICAgICAgICAqICAgICAvLyB8IDEgICAgICAgICAgICAgICAgICAgICAgfCBKb2huICAgICAgICAgICAgICAgIHwgRG9lICAgICAgICAgICAgICAgIHwgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rICAgIHxcbiAgICAgICAgICogICAgIC8vIHwgMiAgICAgICAgICAgICAgICAgICAgICB8IE1hcnkgICAgICAgICAgICAgICAgfCBQb3BwaW5zICAgICAgICAgICAgfCAgICB8IFJlbGF0aW9uQVxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rICAgIHxcbiAgICAgICAgICogICAgIC8vIHwgMyAgICAgICAgICAgICAgICAgICAgICB8IEx1Y2t5ICAgICAgICAgICAgICAgfCBMdWtlICAgICAgICAgICAgICAgfCAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLSsgICAtXG4gICAgICAgICAqICAgICAvLyB8IDEgICAgICAgICAgICAgICAgICAgICAgfCBNciAgICAgICAgICAgICAgICAgIHwgWCAgICAgICAgICAgICAgICAgIHwgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rICAgIHxcbiAgICAgICAgICogICAgIC8vIHwgMiAgICAgICAgICAgICAgICAgICAgICB8IExhZHkgICAgICAgICAgICAgICAgfCBHYWdhICAgICAgICAgICAgICAgfCAgICB8IFJlbGF0aW9uQlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rICAgIHxcbiAgICAgICAgICogICAgIC8vIHwgMyAgICAgICAgICAgICAgICAgICAgICB8IEJvICAgICAgICAgICAgICAgICAgfCBWcmlsICAgICAgICAgICAgICAgfCAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLSsgICAtXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHJlbGF0aW9uQSwgcmVsYXRpb25CKSB7XG4gICAgICAgICAgICB0aGlzLnJlbHMgPSBbcmVsYXRpb25BLCByZWxhdGlvbkJdO1xuICAgICAgICAgICAgUmVsYXRpb24uY2FsbCh0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLnVuaW9uLnRyYWNlKCcjYmluZEV2ZW50cycpO1xuXG4gICAgICAgICAgICBVbmlvbi5fX3N1cGVyX18uYmluZEV2ZW50cy5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoYXQuZWUub25jZSgnYmVmb3JlR2V0Qm9keScsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIGRlYnVnLnVuaW9uLnRyYWNlKCdiZWZvcmVHZXRCb2R5Jyk7XG5cbiAgICAgICAgICAgICAgICBfLmZvckVhY2godGhhdC5yZWxzLCBmdW5jdGlvbiAocmVsYXRpb24pIHtcblxuICAgICAgICAgICAgICAgICAgICByZWxhdGlvbi5lYWNoKGZ1bmN0aW9uKHR1cGxlKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5hZGQodHVwbGUuY2xvbmUoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB9LCB0aGF0KVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhhdC5lZS5vbmNlKCdiZWZvcmVHZXRIZWFkZXInLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICBkZWJ1Zy51bmlvbi50cmFjZSgnYmVmb3JlR2V0SGVhZGVyJyk7XG5cbiAgICAgICAgICAgICAgICBIZWFkZXIuYXNzZXJ0VW5pb25Db21wYXRpYmxlKHRoYXQucmVsc1swXS5oZWFkZXIoKSwgdGhhdC5yZWxzWzFdLmhlYWRlcigpKTtcblxuICAgICAgICAgICAgICAgIHRoYXQuaGVhZGVyKCkuY29weSh0aGF0LnJlbHNbMF0uaGVhZGVyKCkpO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyTGVmdEFkZCA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSl7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlckxlZnRSZW1vdmUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUpe1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJMZWZ0VXBkYXRlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlLCBhdHRyaWJ1dGVOYW1lLCB2YWx1ZSwgb2xkVmFsdWUpe1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJSaWdodEFkZCA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSl7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlclJpZ2h0UmVtb3ZlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyUmlnaHRVcGRhdGUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSl7XG5cbiAgICAgICAgfVxuXG4gICAgfSwge1xuXG4gICAgICAgIHR5cGUgOiAnVW5pb24nXG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBVbmlvbjsiLCJ2YXIgUmVsYXRpb24gPSByZXF1aXJlKCcuLy4uL1JlbGF0aW9uLmpzJyk7XG52YXIgSGVhZGVyID0gcmVxdWlyZSgnLi8uLi9IZWFkZXIuanMnKTtcbnZhciBUdXBsZSA9IHJlcXVpcmUoJy4vLi4vVHVwbGUuanMnKTtcbnZhciBTZXQgPSByZXF1aXJlKCcuLy4uL1NldC5qcycpO1xudmFyIEF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4vLi4vQXR0cmlidXRlLmpzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2RlYnVnJyk7XG5cblxuXG52YXIgVW53cmFwID0gUmVsYXRpb24uZXh0ZW5kKFxuXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgT3BlcmF0b3JzLlVud3JhcFxuICAgICAgICAgKiBAZXh0ZW5kcyBSZWxhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1JlbGF0aW9ufSByZWxhdGlvbiBUaGUgcmVsYXRpb24gdG8gVW53cmFwXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW118U3RyaW5nfFNldHxIZWFkZXJ9IGF0dHJpYnV0ZU5hbWVzIFRoZSBuYW1lIG9mIHRoZSB3cmFwcGVkIGF0dHJpYnV0ZXMgdG8gdW53cmFwXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBVbndyYXAgb3BlcmF0b3Igd2lsbCByZXZlcnNlIHRoZSB7QGxpbmsgT3BlcmF0b3JzLldyYXB9IG9wZXJhdGlvbiwgY29udmVydGluZyBhIHR1cGxlLXZhbHVlZCBhdHRyaWJ1dGUgaW50b1xuICAgICAgICAgKiB0aGUgYXR0cmlidXRlcyBvZiB0aGUgdHVwbGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uQSA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7Y2hhcmFjdGVySWQ6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2ZpcnN0TmFtZTogeyB0eXBlOiBhZmZpbml0eS5TdHJpbmd9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtsYXN0TmFtZTogeyB0eXBlOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsxLCAnSm9obicsICdEb2UnXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsyLCAnTWFyeScsICdQb3BwaW5zJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbMywgJ0x1Y2t5JywgJ0x1a2UnXVxuICAgICAgICAgKiAgICAgICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkIgPSByZWxhdGlvbkEuVW53cmFwKCdVbndyYXBwZWRBdHRyaWJ1dGUnLCBbJ2ZpcnN0TmFtZScsJ2xhc3ROYW1lJ10pO1xuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IGNoYXJhY3RlcklkIDogVEludGVnZXIgfCB1bndyYXBwZWRBdHRyaWJ1dGUgOiBUdXBsZSAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICs9PT09PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgLy8gfCAxICAgICAgICAgICAgICAgICAgICAgIHwgVHVwbGV7Zmlyc3ROYW1lIDogJ0pvaG4nLCBsYXN0TmFtZSA6ICdEb2UnfSAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMiAgICAgICAgICAgICAgICAgICAgICB8IFR1cGxle2ZpcnN0TmFtZSA6ICdNYXJ5JywgbGFzdE5hbWUgOiAnUG9wcGlucyd9fFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDMgICAgICAgICAgICAgICAgICAgICAgfCBUdXBsZXtmaXJzdE5hbWUgOiAnTHVja3knLCBsYXN0TmFtZSA6ICdMdWtlJ30gIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy9cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkMgPSByZWxhdGlvbkIudW53cmFwKCd1bndyYXBwZWRBdHRyaWJ1dGUnKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG9yXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25DID0gbmV3IGFmZmluaXR5LlVud3JhcChyZWxhdGlvbkIsICd1bndyYXBwZWRBdHRyaWJ1dGUnKTtcbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tLS0tLVVOV1JBUFBFRCBBVFRSSUJVVEVTLS0tLS0tLS0tLS0tLS0tPlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IGNoYXJhY3RlcklkIDogVEludGVnZXIgfCBmaXJzdE5hbWUgOiBUU3RyaW5nIHwgbGFzdE5hbWUgOiBUU3RyaW5nIHxcbiAgICAgICAgICogICAgIC8vICs9PT09PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgLy8gfCAxICAgICAgICAgICAgICAgICAgICAgIHwgSm9obiAgICAgICAgICAgICAgICB8IERvZSAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMiAgICAgICAgICAgICAgICAgICAgICB8IE1hcnkgICAgICAgICAgICAgICAgfCBQb3BwaW5zICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDMgICAgICAgICAgICAgICAgICAgICAgfCBMdWNreSAgICAgICAgICAgICAgIHwgTHVrZSAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIChyZWxhdGlvbiwgYXR0cmlidXRlTmFtZXMpIHtcblxuICAgICAgICAgICAgZGVidWcudW53cmFwLnRyYWNlKCcjY29uc3RydWN0b3InKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHJlbGF0aW9uIGFyZ3VtZW50IGlzIG9mIGdvb2QgdHlwZVxuICAgICAgICAgICAgaWYoIShyZWxhdGlvbiBpbnN0YW5jZW9mIFJlbGF0aW9uKSl7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3BlY2lmaWVkIHJlbGF0aW9uIGlzIG9mIHdyb25nIHR5cGUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlIGF0dHJpYnV0ZU5hbWVzIGlzIGEgc3RyaW5nLCBjb2VyY2UgaXQgdG8gYW4gYXJyYXlcbiAgICAgICAgICAgIGlmKF8uaXNTdHJpbmcoYXR0cmlidXRlTmFtZXMpKXtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lcyA9IFthdHRyaWJ1dGVOYW1lc107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBhdHRyaWJ1dGVOYW1lcyBpcyBub3QgYW4gYXJyYXkgb3Igc2V0LCB0aHJvdyBhbiBlcnJvclxuICAgICAgICAgICAgaWYoIV8uaXNBcnJheShhdHRyaWJ1dGVOYW1lcykgJiYgIShhdHRyaWJ1dGVOYW1lcyBpbnN0YW5jZW9mIFNldCkpe1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdHlwZSBvZiBzcGVjaWZpZWQgYXR0cmlidXRlTmFtZXMgdG8gdW53cmFwJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKF8uaXNBcnJheShhdHRyaWJ1dGVOYW1lcykgJiYgYXR0cmlidXRlTmFtZXMubGVuZ3RoIDw9IDApe1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3BlY2lmeSBhdHRyaWJ1dGVzIHRvIHVud3JhcCEnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoKGF0dHJpYnV0ZU5hbWVzIGluc3RhbmNlb2YgU2V0KSAmJiBhdHRyaWJ1dGVOYW1lcy5sZW5ndGgoKSA8PSAwKXtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHNwZWNpZnkgYXR0cmlidXRlcyB0byB1bndyYXAhJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlTmFtZXMgPSBhdHRyaWJ1dGVOYW1lcztcbiAgICAgICAgICAgIHRoaXMucmVsYXRpb24gPSByZWxhdGlvbjtcblxuICAgICAgICAgICAgUmVsYXRpb24uY2FsbCh0aGlzKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGJpbmRFdmVudHM6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgZGVidWcudW53cmFwLnRyYWNlKCcjYmluZEV2ZW50cycpO1xuXG4gICAgICAgICAgICAvLyBDYWxsaW5nIHRoZSBwYXJlbnQgYmluZEV2ZW50c1xuICAgICAgICAgICAgVW53cmFwLl9fc3VwZXJfXy5iaW5kRXZlbnRzLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIHZhciByZWxhdGlvbiA9IHRoaXMucmVsYXRpb247XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgLy8gQmVmb3JlR2V0SGVhZGVyXG4gICAgICAgICAgICB0aGlzLmVlLm9uY2UoJ2JlZm9yZUdldEhlYWRlcicsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIGRlYnVnLnVud3JhcC50cmFjZSgnYmVmb3JlR2V0SGVhZGVyJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBDb3B5IGFsbCBhdHRyaWJ1dGVzIGZyb20gdGhlIGJhc2UgaGVhZGVyIHRoYXQgd2lsbCBub3QgYmUgdW53cmFwcGVkXG4gICAgICAgICAgICAgICAgdGhhdC5oZWFkZXIoKS5jb3B5KHJlbGF0aW9uLmhlYWRlcigpLCB0aGF0LmF0dHJpYnV0ZU5hbWVzLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIC8vIEdldCBhbGwgYXR0cmlidXRlcyB0aGF0IHdlcmUgd3JhcHBlZCBpbiB0aGUgYmFzZSByZWxhdGlvblxuICAgICAgICAgICAgICAgIHZhciBhbHJlYWR5V3JhcHBlZEF0dHJpYnV0ZXMgPSBuZXcgSGVhZGVyKCk7XG4gICAgICAgICAgICAgICAgcmVsYXRpb24uaGVhZGVyKCkuZWFjaChmdW5jdGlvbihhdHRyaWJ1dGUpe1xuICAgICAgICAgICAgICAgICAgICBpZihhdHRyaWJ1dGUud3JhcHBlZEF0dHJpYnV0ZXMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxyZWFkeVdyYXBwZWRBdHRyaWJ1dGVzLmFkZChhdHRyaWJ1dGUuY2xvbmUoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgYXR0cmlidXRlcyB3aGljaCB3aWxsIGJlIHVud3JhcHBlZFxuICAgICAgICAgICAgICAgIHZhciB1bndyYXBwZWRBdHRyaWJ1dGVzID0gbmV3IEhlYWRlcigpO1xuICAgICAgICAgICAgICAgIHVud3JhcHBlZEF0dHJpYnV0ZXMuY29weShyZWxhdGlvbi5oZWFkZXIoKSwgdGhhdC5hdHRyaWJ1dGVOYW1lcyk7XG4gICAgICAgICAgICAgICAgdGhhdC51bndyYXBwZWRBdHRyaWJ1dGVzID0gdW53cmFwcGVkQXR0cmlidXRlcztcblxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgYXR0cmlidXRlcyB3aGljaCB3aWxsIG5vdCBiZSB1bndyYXBwZWRcbiAgICAgICAgICAgICAgICB2YXIgbm9uVW53cmFwcGVkQXR0cmlidXRlcyA9IG5ldyBIZWFkZXIoKTtcbiAgICAgICAgICAgICAgICBub25VbndyYXBwZWRBdHRyaWJ1dGVzLmNvcHkocmVsYXRpb24uaGVhZGVyKCksIHRoYXQuYXR0cmlidXRlTmFtZXMsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoYXQubm9uVW53cmFwcGVkQXR0cmlidXRlcyA9IG5vblVud3JhcHBlZEF0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBhdHRyaWJ1dGVzIHRvIGJlIHVud3JhcHBlZCBhcmUgd3JhcHBlZC4gV2Ugd291bGQgbm90IHdhbnRcbiAgICAgICAgICAgICAgICAvLyB0byB1bndyYXAgbm9uLXdyYXBwZWQgYXR0cmlidXRlcyFcbiAgICAgICAgICAgICAgICBpZighdW53cmFwcGVkQXR0cmlidXRlcy5pc1N1YnNldChhbHJlYWR5V3JhcHBlZEF0dHJpYnV0ZXMpKXtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTcGVjaWZpZWQgYXR0cmlidXRlcyBhcmUgbm90IGFsbCB3cmFwcGVkIGF0dHJpYnV0ZXMuIE11c3Qgc3BlY2lmeSBhdHRyaWJ1dGVzIHdoaWNoIGFyZSB3cmFwcGVkLicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCBhbGwgbmVzdGVkIHVud3JhcHBlZCBhdHRyaWJ1dGVzIGluIHRoZSBoZWFkZXJcbiAgICAgICAgICAgICAgICB1bndyYXBwZWRBdHRyaWJ1dGVzLmVhY2goZnVuY3Rpb24odW53cmFwcGVkQXR0cmlidXRlKXtcbiAgICAgICAgICAgICAgICAgICAgdW53cmFwcGVkQXR0cmlidXRlLndyYXBwZWRBdHRyaWJ1dGVzLmVhY2goZnVuY3Rpb24od3JhcHBlZEF0dHJpYnV0ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmhlYWRlcigpLmFkZCh3cmFwcGVkQXR0cmlidXRlLmNsb25lKCkpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBCZWZvcmVHZXRCb2R5XG4gICAgICAgICAgICB0aGlzLmVlLm9uY2UoJ2JlZm9yZUdldEJvZHknLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICBkZWJ1Zy51bndyYXAudHJhY2UoJ2JlZm9yZUdldEJvZHknKTtcblxuICAgICAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIHR1cGxlIG9mIHRoZSByZWxhdGlvblxuICAgICAgICAgICAgICAgIHRoYXQucmVsYXRpb24uZWFjaChmdW5jdGlvbih0dXBsZSl7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSB0dXBsZSB0byBiZSBpbnNlcnRlZFxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VHVwbGUgPSBuZXcgVHVwbGUoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBc3NpZ24gdGhlIHZhbHVlcyB0byB0aGUgYXR0cmlidXRlcyB3aGljaCB3aWxsIG5vdCBiZSB1bndyYXBwZWRcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5ub25VbndyYXBwZWRBdHRyaWJ1dGVzLmVhY2goZnVuY3Rpb24oYXR0cmlidXRlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1R1cGxlLnNldChhdHRyaWJ1dGUubmFtZSwgdHVwbGUuZ2V0KGF0dHJpYnV0ZS5uYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCB0aGUgYXR0cmlidXRlcyB0byBiZSB1bndyYXBwZWRcbiAgICAgICAgICAgICAgICAgICAgdGhhdC51bndyYXBwZWRBdHRyaWJ1dGVzLmVhY2goZnVuY3Rpb24odW53cmFwcGVkQXR0cmlidXRlKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIHRoZSB3cmFwcGVkIGF0dHJpYnV0ZSBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVud3JhcHBlZEF0dHJpYnV0ZS53cmFwcGVkQXR0cmlidXRlcy5lYWNoKGZ1bmN0aW9uKHdyYXBwZWRBdHRyaWJ1dGUpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSB0dXBsZSB2YWx1ZSBmb3IgdGhpcyBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdUdXBsZS5zZXQod3JhcHBlZEF0dHJpYnV0ZS5uYW1lLCB0dXBsZS5nZXQodW53cmFwcGVkQXR0cmlidXRlLm5hbWUpLmdldCh3cmFwcGVkQXR0cmlidXRlLm5hbWUpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB0aGF0LmFkZChuZXdUdXBsZSk7XG5cbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyQWRkIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlbGF0aW9uLnVud3JhcCh0aGlzLmF0dHJpYnV0ZU5hbWVzKTtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0VG8ocmVzdWx0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlclJlbW92ZSA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSl7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZWxhdGlvbi51bndyYXAodGhpcy5hdHRyaWJ1dGVOYW1lcyk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFRvKHJlc3VsdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJVcGRhdGUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSl7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZWxhdGlvbi51bndyYXAodGhpcy5hdHRyaWJ1dGVOYW1lcyk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFRvKHJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgIH0sIHtcblxuICAgICAgICB0eXBlIDogJ1Vud3JhcCdcblxuICAgIH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVud3JhcDsiLCJ2YXIgUmVsYXRpb24gPSByZXF1aXJlKCcuLy4uL1JlbGF0aW9uLmpzJyk7XG52YXIgU2V0ID0gcmVxdWlyZSgnLi8uLi9TZXQuanMnKTtcbnZhciBIZWFkZXIgPSByZXF1aXJlKCcuLy4uL0hlYWRlci5qcycpO1xudmFyIEF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4vLi4vQXR0cmlidXRlLmpzJyk7XG52YXIgVHVwbGUgPSByZXF1aXJlKCcuLy4uL1R1cGxlLmpzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2RlYnVnJyk7XG5cblxuXG52YXIgV3JhcCA9IFJlbGF0aW9uLmV4dGVuZChcblxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIE9wZXJhdG9ycy5XcmFwXG4gICAgICAgICAqIEBleHRlbmRzIFJlbGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7UmVsYXRpb259IHJlbGF0aW9uQSBUaGUgcmVsYXRpb24gdG8gd3JhcFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gd3JhcHBpbmdBdHRyaWJ1dGVOYW1lIFRoZSBuYW1lIG9mIHRoZSB3cmFwcGluZyBhdHRyaWJ1dGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gd3JhcHBlZEF0dHJpYnV0ZXMgVGhlIHdyYXBwZWRBdHRyaWJ1dGVzIHRvIHdyYXBcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIFdyYXAgd2lsbCBnYXRoZXIgbXVsdGlwbGUgd3JhcHBlZEF0dHJpYnV0ZXMgaW50byBhIHNpbmdsZSBvbmUsIGNvbnZlcnRpbmcgdGhlbSB0byBhIHR1cGxlLXZhbHVlZCBhdHRyaWJ1dGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkEgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge2NoYXJhY3RlcklkOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtmaXJzdE5hbWU6IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7bGFzdE5hbWU6IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbMSwgJ0pvaG4nLCAnRG9lJ10sXG4gICAgICAgICAqICAgICAgICAgICAgICBbMiwgJ01hcnknLCAnUG9wcGlucyddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzMsICdMdWNreScsICdMdWtlJ11cbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgY2hhcmFjdGVySWQgOiBUSW50ZWdlciB8IGZpcnN0TmFtZSA6IFRTdHJpbmcgfCBsYXN0TmFtZSA6IFRTdHJpbmcgfFxuICAgICAgICAgKiAgICAgLy8gKz09PT09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAvLyB8IDEgICAgICAgICAgICAgICAgICAgICAgfCBKb2huICAgICAgICAgICAgICAgIHwgRG9lICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAyICAgICAgICAgICAgICAgICAgICAgIHwgTWFyeSAgICAgICAgICAgICAgICB8IFBvcHBpbnMgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMyAgICAgICAgICAgICAgICAgICAgICB8IEx1Y2t5ICAgICAgICAgICAgICAgfCBMdWtlICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb25DID0gcmVsYXRpb25BLndyYXAoJ3dyYXBwZWRBdHRyaWJ1dGUnLCBbJ2ZpcnN0TmFtZScsJ2xhc3ROYW1lJ10pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gb3JcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbkMgPSBuZXcgYWZmaW5pdHkuV3JhcChyZWxhdGlvbkEsICd3cmFwcGVkQXR0cmlidXRlJywgWydmaXJzdE5hbWUnLCdsYXN0TmFtZSddKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tLVdSQVBQSU5HIEFUVFJJQlVURS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IGNoYXJhY3RlcklkIDogVEludGVnZXIgfCB3cmFwcGVkQXR0cmlidXRlIDogVHVwbGUgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICs9PT09PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgLy8gfCAxICAgICAgICAgICAgICAgICAgICAgIHwgVHVwbGV7Zmlyc3ROYW1lIDogJ0pvaG4nLCBsYXN0TmFtZSA6ICdEb2UnfSAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMiAgICAgICAgICAgICAgICAgICAgICB8IFR1cGxle2ZpcnN0TmFtZSA6ICdNYXJ5JywgbGFzdE5hbWUgOiAnUG9wcGlucyd9fFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDMgICAgICAgICAgICAgICAgICAgICAgfCBUdXBsZXtmaXJzdE5hbWUgOiAnTHVja3knLCBsYXN0TmFtZSA6ICdMdWtlJ30gIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy9cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAocmVsYXRpb25BLCB3cmFwcGluZ0F0dHJpYnV0ZU5hbWUsIHdyYXBwZWRBdHRyaWJ1dGVzKSB7XG5cbiAgICAgICAgICAgIGRlYnVnLndyYXAudHJhY2UoJyNjb25zdHJ1Y3RvcicpO1xuXG4gICAgICAgICAgICB0aGlzLnJlbGF0aW9uID0gcmVsYXRpb25BO1xuXG4gICAgICAgICAgICBBdHRyaWJ1dGUuYXNzZXJ0VmFsaWROYW1lKHdyYXBwaW5nQXR0cmlidXRlTmFtZSk7XG5cbiAgICAgICAgICAgIGlmKCFfLmlzQXJyYXkod3JhcHBlZEF0dHJpYnV0ZXMpICYmICEod3JhcHBlZEF0dHJpYnV0ZXMgaW5zdGFuY2VvZiBTZXQpKXtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyYXBwZWQgYXR0cmlidXRlcyBtdXN0IGJlIGFuIGFycmF5IG9yIHNldCBvZiBhdHRyaWJ1dGVzIC8gYXR0cmlidXRlIG5hbWVzJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKF8uaXNBcnJheSh3cmFwcGVkQXR0cmlidXRlcykgJiYgd3JhcHBlZEF0dHJpYnV0ZXMubGVuZ3RoIDw9IDApe1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgbXVzdCBiZSBhdCBsZWFzdCBvbmUgYXR0cmlidXRlIHRvIHdyYXAnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYod3JhcHBlZEF0dHJpYnV0ZXMgaW5zdGFuY2VvZiBTZXQgJiYgd3JhcHBlZEF0dHJpYnV0ZXMubGVuZ3RoKCkgPD0gMCl7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSBtdXN0IGJlIGF0IGxlYXN0IG9uZSBhdHRyaWJ1dGUgdG8gd3JhcCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLndyYXBwZWRBdHRyaWJ1dGVOYW1lID0gd3JhcHBpbmdBdHRyaWJ1dGVOYW1lO1xuICAgICAgICAgICAgdGhpcy53cmFwcGVkQXR0cmlidXRlcyA9IHdyYXBwZWRBdHRyaWJ1dGVzO1xuXG4gICAgICAgICAgICBSZWxhdGlvbi5jYWxsKHRoaXMpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgYmluZEV2ZW50czogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBkZWJ1Zy53cmFwLnRyYWNlKCcjYmluZEV2ZW50cycpO1xuXG4gICAgICAgICAgICAvLyBDYWxsaW5nIHRoZSBwYXJlbnQgYmluZEV2ZW50c1xuICAgICAgICAgICAgV3JhcC5fX3N1cGVyX18uYmluZEV2ZW50cy5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIEJlZm9yZUdldEhlYWRlclxuICAgICAgICAgICAgdGhpcy5lZS5vbmNlKCdiZWZvcmVHZXRIZWFkZXInLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICBkZWJ1Zy53cmFwLnRyYWNlKCdiZWZvcmVHZXRIZWFkZXInKTtcblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIHBhc3NlZCBhdHRyaWJ1dGVzIGV4aXN0IGluIHRoZSBiYXNlIGhlYWRlclxuICAgICAgICAgICAgICAgIEhlYWRlci5hc3NlcnRBdHRyaWJ1dGVzRXhpc3QodGhhdC5yZWxhdGlvbiwgdGhhdC53cmFwcGVkQXR0cmlidXRlcyk7XG5cbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSB3cmFwcGVkIGF0dHJpYnV0ZXMsIGNvbnZlcnQgdGhlbSB0byBhIEhlYWRlciBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIHZhciB3cmFwcGVkQXR0cmlidXRlcyA9IG5ldyBIZWFkZXIoKTtcbiAgICAgICAgICAgICAgICB3cmFwcGVkQXR0cmlidXRlcy5jb3B5KHRoYXQucmVsYXRpb24uaGVhZGVyKCksIHRoYXQud3JhcHBlZEF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgIHRoYXQud3JhcHBlZEF0dHJpYnV0ZXMgPSB3cmFwcGVkQXR0cmlidXRlcztcblxuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIG5vbiB3cmFwcGVkIGF0dHJpYnV0ZXMgaW4gYW5vdGhlciB2YXJpYWJsZSwgYW5kXG4gICAgICAgICAgICAgICAgLy8gY29weSB0aGUgYXR0cmlidXRlcyBpbiB0aGlzIGhlYWRlclxuICAgICAgICAgICAgICAgIHRoYXQubm9uV3JhcHBlZEF0dHJpYnV0ZXMgPSBuZXcgSGVhZGVyKCk7XG4gICAgICAgICAgICAgICAgdGhhdC5ub25XcmFwcGVkQXR0cmlidXRlcy5jb3B5KHRoYXQucmVsYXRpb24uaGVhZGVyKCksIHRoYXQud3JhcHBlZEF0dHJpYnV0ZXMsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoYXQuaGVhZGVyKCkuY29weSh0aGF0Lm5vbldyYXBwZWRBdHRyaWJ1dGVzKTtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgd3JhcHBlZCBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICB2YXIgbmV3V3JhcHBlZEF0dHJpYnV0ZSA9IG5ldyBBdHRyaWJ1dGUoe25hbWUgOiB0aGF0LndyYXBwZWRBdHRyaWJ1dGVOYW1lLCB0eXBlIDogVHVwbGV9KVxuXG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIHdyYXBwZWQgaGVhZGVyIGluIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICBuZXdXcmFwcGVkQXR0cmlidXRlLndyYXBwZWRBdHRyaWJ1dGVzID0gdGhhdC53cmFwcGVkQXR0cmlidXRlcztcblxuICAgICAgICAgICAgICAgIC8vIEFkZCBpdCB0byB0aGUgaGVhZGVyXG4gICAgICAgICAgICAgICAgdGhhdC5oZWFkZXIoKS5hZGQobmV3V3JhcHBlZEF0dHJpYnV0ZSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgIC8vIEJlZm9yZUdldEJvZHlcbiAgICAgICAgICAgIHRoaXMuZWUub25jZSgnYmVmb3JlR2V0Qm9keScsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIGRlYnVnLndyYXAudHJhY2UoJ2JlZm9yZUdldEJvZHknKTtcblxuICAgICAgICAgICAgICAgIHRoYXQucmVsYXRpb24uZWFjaChmdW5jdGlvbih0dXBsZSl7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSB0dXBsZSB3ZSB3aWxsIGxhdGVyIGluc2VydFxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VHVwbGUgPSBuZXcgVHVwbGUoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHRoZSB2YWx1ZSBvZiB0aGUgbm9uLXdyYXBwZWQgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICBuZXdUdXBsZS5jb3B5KHR1cGxlLCB0aGF0Lm5vbldyYXBwZWRBdHRyaWJ1dGVzKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIG5lc3RlZCB0dXBsZVxuICAgICAgICAgICAgICAgICAgICB2YXIgbmVzdGVkVHVwbGUgPSBuZXcgVHVwbGUoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHRoZSB2YWx1ZXMgb2YgdGhlIHdyYXBwZWQgYXR0cmlidXRlcyBpbiB0aGUgbmVzdGVkIHR1cGxlXG4gICAgICAgICAgICAgICAgICAgIG5lc3RlZFR1cGxlLmNvcHkodHVwbGUsIHRoYXQud3JhcHBlZEF0dHJpYnV0ZXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgbmVzdGVkIHR1cGxlIHRvIHRoZSBjb250YWluaW5nIHR1cGxlXG4gICAgICAgICAgICAgICAgICAgIG5ld1R1cGxlLnNldCh0aGF0LndyYXBwZWRBdHRyaWJ1dGVOYW1lLCBuZXN0ZWRUdXBsZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhhdC5hZGQobmV3VHVwbGUpO1xuXG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBhZnRlckFkZCA6IGZ1bmN0aW9uKHJlbGF0aW9uLCB0dXBsZSl7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZWxhdGlvbi53cmFwKHRoaXMud3JhcHBlZEF0dHJpYnV0ZU5hbWUsIHRoaXMud3JhcHBlZEF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RUbyhyZXN1bHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFmdGVyUmVtb3ZlIDogZnVuY3Rpb24ocmVsYXRpb24sIHR1cGxlKXtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlbGF0aW9uLndyYXAodGhpcy53cmFwcGVkQXR0cmlidXRlTmFtZSwgdGhpcy53cmFwcGVkQXR0cmlidXRlcyk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdFRvKHJlc3VsdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWZ0ZXJVcGRhdGUgOiBmdW5jdGlvbihyZWxhdGlvbiwgdHVwbGUsIGF0dHJpYnV0ZU5hbWUsIHZhbHVlLCBvbGRWYWx1ZSl7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZWxhdGlvbi53cmFwKHRoaXMud3JhcHBlZEF0dHJpYnV0ZU5hbWUsIHRoaXMud3JhcHBlZEF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RUbyhyZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICB9LCB7XG5cbiAgICAgICAgdHlwZSA6ICdXcmFwJ1xuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gV3JhcDsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uJyk7XG5cbnZhciBCb29sZWFuID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9Cb29sZWFuLmpzJyk7XG5cbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbnZhciBBbGwgPSBGdW5jdGlvbi5leHRlbmQoe1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIEZ1bmN0aW9ucy5BZ2dyZWdhdGUuQWxsXG4gICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEZ1bmN0aW9ucyB0aGF0IGNoZWNrcyBpZiBhbGwgdGhlIHR1cGxlcyBpbiBhIHJlbGF0aW9uIG1hdGNoIHRoZVxuICAgICAqIGdpdmVuIGJvb2xlYW4gcHJlZGljYXRlLlxuICAgICAqXG4gICAgICogRXhhbXBsZSA6XG4gICAgICpcbiAgICAgKiAgICAgdmFyIHJlbGF0aW9uID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgKiAgICAgICAgIHsgbmFtZSA6IHsgdHlwZSA6IGFmZmluaXR5LlN0cmluZyB9IH0sXG4gICAgICogICAgICAgICB7IGFnZSA6IHsgdHlwZSA6IGFmZmluaXR5LkludGVnZXIgfSB9XG4gICAgICogICAgIF0sW1xuICAgICAqICAgICAgICAgWydKb2huIERvZScsIDIzXSxcbiAgICAgKiAgICAgICAgIFsnTWFyayBDbGludG9uJywgMzZdLFxuICAgICAqICAgICAgICAgWydTdXBlciBXb21hbicsIDU2XVxuICAgICAqICAgICBdKTtcbiAgICAgKlxuICAgICAqICAgICB2YXIgbmFtZSA9IHJlbGF0aW9uLmdldCgnbmFtZScpO1xuICAgICAqICAgICB2YXIgYWdlID0gcmVsYXRpb24uZ2V0KCdhZ2UnKVxuICAgICAqXG4gICAgICogICAgIHZhciBhbGwgPSByZWxhdGlvbi5hbGwoYWdlLmd0KDIwKSk7XG4gICAgICpcbiAgICAgKiAgICAgY29uc29sZS5sb2coYWxsLnZhbHVlKCkpO1xuICAgICAqXG4gICAgICogICAgIC8vIHRydWVcbiAgICAgKi9cblxuICAgIGNvbnN0cnVjdG9yIDogZnVuY3Rpb24ocmVsYXRpb24sIHByZWRpY2F0ZSl7XG5cbiAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDApKTtcblxuICAgICAgICB0aGlzLm5hbWUgPSAnQWxsJztcblxuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcblxuICAgICAgICB0aGlzLnJlbGF0aW9uID0gcmVsYXRpb247XG5cbiAgICAgICAgdGhpcy50eXBlKEJvb2xlYW4pO1xuXG4gICAgfSxcblxuXG4gICAgdmFsdWUgOiBmdW5jdGlvbigpe1xuXG4gICAgICAgIHZhciByZWxhdGlvbiA9IHRoaXMucmVsYXRpb247XG5cbiAgICAgICAgdmFyIHByZWRpY2F0ZSA9IHRoaXMucHJlZGljYXRlO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuXG4gICAgICAgIHByZWRpY2F0ZS5jb252ZXJ0QXR0cmlidXRlVG9UdXBsZSgpO1xuXG4gICAgICAgIHJlbGF0aW9uLmVhY2goZnVuY3Rpb24odHVwbGUpe1xuXG4gICAgICAgICAgICBwcmVkaWNhdGUuYXNzaWduVHVwbGUodHVwbGUpO1xuXG4gICAgICAgICAgICBpZiggcHJlZGljYXRlLnZhbHVlKCkgPT09IGZhbHNlICl7XG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbGw7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbicpO1xuXG52YXIgQm9vbGVhbiA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvQm9vbGVhbi5qcycpO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG52YXIgQW55ID0gRnVuY3Rpb24uZXh0ZW5kKHtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuQWdncmVnYXRlLkFueVxuICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBGdW5jdGlvbnMgdGhhdCBjaGVja3MgaWYgYW55IG9mIHRoZSB0dXBsZXMgaW4gYSByZWxhdGlvbiBtYXRjaCB0aGVcbiAgICAgKiBnaXZlbiBib29sZWFuIHByZWRpY2F0ZS5cbiAgICAgKlxuICAgICAqIEV4YW1wbGUgOlxuICAgICAqXG4gICAgICogICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICogICAgICAgICB7IG5hbWUgOiB7IHR5cGUgOiBhZmZpbml0eS5TdHJpbmcgfSB9LFxuICAgICAqICAgICAgICAgeyBhZ2UgOiB7IHR5cGUgOiBhZmZpbml0eS5JbnRlZ2VyIH0gfVxuICAgICAqICAgICBdLFtcbiAgICAgKiAgICAgICAgIFsnSm9obiBEb2UnLCAyM10sXG4gICAgICogICAgICAgICBbJ01hcmsgQ2xpbnRvbicsIDM2XSxcbiAgICAgKiAgICAgICAgIFsnU3VwZXIgV29tYW4nLCA1Nl1cbiAgICAgKiAgICAgXSk7XG4gICAgICpcbiAgICAgKiAgICAgdmFyIG5hbWUgPSByZWxhdGlvbi5nZXQoJ25hbWUnKTtcbiAgICAgKiAgICAgdmFyIGFnZSA9IHJlbGF0aW9uLmdldCgnYWdlJylcbiAgICAgKlxuICAgICAqICAgICB2YXIgYW55ID0gcmVsYXRpb24uYW55KGFnZS5ndCg1MCkpO1xuICAgICAqXG4gICAgICogICAgIGNvbnNvbGUubG9nKGFueS52YWx1ZSgpKTtcbiAgICAgKlxuICAgICAqICAgICAvLyB0cnVlXG4gICAgICovXG5cbiAgICBjb25zdHJ1Y3RvciA6IGZ1bmN0aW9uKHJlbGF0aW9uLCBwcmVkaWNhdGUpe1xuXG4gICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywwKSk7XG5cbiAgICAgICAgdGhpcy5uYW1lID0gJ0FueSc7XG5cbiAgICAgICAgdGhpcy50eXBlKEJvb2xlYW4pO1xuXG4gICAgICAgIHRoaXMucmVsYXRpb24gPSByZWxhdGlvbjtcblxuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcblxuICAgIH0sXG5cbiAgICB2YWx1ZSA6IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgdmFyIHJlbGF0aW9uID0gdGhpcy5yZWxhdGlvbjtcblxuICAgICAgICB2YXIgcHJlZGljYXRlID0gdGhpcy5wcmVkaWNhdGU7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICAgIHByZWRpY2F0ZS5jb252ZXJ0QXR0cmlidXRlVG9UdXBsZSgpO1xuXG4gICAgICAgIHJlbGF0aW9uLmVhY2goZnVuY3Rpb24odHVwbGUpe1xuXG4gICAgICAgICAgICBwcmVkaWNhdGUuYXNzaWduVHVwbGUodHVwbGUpO1xuXG4gICAgICAgICAgICBpZiggcHJlZGljYXRlLnZhbHVlKCkgPT09IHRydWUgKXtcblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFueTsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uJyk7XG5cbnZhciBGbG9hdCA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvRmxvYXQuanMnKTtcblxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxudmFyIEF2ZXJhZ2UgPSBGdW5jdGlvbi5leHRlbmQoe1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIEZ1bmN0aW9ucy5BZ2dyZWdhdGUuQXZlcmFnZVxuICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBGdW5jdGlvbnMgdGhhdCByZXR1cm5zIHRoZSBhdmVyYWdlIGZvciBhIHJlbGF0aW9uXG4gICAgICogYXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIDpcbiAgICAgKlxuICAgICAqICAgICB2YXIgcmVsYXRpb24gPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAqICAgICAgICAgeyBuYW1lIDogeyB0eXBlIDogYWZmaW5pdHkuU3RyaW5nIH0gfSxcbiAgICAgKiAgICAgICAgIHsgYWdlIDogeyB0eXBlIDogYWZmaW5pdHkuSW50ZWdlciB9IH1cbiAgICAgKiAgICAgXSxbXG4gICAgICogICAgICAgICBbJ0pvaG4gRG9lJywgMjNdLFxuICAgICAqICAgICAgICAgWydNYXJrIENsaW50b24nLCAzNl0sXG4gICAgICogICAgICAgICBbJ1N1cGVyIFdvbWFuJywgNTZdXG4gICAgICogICAgIF0pO1xuICAgICAqXG4gICAgICogICAgIHZhciBhZ2UgPSByZWxhdGlvbi5nZXQoJ2FnZScpO1xuICAgICAqXG4gICAgICogICAgIHZhciBtYXggPSByZWxhdGlvbi5hdmcoYWdlKVxuICAgICAqXG4gICAgICogICAgIGNvbnNvbGUubG9nKG1heC52YWx1ZSgpKTtcbiAgICAgKlxuICAgICAqICAgICAvLyAzOC4zMzMzMzMzM1xuICAgICAqL1xuXG4gICAgY29uc3RydWN0b3IgOiBmdW5jdGlvbihhdHRyaWJ1dGUpe1xuXG4gICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywwKSk7XG5cbiAgICAgICAgdGhpcy5uYW1lID0gJ0F2ZXJhZ2UnO1xuXG4gICAgICAgIHRoaXMudHlwZShGbG9hdCk7XG5cbiAgICAgICAgdGhpcy5hdHRyaWJ1dGUgPSBhdHRyaWJ1dGU7XG5cbiAgICAgICAgdGhpcy5yZWxhdGlvbiA9IGF0dHJpYnV0ZS5oZWFkZXIucmVsYXRpb247XG5cbiAgICB9LFxuXG4gICAgdmFsdWUgOiBmdW5jdGlvbigpe1xuXG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZTtcblxuICAgICAgICB2YXIgcmVsYXRpb24gPSB0aGlzLnJlbGF0aW9uO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSAwO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSByZWxhdGlvbi5sZW5ndGgoKTtcblxuICAgICAgICByZWxhdGlvbi5lYWNoKGZ1bmN0aW9uKHR1cGxlKXtcblxuICAgICAgICAgICAgcmVzdWx0ICs9IHR1cGxlLmdldChhdHRyaWJ1dGUubmFtZSk7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0IC8gbGVuZ3RoO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdmVyYWdlOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24nKTtcblxudmFyIEludGVnZXIgPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL0ludGVnZXIuanMnKTtcblxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxudmFyIENvdW50ID0gRnVuY3Rpb24uZXh0ZW5kKHtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuQWdncmVnYXRlLkNvdW50XG4gICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEZ1bmN0aW9ucyB0aGF0IGNvdW50cyB0aGUgbnVtYmVyIG9mIHR1cGxlc1xuICAgICAqXG4gICAgICogRXhhbXBsZSA6XG4gICAgICpcbiAgICAgKiAgICAgdmFyIHJlbGF0aW9uID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgKiAgICAgICAgIHsgbmFtZSA6IHsgdHlwZSA6IGFmZmluaXR5LlN0cmluZyB9IH0sXG4gICAgICogICAgICAgICB7IGFnZSA6IHsgdHlwZSA6IGFmZmluaXR5LkludGVnZXIgfSB9XG4gICAgICogICAgIF0sW1xuICAgICAqICAgICAgICAgWydKb2huIERvZScsIDIzXSxcbiAgICAgKiAgICAgICAgIFsnTWFyayBDbGludG9uJywgMzZdLFxuICAgICAqICAgICAgICAgWydTdXBlciBXb21hbicsIDU2XVxuICAgICAqICAgICBdKTtcbiAgICAgKlxuICAgICAqICAgICB2YXIgY291bnQgPSByZWxhdGlvbi5jb3VudCgpXG4gICAgICpcbiAgICAgKiAgICAgY29uc29sZS5sb2coY291bnQudmFsdWUoKSk7XG4gICAgICpcbiAgICAgKiAgICAgLy8gM1xuICAgICAqL1xuXG4gICAgY29uc3RydWN0b3IgOiBmdW5jdGlvbihyZWxhdGlvbil7XG5cbiAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDApKTtcblxuICAgICAgICB0aGlzLm5hbWUgPSAnQ291bnQnO1xuXG4gICAgICAgIHRoaXMudHlwZShJbnRlZ2VyKTtcblxuICAgICAgICB0aGlzLnJlbGF0aW9uID0gcmVsYXRpb247XG5cbiAgICB9LFxuXG4gICAgdmFsdWUgOiBmdW5jdGlvbigpe1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJlbGF0aW9uLmxlbmd0aCgpO1xuXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb3VudDsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uJyk7XG5cbnZhciBjb21wYXJlID0gcmVxdWlyZSgnLi8uLi8uLi9oZWxwZXJzL2NvbXBhcmUuanMnKTtcblxudmFyIEludGVnZXIgPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL0ludGVnZXIuanMnKTtcblxudmFyIE1heGltdW0gPSBGdW5jdGlvbi5leHRlbmQoe1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIEZ1bmN0aW9ucy5BZ2dyZWdhdGUuTWF4aW11bVxuICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBGdW5jdGlvbnMgdGhhdCByZXR1cm5zIHRoZSBsYXJnZXN0IHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSBpbiBhIHJlbGF0aW9uLlxuICAgICAqXG4gICAgICogRXhhbXBsZSA6XG4gICAgICpcbiAgICAgKiAgICAgdmFyIHJlbGF0aW9uID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgKiAgICAgICAgIHsgbmFtZSA6IHsgdHlwZSA6IGFmZmluaXR5LlN0cmluZyB9IH0sXG4gICAgICogICAgICAgICB7IGFnZSA6IHsgdHlwZSA6IGFmZmluaXR5LkludGVnZXIgfSB9XG4gICAgICogICAgIF0sW1xuICAgICAqICAgICAgICAgWydKb2huIERvZScsIDIzXSxcbiAgICAgKiAgICAgICAgIFsnTWFyayBDbGludG9uJywgMzZdLFxuICAgICAqICAgICAgICAgWydTdXBlciBXb21hbicsIDU2XVxuICAgICAqICAgICBdKTtcbiAgICAgKlxuICAgICAqICAgICB2YXIgYWdlID0gcmVsYXRpb24uZ2V0KCdhZ2UnKTtcbiAgICAgKlxuICAgICAqICAgICB2YXIgbWF4ID0gcmVsYXRpb24ubWF4KGFnZSlcbiAgICAgKlxuICAgICAqICAgICBjb25zb2xlLmxvZyhtYXgudmFsdWUoKSk7XG4gICAgICpcbiAgICAgKiAgICAgLy8gNTZcbiAgICAgKi9cblxuICAgIGNvbnN0cnVjdG9yIDogZnVuY3Rpb24oYXR0cmlidXRlKXtcblxuICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMCkpO1xuXG4gICAgICAgIHRoaXMubmFtZSA9ICdNYXhpbXVtJztcblxuICAgICAgICB0aGlzLnR5cGUoSW50ZWdlcik7XG5cbiAgICAgICAgdGhpcy5hdHRyaWJ1dGUgPSBhdHRyaWJ1dGU7XG5cbiAgICAgICAgdGhpcy5yZWxhdGlvbiA9IGF0dHJpYnV0ZS5oZWFkZXIucmVsYXRpb247XG5cbiAgICB9LFxuXG4gICAgdmFsdWUgOiBmdW5jdGlvbigpe1xuXG4gICAgICAgIHZhciByZWxhdGlvbiA9IHRoaXMucmVsYXRpb247XG5cbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlO1xuXG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5hdHRyaWJ1dGUudHlwZTtcblxuICAgICAgICB2YXIgbWF4ID0gbnVsbDtcblxuICAgICAgICByZWxhdGlvbi5lYWNoKGZ1bmN0aW9uKHR1cGxlKXtcblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdHVwbGUuZ2V0KGF0dHJpYnV0ZS5uYW1lKTtcblxuICAgICAgICAgICAgaWYobWF4ID09PSBudWxsKXtcbiAgICAgICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGNvbXBhcmUodHlwZSwgdmFsdWUsIG1heCkgPiAwICl7XG4gICAgICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG1heDtcblxuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1heGltdW07IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbicpO1xuXG52YXIgY29tcGFyZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy9jb21wYXJlLmpzJyk7XG5cbnZhciBJbnRlZ2VyID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9JbnRlZ2VyLmpzJyk7XG5cbnZhciBNaW5pbXVtID0gRnVuY3Rpb24uZXh0ZW5kKHtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuQWdncmVnYXRlLk1pbmltdW1cbiAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAqXG4gICAgICogRnVuY3Rpb25zIHRoYXQgcmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgaW4gYSByZWxhdGlvbi5cbiAgICAgKlxuICAgICAqIEV4YW1wbGUgOlxuICAgICAqXG4gICAgICogICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICogICAgICAgICB7IG5hbWUgOiB7IHR5cGUgOiBhZmZpbml0eS5TdHJpbmcgfSB9LFxuICAgICAqICAgICAgICAgeyBhZ2UgOiB7IHR5cGUgOiBhZmZpbml0eS5JbnRlZ2VyIH0gfVxuICAgICAqICAgICBdLFtcbiAgICAgKiAgICAgICAgIFsnSm9obiBEb2UnLCAyM10sXG4gICAgICogICAgICAgICBbJ01hcmsgQ2xpbnRvbicsIDM2XSxcbiAgICAgKiAgICAgICAgIFsnU3VwZXIgV29tYW4nLCA1Nl1cbiAgICAgKiAgICAgXSk7XG4gICAgICpcbiAgICAgKiAgICAgdmFyIGFnZSA9IHJlbGF0aW9uLmdldCgnYWdlJyk7XG4gICAgICpcbiAgICAgKiAgICAgdmFyIG1pbiA9IHJlbGF0aW9uLm1pbihhZ2UpO1xuICAgICAqXG4gICAgICogICAgIGNvbnNvbGUubG9nKG1pbi52YWx1ZSgpKTtcbiAgICAgKlxuICAgICAqICAgICAvLyAyM1xuICAgICAqL1xuXG4gICAgY29uc3RydWN0b3IgOiBmdW5jdGlvbihhdHRyaWJ1dGUpe1xuXG4gICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywwKSk7XG5cbiAgICAgICAgdGhpcy5uYW1lID0gJ01pbmltdW0nO1xuXG4gICAgICAgIHRoaXMudHlwZShJbnRlZ2VyKTtcblxuICAgICAgICB0aGlzLmF0dHJpYnV0ZSA9IGF0dHJpYnV0ZTtcblxuICAgICAgICB0aGlzLnJlbGF0aW9uID0gYXR0cmlidXRlLmhlYWRlci5yZWxhdGlvbjtcblxuICAgIH0sXG5cbiAgICB2YWx1ZSA6IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgdmFyIHJlbGF0aW9uID0gdGhpcy5yZWxhdGlvbjtcblxuICAgICAgICB2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGU7XG5cbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmF0dHJpYnV0ZS50eXBlO1xuXG4gICAgICAgIHZhciBtaW4gPSBudWxsO1xuXG4gICAgICAgIHJlbGF0aW9uLmVhY2goZnVuY3Rpb24odHVwbGUpe1xuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0dXBsZS5nZXQoYXR0cmlidXRlLm5hbWUpO1xuXG4gICAgICAgICAgICBpZihtaW4gPT09IG51bGwpe1xuICAgICAgICAgICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggY29tcGFyZSh0eXBlLCB2YWx1ZSwgbWluKSA8IDAgKXtcbiAgICAgICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbWluO1xuXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBNaW5pbXVtOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24nKTtcblxudmFyIEZsb2F0ID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9GbG9hdC5qcycpO1xuXG52YXIgVmFyaWFuY2UgPSByZXF1aXJlKCcuL1ZhcmlhbmNlLmpzJyk7XG5cbnZhciBTdGFuZGFyZERldmlhdGlvbiA9IEZ1bmN0aW9uLmV4dGVuZCh7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLkFnZ3JlZ2F0ZS5TdGFuZGFyZERldmlhdGlvblxuICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBGdW5jdGlvbnMgdGhhdCByZXR1cm5zIHRoZSBzdGFuZGFyZCBkZXZpYXRpb25cbiAgICAgKiBvZiBhbiBhdHRyaWJ1dGUgaW4gYSByZWxhdGlvblxuICAgICAqXG4gICAgICogRXhhbXBsZSA6XG4gICAgICpcbiAgICAgKiAgICAgdmFyIHJlbGF0aW9uID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgKiAgICAgICAgIHsgbmFtZSA6IHsgdHlwZSA6IGFmZmluaXR5LlN0cmluZyB9IH0sXG4gICAgICogICAgICAgICB7IGFnZSA6IHsgdHlwZSA6IGFmZmluaXR5LkludGVnZXIgfSB9XG4gICAgICogICAgIF0sW1xuICAgICAqICAgICAgICAgWydKb2huIERvZScsIDIzXSxcbiAgICAgKiAgICAgICAgIFsnTWFyayBDbGludG9uJywgMzZdLFxuICAgICAqICAgICAgICAgWydTdXBlciBXb21hbicsIDU2XVxuICAgICAqICAgICBdKTtcbiAgICAgKlxuICAgICAqICAgICB2YXIgYWdlID0gcmVsYXRpb24uZ2V0KCdhZ2UnKTtcbiAgICAgKlxuICAgICAqICAgICB2YXIgc3RkZXYgPSByZWxhdGlvbi5zdGFuZGFyZERldmlhdGlvbihhZ2UpXG4gICAgICpcbiAgICAgKiAgICAgY29uc29sZS5sb2coc3RkZXYudmFsdWUoKSk7XG4gICAgICpcbiAgICAgKiAgICAgLy8gMTYuNjIzMjc2ODUzMVxuICAgICAqL1xuXG4gICAgY29uc3RydWN0b3IgOiBmdW5jdGlvbihhdHRyaWJ1dGUpe1xuXG4gICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywwKSk7XG5cbiAgICAgICAgdGhpcy5uYW1lID0gJ1N0YW5kYXJkRGV2aWF0aW9uJztcblxuICAgICAgICB0aGlzLnR5cGUoRmxvYXQpO1xuXG4gICAgICAgIHRoaXMuYXR0cmlidXRlID0gYXR0cmlidXRlO1xuXG4gICAgfSxcblxuICAgIHZhbHVlIDogZnVuY3Rpb24oKXtcblxuICAgICAgICB2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGU7XG5cbiAgICAgICAgdmFyIHZhcmlhbmNlID0gbmV3IFZhcmlhbmNlKGF0dHJpYnV0ZSkudmFsdWUoKTtcblxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHZhcmlhbmNlKTtcblxuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YW5kYXJkRGV2aWF0aW9uOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24nKTtcblxudmFyIEZsb2F0ID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9GbG9hdC5qcycpO1xuXG52YXIgU3VtID0gRnVuY3Rpb24uZXh0ZW5kKHtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuQWdncmVnYXRlLkNvdW50XG4gICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEZ1bmN0aW9ucyB0aGF0IGNhbGN1bGF0ZXMgdGhlIHN1bSBvZiBhbGwgdmFsdWVzIGZvclxuICAgICAqIGFuIGF0dHJpYnV0ZSBpbiBhIHJlbGF0aW9uXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIDpcbiAgICAgKlxuICAgICAqICAgICB2YXIgcmVsYXRpb24gPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAqICAgICAgICAgeyBuYW1lIDogeyB0eXBlIDogYWZmaW5pdHkuU3RyaW5nIH0gfSxcbiAgICAgKiAgICAgICAgIHsgYWdlIDogeyB0eXBlIDogYWZmaW5pdHkuSW50ZWdlciB9IH1cbiAgICAgKiAgICAgXSxbXG4gICAgICogICAgICAgICBbJ0pvaG4gRG9lJywgMjNdLFxuICAgICAqICAgICAgICAgWydNYXJrIENsaW50b24nLCAzNl0sXG4gICAgICogICAgICAgICBbJ1N1cGVyIFdvbWFuJywgNTZdXG4gICAgICogICAgIF0pO1xuICAgICAqXG4gICAgICogICAgIHZhciBhZ2UgPSByZWxhdGlvbi5nZXQoJ2FnZScpO1xuICAgICAqXG4gICAgICogICAgIHZhciBzdW0gPSByZWxhdGlvbi5zdW0oYWdlKTtcbiAgICAgKlxuICAgICAqICAgICBjb25zb2xlLmxvZyhzdW0udmFsdWUoKSk7XG4gICAgICpcbiAgICAgKiAgICAgLy8gMTE1XG4gICAgICovXG5cbiAgICBjb25zdHJ1Y3RvciA6IGZ1bmN0aW9uKGF0dHJpYnV0ZSl7XG5cbiAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDApKTtcblxuICAgICAgICB0aGlzLm5hbWUgPSAnU3VtJztcblxuICAgICAgICB0aGlzLnR5cGUoRmxvYXQpO1xuXG4gICAgICAgIHRoaXMuYXR0cmlidXRlID0gYXR0cmlidXRlO1xuXG4gICAgICAgIHRoaXMucmVsYXRpb24gPSBhdHRyaWJ1dGUuaGVhZGVyLnJlbGF0aW9uO1xuXG4gICAgfSxcblxuICAgIHZhbHVlIDogZnVuY3Rpb24oKXtcblxuICAgICAgICB2YXIgcmVsYXRpb24gPSB0aGlzLnJlbGF0aW9uO1xuXG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gdGhpcy5hdHRyaWJ1dGUubmFtZTtcblxuICAgICAgICB2YXIgc3VtID0gMDtcblxuICAgICAgICByZWxhdGlvbi5lYWNoKGZ1bmN0aW9uKHR1cGxlKXtcblxuICAgICAgICAgICAgc3VtICs9IHR1cGxlLmdldChhdHRyaWJ1dGVOYW1lKTtcblxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc3VtO1xuXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdW07IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbicpO1xuXG52YXIgQXZlcmFnZSA9IHJlcXVpcmUoJy4vQXZlcmFnZS5qcycpO1xuXG52YXIgRmxvYXQgPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL0Zsb2F0LmpzJyk7XG5cbnZhciBWYXJpYW5jZSA9IEZ1bmN0aW9uLmV4dGVuZCh7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLkFnZ3JlZ2F0ZS5WYXJpYW5jZVxuICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBGdW5jdGlvbnMgdGhhdCByZXR1cm5zIHRoZSB2YXJpYW5jZVxuICAgICAqIG9mIGF0dHJpYnV0ZSB2YWx1ZXMgaW4gYSByZWxhdGlvblxuICAgICAqXG4gICAgICogRXhhbXBsZSA6XG4gICAgICpcbiAgICAgKiAgICAgdmFyIHJlbGF0aW9uID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgKiAgICAgICAgIHsgbmFtZSA6IHsgdHlwZSA6IGFmZmluaXR5LlN0cmluZyB9IH0sXG4gICAgICogICAgICAgICB7IGFnZSA6IHsgdHlwZSA6IGFmZmluaXR5LkludGVnZXIgfSB9XG4gICAgICogICAgIF0sW1xuICAgICAqICAgICAgICAgWydKb2huIERvZScsIDIzXSxcbiAgICAgKiAgICAgICAgIFsnTWFyayBDbGludG9uJywgMzZdLFxuICAgICAqICAgICAgICAgWydTdXBlciBXb21hbicsIDU2XVxuICAgICAqICAgICBdKTtcbiAgICAgKlxuICAgICAqICAgICB2YXIgYWdlID0gcmVsYXRpb24uZ2V0KCdhZ2UnKTtcbiAgICAgKlxuICAgICAqICAgICB2YXIgdmFyaWFuY2UgPSByZWxhdGlvbi52YXJpYW5jZShhZ2UpXG4gICAgICpcbiAgICAgKiAgICAgY29uc29sZS5sb2codmFyaWFuY2UudmFsdWUoKSk7XG4gICAgICpcbiAgICAgKiAgICAgLy8gMTg0LjIyMjIyXG4gICAgICovXG5cbiAgICBjb25zdHJ1Y3RvciA6IGZ1bmN0aW9uKGF0dHJpYnV0ZSl7XG5cbiAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDApKTtcblxuICAgICAgICB0aGlzLm5hbWUgPSAnU3VtJztcblxuICAgICAgICB0aGlzLnR5cGUoRmxvYXQpO1xuXG4gICAgICAgIHRoaXMuYXR0cmlidXRlID0gYXR0cmlidXRlO1xuXG4gICAgICAgIHRoaXMucmVsYXRpb24gPSBhdHRyaWJ1dGUuaGVhZGVyLnJlbGF0aW9uXG5cbiAgICB9LFxuXG4gICAgdmFsdWUgOiBmdW5jdGlvbigpe1xuXG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZTtcblxuICAgICAgICB2YXIgcmVsYXRpb24gPSB0aGlzLnJlbGF0aW9uO1xuXG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gdGhpcy5hdHRyaWJ1dGUubmFtZTtcblxuICAgICAgICB2YXIgYXZlcmFnZSA9IG5ldyBBdmVyYWdlKGF0dHJpYnV0ZSkudmFsdWUoKTtcblxuICAgICAgICB2YXIgbGVuZ3RoID0gcmVsYXRpb24ubGVuZ3RoKCk7XG5cbiAgICAgICAgdmFyIHRvdGFsVmFyaWFuY2UgPSAwO1xuXG4gICAgICAgIHJlbGF0aW9uLmVhY2goZnVuY3Rpb24odHVwbGUpe1xuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0dXBsZS5nZXQoYXR0cmlidXRlTmFtZSk7XG5cbiAgICAgICAgICAgIHRvdGFsVmFyaWFuY2UgKz0gTWF0aC5wb3coKHZhbHVlIC0gYXZlcmFnZSksIDIpO1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0b3RhbFZhcmlhbmNlIC8gbGVuZ3RoO1xuXG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmFyaWFuY2U7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIFRCb29sZWFuID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9Cb29sZWFuLmpzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIGVxdWFsID0gcmVxdWlyZSgnLi8uLi8uLi9oZWxwZXJzL2VxdWFsJyk7XG5cbnZhciBGRXF1YWwgPSBGdW5jdGlvbi5leHRlbmQoXG5cbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuQ29tcGFyYWJsZS5FcXVhbFxuICAgICAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBGdW5jdGlvbiB0aGF0IGNvbXBhcmVzIGlmIHR3byB2YWx1ZXMgYXJlIGVxdWFsLiBPbmx5IGFwcGxpZXNcbiAgICAgICAgICogdG8gdHlwZXMgdGhhdCBpbXBsZW1lbnQgYSBzdGF0aWMgXCJlcXVhbFwiIG1ldGhvZCBvciB0byBwcmltaXRpdmVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHVzZWQgd2l0aCBhbiBFeHRlbnNpb24gb3BlcmF0b3IgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBwaGlsb3NvcGhlcnMgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge25hbWU6IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7Ym9ybjogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7ZGllZDogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ0FyaXN0b3RsZScsIC0zODQsIC0zMjJdLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydQbGF0bycsICAgICAtNDI4LCAtMzQ4XSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsnU29jcmF0ZXMnLCAgLTQ3MCwgLTM5OV1cbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgbmFtZSA9IHBoaWxvc29waGVycy5nZXQoJ25hbWUnKTtcbiAgICAgICAgICogICAgICBib3JuID0gcGhpbG9zb3BoZXJzLmdldCgnYm9ybicpO1xuICAgICAgICAgKiAgICAgIGRpZWQgPSBwaGlsb3NvcGhlcnMuZ2V0KCdkaWVkJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gcGhpbG9zb3BoZXJzLmV4dGVuZChbeyBkaWVkSW4zMjJCQyA6IGRpZWQuZXEoLTMyMikgfV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vIG9yIGVxdWl2YWxlbnQgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IHBoaWxvc29waGVycy5leHRlbmQoW3sgZGllZEluMzIyQkMgOiBuZXcgYWZmaW5pdHkuRXF1YWwoZGllZCwgLTMyMikgfV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgbmFtZSA6IFRTdHJpbmcgfCBib3JuIDogVEludGVnZXIgfCBkaWVkIDogVEludGVnZXIgfCBkaWVkSW4zMjJCQyA6IFRCb29sZWFuIHxcbiAgICAgICAgICogICAgICAvLyArPT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAgLy8gfCBBcmlzdG90bGUgICAgICB8IC0zODQgICAgICAgICAgICB8IC0zMjIgICAgICAgICAgICB8IHRydWUgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IFBsYXRvICAgICAgICAgIHwgLTQyOCAgICAgICAgICAgIHwgLTM0OCAgICAgICAgICAgIHwgZmFsc2UgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgU29jcmF0ZXMgICAgICAgfCAtNDcwICAgICAgICAgICAgfCAtMzk5ICAgICAgICAgICAgfCBmYWxzZSAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gdXNlZCB3aXRoIGEgUmVzdHJpY3Rpb24gb3BlcmF0b3IgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciByZXN0cmljdGVkID0gcGhpbG9zb3BoZXJzLnJlc3RyaWN0KGRpZWQuZXEoLTMyMikpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vIG9yIGVxdWl2YWxlbnQgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciByZXN0cmljdGVkID0gcGhpbG9zb3BoZXJzLnJlc3RyaWN0KG5ldyBhZmZpbml0eS5FcXVhbChkaWVkLCAtMzIyKSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgcmVzdHJpY3RlZC5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgbmFtZSA6IFRTdHJpbmcgfCBib3JuIDogVEludGVnZXIgfCBkaWVkIDogVEludGVnZXIgfFxuICAgICAgICAgKiAgICAgIC8vICs9PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgIC8vIHwgQXJpc3RvdGxlICAgICAgfCAtMzg0ICAgICAgICAgICAgfCAtMzIyICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDApKTtcblxuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ0VxdWFscyc7XG5cbiAgICAgICAgICAgIHRoaXMudHlwZShUQm9vbGVhbik7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgcmVzdWx0IG9mIHRoZSBmdW5jdGlvblxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBlcXVhbChudWxsLCB0aGlzLnBhcmFtZXRlcnNbMF0sIHRoaXMucGFyYW1ldGVyc1sxXSk7XG5cbiAgICAgICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBGRXF1YWw7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIFRCb29sZWFuID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9Cb29sZWFuLmpzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xudmFyIGNvbXBhcmUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvY29tcGFyZScpO1xuXG52YXIgR3JlYXRlclRoYW4gPSBGdW5jdGlvbi5leHRlbmQoXG5cbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuQ29tcGFyYWJsZS5HcmVhdGVyVGhhblxuICAgICAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBGdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiBhIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBhbm90aGVyIG9uZS5cbiAgICAgICAgICogT25seSBhcHBsaWVzIHRvIHR5cGVzIHRoYXQgaW1wbGVtZW50IHRoZSBzdGF0aWMgXCJjb21wYXJlXCIgbWV0aG9kXG4gICAgICAgICAqIG9yIHRvIHByaW1pdGl2ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gdXNlZCB3aXRoIGFuIEV4dGVuc2lvbiBvcGVyYXRvciA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIHBoaWxvc29waGVycyA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7bmFtZTogeyB0eXBlOiBhZmZpbml0eS5TdHJpbmd9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtib3JuOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtkaWVkOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsnQXJpc3RvdGxlJywgLTM4NCwgLTMyMl0sXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ1BsYXRvJywgICAgIC00MjgsIC0zNDhdLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydTb2NyYXRlcycsICAtNDcwLCAtMzk5XVxuICAgICAgICAgKiAgICAgICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICBuYW1lID0gcGhpbG9zb3BoZXJzLmdldCgnbmFtZScpO1xuICAgICAgICAgKiAgICAgIGJvcm4gPSBwaGlsb3NvcGhlcnMuZ2V0KCdib3JuJyk7XG4gICAgICAgICAqICAgICAgZGllZCA9IHBoaWxvc29waGVycy5nZXQoJ2RpZWQnKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSBwaGlsb3NvcGhlcnMuZXh0ZW5kKFt7IGRpZWRBZnRlcjM1MEJDIDogZGllZC5ndCgtMzIyKSB9XSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gb3IgZXF1aXZhbGVudCA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gcGhpbG9zb3BoZXJzLmV4dGVuZChbeyBkaWVkQWZ0ZXIzNTBCQyA6IG5ldyBhZmZpbml0eS5HcmVhdGVyVGhhbihkaWVkLCAtMzIyKSB9XSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgZXh0ZW5kZWQucHJpbnQoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBuYW1lIDogVFN0cmluZyB8IGJvcm4gOiBUSW50ZWdlciB8IGRpZWQgOiBUSW50ZWdlciB8IGRpZWRBZnRlcjM1MEJDIDogVEJvb2xlYW4gfFxuICAgICAgICAgKiAgICAgIC8vICs9PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgICAvLyB8IEFyaXN0b3RsZSAgICAgIHwgLTM4NCAgICAgICAgICAgIHwgLTMyMiAgICAgICAgICAgIHwgdHJ1ZSAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgUGxhdG8gICAgICAgICAgfCAtNDI4ICAgICAgICAgICAgfCAtMzQ4ICAgICAgICAgICAgfCB0cnVlICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBTb2NyYXRlcyAgICAgICB8IC00NzAgICAgICAgICAgICB8IC0zOTkgICAgICAgICAgICB8IHRydWUgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiB1c2VkIHdpdGggYSBSZXN0cmljdGlvbiBvcGVyYXRvciA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIHJlc3RyaWN0ZWQgPSBwaGlsb3NvcGhlcnMucmVzdHJpY3QoZGllZC5ndCgtMzUwKSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gb3IgZXF1aXZhbGVudCA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIHJlc3RyaWN0ZWQgPSBwaGlsb3NvcGhlcnMucmVzdHJpY3QobmV3IGFmZmluaXR5LkdyZWF0ZXJUaGFuKGRpZWQsIC0zNTApKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICByZXN0cmljdGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBuYW1lIDogVFN0cmluZyB8IGJvcm4gOiBUSW50ZWdlciB8IGRpZWQgOiBUSW50ZWdlciB8XG4gICAgICAgICAqICAgICAgLy8gKz09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAgLy8gfCBBcmlzdG90bGUgICAgICB8IC0zODQgICAgICAgICAgICB8IC0zMjIgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBQbGF0byAgICAgICAgICB8IC00MjggICAgICAgICAgICB8IC0zNDggICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSAnR3JlYXRlclRoYW4nO1xuXG4gICAgICAgICAgICB0aGlzLnR5cGUoVEJvb2xlYW4pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb25cbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gKGNvbXBhcmUobnVsbCwgdGhpcy5wYXJhbWV0ZXJzWzBdLCB0aGlzLnBhcmFtZXRlcnNbMV0pID4gMCk7XG5cbiAgICAgICAgfVxuXG4gICAgfSx7XG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmVhdGVyVGhhbjsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uLmpzJyk7XG52YXIgY29tcGFyZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy9jb21wYXJlJyk7XG52YXIgVEJvb2xlYW4gPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL0Jvb2xlYW4uanMnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbnZhciBGTGFyZ2VyVGhhbkVxdWFsID0gRnVuY3Rpb24uZXh0ZW5kKFxuXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLkNvbXBhcmFibGUuR3JlYXRlclRoYW5FcXVhbFxuICAgICAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBGdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiBhIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBhbm90aGVyIG9uZS4gSXQgb25seSBhcHBsaWVzXG4gICAgICAgICAqIHRvIHR5cGVzIHRoYXQgaW1wbGVtZW50IGEgc3RhdGljIFwiY29tcGFyZVwiIG1ldGhvZCBvciB0byBwcmltaXRpdmVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHVzZWQgd2l0aCBhbiBFeHRlbnNpb24gb3BlcmF0b3IgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBwaGlsb3NvcGhlcnMgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICAgICAge25hbWU6IHsgdHlwZTogYWZmaW5pdHkuU3RyaW5nfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7Ym9ybjogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7ZGllZDogeyB0eXBlOiBhZmZpbml0eS5JbnRlZ2VyfX1cbiAgICAgICAgICogICAgICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ0FyaXN0b3RsZScsIC0zODQsIC0zMjJdLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydQbGF0bycsICAgICAtNDI4LCAtMzQ4XSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsnU29jcmF0ZXMnLCAgLTQ3MCwgLTM5OV1cbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgbmFtZSA9IHBoaWxvc29waGVycy5nZXQoJ25hbWUnKTtcbiAgICAgICAgICogICAgICBib3JuID0gcGhpbG9zb3BoZXJzLmdldCgnYm9ybicpO1xuICAgICAgICAgKiAgICAgIGRpZWQgPSBwaGlsb3NvcGhlcnMuZ2V0KCdkaWVkJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gcGhpbG9zb3BoZXJzLmV4dGVuZChbeyBkaWVkU2luY2UzNDhCQyA6IGRpZWQuZ3RlKC0zNDgpIH1dKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBvciBlcXVpdmFsZW50IDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSBwaGlsb3NvcGhlcnMuZXh0ZW5kKFt7IGRpZWRTaW5jZTM0OEJDIDogbmV3IGFmZmluaXR5LkdyZWF0ZXJUaGFuRXF1YWwoZGllZCwgLTM0OCkgfV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgbmFtZSA6IFRTdHJpbmcgfCBib3JuIDogVEludGVnZXIgfCBkaWVkIDogVEludGVnZXIgfCBkaWVkU2luY2UzNDhCQyA6IFRCb29sZWFuIHxcbiAgICAgICAgICogICAgICAvLyArPT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAgLy8gfCBBcmlzdG90bGUgICAgICB8IC0zODQgICAgICAgICAgICB8IC0zMjIgICAgICAgICAgICB8IGZhbHNlICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IFBsYXRvICAgICAgICAgIHwgLTQyOCAgICAgICAgICAgIHwgLTM0OCAgICAgICAgICAgIHwgdHJ1ZSAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgU29jcmF0ZXMgICAgICAgfCAtNDcwICAgICAgICAgICAgfCAtMzk5ICAgICAgICAgICAgfCB0cnVlICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gdXNlZCB3aXRoIGEgUmVzdHJpY3Rpb24gb3BlcmF0b3IgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciByZXN0cmljdGVkID0gcGhpbG9zb3BoZXJzLnJlc3RyaWN0KGRpZWQuZ3RlKC0zNDgpKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBvciBlcXVpdmFsZW50IDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgcmVzdHJpY3RlZCA9IHBoaWxvc29waGVycy5yZXN0cmljdChuZXcgYWZmaW5pdHkuR3JlYXRlclRoYW5FcXVhbChkaWVkLCAtMzQ4KSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgcmVzdHJpY3RlZC5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgbmFtZSA6IFRTdHJpbmcgfCBib3JuIDogVEludGVnZXIgfCBkaWVkIDogVEludGVnZXIgfFxuICAgICAgICAgKiAgICAgIC8vICs9PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgIC8vIHwgQXJpc3RvdGxlICAgICAgfCAtMzg0ICAgICAgICAgICAgfCAtMzIyICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgUGxhdG8gICAgICAgICAgfCAtNDI4ICAgICAgICAgICAgfCAtMzQ4ICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ0dyZWF0ZXJUaGFuRXF1YWwnO1xuXG4gICAgICAgICAgICB0aGlzLnR5cGUoVEJvb2xlYW4pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb25cbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gKGNvbXBhcmUobnVsbCwgdGhpcy5wYXJhbWV0ZXJzWzBdLCB0aGlzLnBhcmFtZXRlcnNbMV0pID49IDApO1xuXG4gICAgICAgIH1cblxuICAgIH0se1xuXG5cblxuICAgIH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZMYXJnZXJUaGFuRXF1YWw7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIGNvbXBhcmUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvY29tcGFyZScpO1xudmFyIFRCb29sZWFuID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9Cb29sZWFuLmpzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG52YXIgRlNtYWxsZXJUaGFuID0gRnVuY3Rpb24uZXh0ZW5kKFxuXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLkNvbXBhcmFibGUuU21hbGxlclRoYW5cbiAgICAgICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogRnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgYSB2YWx1ZSBpcyBzbWFsbGVyIHRoYW4gYW5vdGhlciBvbmUuIEl0IG9ubHkgYXBwbGllc1xuICAgICAgICAgKiB0byB0eXBlcyB0aGF0IGltcGxlbWVudCBhIHN0YXRpYyBcImNvbXBhcmVcIiBtZXRob2Qgb3IgdG8gcHJpbWl0aXZlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiB1c2VkIHdpdGggYW4gRXh0ZW5zaW9uIG9wZXJhdG9yIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgcGhpbG9zb3BoZXJzID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgICAgIHtuYW1lOiB7IHR5cGU6IGFmZmluaXR5LlN0cmluZ319LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2Jvcm46IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2RpZWQ6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19XG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWydBcmlzdG90bGUnLCAtMzg0LCAtMzIyXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsnUGxhdG8nLCAgICAgLTQyOCwgLTM0OF0sXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ1NvY3JhdGVzJywgIC00NzAsIC0zOTldXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIG5hbWUgPSBwaGlsb3NvcGhlcnMuZ2V0KCduYW1lJyk7XG4gICAgICAgICAqICAgICAgYm9ybiA9IHBoaWxvc29waGVycy5nZXQoJ2Jvcm4nKTtcbiAgICAgICAgICogICAgICBkaWVkID0gcGhpbG9zb3BoZXJzLmdldCgnZGllZCcpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IHBoaWxvc29waGVycy5leHRlbmQoW3sgZGllZEJlZm9yZTM0OEJDIDogZGllZC5zdCgtMzQ4KSB9XSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gb3IgZXF1aXZhbGVudCA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gcGhpbG9zb3BoZXJzLmV4dGVuZChbeyBkaWVkQmVmb3JlMzQ4QkMgOiBuZXcgYWZmaW5pdHkuU21hbGxlclRoYW4oZGllZCwgLTM0OCkgfV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IG5hbWUgOiBUU3RyaW5nIHwgYm9ybiA6IFRJbnRlZ2VyIHwgZGllZCA6IFRJbnRlZ2VyIHwgZGllZEJlZm9yZTM0OEJDIDogVEJvb2xlYW4gfFxuICAgICAgICAgKiAgICAgIC8vICs9PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAgLy8gfCBBcmlzdG90bGUgICAgICB8IC0zODQgICAgICAgICAgICB8IC0zMjIgICAgICAgICAgICB8IHRydWUgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgUGxhdG8gICAgICAgICAgfCAtNDI4ICAgICAgICAgICAgfCAtMzQ4ICAgICAgICAgICAgfCBmYWxzZSAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IFNvY3JhdGVzICAgICAgIHwgLTQ3MCAgICAgICAgICAgIHwgLTM5OSAgICAgICAgICAgIHwgZmFsc2UgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gdXNlZCB3aXRoIGEgUmVzdHJpY3Rpb24gb3BlcmF0b3IgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciByZXN0cmljdGVkID0gcGhpbG9zb3BoZXJzLnJlc3RyaWN0KGRpZWQuc3QoLTM0OCkpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vIG9yIGVxdWl2YWxlbnQgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciByZXN0cmljdGVkID0gcGhpbG9zb3BoZXJzLnJlc3RyaWN0KG5ldyBhZmZpbml0eS5TbWFsbGVyVGhhbihkaWVkLCAtMzQ4KSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgcmVzdHJpY3RlZC5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgbmFtZSA6IFRTdHJpbmcgfCBib3JuIDogVEludGVnZXIgfCBkaWVkIDogVEludGVnZXIgfFxuICAgICAgICAgKiAgICAgIC8vICs9PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgIC8vIHwgQXJpc3RvdGxlICAgICAgfCAtMzg0ICAgICAgICAgICAgfCAtMzIyICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ1NtYWxsZXJUaGFuJztcblxuICAgICAgICAgICAgdGhpcy50eXBlKFRCb29sZWFuKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIChjb21wYXJlKG51bGwsIHRoaXMucGFyYW1ldGVyc1swXSwgdGhpcy5wYXJhbWV0ZXJzWzFdKSA8IDApO1xuXG4gICAgICAgIH1cblxuICAgIH0se1xuXG5cblxuICAgIH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZTbWFsbGVyVGhhbjsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uLmpzJyk7XG52YXIgY29tcGFyZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy9jb21wYXJlJyk7XG52YXIgVEJvb2xlYW4gPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL0Jvb2xlYW4uanMnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbnZhciBGU21hbGxlclRoYW5FcXVhbCA9IEZ1bmN0aW9uLmV4dGVuZChcblxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIEZ1bmN0aW9ucy5Db21wYXJhYmxlLlNtYWxsZXJUaGFuRXF1YWxcbiAgICAgICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogRnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgYSB2YWx1ZSBpcyBzbWFsbGVyIHRoYW4gb3IgZXF1YWwgdG8gYW5vdGhlciBvbmUuIEl0IG9ubHkgYXBwbGllc1xuICAgICAgICAgKiB0byB0eXBlcyB0aGF0IGltcGxlbWVudCBhIHN0YXRpYyBcImNvbXBhcmVcIiBtZXRob2Qgb3IgdG8gcHJpbWl0aXZlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiB1c2VkIHdpdGggYW4gRXh0ZW5zaW9uIG9wZXJhdG9yIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgcGhpbG9zb3BoZXJzID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgICAgIHtuYW1lOiB7IHR5cGU6IGFmZmluaXR5LlN0cmluZ319LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2Jvcm46IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICAgICAge2RpZWQ6IHsgdHlwZTogYWZmaW5pdHkuSW50ZWdlcn19XG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWydBcmlzdG90bGUnLCAtMzg0LCAtMzIyXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsnUGxhdG8nLCAgICAgLTQyOCwgLTM0OF0sXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ1NvY3JhdGVzJywgIC00NzAsIC0zOTldXG4gICAgICAgICAqICAgICAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIG5hbWUgPSBwaGlsb3NvcGhlcnMuZ2V0KCduYW1lJyk7XG4gICAgICAgICAqICAgICAgYm9ybiA9IHBoaWxvc29waGVycy5nZXQoJ2Jvcm4nKTtcbiAgICAgICAgICogICAgICBkaWVkID0gcGhpbG9zb3BoZXJzLmdldCgnZGllZCcpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IHBoaWxvc29waGVycy5leHRlbmQoW3sgZGllZFVwVG8zNDhCQyA6IGRpZWQuc3RlKC0zNDgpIH1dKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBvciBlcXVpdmFsZW50IDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSBwaGlsb3NvcGhlcnMuZXh0ZW5kKFt7IGRpZWRVcFRvMzQ4QkMgOiBuZXcgYWZmaW5pdHkuU21hbGxlclRoYW5FcXVhbChkaWVkLCAtMzQ4KSB9XSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgZXh0ZW5kZWQucHJpbnQoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IG5hbWUgOiBUU3RyaW5nIHwgYm9ybiA6IFRJbnRlZ2VyIHwgZGllZCA6IFRJbnRlZ2VyIHwgZGllZFVwVG8zNDhCQyA6IFRCb29sZWFuIHxcbiAgICAgICAgICogICAgICAvLyArPT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgICAvLyB8IEFyaXN0b3RsZSAgICAgIHwgLTM4NCAgICAgICAgICAgIHwgLTMyMiAgICAgICAgICAgIHwgdHJ1ZSAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IFBsYXRvICAgICAgICAgIHwgLTQyOCAgICAgICAgICAgIHwgLTM0OCAgICAgICAgICAgIHwgdHJ1ZSAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IFNvY3JhdGVzICAgICAgIHwgLTQ3MCAgICAgICAgICAgIHwgLTM5OSAgICAgICAgICAgIHwgZmFsc2UgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiB1c2VkIHdpdGggYSBSZXN0cmljdGlvbiBvcGVyYXRvciA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIHJlc3RyaWN0ZWQgPSBwaGlsb3NvcGhlcnMucmVzdHJpY3QoZGllZC5zdGUoLTM0OCkpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vIG9yIGVxdWl2YWxlbnQgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciByZXN0cmljdGVkID0gcGhpbG9zb3BoZXJzLnJlc3RyaWN0KG5ldyBhZmZpbml0eS5TbWFsbGVyVGhhbkVxdWFsKGRpZWQsIC0zNDgpKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICByZXN0cmljdGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBuYW1lIDogVFN0cmluZyB8IGJvcm4gOiBUSW50ZWdlciB8IGRpZWQgOiBUSW50ZWdlciB8XG4gICAgICAgICAqICAgICAgLy8gKz09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAgLy8gfCBBcmlzdG90bGUgICAgICB8IC0zODQgICAgICAgICAgICB8IC0zMjIgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBQbGF0byAgICAgICAgICB8IC00MjggICAgICAgICAgICB8IC0zNDggICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSAnU21hbGxlclRoYW5FcXVhbCc7XG5cbiAgICAgICAgICAgIHRoaXMudHlwZShUQm9vbGVhbik7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgcmVzdWx0IG9mIHRoZSBmdW5jdGlvblxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiAoY29tcGFyZShudWxsLCB0aGlzLnBhcmFtZXRlcnNbMF0sIHRoaXMucGFyYW1ldGVyc1sxXSkgPD0gMCk7XG5cbiAgICAgICAgfVxuXG4gICAgfSx7XG5cblxuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRlNtYWxsZXJUaGFuRXF1YWw7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIFRCb29sZWFuID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9Cb29sZWFuLmpzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG52YXIgQW5kID0gRnVuY3Rpb24uZXh0ZW5kKFxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIEZ1bmN0aW9ucy5Db25uZWN0aXZlLkFuZFxuICAgICAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBGdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiBpdHMgYXJndW1lbnRzIGFsbCByZXR1cm4gYSB0cnVlIGJvb2xlYW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gdXNlZCB3aXRoIGFuIEV4dGVuc2lvbiBvcGVyYXRvciA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIHBoaWxvc29waGVycyA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7bmFtZTogeyB0eXBlOiBhZmZpbml0eS5TdHJpbmd9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtib3JuOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtkaWVkOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsnQXJpc3RvdGxlJywgLTM4NCwgLTMyMl0sXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ1BsYXRvJywgICAgIC00MjgsIC0zNDhdLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydTb2NyYXRlcycsICAtNDcwLCAtMzk5XVxuICAgICAgICAgKiAgICAgICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICBuYW1lID0gcGhpbG9zb3BoZXJzLmdldCgnbmFtZScpO1xuICAgICAgICAgKiAgICAgIGJvcm4gPSBwaGlsb3NvcGhlcnMuZ2V0KCdib3JuJyk7XG4gICAgICAgICAqICAgICAgZGllZCA9IHBoaWxvc29waGVycy5nZXQoJ2RpZWQnKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSBwaGlsb3NvcGhlcnMuZXh0ZW5kKFt7IFwiMzIydG8zODRCQ1wiIDogZGllZC5lcSgtMzIyKS5hbmQoYm9ybi5lcSgtMzg0KSkgfV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vIG9yIGVxdWl2YWxlbnQgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IHBoaWxvc29waGVycy5leHRlbmQoW1xuICAgICAgICAgKiAgICAgICAgICB7IGRpZWRJbjMyMkJDIDogbmV3IGFmZmluaXR5LkFuZChuZXcgYWZmaW5pdHkuRXF1YWwoZGllZCwgLTMyMiksIG5ldyBhZmZpbml0eS5FcXVhbChib3JuLCAtMzg0KSkgfVxuICAgICAgICAgKiAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgbmFtZSA6IFRTdHJpbmcgfCBib3JuIDogVEludGVnZXIgfCBkaWVkIDogVEludGVnZXIgfCAzMjJ0bzM4NEJDIDogVEJvb2xlYW4gIHxcbiAgICAgICAgICogICAgICAvLyArPT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAgLy8gfCBBcmlzdG90bGUgICAgICB8IC0zODQgICAgICAgICAgICB8IC0zMjIgICAgICAgICAgICB8IHRydWUgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IFBsYXRvICAgICAgICAgIHwgLTQyOCAgICAgICAgICAgIHwgLTM0OCAgICAgICAgICAgIHwgZmFsc2UgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgU29jcmF0ZXMgICAgICAgfCAtNDcwICAgICAgICAgICAgfCAtMzk5ICAgICAgICAgICAgfCBmYWxzZSAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gdXNlZCB3aXRoIGEgUmVzdHJpY3Rpb24gb3BlcmF0b3IgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciByZXN0cmljdGVkID0gcGhpbG9zb3BoZXJzLnJlc3RyaWN0KGRpZWQuZXEoLTMyMikuYW5kKGJvcm4uZXEoLTM4NCkpKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBvciBlcXVpdmFsZW50IDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgcmVzdHJpY3RlZCA9IHBoaWxvc29waGVycy5yZXN0cmljdChcbiAgICAgICAgICogICAgICAgICAgbmV3IGFmZmluaXR5LkFuZChuZXcgYWZmaW5pdHkuRXF1YWwoZGllZCwgLTMyMiksIG5ldyBhZmZpbml0eS5FcXVhbChib3JuLCAtMzg0KSlcbiAgICAgICAgICogICAgICApO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHJlc3RyaWN0ZWQucHJpbnQoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IG5hbWUgOiBUU3RyaW5nIHwgYm9ybiA6IFRJbnRlZ2VyIHwgZGllZCA6IFRJbnRlZ2VyIHxcbiAgICAgICAgICogICAgICAvLyArPT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgICAvLyB8IEFyaXN0b3RsZSAgICAgIHwgLTM4NCAgICAgICAgICAgIHwgLTMyMiAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuXG4gICAgICAgICAgICB0aGlzLnR5cGUoVEJvb2xlYW4pO1xuXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSAnQW5kJztcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBmdW5jdGlvbiByZXR1cm4gdmFsdWVcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gXy5ldmVyeSh0aGlzLnBhcmFtZXRlcnMsIGZ1bmN0aW9uKHBhcmFtZXRlcil7XG5cbiAgICAgICAgICAgICAgICBpZighXy5pc0Jvb2xlYW4ocGFyYW1ldGVyKSl7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlciA9IHBhcmFtZXRlci52YWx1ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1ldGVyO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9XG5cbiAgICB9LHtcblxuXG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbmQ7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIFRCb29sZWFuID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9Cb29sZWFuLmpzJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG52YXIgTm90ID0gRnVuY3Rpb24uZXh0ZW5kKFxuXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLkNvbm5lY3RpdmUuTm90XG4gICAgICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIGl0cyBhcmd1bWVudCByZXR1cm5zIGZhbHNlXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gdXNlZCB3aXRoIGFuIEV4dGVuc2lvbiBvcGVyYXRvciA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIHBoaWxvc29waGVycyA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7bmFtZTogeyB0eXBlOiBhZmZpbml0eS5TdHJpbmd9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtib3JuOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtkaWVkOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsnQXJpc3RvdGxlJywgLTM4NCwgLTMyMl0sXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ1BsYXRvJywgICAgIC00MjgsIC0zNDhdLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydTb2NyYXRlcycsICAtNDcwLCAtMzk5XVxuICAgICAgICAgKiAgICAgICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICBuYW1lID0gcGhpbG9zb3BoZXJzLmdldCgnbmFtZScpO1xuICAgICAgICAgKiAgICAgIGJvcm4gPSBwaGlsb3NvcGhlcnMuZ2V0KCdib3JuJyk7XG4gICAgICAgICAqICAgICAgZGllZCA9IHBoaWxvc29waGVycy5nZXQoJ2RpZWQnKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSBwaGlsb3NvcGhlcnMuZXh0ZW5kKFt7IFwibm90Qm9ybkluMzg0QkNcIiA6IGJvcm4ubm90KCkuZXEoLTM4NCkgfV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vIG9yIGVxdWl2YWxlbnQgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IHBoaWxvc29waGVycy5leHRlbmQoW1xuICAgICAgICAgKiAgICAgICAgICB7IGRpZWRJbjMyMkJDIDogbmV3IGFmZmluaXR5Lk5vdChuZXcgYWZmaW5pdHkuRXF1YWwoYm9ybiwgLTMyMikpIH1cbiAgICAgICAgICogICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICBleHRlbmRlZC5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBuYW1lIDogVFN0cmluZyB8IGJvcm4gOiBUSW50ZWdlciB8IGRpZWQgOiBUSW50ZWdlciB8IG5vdEJvcm5JbjM4NEJDIDogVEJvb2xlYW4gIHxcbiAgICAgICAgICogICAgICAvLyArPT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgIC8vIHwgQXJpc3RvdGxlICAgICAgfCAtMzg0ICAgICAgICAgICAgfCAtMzIyICAgICAgICAgICAgfCBmYWxzZSAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IFBsYXRvICAgICAgICAgIHwgLTQyOCAgICAgICAgICAgIHwgLTM0OCAgICAgICAgICAgIHwgdHJ1ZSAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBTb2NyYXRlcyAgICAgICB8IC00NzAgICAgICAgICAgICB8IC0zOTkgICAgICAgICAgICB8IHRydWUgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHVzZWQgd2l0aCBhIFJlc3RyaWN0aW9uIG9wZXJhdG9yIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgcmVzdHJpY3RlZCA9IHBoaWxvc29waGVycy5yZXN0cmljdChib3JuLm5vdCgpLmVxKC0zODQpKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBvciBlcXVpdmFsZW50IDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgcmVzdHJpY3RlZCA9IHBoaWxvc29waGVycy5yZXN0cmljdChcbiAgICAgICAgICogICAgICAgICAgbmV3IGFmZmluaXR5Lk5vdChuZXcgYWZmaW5pdHkuRXF1YWwoYm9ybiwgLTMyMikpXG4gICAgICAgICAqICAgICAgKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICByZXN0cmljdGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBuYW1lIDogVFN0cmluZyB8IGJvcm4gOiBUSW50ZWdlciB8IGRpZWQgOiBUSW50ZWdlciB8XG4gICAgICAgICAqICAgICAgLy8gKz09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAgLy8gfCBQbGF0byAgICAgICAgICB8IC00MjggICAgICAgICAgICB8IC0zNDggICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBTb2NyYXRlcyAgICAgICB8IC00NzAgICAgICAgICAgICB8IC0zOTkgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICB0aGlzLnR5cGUoVEJvb2xlYW4pO1xuXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSAnTm90JztcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBmdW5jdGlvbiByZXR1cm4gdmFsdWVcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBpZighXy5pc0Jvb2xlYW4odGhpcy5wYXJhbWV0ZXJzWzBdKSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLnBhcmFtZXRlcnNbMF0udmFsdWUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLnBhcmFtZXRlcnNbMF07XG5cbiAgICAgICAgfVxuXG4gICAgfSx7XG5cblxuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTm90OyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24uanMnKTtcbnZhciBUQm9vbGVhbiA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvQm9vbGVhbi5qcycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxudmFyIE9yID0gRnVuY3Rpb24uZXh0ZW5kKFxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIEZ1bmN0aW9ucy5Db25uZWN0aXZlLk9yXG4gICAgICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIG9uZSBvZiBpdHMgYXJndW1lbnRzIHJldHVybiB0cnVlXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gdXNlZCB3aXRoIGFuIEV4dGVuc2lvbiBvcGVyYXRvciA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIHBoaWxvc29waGVycyA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7bmFtZTogeyB0eXBlOiBhZmZpbml0eS5TdHJpbmd9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtib3JuOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgICAgICAgICAgIHtkaWVkOiB7IHR5cGU6IGFmZmluaXR5LkludGVnZXJ9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsnQXJpc3RvdGxlJywgLTM4NCwgLTMyMl0sXG4gICAgICAgICAqICAgICAgICAgICAgICBbJ1BsYXRvJywgICAgIC00MjgsIC0zNDhdLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWydTb2NyYXRlcycsICAtNDcwLCAtMzk5XVxuICAgICAgICAgKiAgICAgICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICBuYW1lID0gcGhpbG9zb3BoZXJzLmdldCgnbmFtZScpO1xuICAgICAgICAgKiAgICAgIGJvcm4gPSBwaGlsb3NvcGhlcnMuZ2V0KCdib3JuJyk7XG4gICAgICAgICAqICAgICAgZGllZCA9IHBoaWxvc29waGVycy5nZXQoJ2RpZWQnKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSBwaGlsb3NvcGhlcnMuZXh0ZW5kKFt7IFwiYm9ybjM4NG9yNDI4QkNcIiA6IGJvcm4uZXEoLTM4NCkub3IoYm9ybi5lcSgtNDI4KSkgfV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vIG9yIGVxdWl2YWxlbnQgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IHBoaWxvc29waGVycy5leHRlbmQoW1xuICAgICAgICAgKiAgICAgICAgICB7IGRpZWRJbjMyMkJDIDogbmV3IGFmZmluaXR5Lk9yKG5ldyBhZmZpbml0eS5FcXVhbChib3JuLCAtMzg0KSwgbmV3IGFmZmluaXR5LkVxdWFsKGJvcm4sIC00MjgpKSB9XG4gICAgICAgICAqICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgZXh0ZW5kZWQucHJpbnQoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgbmFtZSA6IFRTdHJpbmcgfCBib3JuIDogVEludGVnZXIgfCBkaWVkIDogVEludGVnZXIgfCBib3JuMzg0b3I0MjhCQyA6IFRCb29sZWFuICB8XG4gICAgICAgICAqICAgICAgLy8gKz09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgICAvLyB8IEFyaXN0b3RsZSAgICAgIHwgLTM4NCAgICAgICAgICAgIHwgLTMyMiAgICAgICAgICAgIHwgdHJ1ZSAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBQbGF0byAgICAgICAgICB8IC00MjggICAgICAgICAgICB8IC0zNDggICAgICAgICAgICB8IHRydWUgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgU29jcmF0ZXMgICAgICAgfCAtNDcwICAgICAgICAgICAgfCAtMzk5ICAgICAgICAgICAgfCBmYWxzZSAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiB1c2VkIHdpdGggYSBSZXN0cmljdGlvbiBvcGVyYXRvciA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIHJlc3RyaWN0ZWQgPSBwaGlsb3NvcGhlcnMucmVzdHJpY3QoYm9ybi5lcSgtMzg0KS5vcihib3JuLmVxKC00MjgpKSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gb3IgZXF1aXZhbGVudCA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIHJlc3RyaWN0ZWQgPSBwaGlsb3NvcGhlcnMucmVzdHJpY3QoXG4gICAgICAgICAqICAgICAgICAgIG5ldyBhZmZpbml0eS5PcihuZXcgYWZmaW5pdHkuRXF1YWwoYm9ybiwgLTM4NCksIG5ldyBhZmZpbml0eS5FcXVhbChib3JuLCAtNDI4KSlcbiAgICAgICAgICogICAgICApO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHJlc3RyaWN0ZWQucHJpbnQoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IG5hbWUgOiBUU3RyaW5nIHwgYm9ybiA6IFRJbnRlZ2VyIHwgZGllZCA6IFRJbnRlZ2VyIHxcbiAgICAgICAgICogICAgICAvLyArPT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgICAvLyB8IEFyaXN0b3RsZSAgICAgIHwgLTM4NCAgICAgICAgICAgIHwgLTMyMiAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IFBsYXRvICAgICAgICAgIHwgLTQyOCAgICAgICAgICAgIHwgLTM0OCAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHRoaXMudHlwZShUQm9vbGVhbik7XG5cbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdPcic7XG5cbiAgICAgICAgfSxcblxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXG5cbiAgICAgICAgICAgIHJldHVybiBfLmFueSh0aGlzLnBhcmFtZXRlcnMsIGZ1bmN0aW9uKHBhcmFtZXRlcil7XG5cbiAgICAgICAgICAgICAgICBpZighXy5pc0Jvb2xlYW4ocGFyYW1ldGVyKSl7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlciA9IHBhcmFtZXRlci52YWx1ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1ldGVyO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9XG5cbiAgICB9LHtcblxuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gT3I7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIFRJbnRlZ2VyID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9JbnRlZ2VyLmpzJyk7XG52YXIgdmFsdWUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvdmFsdWUnKTtcblxudmFyIEZEYXlPZk1vbnRoID0gRnVuY3Rpb24uZXh0ZW5kKFxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIEZ1bmN0aW9ucy5EYXRlLkRheU9mTW9udGhcbiAgICAgICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogRnVuY3Rpb24gdGhhdCBleHRyYWN0cyBhIGRhdGUncyBkYXkgb2YgdGhlIG1vbnRoXG4gICAgICAgICAqXG4gICAgICAgICAqIFdpdGggZXh0ZW5kIG9wZXJhdGlvbiA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV2ZW50cyA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgIHtkYXRlIDoge3R5cGUgOiBhZmZpbml0eS5EYXRlfX0sXG4gICAgICAgICAqICAgICAgICAgIHtuYW1lIDoge3R5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICBbbmV3IERhdGUoMjAxNCwgMSwgMDcpLCAnU29jaGknXSxcbiAgICAgICAgICogICAgICAgICAgW25ldyBEYXRlKDIwMTQsIDAsIDAyKSwgJ0Nob2NvbGF0ZSBydXNoJ10sXG4gICAgICAgICAqICAgICAgICAgIFtuZXcgRGF0ZSgyMDE0LCAzLCAxNSksICdNaWxsaW9udGggY29mZmVlIGRyYW5rJ11cbiAgICAgICAgICogICAgICBdKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBkYXRlID0gZXZlbnRzLmdldCgnZGF0ZScpXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gZXZlbnRzLmV4dGVuZChbIHsgXCJkYXRlLmRheU9mTW9udGgoKVwiIDogZGF0ZS5kYXlPZk1vbnRoKCkgfSBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBvciBlcXVpdmFsZW50XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gZXZlbnRzLmV4dGVuZChbIHsgXCJkYXRlLmRheU9mTW9udGgoKVwiIDogbmV3IGFmZmluaXR5LkRheU9mTW9udGgoZGF0ZSkgfSBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICBleHRlbmRlZC5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgfCBkYXRlIDogRGF0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IG5hbWUgOiBTdHJpbmcgICAgICAgICAgICB8IGRhdGUuZGF5T2ZNb250aCgpIDogSW50ZWdlciAgIHxcbiAgICAgICAgICogICAgICArPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgIHwgRnJpIEZlYiAwNyAyMDE0IDAwOjAwOjAwIEdNVC0wNTAwIChFU1QpICAgfCBTb2NoaSAgICAgICAgICAgICAgICAgICAgfCA3ICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICB8IFRodSBKYW4gMDIgMjAxNCAwMDowMDowMCBHTVQtMDUwMCAoRVNUKSAgIHwgQ2hvY29sYXRlIHJ1c2ggICAgICAgICAgIHwgMiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgfCBUdWUgQXByIDE1IDIwMTQgMDA6MDA6MDAgR01ULTA0MDAgKEVEVCkgICB8IE1pbGxpb250aCBjb2ZmZWUgZHJhbmsgICB8IDE1ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG5cbiAgICAgICAgICAgIHRoaXMudHlwZShUSW50ZWdlcik7XG5cbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdEYXlPZk1vbnRoJztcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBmdW5jdGlvbidzIHJldHVybiB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlKHRoaXMucGFyYW1ldGVyc1swXSkuZ2V0RGF0ZSgpO1xuXG4gICAgICAgIH1cblxuICAgIH0se1xuXG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBGRGF5T2ZNb250aDsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uLmpzJyk7XG52YXIgVEludGVnZXIgPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL0ludGVnZXIuanMnKTtcbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy92YWx1ZScpO1xuXG52YXIgRkRheU9mV2VlayA9IEZ1bmN0aW9uLmV4dGVuZChcbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuRGF0ZS5EYXlPZldlZWtcbiAgICAgICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogRnVuY3Rpb24gdGhhdCBleHRyYWN0cyBhIGRhdGUncyBkYXkgb2YgdGhlIHdlZWtcbiAgICAgICAgICpcbiAgICAgICAgICogU3VuZGF5IGlzIDAsIFNhdHVyZGF5IGlzIDZcbiAgICAgICAgICpcbiAgICAgICAgICogV2l0aCBleHRlbmQgb3BlcmF0aW9uIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXZlbnRzID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAge2RhdGUgOiB7dHlwZSA6IGFmZmluaXR5LkRhdGV9fSxcbiAgICAgICAgICogICAgICAgICAge25hbWUgOiB7dHlwZSA6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgIFtuZXcgRGF0ZSgyMDE0LCAxLCAwNyksICdTb2NoaSddLFxuICAgICAgICAgKiAgICAgICAgICBbbmV3IERhdGUoMjAxNCwgMCwgMDIpLCAnQ2hvY29sYXRlIHJ1c2gnXSxcbiAgICAgICAgICogICAgICAgICAgW25ldyBEYXRlKDIwMTQsIDMsIDE1KSwgJ01pbGxpb250aCBjb2ZmZWUgZHJhbmsnXVxuICAgICAgICAgKiAgICAgIF0pXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGRhdGUgPSBldmVudHMuZ2V0KCdkYXRlJylcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSBldmVudHMuZXh0ZW5kKFsgeyBcImRhdGUuZGF5T2ZXZWVrKClcIiA6IGRhdGUuZGF5T2ZXZWVrKCkgfSBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBvciBlcXVpdmFsZW50XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gZXZlbnRzLmV4dGVuZChbIHsgXCJkYXRlLmRheU9mV2VlaygpXCIgOiBuZXcgYWZmaW5pdHkuRGF5T2ZXZWVrKGRhdGUpIH0gXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgZXh0ZW5kZWQucHJpbnQoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBkYXRlIDogRGF0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IG5hbWUgOiBTdHJpbmcgICAgICAgICAgICB8IGRhdGUuZGF5T2ZXZWVrKCkgOiBJbnRlZ2VyICAgfFxuICAgICAgICAgKiAgICAgIC8vICs9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgICAvLyB8IEZyaSBGZWIgMDcgMjAxNCAwMDowMDowMCBHTVQtMDUwMCAoRVNUKSAgIHwgU29jaGkgICAgICAgICAgICAgICAgICAgIHwgNSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgVGh1IEphbiAwMiAyMDE0IDAwOjAwOjAwIEdNVC0wNTAwIChFU1QpICAgfCBDaG9jb2xhdGUgcnVzaCAgICAgICAgICAgfCA0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBUdWUgQXByIDE1IDIwMTQgMDA6MDA6MDAgR01ULTA0MDAgKEVEVCkgICB8IE1pbGxpb250aCBjb2ZmZWUgZHJhbmsgICB8IDIgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuXG4gICAgICAgICAgICB0aGlzLnR5cGUoVEludGVnZXIpO1xuXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSAnRGF5T2ZXZWVrJztcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBmdW5jdGlvbiByZXR1cm4gdmFsdWVcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMF0pLmdldERheSgpO1xuXG4gICAgICAgIH1cblxuICAgIH0se1xuXG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBGRGF5T2ZXZWVrOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24uanMnKTtcbnZhciBUSW50ZWdlciA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvSW50ZWdlci5qcycpO1xudmFyIHZhbHVlID0gcmVxdWlyZSgnLi8uLi8uLi9oZWxwZXJzL3ZhbHVlJyk7XG5cbnZhciBGRGF5T2ZZZWFyID0gRnVuY3Rpb24uZXh0ZW5kKFxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIEZ1bmN0aW9ucy5EYXRlLkRheU9mWWVhclxuICAgICAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBGdW5jdGlvbiB0aGF0IGV4dHJhY3RzIGEgZGF0ZSdzIGRheSBvZiB0aGUgeWVhclxuICAgICAgICAgKlxuICAgICAgICAgKiBKYW51YXJ5IDFzdCBpcyAwXG4gICAgICAgICAqXG4gICAgICAgICAqIFdpdGggZXh0ZW5kIG9wZXJhdGlvbiA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV2ZW50cyA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgIHtkYXRlIDoge3R5cGUgOiBhZmZpbml0eS5EYXRlfX0sXG4gICAgICAgICAqICAgICAgICAgIHtuYW1lIDoge3R5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICBbbmV3IERhdGUoMjAxNCwgMSwgMDcpLCAnU29jaGknXSxcbiAgICAgICAgICogICAgICAgICAgW25ldyBEYXRlKDIwMTQsIDAsIDAyKSwgJ0Nob2NvbGF0ZSBydXNoJ10sXG4gICAgICAgICAqICAgICAgICAgIFtuZXcgRGF0ZSgyMDE0LCAzLCAxNSksICdNaWxsaW9udGggY29mZmVlIGRyYW5rJ11cbiAgICAgICAgICogICAgICBdKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBkYXRlID0gZXZlbnRzLmdldCgnZGF0ZScpXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gZXZlbnRzLmV4dGVuZChbIHsgXCJkYXRlLmRheU9mWWVhcigpXCIgOiBkYXRlLmRheU9mWWVhcigpIH0gXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gb3IgZXF1aXZhbGVudFxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IGV2ZW50cy5leHRlbmQoWyB7IFwiZGF0ZS5kYXlPZlllYXIoKVwiIDogbmV3IGFmZmluaXR5LkRheU9mWWVhcihkYXRlKSB9IF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgZGF0ZSA6IERhdGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBuYW1lIDogU3RyaW5nICAgICAgICAgICAgfCBkYXRlLmRheU9mWWVhcigpIDogSW50ZWdlciAgIHxcbiAgICAgICAgICogICAgICAvLyArPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAgLy8gfCBGcmkgRmViIDA3IDIwMTQgMDA6MDA6MDAgR01ULTA1MDAgKEVTVCkgICB8IFNvY2hpICAgICAgICAgICAgICAgICAgICB8IDM3ICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IFRodSBKYW4gMDIgMjAxNCAwMDowMDowMCBHTVQtMDUwMCAoRVNUKSAgIHwgQ2hvY29sYXRlIHJ1c2ggICAgICAgICAgIHwgMSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgVHVlIEFwciAxNSAyMDE0IDAwOjAwOjAwIEdNVC0wNDAwIChFRFQpICAgfCBNaWxsaW9udGggY29mZmVlIGRyYW5rICAgfCAxMDQgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcblxuICAgICAgICAgICAgdGhpcy50eXBlKFRJbnRlZ2VyKTtcblxuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ0RheU9mWWVhcic7XG5cbiAgICAgICAgfSxcblxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICB2YXIgZGF0ZSA9IHZhbHVlKHRoaXMucGFyYW1ldGVyc1swXSk7XG5cbiAgICAgICAgICAgIHZhciBiZWdpbiA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwwLDEpO1xuXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKChkYXRlIC0gYmVnaW4pIC8gODY0MDAwMDApO1xuXG4gICAgICAgIH1cblxuICAgIH0se1xuXG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBGRGF5T2ZZZWFyOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24uanMnKTtcbnZhciBUSW50ZWdlciA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvSW50ZWdlci5qcycpO1xudmFyIHZhbHVlID0gcmVxdWlyZSgnLi8uLi8uLi9oZWxwZXJzL3ZhbHVlJyk7XG5cbnZhciBGSG91cnMgPSBGdW5jdGlvbi5leHRlbmQoXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLkRhdGUuSG91cnNcbiAgICAgICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogRnVuY3Rpb24gdGhhdCBleHRyYWN0cyBhIGRhdGUncyBob3VycyBjb21wb25lbnQgYXMgYW4gaW50ZWdlclxuICAgICAgICAgKlxuICAgICAgICAgKiBNaWRuaWdodCBpcyAwXG4gICAgICAgICAqXG4gICAgICAgICAqIFdpdGggZXh0ZW5kIG9wZXJhdGlvbiA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIHdva2VVcCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAqICAgICAgd29rZVVwLnNldEhvdXJzKDgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBicmVha2Zhc3QgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgKiAgICAgIGJyZWFrZmFzdC5zZXRIb3Vycyg5KVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBkaW5uZXIgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgKiAgICAgIGRpbm5lci5zZXRIb3VycygxOCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV2ZW50cyA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgIHt0aW1lIDoge3R5cGUgOiBhZmZpbml0eS5EYXRlfX0sXG4gICAgICAgICAqICAgICAgICAgIHtuYW1lIDoge3R5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICBbd29rZVVwLCAnV29rZSBVcCddLFxuICAgICAgICAgKiAgICAgICAgICBbYnJlYWtmYXN0LCAnQnJlYWtmYXN0J10sXG4gICAgICAgICAqICAgICAgICAgIFtkaW5uZXIsICdEaW5uZXInXVxuICAgICAgICAgKiAgICAgIF0pXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIHRpbWUgPSBldmVudHMuZ2V0KCd0aW1lJylcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSBldmVudHMuZXh0ZW5kKFsgeyBcInRpbWUuaG91cnMoKVwiIDogdGltZS5ob3VycygpIH0gXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gb3IgZXF1aXZhbGVudFxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IGV2ZW50cy5leHRlbmQoWyB7IFwidGltZS5ob3VycygpXCIgOiBuZXcgYWZmaW5pdHkuSG91cnModGltZSkgfSBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICBleHRlbmRlZC5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgdGltZSA6IERhdGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBuYW1lIDogU3RyaW5nICAgfCB0aW1lLmhvdXJzKCkgOiBJbnRlZ2VyICAgfFxuICAgICAgICAgKiAgICAgIC8vICs9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgIC8vIHwgU3VuIEp1biAyOSAyMDE0IDA4OjQzOjM5IEdNVC0wNDAwIChFRFQpICAgfCBXb2tlIFVwICAgICAgICAgfCA4ICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgU3VuIEp1biAyOSAyMDE0IDA5OjQzOjM5IEdNVC0wNDAwIChFRFQpICAgfCBCcmVha2Zhc3QgICAgICAgfCA5ICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgU3VuIEp1biAyOSAyMDE0IDE4OjQzOjM5IEdNVC0wNDAwIChFRFQpICAgfCBEaW5uZXIgICAgICAgICAgfCAxOCAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG5cbiAgICAgICAgICAgIHRoaXMudHlwZShUSW50ZWdlcik7XG5cbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdIb3Vycyc7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZnVuY3Rpb24ncyByZXR1cm4gdmFsdWVcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMF0pLmdldEhvdXJzKCk7XG5cbiAgICAgICAgfVxuXG4gICAgfSx7XG5cblxuICAgIH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZIb3VyczsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uLmpzJyk7XG52YXIgVEludGVnZXIgPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL0ludGVnZXIuanMnKTtcbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy92YWx1ZScpO1xuXG52YXIgRk1pbGxpc2Vjb25kcyA9IEZ1bmN0aW9uLmV4dGVuZChcbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuRGF0ZS5NaWxsaXNlY29uZHNcbiAgICAgICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogRnVuY3Rpb24gdGhhdCBleHRyYWN0cyBhIGRhdGUncyBtaWxsaXNlY29uZHMgY29tcG9uZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIE1pZG5pZ2h0IGlzIDBcbiAgICAgICAgICpcbiAgICAgICAgICogV2l0aCBleHRlbmQgb3BlcmF0aW9uIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZGF0ZTEgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgKiAgICAgIGRhdGUxLnNldE1pbGxpc2Vjb25kcygxMDApO1xuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBkYXRlMiA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAqICAgICAgZGF0ZTIuc2V0TWlsbGlzZWNvbmRzKDIwMCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGRhdGUzID0gbmV3IERhdGUoKTtcbiAgICAgICAgICogICAgICBkYXRlMy5zZXRNaWxsaXNlb2NuZHMoMzAwKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXZlbnRzID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAge3RpbWUgOiB7dHlwZSA6IGFmZmluaXR5LkRhdGV9fVxuICAgICAgICAgKiAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgIFtkYXRlMV0sIFtkYXRlMl0sIFtkYXRlM11cbiAgICAgICAgICogICAgICBdKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciB0aW1lID0gZXZlbnRzLmdldCgndGltZScpXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gZXZlbnRzLmV4dGVuZChbIHsgXCJ0aW1lLm1pbGxpc2Vjb25kcygpXCIgOiB0aW1lLm1pbGxpc2Vjb25kcygpIH0gXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gb3IgZXF1aXZhbGVudFxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IGV2ZW50cy5leHRlbmQoWyB7IFwidGltZS5taWxsaXNlY29uZHMoKVwiIDogbmV3IGFmZmluaXR5Lk1pbGxpc2Vjb25kcyh0aW1lKSB9IF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgdGltZSA6IERhdGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0aW1lLm1pbGxpc2Vjb25kcygpIDogSW50ZWdlciAgIHxcbiAgICAgICAgICogICAgICAvLyArPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAgLy8gfCBTdW4gSnVuIDI5IDIwMTQgMDg6NDQ6MTcgR01ULTA0MDAgKEVEVCkgICB8IDEwMCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IFN1biBKdW4gMjkgMjAxNCAwODo0NDoxNyBHTVQtMDQwMCAoRURUKSAgIHwgMjAwICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgU3VuIEp1biAyOSAyMDE0IDA4OjQ0OjE3IEdNVC0wNDAwIChFRFQpICAgfCA1NTcgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcblxuICAgICAgICAgICAgdGhpcy50eXBlKFRJbnRlZ2VyKTtcblxuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ01pbGxpc2Vjb25kcyc7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZnVuY3Rpb24gcmV0dXJuIHZhbHVlXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUodGhpcy5wYXJhbWV0ZXJzWzBdKS5nZXRNaWxsaXNlY29uZHMoKTtcblxuICAgICAgICB9XG5cbiAgICB9LHtcblxuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRk1pbGxpc2Vjb25kczsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uLmpzJyk7XG52YXIgVEludGVnZXIgPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL0ludGVnZXIuanMnKTtcbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy92YWx1ZScpO1xuXG52YXIgRk1pbnV0ZXMgPSBGdW5jdGlvbi5leHRlbmQoXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLkRhdGUuTWludXRlc1xuICAgICAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBGdW5jdGlvbiB0aGF0IGV4dHJhY3RzIGEgZGF0ZSdzIG1pbnV0ZXMgY29tcG9uZW50IGFzIGFuIGludGVnZXJcbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogV2l0aCBleHRlbmQgb3BlcmF0aW9uIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgcXVhcnRlclRvRml2ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAqICAgICAgcXVhcnRlclRvRml2ZS5zZXRIb3Vycyg0KTtcbiAgICAgICAgICogICAgICBxdWFydGVyVG9GaXZlLnNldE1pbnV0ZXMoNDUpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBmaXZlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICogICAgICBmaXZlLnNldEhvdXJzKDUpXG4gICAgICAgICAqICAgICAgZml2ZS5zZXRNaW51dGVzKDApO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBzaXhUaGlydHkgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgKiAgICAgIHNpeFRoaXJ0eS5zZXRIb3Vycyg2KTtcbiAgICAgICAgICogICAgICBzaXhUaGlydHkuc2V0TWludXRlcygzMCk7XG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV2ZW50cyA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgIHt0aW1lIDoge3R5cGUgOiBhZmZpbml0eS5EYXRlfX0sXG4gICAgICAgICAqICAgICAgICAgIHtuYW1lIDoge3R5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICBbcXVhcnRlclRvRml2ZSwgJ1F1YXJ0ZXIgdG8gRml2ZSddLFxuICAgICAgICAgKiAgICAgICAgICBbZml2ZSwgJ0ZpdmUnXSxcbiAgICAgICAgICogICAgICAgICAgW3NpeFRoaXJ0eSwgJ1NpeCBUaGlydHknXVxuICAgICAgICAgKiAgICAgIF0pXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIHRpbWUgPSBldmVudHMuZ2V0KCd0aW1lJylcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSBldmVudHMuZXh0ZW5kKFsgeyBcInRpbWUubWludXRlcygpXCIgOiB0aW1lLm1pbnV0ZXMoKSB9IF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vIG9yIGVxdWl2YWxlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSBldmVudHMuZXh0ZW5kKFsgeyBcInRpbWUubWludXRlcygpXCIgOiBuZXcgYWZmaW5pdHkuTWludXRlcyh0aW1lKSB9IF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgdGltZSA6IERhdGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBuYW1lIDogU3RyaW5nICAgICB8IHRpbWUubWludXRlcygpIDogSW50ZWdlciAgIHxcbiAgICAgICAgICogICAgICAvLyArPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAgLy8gfCBTdW4gSnVuIDI5IDIwMTQgMDQ6NDU6NDkgR01ULTA0MDAgKEVEVCkgICB8IFF1YXJ0ZXIgdG8gRml2ZSAgIHwgNDUgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IFN1biBKdW4gMjkgMjAxNCAwNTowMDo0OSBHTVQtMDQwMCAoRURUKSAgIHwgRml2ZSAgICAgICAgICAgICAgfCAwICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vIHwgU3VuIEp1biAyOSAyMDE0IDA2OjMwOjQ5IEdNVC0wNDAwIChFRFQpICAgfCBTaXggVGhpcnR5ICAgICAgICB8IDMwICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcblxuICAgICAgICAgICAgdGhpcy50eXBlKFRJbnRlZ2VyKTtcblxuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ01pbnV0ZXMnO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlKHRoaXMucGFyYW1ldGVyc1swXSkuZ2V0TWludXRlcygpO1xuXG4gICAgICAgIH1cblxuICAgIH0se1xuXG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBGTWludXRlczsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uLmpzJyk7XG52YXIgVEludGVnZXIgPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL0ludGVnZXIuanMnKTtcbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy92YWx1ZScpO1xuXG52YXIgRk1vbnRoID0gRnVuY3Rpb24uZXh0ZW5kKFxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIEZ1bmN0aW9ucy5EYXRlLk1vbnRoXG4gICAgICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEZ1bmN0aW9uIHRoYXQgZXh0cmFjdHMgYSBkYXRlJ3MgbW9udGggbnVtYmVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEphbnVhcnkgaXMgMFxuICAgICAgICAgKlxuICAgICAgICAgKiBXaXRoIGV4dGVuZCBvcGVyYXRpb24gOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBldmVudHMgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICB7ZGF0ZSA6IHt0eXBlIDogYWZmaW5pdHkuRGF0ZX19LFxuICAgICAgICAgKiAgICAgICAgICB7bmFtZSA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgW25ldyBEYXRlKDIwMTQsIDEsIDA3KSwgJ1NvY2hpJ10sXG4gICAgICAgICAqICAgICAgICAgIFtuZXcgRGF0ZSgyMDE0LCAwLCAwMiksICdDaG9jb2xhdGUgcnVzaCddLFxuICAgICAgICAgKiAgICAgICAgICBbbmV3IERhdGUoMjAxNCwgMywgMTUpLCAnTWlsbGlvbnRoIGNvZmZlZSBkcmFuayddXG4gICAgICAgICAqICAgICAgXSlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZGF0ZSA9IGV2ZW50cy5nZXQoJ2RhdGUnKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IGV2ZW50cy5leHRlbmQoWyB7IFwiZGF0ZS5tb250aCgpXCIgOiBkYXRlLm1vbnRoKCkgfSBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBvciBlcXVpdmFsZW50XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gZXZlbnRzLmV4dGVuZChbIHsgXCJkYXRlLm1vbnRoKClcIiA6IG5ldyBhZmZpbml0eS5Nb250aChkYXRlKSB9IF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBkYXRlIDogRGF0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IG5hbWUgOiBTdHJpbmcgICAgICAgICAgICB8IGRhdGUubW9udGgoKSA6IEludGVnZXIgICB8XG4gICAgICAgICAqICAgICAgLy8gKz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAgLy8gfCBGcmkgRmViIDA3IDIwMTQgMDA6MDA6MDAgR01ULTA1MDAgKEVTVCkgICB8IFNvY2hpICAgICAgICAgICAgICAgICAgICB8IDEgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBUaHUgSmFuIDAyIDIwMTQgMDA6MDA6MDAgR01ULTA1MDAgKEVTVCkgICB8IENob2NvbGF0ZSBydXNoICAgICAgICAgICB8IDAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBUdWUgQXByIDE1IDIwMTQgMDA6MDA6MDAgR01ULTA0MDAgKEVEVCkgICB8IE1pbGxpb250aCBjb2ZmZWUgZHJhbmsgICB8IDMgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy9cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuXG4gICAgICAgICAgICB0aGlzLnR5cGUoVEludGVnZXIpO1xuXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSAnTW9udGgnO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlKHRoaXMucGFyYW1ldGVyc1swXSkuZ2V0TW9udGgoKTtcblxuICAgICAgICB9XG5cbiAgICB9LHtcblxuXG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRk1vbnRoOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24uanMnKTtcbnZhciBUSW50ZWdlciA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvSW50ZWdlci5qcycpO1xudmFyIHZhbHVlID0gcmVxdWlyZSgnLi8uLi8uLi9oZWxwZXJzL3ZhbHVlJyk7XG5cbnZhciBTZWNvbmRzID0gRnVuY3Rpb24uZXh0ZW5kKFxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIEZ1bmN0aW9ucy5EYXRlLlNlY29uZHNcbiAgICAgICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogRnVuY3Rpb24gdGhhdCBleHRyYWN0cyBhIGRhdGUncyBzZWNvbmQgbnVtYmVyXG4gICAgICAgICAqXG4gICAgICAgICAqIFdpdGggZXh0ZW5kIG9wZXJhdGlvbiA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV2ZW50cyA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgIHtkYXRlIDoge3R5cGUgOiBhZmZpbml0eS5EYXRlfX0sXG4gICAgICAgICAqICAgICAgICAgIHtuYW1lIDoge3R5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICBbbmV3IERhdGUoKSwgJ05vdyddLFxuICAgICAgICAgKiAgICAgIF0pXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGRhdGUgPSBldmVudHMuZ2V0KCdkYXRlJylcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSBldmVudHMuZXh0ZW5kKFsgeyBcImRhdGUuc2Vjb25kcygpXCIgOiBkYXRlLnNlY29uZHMoKSB9IF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vIG9yIGVxdWl2YWxlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSBldmVudHMuZXh0ZW5kKFsgeyBcImRhdGUuc2Vjb25kcygpXCIgOiBuZXcgYWZmaW5pdHkuU2Vjb25kcyhkYXRlKSB9IF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IGRhdGUgOiBEYXRlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgbmFtZSA6IFN0cmluZyAgIHwgZGF0ZS5zZWNvbmRzKCkgOiBJbnRlZ2VyICAgfFxuICAgICAgICAgKiAgICAgIC8vICs9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAgLy8gfCBTdW4gSnVuIDI5IDIwMTQgMDg6NTE6MDUgR01ULTA0MDAgKEVEVCkgICB8IE5vdyAgICAgICAgICAgICB8IDUgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcblxuICAgICAgICAgICAgdGhpcy50eXBlKFRJbnRlZ2VyKTtcblxuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ1NlY29uZHMnO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGZ1bmN0aW9uIHJldHVybiB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlKHRoaXMucGFyYW1ldGVyc1swXSkuZ2V0U2Vjb25kcygpO1xuXG4gICAgICAgIH1cblxuICAgIH0se1xuXG5cbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZWNvbmRzOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24uanMnKTtcbnZhciBJbnRlZ2VyID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9JbnRlZ2VyLmpzJyk7XG52YXIgdmFsdWUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvdmFsdWUnKTtcblxudmFyIFRpbWVzdGFtcCA9IEZ1bmN0aW9uLmV4dGVuZChcblxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIEZ1bmN0aW9ucy5EYXRlLlRpbWVzdGFtcFxuICAgICAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBGdW5jdGlvbiB0aGF0IGV4dHJhY3RzIGEgZGF0ZSdzIHRpbWVzdGFtcFxuICAgICAgICAgKlxuICAgICAgICAgKiBXaXRoIGV4dGVuZCBvcGVyYXRpb24gOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBldmVudHMgPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICB7ZGF0ZSA6IHt0eXBlIDogYWZmaW5pdHkuRGF0ZX19LFxuICAgICAgICAgKiAgICAgICAgICB7bmFtZSA6IHt0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgICAgICogICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgW25ldyBEYXRlKCksICdOb3cnXSxcbiAgICAgICAgICogICAgICBdKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBkYXRlID0gZXZlbnRzLmdldCgnZGF0ZScpXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gZXZlbnRzLmV4dGVuZChbIHsgXCJkYXRlLnRpbWVzdGFtcCgpXCIgOiBkYXRlLnRzKCkgfSBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBvciBlcXVpdmFsZW50XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gZXZlbnRzLmV4dGVuZChbIHsgXCJkYXRlLnRpbWVzdGFtcCgpXCIgOiBuZXcgYWZmaW5pdHkuVGltZXN0YW1wKGRhdGUpIH0gXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgZXh0ZW5kZWQucHJpbnQoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBkYXRlIDogRGF0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IG5hbWUgOiBTdHJpbmcgICB8IGRhdGUudGltZXN0YW1wKCkgOiBJbnRlZ2VyICAgfFxuICAgICAgICAgKiAgICAgIC8vICs9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgICAvLyB8IFN1biBKdW4gMjkgMjAxNCAxMDowMjozNCBHTVQtMDQwMCAoRURUKSAgIHwgTm93ICAgICAgICAgICAgIHwgMTQwNDA1MDU1NDgwNSAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG5cbiAgICAgICAgICAgIHRoaXMudHlwZShJbnRlZ2VyKTtcblxuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ1RpbWVzdGFtcCc7XG5cbiAgICAgICAgfSxcblxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICB2YXIgcGFyYW0gPSB2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMF0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUodGhpcy5wYXJhbWV0ZXJzWzBdKS5nZXRUaW1lKCk7XG5cbiAgICAgICAgfVxuXG4gICAgfSx7XG5cblxuICAgIH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVzdGFtcDsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uLmpzJyk7XG52YXIgVEludGVnZXIgPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL0ludGVnZXIuanMnKTtcbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy92YWx1ZScpO1xuXG52YXIgV2Vla09mWWVhciA9IEZ1bmN0aW9uLmV4dGVuZChcbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuRGF0ZS5XZWVrT2ZZZWFyXG4gICAgICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEZ1bmN0aW9uIHRoYXQgZXh0cmFjdHMgYSBkYXRlJ3Mgd2VlayBudW1iZXIgKDAtNTEpXG4gICAgICAgICAqXG4gICAgICAgICAqIFdpdGggZXh0ZW5kIG9wZXJhdGlvbiA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV2ZW50cyA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgIHtkYXRlIDoge3R5cGUgOiBhZmZpbml0eS5EYXRlfX0sXG4gICAgICAgICAqICAgICAgICAgIHtuYW1lIDoge3R5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAgICAgKiAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICBbbmV3IERhdGUoMjAxNCwgMDIsIDA3KSwgJ1NvY2hpJ10sXG4gICAgICAgICAqICAgICAgICAgIFtuZXcgRGF0ZSgyMDE0LCAwMSwgMDIpLCAnQ2hvY29sYXRlIHJ1c2gnXSxcbiAgICAgICAgICogICAgICAgICAgW25ldyBEYXRlKDIwMTQsIDA0LCAxNSksICdNaWxsaW9udGggY29mZmVlIGRyYW5rJ11cbiAgICAgICAgICogICAgICBdKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBkYXRlID0gZXZlbnRzLmdldCgnZGF0ZScpXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gZXZlbnRzLmV4dGVuZChbIHsgXCJkYXRlLndlZWtPZlllYXIoKVwiIDogZGF0ZS53ZWVrT2ZZZWFyKCkgfSBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBvciBlcXVpdmFsZW50XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gZXZlbnRzLmV4dGVuZChbIHsgXCJkYXRlLndlZWtPZlllYXIoKVwiIDogbmV3IGFmZmluaXR5LndlZWtPZlllYXIoZGF0ZSkgfSBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICBleHRlbmRlZC5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBkYXRlIDogRGF0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IG5hbWUgOiBTdHJpbmcgICAgICAgICAgICB8IGRhdGUud2Vla09mWWVhcigpIDogSW50ZWdlciAgIHxcbiAgICAgICAgICogICAgICAvLyArPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgIC8vIHwgRnJpIE1hciAwNyAyMDE0IDAwOjAwOjAwIEdNVC0wNTAwIChFU1QpICAgfCBTb2NoaSAgICAgICAgICAgICAgICAgICAgfCAxMCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IFN1biBGZWIgMDIgMjAxNCAwMDowMDowMCBHTVQtMDUwMCAoRVNUKSAgIHwgQ2hvY29sYXRlIHJ1c2ggICAgICAgICAgIHwgNSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBUaHUgTWF5IDE1IDIwMTQgMDA6MDA6MDAgR01ULTA0MDAgKEVEVCkgICB8IE1pbGxpb250aCBjb2ZmZWUgZHJhbmsgICB8IDIwICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcblxuICAgICAgICAgICAgdGhpcy50eXBlKFRJbnRlZ2VyKTtcblxuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ1dlZWtPZlllYXInO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGZ1bmN0aW9uIHJldHVybiB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgdmFyIGQgPSBuZXcgRGF0ZSgrdmFsdWUodGhpcy5wYXJhbWV0ZXJzWzBdKSk7XG4gICAgICAgICAgICBkLnNldEhvdXJzKDAsMCwwKTtcbiAgICAgICAgICAgIGQuc2V0RGF0ZShkLmdldERhdGUoKSs0LShkLmdldERheSgpfHw3KSk7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKCgoKGQtbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLDAsMSkpLzguNjRlNykrMSkvNyk7XG5cbiAgICAgICAgfVxuXG4gICAgfSx7XG5cblxuICAgIH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlZWtPZlllYXI7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIFRJbnRlZ2VyID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9JbnRlZ2VyLmpzJyk7XG52YXIgdmFsdWUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvdmFsdWUnKTtcblxudmFyIFllYXIgPSBGdW5jdGlvbi5leHRlbmQoXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLkRhdGUuWWVhclxuICAgICAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiBGdW5jdGlvbiB0aGF0IGV4dHJhY3RzIGEgZGF0ZSdzIGZ1bGwgeWVhciBudW1iZXJcbiAgICAgICAgICpcbiAgICAgICAgICogV2l0aCBleHRlbmQgb3BlcmF0aW9uIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXZlbnRzID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAge2RhdGUgOiB7dHlwZSA6IGFmZmluaXR5LkRhdGV9fSxcbiAgICAgICAgICogICAgICAgICAge25hbWUgOiB7dHlwZSA6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICAgICAqICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgIFtuZXcgRGF0ZSgyMDEzLCAwMSwgMDIpXSxcbiAgICAgICAgICogICAgICAgICAgW25ldyBEYXRlKDIwMTEsIDA2LCAzMCldLFxuICAgICAgICAgKiAgICAgICAgICBbbmV3IERhdGUoMjAxMCwgMDQsIDE1KV1cbiAgICAgICAgICogICAgICBdKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBkYXRlID0gZXZlbnRzLmdldCgnZGF0ZScpXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gZXZlbnRzLmV4dGVuZChbIHsgXCJkYXRlLnllYXIoKVwiIDogZGF0ZS55ZWFyKCkgfSBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBvciBlcXVpdmFsZW50XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gZXZlbnRzLmV4dGVuZChbIHsgXCJkYXRlLnllYXIoKVwiIDogbmV3IGFmZmluaXR5LlllYXIoZGF0ZSkgfSBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICBleHRlbmRlZC5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBkYXRlIDogRGF0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IG5hbWUgOiBTdHJpbmcgICAgICAgICAgICB8IGRhdGUueWVhcigpIDogSW50ZWdlciAgIHxcbiAgICAgICAgICogICAgICAvLyArPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgIC8vIHwgRnJpIE1hciAwNyAyMDE0IDAwOjAwOjAwIEdNVC0wNTAwIChFU1QpICAgfCBTb2NoaSAgICAgICAgICAgICAgICAgICAgfCAyMDE0ICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvLyB8IFN1biBGZWIgMDIgMjAxNCAwMDowMDowMCBHTVQtMDUwMCAoRVNUKSAgIHwgQ2hvY29sYXRlIHJ1c2ggICAgICAgICAgIHwgMjAxNCAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBUaHUgTWF5IDE1IDIwMTQgMDA6MDA6MDAgR01ULTA0MDAgKEVEVCkgICB8IE1pbGxpb250aCBjb2ZmZWUgZHJhbmsgICB8IDIwMTQgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG5cbiAgICAgICAgICAgIHRoaXMudHlwZShUSW50ZWdlcik7XG5cbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdZZWFyJztcblxuICAgICAgICB9LFxuXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMF0pLmdldEZ1bGxZZWFyKCk7XG5cbiAgICAgICAgfVxuXG4gICAgfSx7XG5cblxuICAgIH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFllYXI7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIFROdW1lcmljID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9OdW1lcmljLmpzJyk7XG52YXIgdmFsdWUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvdmFsdWUnKTtcblxudmFyIEFic29sdXRlID0gRnVuY3Rpb24uZXh0ZW5kKFxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIEZ1bmN0aW9ucy5OdW1lcmljLkFic29sdXRlXG4gICAgICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEZ1bmN0aW9uIHRoYXQgZXh0cmFjdHMgdGhlIEFic29sdXRlIHZhbHVlIG9mIGEgTnVtYmVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEV4YW1wbGUgd2l0aCBFeHRlbmQgb3BlcmF0b3IgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgIHsgQSA6ICB7dHlwZSA6IGFmZmluaXR5LkludGVnZXJ9IH0sXG4gICAgICAgICAqICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgIFstMTBdLCBbLTVdLCBbMF0sIFs1XSwgWzEwXV1cbiAgICAgICAgICogICAgICBdKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBBID0gcmVsYXRpb24uZ2V0KCdBJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKFt7IFwiQS5hYnMoKVwiIDogQS5hYnMoKSB9XSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gb3JcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSByZWxhdGlvbi5leHRlbmQoW3sgXCJBLmFicygpXCIgOiBuZXcgYWZmaW5pdHkuQWJzb2x1dGUoQSkgfV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvL3wgQSA6IEludGVnZXIgICB8IEEuYWJzKCkgOiBJbnRlZ2VyICAgfFxuICAgICAgICAgKiAgICAgIC8vKz09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAgLy98IC0xMCAgICAgICAgICAgfCAxMCAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vfCAtNSAgICAgICAgICAgIHwgNSAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvL3wgMCAgICAgICAgICAgICB8IDAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy98IDUgICAgICAgICAgICAgfCA1ICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vfCAxMCAgICAgICAgICAgIHwgMTAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICpcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfEZ1bmN0aW9ufEF0dHJpYnV0ZX0gcGFyYW0gVGhlIG51bWJlciB0byBhYnNvbHVjaXplXG4gICAgICAgICAqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBBYnNvbHV0ZSBmdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIChwYXJhbSkge1xuXG4gICAgICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcblxuICAgICAgICAgICAgdGhpcy50eXBlKFROdW1lcmljKTtcblxuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ0Fic29sdXRlJztcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgcmVzdWx0XG4gICAgICAgICAqXG4gICAgICAgICAqIEdldHMgdGhlIGZ1bmN0aW9uIHJlc3VsdFxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHZhbHVlKHRoaXMucGFyYW1ldGVyc1swXSkpO1xuXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG5BYnNvbHV0ZS5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9udW1lcmljJykpO1xuQWJzb2x1dGUubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvY29tcGFyYWJsZScpKTtcbkFic29sdXRlLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL3NpemUtY29tcGFyYWJsZScpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBYnNvbHV0ZTsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uLmpzJyk7XG52YXIgVE51bWVyaWMgPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL051bWVyaWMuanMnKTtcbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy92YWx1ZScpO1xuXG52YXIgRkNlaWwgPSBGdW5jdGlvbi5leHRlbmQoXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLk51bWVyaWMuQ2VpbFxuICAgICAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBGdW5jdGlvbiB0aGF0IHJvdW5kcyBhIG51bWJlciB1cHdhcmRzXG4gICAgICAgICAqXG4gICAgICAgICAqIEV4YW1wbGUgd2l0aCBFeHRlbmQgb3BlcmF0b3IgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgIHsgQSA6ICB7dHlwZSA6IGFmZmluaXR5LkludGVnZXJ9IH0sXG4gICAgICAgICAqICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgIFsxLjAxXSwgWy0yLjg1XSwgWzNdLCBbMy4xMl0sIFsxMC4yXV1cbiAgICAgICAgICogICAgICBdKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBBID0gcmVsYXRpb24uZ2V0KCdBJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKFt7IFwiQS5jZWlsKClcIiA6IEEuY2VpbCgpIH1dKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBvclxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbeyBcIkEuY2VpbCgpXCIgOiBuZXcgYWZmaW5pdHkuQ2VpbChBKSB9XSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgZXh0ZW5kZWQucHJpbnQoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvL3wgQSA6IEludGVnZXIgICB8IEEuY2VpbCgpIDogSW50ZWdlciAgIHxcbiAgICAgICAgICogICAgICAvLys9PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgICAvL3wgMS4wMSAgICAgICAgICB8IDIgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvL3wgLTIuODUgICAgICAgICB8IC0yICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvL3wgMyAgICAgICAgICAgICB8IDMgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvL3wgMy4xMiAgICAgICAgICB8IDQgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvL3wgMTAuMiAgICAgICAgICB8IDExICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuXG4gICAgICAgICAgICB0aGlzLnR5cGUoVE51bWVyaWMpO1xuXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSAnQ2VpbCc7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZnVuY3Rpb24gcmV0dXJuIHZhbHVlXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHZhbHVlKHRoaXMucGFyYW1ldGVyc1swXSkpO1xuXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG5GQ2VpbC5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9udW1lcmljJykpO1xuRkNlaWwubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvY29tcGFyYWJsZScpKTtcbkZDZWlsLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL3NpemUtY29tcGFyYWJsZScpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGQ2VpbDsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uLmpzJyk7XG52YXIgTnVtZXJpYyA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvTnVtZXJpYy5qcycpO1xudmFyIHZhbHVlID0gcmVxdWlyZSgnLi8uLi8uLi9oZWxwZXJzL3ZhbHVlJyk7XG5cbnZhciBDb3NpbmUgPSBGdW5jdGlvbi5leHRlbmQoXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLk51bWVyaWMuQ29zaW5lXG4gICAgICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY29zaW5lIG9mIGEgbnVtYmVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEV4YW1wbGUgd2l0aCBFeHRlbmQgb3BlcmF0b3IgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgIHsgQSA6ICB7dHlwZSA6IGFmZmluaXR5LkludGVnZXJ9IH0sXG4gICAgICAgICAqICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgIFswXSwgW01hdGguUEkvMl0sIFtNYXRoLlBJXSwgWzMqTWF0aC5QSS8yXSwgWzIqTWF0aC5QSV1cbiAgICAgICAgICogICAgICBdKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBBID0gcmVsYXRpb24uZ2V0KCdBJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKFt7IFwiY29zKEEpXCIgOiBBLmNvcygpIH1dKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBvclxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbeyBcImNvcyhBKVwiIDogbmV3IGFmZmluaXR5LkNvc2luZShBKSB9XSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgZXh0ZW5kZWQucHJpbnQoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBUaGUgZm9sbG93aW5nIHJlc3VsdCBzaG93cyBhIGJ1ZywgYnV0IGl0J3Mgbm90IGFmZmluaXR5J3MgZmF1bHQuXG4gICAgICAgICAqICAgICAgLy8gRHVlIHRvIGEgYnVnIGluIFY4XG4gICAgICAgICAqICAgICAgLy8gKHNlZSB0aGlzIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjQ0NTU3NzUvd2h5LWRvZXMtbm9kZS1ub3QtZXZhbHVhdGUtbWF0aC10YW5tYXRoLXBpLTItdG8taW5maW5pdHktYnV0LWNocm9tZS12OC1kb2VzKVxuICAgICAgICAgKiAgICAgIC8vIE1hdGgudGFuKE1hdGguUEkvMikgd29uJ3QgZXZhbHVhdGUgdG8gSW5maW5pdHkuXG4gICAgICAgICAqICAgICAgLy8gTWF0aC50YW4oTWF0aC5QSSkgd29uJ3QgZXZhbHVhdGUgdG8gMC5cbiAgICAgICAgICogICAgICAvLyBBbmQgc28gb24uIFRoaXMgaXMgZHVlIHRvIE1hdGguY29zKE1hdGguUEkvMikgbm90IGV2YWx1YXRpbmcgdG8gMC5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBUaGlzIHdpbGwgYmUgZml4ZWQgaW4gbm9kZSB2MC4xMS4gYXMgSSB0ZXN0ZWQgdGhlIHYwLjExLjE0LXByZSB2ZXJzaW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIC8vKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvL3wgQSA6IEludGVnZXIgICB8IGNvcyhBKSA6IE51bWVyaWMgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8rPT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgIC8vfCAwICAgICAgICAgICAgIHwgMSAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy98IFBJLzIgICAgICAgICAgfCA2LjEyMzAzMTc2OTExMTg4NmUtMTcgICAgfFxuICAgICAgICAgKiAgICAgIC8vKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvL3wgz4AgICAgICAgICAgICAgfCAtMSAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvL3wgM8+ALzIgICAgICAgICAgfCAtMS44MzY5MDk1MzA3MzM1NjZlLTE2ICAgfFxuICAgICAgICAgKiAgICAgIC8vKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvL3wgMs+AICAgICAgICAgICAgfCAxICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuXG4gICAgICAgICAgICB0aGlzLnR5cGUoTnVtZXJpYyk7XG5cbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdDb3MnO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGZ1bmN0aW9uIHJlc3VsdFxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIE1hdGguY29zKHZhbHVlKHRoaXMucGFyYW1ldGVyc1swXSkpO1xuXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG5Db3NpbmUubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvbnVtZXJpYycpKTtcbkNvc2luZS5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9jb21wYXJhYmxlJykpO1xuQ29zaW5lLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL3NpemUtY29tcGFyYWJsZScpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb3NpbmU7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIFROdW1lcmljID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9OdW1lcmljLmpzJyk7XG52YXIgdmFsdWUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvdmFsdWUnKTtcblxudmFyIEZEaXZpc2lvbiA9IEZ1bmN0aW9uLmV4dGVuZChcbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuTnVtZXJpYy5EaXZpc2lvblxuICAgICAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBhIGRpdmlzaW9uIGJldHdlZW4gdHdvIG51bWJlcnNcbiAgICAgICAgICpcbiAgICAgICAgICogRXhhbXBsZSB3aXRoIEV4dGVuZCBvcGVyYXRvciA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIHJlbGF0aW9uID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgeyBBIDogIHt0eXBlIDogYWZmaW5pdHkuSW50ZWdlcn0gfSxcbiAgICAgICAgICogICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgWy0yXSwgWy0xXSwgWzBdLCBbMV0sIFsyXV1cbiAgICAgICAgICogICAgICBdKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciByZWxhdGlvbjIgPSByZWxhdGlvbi5leHRlbmQoW3tCIDogcmVsYXRpb24uZ2V0KCdBJyl9XSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIHByb2R1Y3QgPSByZWxhdGlvbjIucHJvamVjdChbJ0EnXSkucHJvZHVjdChyZWxhdGlvbjIuZ2V0KCdCJykpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBBID0gcHJvZHVjdC5nZXQoJ0EnKTtcbiAgICAgICAgICogICAgICB2YXIgQiA9IHByb2R1Y3QuZ2V0KCdCJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gcHJvZHVjdC5leHRlbmQoW3tcIkEgLyBCXCIgOiBBLmRpdihCKX1dKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBvciBlcXVpdmFsZW50XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgbmV3IGFmZmluaXR5LkV4dGVuZChwcm9kdWN0LCBbeyBcIkEgLyBCXCIgOiBuZXcgYWZmaW5pdHkuRGl2aXNpb24oQSwgQikgfV0pXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgZXh0ZW5kZWQucHJpbnQoKTtcbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyAoU3RhbmRhcmQgYmVoYXZpb3VyIG9mIEphdmFTY3JpcHQpXG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCBBIDogSW50ZWdlciAgIHwgQiA6IEludGVnZXIgICB8IEEgLyBCIDogTnVtZXJpYyB8XG4gICAgICAgICAqICAgICAgLy8gKz09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAgLy8gfCAtMiAgICAgICAgICAgIHwgLTIgICAgICAgICAgICB8IDEgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCAtMiAgICAgICAgICAgIHwgLTEgICAgICAgICAgICB8IDIgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCAtMiAgICAgICAgICAgIHwgMCAgICAgICAgICAgICB8IC1JbmZpbml0eSAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCAtMiAgICAgICAgICAgIHwgMSAgICAgICAgICAgICB8IC0yICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCAtMiAgICAgICAgICAgIHwgMiAgICAgICAgICAgICB8IC0xICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCAtMSAgICAgICAgICAgIHwgLTIgICAgICAgICAgICB8IDAuNSAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCAtMSAgICAgICAgICAgIHwgLTEgICAgICAgICAgICB8IDEgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCAtMSAgICAgICAgICAgIHwgMCAgICAgICAgICAgICB8IC1JbmZpbml0eSAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCAtMSAgICAgICAgICAgIHwgMSAgICAgICAgICAgICB8IC0xICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCAtMSAgICAgICAgICAgIHwgMiAgICAgICAgICAgICB8IC0wLjUgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCAwICAgICAgICAgICAgIHwgLTIgICAgICAgICAgICB8IDAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCAwICAgICAgICAgICAgIHwgLTEgICAgICAgICAgICB8IDAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCAwICAgICAgICAgICAgIHwgMCAgICAgICAgICAgICB8IE5hTiAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCAwICAgICAgICAgICAgIHwgMSAgICAgICAgICAgICB8IDAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCAwICAgICAgICAgICAgIHwgMiAgICAgICAgICAgICB8IDAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCAxICAgICAgICAgICAgIHwgLTIgICAgICAgICAgICB8IC0wLjUgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCAxICAgICAgICAgICAgIHwgLTEgICAgICAgICAgICB8IC0xICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCAxICAgICAgICAgICAgIHwgMCAgICAgICAgICAgICB8IEluZmluaXR5ICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCAxICAgICAgICAgICAgIHwgMSAgICAgICAgICAgICB8IDEgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCAxICAgICAgICAgICAgIHwgMiAgICAgICAgICAgICB8IDAuNSAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCAyICAgICAgICAgICAgIHwgLTIgICAgICAgICAgICB8IC0xICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCAyICAgICAgICAgICAgIHwgLTEgICAgICAgICAgICB8IC0yICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCAyICAgICAgICAgICAgIHwgMCAgICAgICAgICAgICB8IEluZmluaXR5ICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCAyICAgICAgICAgICAgIHwgMSAgICAgICAgICAgICB8IDIgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy8gfCAyICAgICAgICAgICAgIHwgMiAgICAgICAgICAgICB8IDEgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcblxuICAgICAgICAgICAgdGhpcy50eXBlKFROdW1lcmljKTtcblxuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ0RpdmlzaW9uJztcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBmdW5jdGlvbiByZXN1bHRcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMF0pL3ZhbHVlKHRoaXMucGFyYW1ldGVyc1sxXSk7XG5cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbkZEaXZpc2lvbi5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9udW1lcmljJykpO1xuRkRpdmlzaW9uLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL2NvbXBhcmFibGUnKSk7XG5GRGl2aXNpb24ubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvc2l6ZS1jb21wYXJhYmxlJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZEaXZpc2lvbjsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uLmpzJyk7XG52YXIgVE51bWVyaWMgPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL051bWVyaWMuanMnKTtcbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy92YWx1ZScpO1xuXG52YXIgRkV4cCA9IEZ1bmN0aW9uLmV4dGVuZChcbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuTnVtZXJpYy5FeHBvbmVudGlhbFxuICAgICAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBleHBvbmVudGlhbCBvZiBhIG51bWJlciAoZV54KVxuICAgICAgICAgKlxuICAgICAgICAgKiBFeGFtcGxlIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbeyBBIDoge3R5cGUgOiBhZmZpbml0eS5JbnRlZ2VyfSB9XSxbWy0yXSwgWy0xXSxbMF0sWzFdLFsyXV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKFt7IFwiQS5leHAoKVwiIDogcmVsYXRpb24uZ2V0KCdBJykuZXhwKCl9XSlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIG9yIGVxdWl2YWxlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbeyBcIkEuZXhwKClcIiA6IG5ldyBhZmZpbml0eS5FeHAoQSl9XSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBleHRlbmRlZC5wcmludCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgQSA6IEludGVnZXIgICB8IEEuZXhwKCkgOiBOdW1lcmljICAgICB8XG4gICAgICAgICAqICAgICAvLyArPT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09K1xuICAgICAgICAgKiAgICAgLy8gfCAtMiAgICAgICAgICAgIHwgMC4xMzUzMzUyODMyMzY2MTI3ICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IC0xICAgICAgICAgICAgfCAwLjM2Nzg3OTQ0MTE3MTQ0MjMzICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMCAgICAgICAgICAgICB8IDEgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAxICAgICAgICAgICAgIHwgMi43MTgyODE4Mjg0NTkwNDUgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDIgICAgICAgICAgICAgfCA3LjM4OTA1NjA5ODkzMDY1ICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuXG4gICAgICAgICAgICB0aGlzLnR5cGUoVE51bWVyaWMpO1xuXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSAnRXhwb25lbnQnO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGZ1bmN0aW9uIHJlc3VsdFxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIE1hdGguZXhwKHZhbHVlKHRoaXMucGFyYW1ldGVyc1swXSkpO1xuXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG5GRXhwLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL251bWVyaWMnKSk7XG5GRXhwLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL2NvbXBhcmFibGUnKSk7XG5GRXhwLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL3NpemUtY29tcGFyYWJsZScpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGRXhwOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24uanMnKTtcbnZhciBUTnVtZXJpYyA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvTnVtZXJpYy5qcycpO1xudmFyIHZhbHVlID0gcmVxdWlyZSgnLi8uLi8uLi9oZWxwZXJzL3ZhbHVlJyk7XG5cbnZhciBGbG9vciA9IEZ1bmN0aW9uLmV4dGVuZChcbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuTnVtZXJpYy5GbG9vclxuICAgICAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBGdW5jdGlvbiB0aGF0IHJvdW5kcyBhIG51bWJlciBkb3dud2FyZHNcbiAgICAgICAgICpcbiAgICAgICAgICogRXhhbXBsZSB3aXRoIEV4dGVuZCBvcGVyYXRvciA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIHJlbGF0aW9uID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgeyBBIDogIHt0eXBlIDogYWZmaW5pdHkuSW50ZWdlcn0gfSxcbiAgICAgICAgICogICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgWzEuMDFdLCBbLTIuODVdLCBbM10sIFszLjEyXSwgWzEwLjJdXVxuICAgICAgICAgKiAgICAgIF0pXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIEEgPSByZWxhdGlvbi5nZXQoJ0EnKTtcbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSByZWxhdGlvbi5leHRlbmQoW3sgXCJBLmZsb29yKClcIiA6IEEuRmxvb3IoKSB9XSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gb3JcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICB2YXIgZXh0ZW5kZWQgPSByZWxhdGlvbi5leHRlbmQoW3sgXCJBLmZsb29yKClcIiA6IG5ldyBhZmZpbml0eS5mbG9vcihBKSB9XSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgZXh0ZW5kZWQucHJpbnQoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy98IEEgOiBJbnRlZ2VyICAgfCBBLmZsb29yKCkgOiBJbnRlZ2VyICAgfFxuICAgICAgICAgKiAgICAgIC8vKz09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgICAvL3wgMS4wMSAgICAgICAgICB8IDEgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vfCAtMi44NSAgICAgICAgIHwgLTMgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy98IDMgICAgICAgICAgICAgfCAzICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvL3wgMy4xMiAgICAgICAgICB8IDMgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vfCAxMC4yICAgICAgICAgIHwgMTAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcblxuICAgICAgICAgICAgdGhpcy50eXBlKFROdW1lcmljKTtcblxuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ0Zsb29yJztcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBmdW5jdGlvbiByZXR1cm4gdmFsdWVcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKHZhbHVlKHRoaXMucGFyYW1ldGVyc1swXSkpO1xuXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG5GbG9vci5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9udW1lcmljJykpO1xuRmxvb3IubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvY29tcGFyYWJsZScpKTtcbkZsb29yLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL3NpemUtY29tcGFyYWJsZScpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGbG9vcjsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uLmpzJyk7XG52YXIgVE51bWVyaWMgPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL051bWVyaWMuanMnKTtcbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy92YWx1ZScpO1xudmFyIHR5cGUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvdHlwZScpO1xuXG52YXIgRk1pbnVzID0gRnVuY3Rpb24uZXh0ZW5kKFxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIEZ1bmN0aW9ucy5OdW1lcmljLk1pbnVzXG4gICAgICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIFN1YnRyYWN0cyB0d28gbnVtYmVyc1xuICAgICAgICAgKlxuICAgICAgICAgKiBFeGFtcGxlIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgICAgICB7QSA6IHt0eXBlIDogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICAgICAge0IgOiB7dHlwZSA6IGFmZmluaXR5LkludGVnZXJ9fVxuICAgICAgICAgKiAgICAgICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgICAgIFsxLCAyXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsxMCwgMV1cbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgQSA9IHJlbGF0aW9uLmdldCgnQScpO1xuICAgICAgICAgKiAgICAgdmFyIEIgPSByZWxhdGlvbi5nZXQoJ0InKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbeyBcIkEgLSBCXCIgOiBBLm1pbnVzKEIpfV0pXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBvciBlcXVpdmFsZW50XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgZXh0ZW5kZWQgPSByZWxhdGlvbi5leHRlbmQoW3tcIkEgLSBCXCIgOiBuZXcgYWZmaW5pdHkuTWludXMoQSwgQil9XSlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBBIDogSW50ZWdlciAgIHwgQiA6IEludGVnZXIgICB8IEEgLSBCIDogSW50ZWdlciAgIHxcbiAgICAgICAgICogICAgIC8vICs9PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAvLyB8IDEgICAgICAgICAgICAgfCAyICAgICAgICAgICAgIHwgLTEgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMCAgICAgICAgICAgICB8IDAgICAgICAgICAgICAgfCAwICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAxMCAgICAgICAgICAgIHwgMSAgICAgICAgICAgICB8IDkgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcblxuICAgICAgICAgICAgdGhpcy50eXBlKHR5cGUodGhpcy5wYXJhbWV0ZXJzWzBdKSk7XG5cbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdNaW51cyc7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZnVuY3Rpb24gcmV0dXJuIHZhbHVlXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlKCkuY29lcmNlKHZhbHVlKHRoaXMucGFyYW1ldGVyc1swXSktdmFsdWUodGhpcy5wYXJhbWV0ZXJzWzFdKSk7XG5cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbkZNaW51cy5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9udW1lcmljJykpO1xuRk1pbnVzLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL2NvbXBhcmFibGUnKSk7XG5GTWludXMubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvc2l6ZS1jb21wYXJhYmxlJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZNaW51czsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uLmpzJyk7XG52YXIgVE51bWVyaWMgPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL051bWVyaWMuanMnKTtcbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy92YWx1ZScpO1xuXG52YXIgRk1vZHVsbyA9IEZ1bmN0aW9uLmV4dGVuZChcbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuTnVtZXJpYy5Nb2R1bG9cbiAgICAgICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogR2V0cyB0aGUgbW9kdWxvIG9mIHR3byBudW1iZXJzXG4gICAgICAgICAqXG4gICAgICAgICAqIEV4YW1wbGUgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgICAgIHtBIDoge3R5cGUgOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgICAgICB7QiA6IHt0eXBlIDogYWZmaW5pdHkuSW50ZWdlcn19XG4gICAgICAgICAqICAgICAgICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICAgICAgWzEsIDJdLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgKiAgICAgICAgICAgICAgWzEwLCAxXSxcbiAgICAgICAgICogICAgICAgICAgICAgIFsxMCwgMl1cbiAgICAgICAgICogICAgICAgICAgXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgQSA9IHJlbGF0aW9uLmdldCgnQScpO1xuICAgICAgICAgKiAgICAgdmFyIEIgPSByZWxhdGlvbi5nZXQoJ0InKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbe1wiQSAlIEJcIiA6IEEubW9kKEIpfV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gb3IgZXF1aXZhbGVudFxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKFt7XCJBICUgQlwiIDogbmV3IGFmZmluaXR5Lk1vZHVsbyhBLCBCKX1dKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgQSA6IEludGVnZXIgICB8IEIgOiBJbnRlZ2VyICAgfCBBICUgQiA6IE51bWVyaWMgICAgfFxuICAgICAgICAgKiAgICAgLy8gKz09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAvLyB8IDEgICAgICAgICAgICAgfCAyICAgICAgICAgICAgIHwgMSAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAwICAgICAgICAgICAgIHwgMCAgICAgICAgICAgICB8IE5hTiAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMTAgICAgICAgICAgICB8IDEgICAgICAgICAgICAgfCAwICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDEwICAgICAgICAgICAgfCAyICAgICAgICAgICAgIHwgMCAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG5cbiAgICAgICAgICAgIHRoaXMudHlwZShUTnVtZXJpYyk7XG5cbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdNb2R1bG8nO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGZ1bmN0aW9uIHJldHVybiB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWUgOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMF0pJXZhbHVlKHRoaXMucGFyYW1ldGVyc1sxXSk7XG5cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbkZNb2R1bG8ubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvbnVtZXJpYycpKTtcbkZNb2R1bG8ubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvY29tcGFyYWJsZScpKTtcbkZNb2R1bG8ubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvc2l6ZS1jb21wYXJhYmxlJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZNb2R1bG87IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIFROdW1lcmljID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9OdW1lcmljLmpzJyk7XG52YXIgdmFsdWUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvdmFsdWUnKTtcblxudmFyIEZNdWx0aXBsaWNhdGlvbiA9IEZ1bmN0aW9uLmV4dGVuZChcbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuTnVtZXJpYy5NdWx0aXBsaWNhdGlvblxuICAgICAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBNdWx0aXBsaWVzIHR3byBudW1iZXJzXG4gICAgICAgICAqXG4gICAgICAgICAqIGV4YW1wbGUgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgeyBBIDogeyB0eXBlIDogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICB7IEIgOiB7IHR5cGUgOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgWzEsIC0xXSxcbiAgICAgICAgICogICAgICAgICAgWy0xLCAxXSxcbiAgICAgICAgICogICAgICAgICAgWzAsIDEwXSxcbiAgICAgICAgICogICAgICAgICAgWzEsIDEwXSxcbiAgICAgICAgICogICAgICAgICAgWzIsIC0xMF0sXG4gICAgICAgICAqICAgICBdKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIEEgPSByZWxhdGlvbi5nZXQoJ0EnKVxuICAgICAgICAgKiAgICAgdmFyIEIgPSByZWxhdGlvbi5nZXQoJ0InKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKFt7IFwiQSB4IEJcIiA6IEEudGltZXMoQil9XSlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG9yXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgZXh0ZW5kZWQgPSByZWxhdGlvbi5leHRlbmQoW3sgXCJBIHggQlwiIDogbmV3IGFmZmluaXR5Lk11bHRpcGxpY2F0aW9uKEEsIEIpfV0pXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBleHRlbmRlZC5wcmludCgpXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgQSA6IEludGVnZXIgICB8IEIgOiBJbnRlZ2VyICAgfCBBIHggQiA6IE51bWVyaWMgfFxuICAgICAgICAgKiAgICAgLy8gKz09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAvLyB8IDEgICAgICAgICAgICAgfCAtMSAgICAgICAgICAgIHwgLTEgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAtMSAgICAgICAgICAgIHwgMSAgICAgICAgICAgICB8IC0xICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMCAgICAgICAgICAgICB8IDEwICAgICAgICAgICAgfCAwICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDEgICAgICAgICAgICAgfCAxMCAgICAgICAgICAgIHwgMTAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAyICAgICAgICAgICAgIHwgLTEwICAgICAgICAgICB8IC0yMCAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuXG4gICAgICAgICAgICB0aGlzLnR5cGUoVE51bWVyaWMpO1xuXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSAnTXVsdGlwbGljYXRpb24nO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgdmFsdWUgOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMF0pKnZhbHVlKHRoaXMucGFyYW1ldGVyc1sxXSk7XG5cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbkZNdWx0aXBsaWNhdGlvbi5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9udW1lcmljJykpO1xuRk11bHRpcGxpY2F0aW9uLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL2NvbXBhcmFibGUnKSk7XG5GTXVsdGlwbGljYXRpb24ubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvc2l6ZS1jb21wYXJhYmxlJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZNdWx0aXBsaWNhdGlvbjsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uLmpzJyk7XG52YXIgVE51bWVyaWMgPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL051bWVyaWMuanMnKTtcbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy92YWx1ZScpO1xudmFyIHR5cGUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvdHlwZScpO1xuXG52YXIgUGx1cyA9IEZ1bmN0aW9uLmV4dGVuZChcbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuTnVtZXJpYy5QbHVzXG4gICAgICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEFkZHMgdHdvIG51bWJlcnNcbiAgICAgICAgICpcbiAgICAgICAgICogZXhhbXBsZSA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb24gPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICB7IEEgOiB7IHR5cGUgOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICAgICAgIHsgQiA6IHsgdHlwZSA6IGFmZmluaXR5LkludGVnZXJ9fSxcbiAgICAgICAgICogICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICBbMSwgLTFdLFxuICAgICAgICAgKiAgICAgICAgICBbLTEsIDFdLFxuICAgICAgICAgKiAgICAgICAgICBbMCwgMTBdLFxuICAgICAgICAgKiAgICAgICAgICBbMSwgMTBdLFxuICAgICAgICAgKiAgICAgICAgICBbMiwgLTEwXSxcbiAgICAgICAgICogICAgIF0pXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgQSA9IHJlbGF0aW9uLmdldCgnQScpXG4gICAgICAgICAqICAgICB2YXIgQiA9IHJlbGF0aW9uLmdldCgnQicpXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgZXh0ZW5kZWQgPSByZWxhdGlvbi5leHRlbmQoW3sgXCJBICsgQlwiIDogQS5wbHVzKEIpfV0pXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBvclxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKFt7IFwiQSArIEJcIiA6IG5ldyBhZmZpbml0eS5QbHVzKEEsIEIpfV0pXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBleHRlbmRlZC5wcmludCgpXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgQSA6IEludGVnZXIgICB8IEIgOiBJbnRlZ2VyICAgfCBBICsgQiA6IE51bWVyaWMgfFxuICAgICAgICAgKiAgICAgLy8gKz09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAvLyB8IDEgICAgICAgICAgICAgfCAtMSAgICAgICAgICAgIHwgMCAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAtMSAgICAgICAgICAgIHwgMSAgICAgICAgICAgICB8IDAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMCAgICAgICAgICAgICB8IDEwICAgICAgICAgICAgfCAxMCAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDEgICAgICAgICAgICAgfCAxMCAgICAgICAgICAgIHwgMTEgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAyICAgICAgICAgICAgIHwgLTEwICAgICAgICAgICB8IC0xOCAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuXG4gICAgICAgICAgICB0aGlzLnR5cGUodGhpcy5wYXJhbWV0ZXJzWzBdKTtcblxuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ1BsdXMnO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGZ1bmN0aW9uIHJldHVybiB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZSgpLmNvZXJjZSh2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMF0pK3ZhbHVlKHRoaXMucGFyYW1ldGVyc1sxXSkpO1xuXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG5QbHVzLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL251bWVyaWMnKSk7XG5QbHVzLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL2NvbXBhcmFibGUnKSk7XG5QbHVzLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL3NpemUtY29tcGFyYWJsZScpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQbHVzOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24uanMnKTtcbnZhciBUTnVtZXJpYyA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvTnVtZXJpYy5qcycpO1xudmFyIHZhbHVlID0gcmVxdWlyZSgnLi8uLi8uLi9oZWxwZXJzL3ZhbHVlJyk7XG5cbnZhciBGUG93ID0gRnVuY3Rpb24uZXh0ZW5kKFxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIEZ1bmN0aW9ucy5OdW1lcmljLlBvd2VyXG4gICAgICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybnMgYSBudW1iZXIgdG8gdGhlIHBvd2VyIG9mIGFub3RoZXIgbnVtYmVyXG4gICAgICAgICAqXG4gICAgICAgICAqIGV4YW1wbGUgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIHJlbGF0aW9uID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgeyBBIDogeyB0eXBlIDogYWZmaW5pdHkuSW50ZWdlcn19LFxuICAgICAgICAgKiAgICAgICAgICB7IEIgOiB7IHR5cGUgOiBhZmZpbml0eS5JbnRlZ2VyfX0sXG4gICAgICAgICAqICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgWzEsIC0xXSxcbiAgICAgICAgICogICAgICAgICAgWy0xLCAxXSxcbiAgICAgICAgICogICAgICAgICAgWzAsIDEwXSxcbiAgICAgICAgICogICAgICAgICAgWzEsIDEwXSxcbiAgICAgICAgICogICAgICAgICAgWzIsIC0xMF0sXG4gICAgICAgICAqICAgICBdKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIEEgPSByZWxhdGlvbi5nZXQoJ0EnKVxuICAgICAgICAgKiAgICAgdmFyIEIgPSByZWxhdGlvbi5nZXQoJ0InKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKFt7IFwiQSBeIEJcIiA6IEEucG93KEIpfV0pXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBvclxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKFt7IFwiQSBeIEJcIiA6IG5ldyBhZmZpbml0eS5Qb3coQSwgQil9XSlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGV4dGVuZGVkLnByaW50KClcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCBBIDogSW50ZWdlciAgIHwgQiA6IEludGVnZXIgICB8IEEgXiBCIDogTnVtZXJpYyB8XG4gICAgICAgICAqICAgICAvLyArPT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgIC8vIHwgMSAgICAgICAgICAgICB8IC0xICAgICAgICAgICAgfCAxICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IC0xICAgICAgICAgICAgfCAxICAgICAgICAgICAgIHwgLTEgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAwICAgICAgICAgICAgIHwgMTAgICAgICAgICAgICB8IDAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMSAgICAgICAgICAgICB8IDEwICAgICAgICAgICAgfCAxICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDIgICAgICAgICAgICAgfCAtMTAgICAgICAgICAgIHwgMC4wMDA5NzY1NjI1ICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG5cbiAgICAgICAgICAgIHRoaXMudHlwZShUTnVtZXJpYyk7XG5cbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdQb3dlcic7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZnVuY3Rpb24ncyByZXR1cm4gdmFsdWU7XG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5wb3codmFsdWUodGhpcy5wYXJhbWV0ZXJzWzBdKSx2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMV0pKTtcblxuICAgICAgICB9XG5cbiAgICB9KTtcblxuRlBvdy5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9udW1lcmljJykpO1xuRlBvdy5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9jb21wYXJhYmxlJykpO1xuRlBvdy5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9zaXplLWNvbXBhcmFibGUnKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRlBvdzsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uLmpzJyk7XG52YXIgVE51bWVyaWMgPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL051bWVyaWMuanMnKTtcbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy92YWx1ZScpO1xuXG52YXIgUm91bmQgPSBGdW5jdGlvbi5leHRlbmQoXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLk51bWVyaWMuUm91bmRcbiAgICAgICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogUm91bmRzIGEgbnVtYmVyIHRvIGl0cyBjbG9zZXN0IHdob2xlIG51bWJlclxuICAgICAgICAgKlxuICAgICAgICAgKiBleGFtcGxlIDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgIHsgQSA6IHsgdHlwZSA6IGFmZmluaXR5LkludGVnZXJ9fVxuICAgICAgICAgKiAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgIFstMTBdLFstNV0sWy0yXSxbLTFdLFswXSxbMV0sWzJdLFs1XSxbMTBdXG4gICAgICAgICAqICAgICBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBBID0gcmVsYXRpb24uZ2V0KCdBJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgZXh0ZW5kZWQgPSByZWxhdGlvbi5leHRlbmQoW3tcIkEuc3FydCgpXCIgOiBBLnNxcnQoKX0sIHtcIkEuc3FydCgpLnJvdW5kKClcIiA6IEEuc3FydCgpLnJvdW5kKCl9XSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBvclxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKFtcbiAgICAgICAgICogICAgICAgICB7XCJBLnNxcnQoKVwiICAgICAgICAgOiBuZXcgYWZmaW5pdHkuU3F1YXJlUm9vdChBKX0sXG4gICAgICAgICAqICAgICAgICAge1wiQS5zcXJ0KCkucm91bmQoKVwiIDogbmV3IGFmZmluaXR5LlJvdW5kKG5ldyBhZmZpbml0eS5TcXVhcmVSb290KEEpKX1cbiAgICAgICAgICogICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgZXh0ZW5kZWQucHJpbnQoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IEEgOiBJbnRlZ2VyICAgfCBBLnNxcnQoKSA6IE51bWVyaWMgICB8IEEuc3FydCgpLnJvdW5kKCkgOiBOdW1lcmljICAgfFxuICAgICAgICAgKiAgICAgLy8gKz09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgIC8vIHwgLTEwICAgICAgICAgICB8IE5hTiAgICAgICAgICAgICAgICAgIHwgTmFOICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAtNSAgICAgICAgICAgIHwgTmFOICAgICAgICAgICAgICAgICAgfCBOYU4gICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IC0yICAgICAgICAgICAgfCBOYU4gICAgICAgICAgICAgICAgICB8IE5hTiAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgLTEgICAgICAgICAgICB8IE5hTiAgICAgICAgICAgICAgICAgIHwgTmFOICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCAwICAgICAgICAgICAgIHwgMCAgICAgICAgICAgICAgICAgICAgfCAwICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAvLyB8IDEgICAgICAgICAgICAgfCAxICAgICAgICAgICAgICAgICAgICB8IDEgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMiAgICAgICAgICAgICB8IDEuNDE0MjEzNTYyMzczMDk1MSAgIHwgMSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgLy8gfCA1ICAgICAgICAgICAgIHwgMi4yMzYwNjc5Nzc0OTk3OSAgICAgfCAyICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBGdW5jdGlvbi5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcblxuICAgICAgICAgICAgdGhpcy50eXBlKFROdW1lcmljKTtcblxuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ1JvdW5kJztcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBmdW5jdGlvbidzIHJldHVybiB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUodGhpcy5wYXJhbWV0ZXJzWzBdKSk7XG5cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cblJvdW5kLm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL251bWVyaWMnKSk7XG5Sb3VuZC5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9jb21wYXJhYmxlJykpO1xuUm91bmQubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvc2l6ZS1jb21wYXJhYmxlJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdW5kOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24uanMnKTtcbnZhciBUTnVtZXJpYyA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvTnVtZXJpYy5qcycpO1xudmFyIHZhbHVlID0gcmVxdWlyZSgnLi8uLi8uLi9oZWxwZXJzL3ZhbHVlJyk7XG5cbnZhciBTaW5lID0gRnVuY3Rpb24uZXh0ZW5kKFxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIEZ1bmN0aW9ucy5OdW1lcmljLlNpbmVcbiAgICAgICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogRnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBzaW5lIG9mIGEgbnVtYmVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEV4YW1wbGUgd2l0aCBFeHRlbmQgb3BlcmF0b3IgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICAgICAqICAgICAgICAgIHsgQSA6ICB7dHlwZSA6IGFmZmluaXR5LkludGVnZXJ9IH0sXG4gICAgICAgICAqICAgICAgXSxbXG4gICAgICAgICAqICAgICAgICAgIFswXSwgW01hdGguUEkvMl0sIFtNYXRoLlBJXSwgWzMqTWF0aC5QSS8yXSwgWzIqTWF0aC5QSV1cbiAgICAgICAgICogICAgICBdKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBBID0gcmVsYXRpb24uZ2V0KCdBJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKFt7IFwic2luKEEpXCIgOiBBLnNpbigpIH1dKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBvclxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbeyBcInNpbihBKVwiIDogbmV3IGFmZmluaXR5LlNpbmUoQSkgfV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvL3wgQSA6IEludGVnZXIgICB8IHNpbihBKSA6IE51bWVyaWMgfFxuICAgICAgICAgKiAgICAgIC8vKz09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT0rXG4gICAgICAgICAqICAgICAgLy98IDAgICAgICAgICAgICAgfCAwICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vfCBQSS8yICAgICAgICAgIHwgMSAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvL3wgz4AgICAgICAgICAgICAgfCAwICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vfCAzz4AvMiAgICAgICAgICB8IDEgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy98IDLPgCAgICAgICAgICAgIHwgMCAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuXG4gICAgICAgICAgICB0aGlzLnR5cGUoVE51bWVyaWMpO1xuXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSAnU2luZSc7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZnVuY3Rpb24gcmV0dXJuIHZhbHVlXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zaW4odmFsdWUodGhpcy5wYXJhbWV0ZXJzWzBdKSk7XG5cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cblNpbmUubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvbnVtZXJpYycpKTtcblNpbmUubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvY29tcGFyYWJsZScpKTtcblNpbmUubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvc2l6ZS1jb21wYXJhYmxlJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpbmU7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIFROdW1lcmljID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9OdW1lcmljLmpzJyk7XG52YXIgdmFsdWUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvdmFsdWUnKTtcblxudmFyIEZTcXVhcmVSb290ID0gRnVuY3Rpb24uZXh0ZW5kKFxuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNsYXNzIEZ1bmN0aW9ucy5OdW1lcmljLlNxdWFyZVJvb3RcbiAgICAgICAgICogQGV4dGVuZHMgRnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogUmV0dXJucyB0aGUgc3F1YXJlIHJvb3Qgb2YgYSBudW1iZXJcbiAgICAgICAgICpcbiAgICAgICAgICogZXhhbXBsZSA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgcmVsYXRpb24gPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAgICAgKiAgICAgICAgICB7IEEgOiB7IHR5cGUgOiBhZmZpbml0eS5JbnRlZ2VyfX1cbiAgICAgICAgICogICAgIF0sW1xuICAgICAgICAgKiAgICAgICAgICBbLTEwXSxbLTVdLFstMl0sWy0xXSxbMF0sWzFdLFsyXSxbNV0sWzEwXVxuICAgICAgICAgKiAgICAgXSlcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBBID0gcmVsYXRpb24uZ2V0KCdBJylcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbe1wiQS5zcXJ0KClcIiA6IEEuc3FydCgpfV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gb3JcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbeyBcIkEuc3FydCgpXCIgOiBuZXcgYWZmaW5pdHkuU3FydChBKX1dKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgZXh0ZW5kZWQucHJpbnQoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgQSA6IEludGVnZXIgICB8IEEuc3FydCgpIDogTnVtZXJpYyAgIHxcbiAgICAgICAgICogICAgIC8vICs9PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgIC8vIHwgLTEwICAgICAgICAgICB8IE5hTiAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgLTUgICAgICAgICAgICB8IE5hTiAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgLTIgICAgICAgICAgICB8IE5hTiAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgLTEgICAgICAgICAgICB8IE5hTiAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMCAgICAgICAgICAgICB8IDAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMSAgICAgICAgICAgICB8IDEgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgMiAgICAgICAgICAgICB8IDEuNDE0MjEzNTYyMzczMDk1MSAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgIC8vIHwgNSAgICAgICAgICAgICB8IDIuMjM2MDY3OTc3NDk5NzkgICAgIHxcbiAgICAgICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuXG4gICAgICAgICAgICB0aGlzLnR5cGUoVE51bWVyaWMpO1xuXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSAnU3F1YXJlIFJvb3QnO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGZ1bmN0aW9uIHJlc3VsdFxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCh2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMF0pKTtcblxuICAgICAgICB9XG5cbiAgICB9KTtcblxuRlNxdWFyZVJvb3QubWl4aW4ocmVxdWlyZSgnLi8uLi8uLi9taXhpbnMvbnVtZXJpYycpKTtcbkZTcXVhcmVSb290Lm1peGluKHJlcXVpcmUoJy4vLi4vLi4vbWl4aW5zL2NvbXBhcmFibGUnKSk7XG5GU3F1YXJlUm9vdC5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9zaXplLWNvbXBhcmFibGUnKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRlNxdWFyZVJvb3Q7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIFROdW1lcmljID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9OdW1lcmljLmpzJyk7XG52YXIgdmFsdWUgPSByZXF1aXJlKCcuLy4uLy4uL2hlbHBlcnMvdmFsdWUnKTtcblxudmFyIFRhbmdlbnQgPSBGdW5jdGlvbi5leHRlbmQoXG4gICAge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLk51bWVyaWMuVGFuZ2VudFxuICAgICAgICAgKiBAZXh0ZW5kcyBGdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIFRhbmdlbnQgb2YgYSBudW1iZXJcbiAgICAgICAgICpcbiAgICAgICAgICogRXhhbXBsZSB3aXRoIEV4dGVuZCBvcGVyYXRvciA6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIHJlbGF0aW9uID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgICAgICogICAgICAgICAgeyBBIDogIHt0eXBlIDogYWZmaW5pdHkuSW50ZWdlcn0gfSxcbiAgICAgICAgICogICAgICBdLFtcbiAgICAgICAgICogICAgICAgICAgWzBdLCBbTWF0aC5QSS8yXSwgW01hdGguUEldLCBbMypNYXRoLlBJLzJdLCBbMipNYXRoLlBJXVxuICAgICAgICAgKiAgICAgIF0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBBID0gcmVsYXRpb24uZ2V0KCdBJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKFt7IFwidGFuKEEpXCIgOiBBLnRhbigpIH1dKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLyBvclxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbeyBcInRhbihBKVwiIDogbmV3IGFmZmluaXR5LlRhbmdlbnQoQSkgfV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gVGhlIGZvbGxvd2luZyByZXN1bHQgc2hvd3MgYSBidWcsIGJ1dCBpdCdzIG5vdCBhZmZpbml0eSdzIGZhdWx0LlxuICAgICAgICAgKiAgICAgIC8vIER1ZSB0byBhIGJ1ZyBpbiBWOFxuICAgICAgICAgKiAgICAgIC8vIChzZWUgdGhpcyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI0NDU1Nzc1L3doeS1kb2VzLW5vZGUtbm90LWV2YWx1YXRlLW1hdGgtdGFubWF0aC1waS0yLXRvLWluZmluaXR5LWJ1dC1jaHJvbWUtdjgtZG9lcylcbiAgICAgICAgICogICAgICAvLyBNYXRoLnRhbihNYXRoLlBJLzIpIHdvbid0IGV2YWx1YXRlIHRvIEluZmluaXR5LlxuICAgICAgICAgKiAgICAgIC8vIE1hdGgudGFuKE1hdGguUEkpIHdvbid0IGV2YWx1YXRlIHRvIDAuXG4gICAgICAgICAqICAgICAgLy8gQW5kIHNvIG9uLiBUaGlzIGlzIGR1ZSB0byBNYXRoLmNvcyhNYXRoLlBJLzIpIG5vdCBldmFsdWF0aW5nIHRvIDAuXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgLy8gVGhpcyB3aWxsIGJlIGZpeGVkIGluIG5vZGUgdjAuMTEuIGFzIEkgdGVzdGVkIHRoZSB2MC4xMS4xNC1wcmUgdmVyc2lvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vfCBBIDogSW50ZWdlciAgIHwgdGFuKEEpIDogTnVtZXJpYyAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8rPT09PT09PT09PT09PT09Kz09PT09PT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgICAgICogICAgICAvL3wgMCAgICAgICAgICAgICB8IDAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgIC8vKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy98IFBJLzIgICAgICAgICAgfCAxNjMzMTc3ODcyODM4Mzg0NCAgICAgICAgIHxcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKiAgICAgIC8vfCDPgCAgICAgICAgICAgICB8IC0xLjIyNDYwNjM1MzgyMjM3NzNlLTE2ICAgfFxuICAgICAgICAgKiAgICAgIC8vKy0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAqICAgICAgLy98IDPPgC8yICAgICAgICAgIHwgNTQ0MzkyNjI0Mjc5NDYxNSAgICAgICAgICB8XG4gICAgICAgICAqICAgICAgLy8rLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICogICAgICAvL3wgMs+AICAgICAgICAgICAgfCAtMi40NDkyMTI3MDc2NDQ3NTQ1ZS0xNiAgIHxcbiAgICAgICAgICogICAgICAvLystLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG5cbiAgICAgICAgICAgIHRoaXMudHlwZShUTnVtZXJpYyk7XG5cbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdUYW5nZW50JztcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBmdW5jdGlvbiByZXR1cm4gdmFsdWVcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBNYXRoLnRhbih2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMF0pKTtcblxuICAgICAgICB9XG5cbiAgICB9KTtcblxuVGFuZ2VudC5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9udW1lcmljJykpO1xuVGFuZ2VudC5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9jb21wYXJhYmxlJykpO1xuVGFuZ2VudC5taXhpbihyZXF1aXJlKCcuLy4uLy4uL21peGlucy9zaXplLWNvbXBhcmFibGUnKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGFuZ2VudDsiLCJ2YXIgRnVuY3Rpb24gPSByZXF1aXJlKCcuLy4uLy4uL0Z1bmN0aW9uLmpzJyk7XG52YXIgVEludGVnZXIgPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL0ludGVnZXIuanMnKTtcbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy92YWx1ZScpO1xuXG52YXIgTGVuZ3RoID0gRnVuY3Rpb24uZXh0ZW5kKHtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuU3RyaW5nLkxlbmd0aFxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIGEgc3RyaW5nXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIHdpdGggRXh0ZW5zaW9uIG9wZXJhdG9yIDpcbiAgICAgKlxuICAgICAqICAgICB2YXIgYWZmaW5pdHkgPSByZXF1aXJlKCcuL2luZGV4LmpzJyk7XG4gICAgICpcbiAgICAgKiAgICAgdmFyIHJlbGF0aW9uID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgKiAgICAgICAgICB7IG5hbWUgOiB7IHR5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAqICAgICBdLFtcbiAgICAgKiAgICAgICAgICBbJ0pvaG4gRG9lJ10sIFsnTWFyayBDbGludG9uJ10sIFsnQm8gVnJpbCddXG4gICAgICogICAgIF0pO1xuICAgICAqXG4gICAgICogICAgIHZhciBuYW1lID0gcmVsYXRpb24uZ2V0KCduYW1lJyk7XG4gICAgICpcbiAgICAgKiAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKFt7XCJuYW1lLmxlbmd0aCgpXCIgOiBuYW1lLmxlbmd0aCgpfV0pO1xuICAgICAqXG4gICAgICogICAgIC8vIG9yXG4gICAgICpcbiAgICAgKiAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKFtcbiAgICAgKiAgICAgICAgIHtcIm5hbWUubGVuZ3RoKClcIiA6IG5ldyBhZmZpbml0eS5MZW5ndGgobmFtZSl9XG4gICAgICogICAgIF0pO1xuICAgICAqXG4gICAgICogICAgIGV4dGVuZGVkLnByaW50KCk7XG4gICAgICpcbiAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICogICAgIC8vIHwgbmFtZSA6IFN0cmluZyAgIHwgbmFtZS5sZW5ndGgoKSA6IEludGVnZXIgfFxuICAgICAqICAgICAvLyArPT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PStcbiAgICAgKiAgICAgLy8gfCBKb2huIERvZSAgICAgICAgfCA4ICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAqICAgICAvLyB8IE1hcmsgQ2xpbnRvbiAgICB8IDEyICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICogICAgIC8vIHwgQm8gVnJpbCAgICAgICAgIHwgNyAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG5cbiAgICAgICAgdGhpcy50eXBlKFRJbnRlZ2VyKTtcblxuICAgICAgICB0aGlzLm5hbWUgPSAnTGVuZ3RoJztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmdW5jdGlvbiByZXR1cm4gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlKHRoaXMucGFyYW1ldGVyc1swXSkubGVuZ3RoO1xuXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBMZW5ndGg7IiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIFRTdHJpbmcgPSByZXF1aXJlKCcuLy4uLy4uL3R5cGVzL1N0cmluZy5qcycpO1xudmFyIHZhbHVlID0gcmVxdWlyZSgnLi8uLi8uLi9oZWxwZXJzL3ZhbHVlJyk7XG5cbnZhciBMZW5ndGggPSBGdW5jdGlvbi5leHRlbmQoe1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIEZ1bmN0aW9ucy5TdHJpbmcuTG93ZXJjYXNlXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBsb3dlcmNhc2UgdmVyc2lvbiBvZiBhIHN0cmluZ1xuICAgICAqXG4gICAgICogRXhhbXBsZSB3aXRoIEV4dGVuc2lvbiBvcGVyYXRvciA6XG4gICAgICpcbiAgICAgKiAgICAgdmFyIGFmZmluaXR5ID0gcmVxdWlyZSgnLi9pbmRleC5qcycpO1xuICAgICAqXG4gICAgICogICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICogICAgICAgICAgeyBuYW1lIDogeyB0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgKiAgICAgXSxbXG4gICAgICogICAgICAgICAgWydKb2huIERvZSddLCBbJ01hcmsgQ2xpbnRvbiddLCBbJ0JvIFZyaWwnXVxuICAgICAqICAgICBdKTtcbiAgICAgKlxuICAgICAqICAgICB2YXIgbmFtZSA9IHJlbGF0aW9uLmdldCgnbmFtZScpO1xuICAgICAqXG4gICAgICogICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbe1wibmFtZS5sb3dlcmNhc2UoKVwiIDogbmFtZS5sb3dlcmNhc2UoKX1dKTtcbiAgICAgKlxuICAgICAqICAgICAvLyBvclxuICAgICAqXG4gICAgICogICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbXG4gICAgICogICAgICAgICB7IFwibmFtZS5sb3dlcmNhc2UoKVwiIDogbmV3IGFmZmluaXR5Lkxvd2VyY2FzZShuYW1lKSB9XG4gICAgICogICAgIF0pXG4gICAgICpcbiAgICAgKiAgICAgZXh0ZW5kZWQucHJpbnQoKTtcbiAgICAgKlxuICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAqICAgICAvLyB8IG5hbWUgOiBTdHJpbmcgICB8IG5hbWUubG93ZXJjYXNlKCkgOiBTdHJpbmcgfFxuICAgICAqICAgICAvLyArPT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PT09K1xuICAgICAqICAgICAvLyB8IEpvaG4gRG9lICAgICAgICB8IGpvaG4gZG9lICAgICAgICAgICAgICAgICAgfFxuICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAqICAgICAvLyB8IE1hcmsgQ2xpbnRvbiAgICB8IG1hcmsgY2xpbnRvbiAgICAgICAgICAgICAgfFxuICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAqICAgICAvLyB8IEJvIFZyaWwgICAgICAgICB8IGJvIHZyaWwgICAgICAgICAgICAgICAgICAgfFxuICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG5cbiAgICAgICAgdGhpcy50eXBlKFRTdHJpbmcpO1xuXG4gICAgICAgIHRoaXMubmFtZSA9ICdMb3dlcmNhc2UnO1xuXG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlKHRoaXMucGFyYW1ldGVyc1swXSkudG9Mb3dlckNhc2UoKTtcblxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGVuZ3RoOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24uanMnKTtcbnZhciBUU3RyaW5nID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9TdHJpbmcuanMnKTtcbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy92YWx1ZScpO1xuXG52YXIgVXBwZXJjYXNlID0gRnVuY3Rpb24uZXh0ZW5kKHtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuU3RyaW5nLlN1YnN0cmluZ1xuICAgICAqXG4gICAgICogUmV0dXJucyBhIHN1YnN0cmluZyBmcm9tIGEgc3RyaW5nXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIHdpdGggRXh0ZW5zaW9uIG9wZXJhdG9yIDpcbiAgICAgKlxuICAgICAqICAgICB2YXIgYWZmaW5pdHkgPSByZXF1aXJlKCcuL2luZGV4LmpzJyk7XG4gICAgICpcbiAgICAgKiAgICAgdmFyIHJlbGF0aW9uID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtcbiAgICAgKiAgICAgICAgICB7IG5hbWUgOiB7IHR5cGUgOiBhZmZpbml0eS5TdHJpbmd9fVxuICAgICAqICAgICBdLFtcbiAgICAgKiAgICAgICAgICBbJ0pvaG4gRG9lJ10sIFsnTWFyayBDbGludG9uJ10sIFsnQm8gVnJpbCddXG4gICAgICogICAgIF0pO1xuICAgICAqXG4gICAgICogICAgIHZhciBuYW1lID0gcmVsYXRpb24uZ2V0KCduYW1lJyk7XG4gICAgICpcbiAgICAgKiAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKFt7XCJuYW1lLnN1YnN0cigwLDUpXCIgOiBuYW1lLnN1YnN0cigwLCA1KX1dKTtcbiAgICAgKlxuICAgICAqICAgICAvL29yXG4gICAgICpcbiAgICAgKiAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKFtcbiAgICAgKiAgICAgICAgIHsgXCJuYW1lLnN1YnN0cigwLDUpXCIgOiBuZXcgYWZmaW5pdHkuU3Vic3RyaW5nKG5hbWUsIDAsIDUpIH1cbiAgICAgKiAgICAgXSk7XG4gICAgICpcbiAgICAgKiAgICAgZXh0ZW5kZWQucHJpbnQoKTtcbiAgICAgKlxuICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAqICAgICAvLyB8IG5hbWUgOiBTdHJpbmcgICB8IG5hbWUuc3Vic3RyKDAsNSkgOiBTdHJpbmcgfFxuICAgICAqICAgICAvLyArPT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PT09K1xuICAgICAqICAgICAvLyB8IEpvaG4gRG9lICAgICAgICB8IEpvaG4gICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAqICAgICAvLyB8IE1hcmsgQ2xpbnRvbiAgICB8IE1hcmsgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAqICAgICAvLyB8IEJvIFZyaWwgICAgICAgICB8IEJvIFZyICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG5cbiAgICAgICAgdGhpcy50eXBlKFRTdHJpbmcpO1xuXG4gICAgICAgIHRoaXMubmFtZSA9ICdTdWJzdHJpbmcnO1xuXG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIHN0YXJ0ID0gdmFsdWUodGhpcy5wYXJhbWV0ZXJzWzFdKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlKHRoaXMucGFyYW1ldGVyc1syXSk7XG4gICAgICAgIHJldHVybiB2YWx1ZSh0aGlzLnBhcmFtZXRlcnNbMF0pLnN1YnN0cihzdGFydCwgbGVuZ3RoKTtcblxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVXBwZXJjYXNlOyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24uanMnKTtcbnZhciBUU3RyaW5nID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9TdHJpbmcuanMnKTtcbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy92YWx1ZScpO1xuXG52YXIgVGVzdCA9IEZ1bmN0aW9uLmV4dGVuZCh7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgRnVuY3Rpb25zLlN0cmluZy5UZXN0XG4gICAgICpcbiAgICAgKiBUZXN0cyBhIHJlZ2V4IG9uIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogRXhhbXBsZSB3aXRoIEV4dGVuc2lvbiBvcGVyYXRvciA6XG4gICAgICpcbiAgICAgKiAgICAgdmFyIGFmZmluaXR5ID0gcmVxdWlyZSgnLi9pbmRleC5qcycpO1xuICAgICAqXG4gICAgICogICAgIHZhciByZWxhdGlvbiA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXG4gICAgICogICAgICAgICAgeyBuYW1lIDogeyB0eXBlIDogYWZmaW5pdHkuU3RyaW5nfX1cbiAgICAgKiAgICAgXSxbXG4gICAgICogICAgICAgICAgWydKb2huIERvZSddLCBbJ01hcmsgQ2xpbnRvbiddLCBbJ0JvIFZyaWwnXVxuICAgICAqICAgICBdKTtcbiAgICAgKlxuICAgICAqICAgICB2YXIgbmFtZSA9IHJlbGF0aW9uLmdldCgnbmFtZScpO1xuICAgICAqXG4gICAgICogICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbeyBcIm5hbWUudGVzdCgvRG9lLylcIiA6IG5hbWUudGVzdCgvRG9lLyl9XSk7XG4gICAgICpcbiAgICAgKiAgICAgLy8gb3JcbiAgICAgKlxuICAgICAqICAgICB2YXIgZXh0ZW5kZWQgPSByZWxhdGlvbi5leHRlbmQoW1xuICAgICAqICAgICAgICAgeyBcIm5hbWUudGVzdCgvRG9lLylcIiA6IG5ldyBhZmZpbml0eS5UZXN0KG5hbWUsIC9Eb2UvKSB9XG4gICAgICogICAgIF0pXG4gICAgICpcbiAgICAgKiAgICAgZXh0ZW5kZWQucHJpbnQoKTtcbiAgICAgKlxuICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKiAgICAgLy8gfCBuYW1lIDogU3RyaW5nICAgfCBuYW1lLnRlc3QoL0RvZS8pIDogQm9vbGVhbiB8XG4gICAgICogICAgIC8vICs9PT09PT09PT09PT09PT09PSs9PT09PT09PT09PT09PT09PT09PT09PT09PT09K1xuICAgICAqICAgICAvLyB8IEpvaG4gRG9lICAgICAgICB8IHRydWUgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgKiAgICAgLy8gKy0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICogICAgIC8vIHwgTWFyayBDbGludG9uICAgIHwgZmFsc2UgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKiAgICAgLy8gfCBCbyBWcmlsICAgICAgICAgfCBmYWxzZSAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICogICAgIC8vICstLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG5cbiAgICAgICAgdGhpcy50eXBlKFRTdHJpbmcpO1xuXG4gICAgICAgIHRoaXMubmFtZSA9ICdUZXN0JztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmdW5jdGlvbiByZXR1cm4gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciByZWdleCA9IHZhbHVlKHRoaXMucGFyYW1ldGVyc1sxXSk7XG4gICAgICAgIHJldHVybiByZWdleC50ZXN0KHZhbHVlKHRoaXMucGFyYW1ldGVyc1swXSkpO1xuXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUZXN0OyIsInZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vLi4vRnVuY3Rpb24uanMnKTtcbnZhciBUU3RyaW5nID0gcmVxdWlyZSgnLi8uLi8uLi90eXBlcy9TdHJpbmcuanMnKTtcbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4vLi4vLi4vaGVscGVycy92YWx1ZScpO1xuXG52YXIgVXBwZXJjYXNlID0gRnVuY3Rpb24uZXh0ZW5kKHtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzcyBGdW5jdGlvbnMuU3RyaW5nLlVwcGVyY2FzZVxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgdXBwZXJjYXNlIHZlcnNpb24gb2YgYSBzdHJpbmdcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgd2l0aCBFeHRlbnNpb24gb3BlcmF0b3IgOlxuICAgICAqXG4gICAgICogICAgIHZhciBhZmZpbml0eSA9IHJlcXVpcmUoJy4vaW5kZXguanMnKTtcbiAgICAgKlxuICAgICAqICAgICB2YXIgcmVsYXRpb24gPSBuZXcgYWZmaW5pdHkuUmVsYXRpb24oW1xuICAgICAqICAgICAgICAgIHsgdXBjcyA6IHsgdHlwZSA6IGFmZmluaXR5LlN0cmluZ319XG4gICAgICogICAgIF0sW1xuICAgICAqICAgICAgICAgIFsnSm9obiBEb2UnXSwgWydNYXJrIENsaW50b24nXSwgWydCbyBWcmlsJ11cbiAgICAgKiAgICAgXSk7XG4gICAgICpcbiAgICAgKiAgICAgdmFyIGV4dGVuZGVkID0gcmVsYXRpb24uZXh0ZW5kKFt7XCJuYW1lLnVwcGVyY2FzZSgpXCIgOiByZWxhdGlvbi5nZXQoJ25hbWUnKS51cHBlcmNhc2UoKX1dKTtcbiAgICAgKlxuICAgICAqICAgICAvLyBvclxuICAgICAqXG4gICAgICogICAgIHZhciBleHRlbmRlZCA9IHJlbGF0aW9uLmV4dGVuZChbXG4gICAgICogICAgICAgICB7IFwibmFtZS51cHBlcmNhc2UoKVwiIDogbmV3IGFmZmluaXR5LlVwcGVyY2FzZShuYW1lKSB9XG4gICAgICogICAgIF0pXG4gICAgICpcbiAgICAgKiAgICAgZXh0ZW5kZWQucHJpbnQoKTtcbiAgICAgKlxuICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAqICAgICAvLyB8IG5hbWUgOiBTdHJpbmcgICB8IG5hbWUudXBwZXJjYXNlKCkgOiBTdHJpbmcgfFxuICAgICAqICAgICAvLyArPT09PT09PT09PT09PT09PT0rPT09PT09PT09PT09PT09PT09PT09PT09PT09K1xuICAgICAqICAgICAvLyB8IEpvaG4gRG9lICAgICAgICB8IEpPSE4gRE9FICAgICAgICAgICAgICAgICAgfFxuICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAqICAgICAvLyB8IE1hcmsgQ2xpbnRvbiAgICB8IE1BUksgQ0xJTlRPTiAgICAgICAgICAgICAgfFxuICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAqICAgICAvLyB8IEJvIFZyaWwgICAgICAgICB8IEJPIFZSSUwgICAgICAgICAgICAgICAgICAgfFxuICAgICAqICAgICAvLyArLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgRnVuY3Rpb24uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG5cbiAgICAgICAgdGhpcy50eXBlKFRTdHJpbmcpO1xuXG4gICAgICAgIHRoaXMubmFtZSA9ICdVcHBlcmNhc2UnO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGZ1bmN0aW9uIHJldHVybiB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICByZXR1cm4gdmFsdWUodGhpcy5wYXJhbWV0ZXJzWzBdKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBVcHBlcmNhc2U7XG5cblxuIiwidmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi8uLi9GdW5jdGlvbi5qcycpO1xudmFyIFR5cGUgPSByZXF1aXJlKCcuLy4uLy4uL1R5cGUuanMnKTtcbnZhciBUQm9vbGVhbiA9IHJlcXVpcmUoJy4vLi4vLi4vdHlwZXMvQm9vbGVhbi5qcycpO1xuXG52YXIgVHVwbGVBdHRyaWJ1dGUgPSBGdW5jdGlvbi5leHRlbmQoe1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIEZ1bmN0aW9ucy5UdXBsZS5BdHRyaWJ1dGVWYWx1ZVxuICAgICAqIEBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBXaGVuIGJ1aWxkaW5nIGEgcHJlZGljYXRlLCB5b3UgcGFzcyB0aGUgSGVhZGVyIEF0dHJpYnV0ZXMgZGlyZWN0bHkgbGlrZSB0aGlzIDpcbiAgICAgKlxuICAgICAqICAgICB2YXIgZXh0ZW5kZWQgPSByZWxhdGlvbi5leHRlbmQocmVsYXRpb24uZ2V0KCdhdHRyaWJ1dGUxJykucGx1cyhyZWxhdGlvbi5nZXQoJ2F0dHJpYnV0ZTInKSkpO1xuICAgICAqXG4gICAgICogSW4gdGhlIGRvY3VtZW50YXRpb24gZm9yIFJlbGF0aW9uI2dldCwgaXQgaXMgc3BlY2lmaWVkIHRoYXQgaXQgcmV0dXJucyBhbiBBdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBUaG91Z2gsIHdoZW4gYnVpbGRpbmcgcHJlZGljYXRlcyBmb3IgcmVzdHJpY3Rpb24gb3IgZXh0ZW5zaW9uIG9wZXJhdG9ycywgd2UgY29udmVydCB0aGUgcGFzc2VkIEF0dHJpYnV0ZXNcbiAgICAgKiBpbnRvIGEgZnVuY3Rpb24gVHVwbGVBdHRyaWJ1dGUuIFNvIHRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIGFib3ZlIDpcbiAgICAgKlxuICAgICAqICAgICB2YXIgZXh0ZW5kZWQgPSByZWxhdGlvbi5leHRlbmQobmV3IGFmZmluaXR5LlR1cGxlQXR0cmlidXRlKCdhdHRyaWJ1dGUxJykucGx1cyhuZXcgYWZmaW5pdHkuVHVwbGVBdHRyaWJ1dGUoJ2F0dHJpYnV0ZTInKSkpO1xuICAgICAqXG4gICAgICogRGlyZWN0bHkgcGFzc2luZyB0aGUgSGVhZGVyIEF0dHJpYnV0ZSBpcyBqdXN0IHNvbWUgbmljZSBzdWdhci5cbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuXG4gICAgICAgIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcblxuICAgICAgICB0aGlzLm5hbWUgPSAnVHVwbGVBdHRyaWJ1dGUnO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGZ1bmN0aW9uIHJldHVybiB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIHR1cGxlID0gdGhpcy5wYXJhbWV0ZXJzWzBdO1xuXG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gdGhpcy5hdHRyaWJ1dGVOYW1lO1xuXG4gICAgICAgIGlmKCF0dXBsZS5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0cmlidXRlIFwiJythdHRyaWJ1dGVOYW1lKydcIiBkb2VzIG5vdCBleGlzdCBpbiBUdXBsZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHR1cGxlLmdldChhdHRyaWJ1dGVOYW1lKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIGEgdHVwbGUgdG8gdGhlIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHR1cGxlXG4gICAgICovXG4gICAgYXNzaWduVHVwbGUgOiBmdW5jdGlvbih0dXBsZSl7XG5cbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzWzBdID0gdHVwbGU7XG5cbiAgICB9XG5cbn0se1xuXG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFR1cGxlQXR0cmlidXRlOyIsInZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5cbnZhciBjbG9uZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cbiAgICBkZWJ1Zy5jbG9uZS50cmFjZSgnI2Nsb25lJyk7XG5cbiAgICBpZiAoZWxlbWVudC5jbG9uZSAmJiBfLmlzRnVuY3Rpb24oZWxlbWVudC5jbG9uZSkpIHtcblxuICAgICAgICByZXR1cm4gZWxlbWVudC5jbG9uZSgpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICByZXR1cm4gXy5jbG9uZURlZXAoZWxlbWVudCk7XG5cbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmU7IiwidmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbnZhciBjb2VyY2UgPSBmdW5jdGlvbiAodHlwZSwgdmFsdWUpIHtcbiAgICBkZWJ1Zy5jb2VyY2UudHJhY2UoJyNjb2VyY2UnKTtcbiAgICBpZih2YWx1ZSBpbnN0YW5jZW9mIHR5cGUpe1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIGlmICh0eXBlICYmIF8uaXNGdW5jdGlvbih0eXBlLmNvZXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUuY29lcmNlLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlICYmIHZhbHVlIGluc3RhbmNlb2YgdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3ICh0eXBlLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5iaW5kLmFwcGx5KHR5cGUsIChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBjb2VyY2U7IiwidmFyIHZhbHVlID0gcmVxdWlyZSgnLi92YWx1ZScpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vRnVuY3Rpb24nKTtcbnZhciBUeXBlID0gcmVxdWlyZSgnLi8uLi9UeXBlJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5cbnZhciBjb21wYXJlID0gZnVuY3Rpb24gKHR5cGUsIHZhbHVlMSwgdmFsdWUyKSB7XG5cbiAgICBkZWJ1Zy5jb21wYXJlLnRyYWNlKCcjY29tcGFyZScpO1xuXG4gICAgLy8gR2V0IHRoZSBmdW5jdGlvbiByZXR1cm4gdmFsdWVzIGlmIGFwcGxpY2FibGVcblxuICAgIHZhbHVlMSA9IHZhbHVlKHZhbHVlMSk7XG4gICAgdmFsdWUyID0gdmFsdWUodmFsdWUyKTtcblxuXG4gICAgLy8gQWNjZXNzIHRoZSB0eXBlJ3MgZXF1YWwgZnVuY3Rpb25cblxuICAgIGlmKHZhbHVlMSBpbnN0YW5jZW9mIFR5cGUpe1xuICAgICAgICByZXR1cm4gdmFsdWUxLmNvbnN0cnVjdG9yLmNvbXBhcmUodmFsdWUxLCB2YWx1ZTIpO1xuICAgIH1cblxuICAgIGlmKHZhbHVlMiBpbnN0YW5jZW9mIFR5cGUpe1xuICAgICAgICByZXR1cm4gdmFsdWUyLmNvbnN0cnVjdG9yLmNvbXBhcmUodmFsdWUxLCB2YWx1ZTIpO1xuICAgIH1cblxuICAgIGlmKHZhbHVlMSBpbnN0YW5jZW9mIERhdGUpe1xuICAgICAgICB2YWx1ZTEgPSB2YWx1ZTEuZ2V0VGltZSgpO1xuICAgIH1cblxuICAgIGlmKHZhbHVlMiBpbnN0YW5jZW9mIERhdGUpe1xuICAgICAgICB2YWx1ZTIgPSB2YWx1ZTIuZ2V0VGltZSgpO1xuICAgIH1cblxuXG4gICAgaWYodmFsdWUxID09PSB2YWx1ZTIpe1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKHZhbHVlMSA+IHZhbHVlMil7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAodmFsdWUyID4gdmFsdWUxKXtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmU7IiwiXG52YXIgbG9nNGpzO1xuXG50cnkge1xuICAgIGxvZzRqcyA9IHJlcXVpcmUoXCJsb2c0anNcIik7XG5cbiAgICBsb2c0anMuY29uZmlndXJlKHtcbiAgICAgICAgYXBwZW5kZXJzOiBbXG4gICAgICAgICAgICB7IHR5cGU6ICdjb25zb2xlJyB9XG4gICAgICAgIF0sXG4gICAgICAgIHJlcGxhY2VDb25zb2xlOiBmYWxzZVxuICAgIH0pO1xuXG4gICAgbG9nNGpzLnNldEdsb2JhbExvZ0xldmVsKGxvZzRqcy5sZXZlbHMuV0FSTik7XG5cbn0gY2F0Y2goZSkge1xuICAgIGxvZzRqcyA9IHt9O1xuXG4gICAgdmFyIGxvZ2dlciA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMudHJhY2UgPSB0aGlzLndhcm4gPSB0aGlzLmRlYnVnID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBsb2c0anMuZ2V0TG9nZ2VyID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIG5ldyBsb2dnZXIoKTtcbiAgICB9O1xufVxuXG52YXIgU2V0ID0gbW9kdWxlLmV4cG9ydHMuc2V0ID0gbG9nNGpzLmdldExvZ2dlcignU2V0Jyk7XG52YXIgUmVsYXRpb24gPSBtb2R1bGUuZXhwb3J0cy5yZWxhdGlvbiA9IGxvZzRqcy5nZXRMb2dnZXIoJ1JlbGF0aW9uJyk7XG52YXIgSGVhZGVyID0gbW9kdWxlLmV4cG9ydHMuaGVhZGVyID0gbG9nNGpzLmdldExvZ2dlcignSGVhZGVyJyk7XG5cbnZhciBDb21wb3NlID0gbW9kdWxlLmV4cG9ydHMuY29tcG9zZSA9IGxvZzRqcy5nZXRMb2dnZXIoJ0NvbXBvc2UnKTtcbnZhciBEaWZmZXJlbmNlID0gbW9kdWxlLmV4cG9ydHMuZGlmZmVyZW5jZSA9IGxvZzRqcy5nZXRMb2dnZXIoJ0RpZmZlcmVuY2UnKTtcbnZhciBFeHRlbmQgPSBtb2R1bGUuZXhwb3J0cy5leHRlbmQgPSBsb2c0anMuZ2V0TG9nZ2VyKCdFeHRlbmQnKTtcbnZhciBHcm91cCA9IG1vZHVsZS5leHBvcnRzLmdyb3VwID0gbG9nNGpzLmdldExvZ2dlcignR3JvdXAnKTtcbnZhciBJbnRlcnNlY3Rpb24gPSBtb2R1bGUuZXhwb3J0cy5pbnRlcnNlY3Rpb24gPSBsb2c0anMuZ2V0TG9nZ2VyKCdJbnRlcnNlY3Rpb24nKTtcbnZhciBKb2luID0gbW9kdWxlLmV4cG9ydHMuam9pbiA9IGxvZzRqcy5nZXRMb2dnZXIoJ0pvaW4nKTtcbnZhciBQcm9kdWN0ID0gbW9kdWxlLmV4cG9ydHMucHJvZHVjdCA9IGxvZzRqcy5nZXRMb2dnZXIoJ1Byb2R1Y3QnKTtcbnZhciBQcm9qZWN0aW9uID0gbW9kdWxlLmV4cG9ydHMucHJvamVjdGlvbiA9IGxvZzRqcy5nZXRMb2dnZXIoJ1Byb2plY3Rpb24nKTtcbnZhciBSZW5hbWUgPSBtb2R1bGUuZXhwb3J0cy5yZW5hbWUgPSBsb2c0anMuZ2V0TG9nZ2VyKCdSZW5hbWUnKTtcbnZhciBSZXN0cmljdGlvbiA9IG1vZHVsZS5leHBvcnRzLnJlc3RyaWN0aW9uID0gbG9nNGpzLmdldExvZ2dlcignUmVzdHJpY3Rpb24nKTtcbnZhciBTZW1pSm9pbiA9IG1vZHVsZS5leHBvcnRzLnNlbWlKb2luID0gbG9nNGpzLmdldExvZ2dlcignU2VtaUpvaW4nKTtcbnZhciBTZW1pRGlmZmVyZW5jZSA9IG1vZHVsZS5leHBvcnRzLnNlbWlEaWZmZXJlbmNlID0gbG9nNGpzLmdldExvZ2dlcignU2VtaURpZmZlcmVuY2UnKTtcbnZhciBVbmdyb3VwID0gbW9kdWxlLmV4cG9ydHMudW5ncm91cCA9IGxvZzRqcy5nZXRMb2dnZXIoJ1VuZ3JvdXAnKTtcbnZhciBVbmlvbiA9IG1vZHVsZS5leHBvcnRzLnVuaW9uID0gbG9nNGpzLmdldExvZ2dlcignVW5pb24nKTtcbnZhciBVbndyYXAgPSBtb2R1bGUuZXhwb3J0cy51bndyYXAgPSBsb2c0anMuZ2V0TG9nZ2VyKCdVbndyYXAnKTtcbnZhciBXcmFwID0gbW9kdWxlLmV4cG9ydHMud3JhcCA9IGxvZzRqcy5nZXRMb2dnZXIoJ1dyYXAnKTtcbnZhciBUYWJsZUR1bXAgPSBtb2R1bGUuZXhwb3J0cy5yZWxkdW1wID0gbG9nNGpzLmdldExvZ2dlcignVGFibGVEdW1wJyk7XG52YXIgVGVzdCA9IG1vZHVsZS5leHBvcnRzLnRlc3QgPSBsb2c0anMuZ2V0TG9nZ2VyKCdUZXN0Jyk7XG5cbnZhciBJbmRleCA9IG1vZHVsZS5leHBvcnRzLmluZGV4ID0gbG9nNGpzLmdldExvZ2dlcignSW5kZXgnKTtcbnZhciBLZXkgPSBtb2R1bGUuZXhwb3J0cy5rZXkgPSBsb2c0anMuZ2V0TG9nZ2VyKCdLZXknKTtcbnZhciBGb3JlaWduS2V5ID0gbW9kdWxlLmV4cG9ydHMuZm9yZWlnbktleSA9IGxvZzRqcy5nZXRMb2dnZXIoJ0ZvcmVpZ25LZXknKTtcblxuXG52YXIgQ2xvbmUgPSBtb2R1bGUuZXhwb3J0cy5jbG9uZSA9IGxvZzRqcy5nZXRMb2dnZXIoJ0Nsb25lJyk7XG52YXIgVHlwZSA9IG1vZHVsZS5leHBvcnRzLnR5cGUgPSBsb2c0anMuZ2V0TG9nZ2VyKCdUeXBlJyk7XG52YXIgQ29lcmNlID0gbW9kdWxlLmV4cG9ydHMuY29lcmNlID0gbG9nNGpzLmdldExvZ2dlcignQ29lcmNlJyk7XG52YXIgQ29tcGFyZSA9IG1vZHVsZS5leHBvcnRzLmNvbXBhcmUgPSBsb2c0anMuZ2V0TG9nZ2VyKCdDb21wYXJlJyk7XG52YXIgVmFsdWUgPSBtb2R1bGUuZXhwb3J0cy52YWx1ZSA9IGxvZzRqcy5nZXRMb2dnZXIoJ1ZhbHVlJyk7XG52YXIgRXF1YWwgPSBtb2R1bGUuZXhwb3J0cy5lcXVhbCA9IGxvZzRqcy5nZXRMb2dnZXIoJ0VxdWFsJyk7XG5cblxuIiwidmFyIHZhbHVlID0gcmVxdWlyZSgnLi92YWx1ZScpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vRnVuY3Rpb24nKTtcbnZhciBUeXBlID0gcmVxdWlyZSgnLi8uLi9UeXBlJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5cbnZhciBlcXVhbCA9IGZ1bmN0aW9uICh0eXBlLCB2YWx1ZTEsIHZhbHVlMikge1xuXG4gICAgZGVidWcuZXF1YWwudHJhY2UoJyNlcXVhbCcpO1xuXG4gICAgLy8gR2V0IHRoZSBmdW5jdGlvbiByZXR1cm4gdmFsdWVzIGlmIGFwcGxpY2FibGVcblxuICAgIHZhbHVlMSA9IHZhbHVlKHZhbHVlMSk7XG4gICAgdmFsdWUyID0gdmFsdWUodmFsdWUyKTtcblxuICAgIGlmKF8uaXNVbmRlZmluZWQodmFsdWUxKSAmJiBfLmlzVW5kZWZpbmVkKHZhbHVlMikpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKF8uaXNVbmRlZmluZWQodmFsdWUxKSB8fCBfLmlzVW5kZWZpbmVkKHZhbHVlMikpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChfLmlzTnVsbCh2YWx1ZTEpICYmIF8uaXNOdWxsKHZhbHVlMikpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKF8uaXNOdWxsKHZhbHVlMSkgfHwgXy5pc051bGwodmFsdWUyKSl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cblxuICAgIC8vIEFjY2VzcyB0aGUgdHlwZSdzIGVxdWFsIGZ1bmN0aW9uXG5cbiAgICBpZih2YWx1ZTEuY29uc3RydWN0b3IgJiYgdmFsdWUxLmNvbnN0cnVjdG9yLmVxdWFsKXtcbiAgICAgICAgcmV0dXJuIHZhbHVlMS5jb25zdHJ1Y3Rvci5lcXVhbCh2YWx1ZTEsIHZhbHVlMik7XG4gICAgfVxuXG4gICAgaWYodmFsdWUyLmNvbnN0cnVjdG9yICYmIHZhbHVlMi5jb25zdHJ1Y3Rvci5lcXVhbCl7XG4gICAgICAgIHJldHVybiB2YWx1ZTIuY29uc3RydWN0b3IuZXF1YWwodmFsdWUxLCB2YWx1ZTIpO1xuICAgIH1cblxuXG4gICAgLy8gRmFsbGJhY2sgb24gZ29vZCdvbCBsb2Rhc2hcblxuICAgIHJldHVybiBfLmlzRXF1YWwodmFsdWUxLCB2YWx1ZTIpO1xuXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWw7IiwidmFyIHZhbHVlID0gcmVxdWlyZSgnLi92YWx1ZScpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBGdW5jdGlvbiA9IHJlcXVpcmUoJy4vLi4vRnVuY3Rpb24nKTtcbnZhciBBdHRyaWJ1dGUgPSByZXF1aXJlKCcuLy4uL0F0dHJpYnV0ZScpO1xudmFyIFR5cGUgPSByZXF1aXJlKCcuLy4uL1R5cGUnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcblxudmFyIFRCb29sZWFuID0gcmVxdWlyZSgnLi8uLi90eXBlcy9Cb29sZWFuJyk7XG52YXIgVFN0cmluZyA9IHJlcXVpcmUoJy4vLi4vdHlwZXMvU3RyaW5nJyk7XG52YXIgVERhdGUgPSByZXF1aXJlKCcuLy4uL3R5cGVzL0RhdGUnKTtcbnZhciBUSW50ZWdlciA9IHJlcXVpcmUoJy4vLi4vdHlwZXMvSW50ZWdlcicpO1xudmFyIFROdW1lcmljID0gcmVxdWlyZSgnLi8uLi90eXBlcy9OdW1lcmljJyk7XG52YXIgVEZsb2F0ID0gcmVxdWlyZSgnLi8uLi90eXBlcy9GbG9hdCcpO1xuXG5cbnZhciB0eXBlID0gZnVuY3Rpb24odGhhbmcpe1xuXG4gICAgZGVidWcudHlwZS50cmFjZSgnI3R5cGUnKTtcblxuICAgIGlmKHRoYW5nIGluc3RhbmNlb2YgQXR0cmlidXRlKXtcbiAgICAgICAgcmV0dXJuIHRoYW5nLnR5cGU7XG4gICAgfVxuXG4gICAgaWYodGhhbmcgaW5zdGFuY2VvZiBUeXBlKXtcbiAgICAgICAgcmV0dXJuIHRoYW5nLmNvbnN0cnVjdG9yO1xuICAgIH1cblxuICAgIGlmKHRoYW5nIGluc3RhbmNlb2YgRnVuY3Rpb24pe1xuICAgICAgICByZXR1cm4gdGhhbmcudHlwZSgpO1xuICAgIH1cblxuICAgIGlmKF8uaXNCb29sZWFuKHRoYW5nKSl7XG4gICAgICAgIHJldHVybiBUQm9vbGVhbjtcbiAgICB9XG5cbiAgICBpZihfLmlzTnVtYmVyKHRoYW5nKSl7XG4gICAgICAgIHJldHVybiBUTnVtZXJpYztcbiAgICB9XG5cbiAgICBpZihfLmlzRGF0ZSh0aGFuZykpe1xuICAgICAgICByZXR1cm4gVERhdGU7XG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGU7XG5cbiIsIlxudmFyIGRlYnVnID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xudmFyIEZ1bmN0aW9uID0gcmVxdWlyZSgnLi8uLi9GdW5jdGlvbicpO1xuXG52YXIgdmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIGRlYnVnLnZhbHVlLnRyYWNlKCcjdmFsdWUnKTtcblxuICAgIGlmKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pe1xuXG4gICAgICAgIHZhbHVlID0gdmFsdWUudmFsdWUoKTtcblxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB2YWx1ZTsiLCIvKipcbiAqIEBjbGFzcyBNaXhpbnMuQ29tcGFyYWJsZVxuICovXG5cblxuLyoqXG4gKiBAbWVtYmVyIE1peGlucy5Db21wYXJhYmxlXG4gKi9cbm1vZHVsZS5leHBvcnRzLmVxdWFscyA9IGZ1bmN0aW9uIChhdHRyKSB7XG5cbiAgICB2YXIgRXF1YWwgPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9jb21wYXJhYmxlL0VxdWFsLmpzJyk7XG5cbiAgICBpZiAodGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUobmV3IEVxdWFsKHRoaXMsIGF0dHIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEVxdWFsKHRoaXMsIGF0dHIpO1xuXG59O1xuXG4vKipcbiAqIEBtZW1iZXIgTWl4aW5zLkNvbXBhcmFibGVcbiAqL1xubW9kdWxlLmV4cG9ydHMuZXEgPSBmdW5jdGlvbihhdHRyKXtcbiAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHMuZXF1YWxzLmNhbGwodGhpcywgYXR0cik7XG59OyIsIi8qKlxuICogQGNsYXNzIE1peGlucy5DaGFpbmFibGVcbiAqL1xuXG4vKipcbiAqIEBtZW1iZXIgTWl4aW5zLkNoYWluYWJsZVxuICovXG5tb2R1bGUuZXhwb3J0cy5hbmQgPSBmdW5jdGlvbiAocGFyYW0pIHtcblxuICAgIHZhciBBbmQgPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9jb25uZWN0aXZlL0FuZC5qcycpO1xuXG4gICAgaWYgKHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKG5ldyBBbmQodGhpcywgcGFyYW0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEFuZCh0aGlzLCBwYXJhbSk7XG5cbn07XG5cbi8qKlxuICogQG1lbWJlciBNaXhpbnMuQ2hhaW5hYmxlXG4gKi9cbm1vZHVsZS5leHBvcnRzLm9yID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIE9yID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvY29ubmVjdGl2ZS9Pci5qcycpO1xuXG4gICAgaWYgKHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKG5ldyBPcih0aGlzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBPcih0aGlzKTtcblxufTsiLCJtb2R1bGUuZXhwb3J0cy5kYXlPZk1vbnRoID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIERheU9mTW9udGggPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9kYXRlL0RheU9mTW9udGguanMnKTtcblxuICAgIGlmICh0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZShuZXcgRGF5T2ZNb250aCh0aGlzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEYXlPZk1vbnRoKHRoaXMpO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5kYXlPZldlZWsgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgRGF5T2ZXZWVrID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvZGF0ZS9EYXlPZldlZWsuanMnKTtcblxuICAgIGlmICh0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZShuZXcgRGF5T2ZXZWVrKHRoaXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IERheU9mV2Vlayh0aGlzKTtcblxufTtcblxubW9kdWxlLmV4cG9ydHMuZGF5T2ZZZWFyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIERheU9mWWVhciA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL2RhdGUvRGF5T2ZZZWFyLmpzJyk7XG5cbiAgICBpZiAodGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUobmV3IERheU9mWWVhcih0aGlzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEYXlPZlllYXIodGhpcyk7XG5cbn07XG5cblxubW9kdWxlLmV4cG9ydHMubW9udGggPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgTW9udGggPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9kYXRlL01vbnRoLmpzJyk7XG5cbiAgICBpZiAodGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUobmV3IE1vbnRoKHRoaXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE1vbnRoKHRoaXMpO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cy50cyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBUaW1lc3RhbXAgPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9kYXRlL1RpbWVzdGFtcC5qcycpO1xuXG4gICAgaWYgKHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKG5ldyBUaW1lc3RhbXAodGhpcykpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVGltZXN0YW1wKHRoaXMpO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cy53ZWVrT2ZZZWFyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIFdlZWtPZlllYXIgPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9kYXRlL1dlZWtPZlllYXIuanMnKTtcblxuICAgIGlmICh0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZShuZXcgV2Vla09mWWVhcih0aGlzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBXZWVrT2ZZZWFyKHRoaXMpO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cy55ZWFyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIFllYXIgPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9kYXRlL1llYXIuanMnKTtcblxuICAgIGlmICh0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZShuZXcgWWVhcih0aGlzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBZZWFyKHRoaXMpO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5ob3VycyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBIb3VycyA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL2RhdGUvSG91cnMuanMnKTtcblxuICAgIGlmICh0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZShuZXcgSG91cnModGhpcykpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSG91cnModGhpcyk7XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzLm1pbnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgTWludXRlcyA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL2RhdGUvTWludXRlcy5qcycpO1xuXG4gICAgaWYgKHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKG5ldyBNaW51dGVzKHRoaXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE1pbnV0ZXModGhpcyk7XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzLnNlY29uZHMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgU2Vjb25kcyA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL2RhdGUvU2Vjb25kcy5qcycpO1xuXG4gICAgaWYgKHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKG5ldyBTZWNvbmRzKHRoaXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFNlY29uZHModGhpcyk7XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzLm1pbGxpc2Vjb25kcyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBNaWxsaXNlY29uZHMgPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9kYXRlL01pbGxpc2Vjb25kcy5qcycpO1xuXG4gICAgaWYgKHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKG5ldyBNaWxsaXNlY29uZHModGhpcykpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgTWlsbGlzZWNvbmRzKHRoaXMpO1xuXG59OyIsIi8qKlxuICogQGNsYXNzIE1peGlucy5OZWdhdGFibGVcbiAqL1xuXG4vKipcbiAqIEBtZW1iZXIgTWl4aW5zLk5lZ2F0YWJsZVxuICovXG5tb2R1bGUuZXhwb3J0cy5ub3QgPSBmdW5jdGlvbiAoYXR0cikge1xuXG4gICAgdGhpcy5fbmVnYXRlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG5cbn07IiwibW9kdWxlLmV4cG9ydHMuYWJzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBBYnNvbHV0ZSA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL251bWVyaWMvQWJzb2x1dGUuanMnKTtcbiAgICBpZiAodGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUobmV3IEFic29sdXRlKHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBYnNvbHV0ZSh0aGlzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmNlaWwgPSBmdW5jdGlvbiAoYXR0cikge1xuICAgIHZhciBDZWlsID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvbnVtZXJpYy9DZWlsLmpzJyk7XG4gICAgaWYgKHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKG5ldyBDZWlsKHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDZWlsKHRoaXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuZmxvb3IgPSBmdW5jdGlvbiAoYXR0cikge1xuICAgIHZhciBGbG9vciA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL251bWVyaWMvRmxvb3IuanMnKTtcbiAgICBpZiAodGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUobmV3IENlaWwodGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEZsb29yKHRoaXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuY29zID0gZnVuY3Rpb24gKGF0dHIpIHtcbiAgICB2YXIgQ29zID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvbnVtZXJpYy9Db3NpbmUuanMnKTtcbiAgICBpZiAodGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUobmV3IENvcyh0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29zKHRoaXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuZGl2ID0gZnVuY3Rpb24gKGF0dHIpIHtcbiAgICB2YXIgRGl2aXNpb24gPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9udW1lcmljL0RpdmlzaW9uLmpzJyk7XG4gICAgaWYgKHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKG5ldyBEaXZpc2lvbih0aGlzLCBhdHRyKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGl2aXNpb24odGhpcywgYXR0cik7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLmV4cCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgRXhwID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvbnVtZXJpYy9FeHBvbmVudGlhbC5qcycpO1xuICAgIGlmICh0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZShuZXcgRXhwKHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFeHAodGhpcyk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLm1pbnVzID0gZnVuY3Rpb24gKGF0dHIpIHtcbiAgICB2YXIgTWludXMgPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9udW1lcmljL01pbnVzLmpzJyk7XG4gICAgaWYgKHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKG5ldyBNaW51cyh0aGlzLCBhdHRyKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTWludXModGhpcywgYXR0cik7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLm1vZCA9IGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgdmFyIE1vZHVsbyA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL251bWVyaWMvTW9kdWxvLmpzJyk7XG4gICAgaWYgKHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKG5ldyBNb2R1bG8odGhpcywgYXR0cikpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE1vZHVsbyh0aGlzLCBhdHRyKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMudGltZXMgPSBmdW5jdGlvbiAoYXR0cikge1xuICAgIHZhciBNdWx0aXBsaWNhdGlvbiA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL251bWVyaWMvTXVsdGlwbGljYXRpb24uanMnKTtcbiAgICBpZiAodGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUobmV3IE11bHRpcGxpY2F0aW9uKHRoaXMsIGF0dHIpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNdWx0aXBsaWNhdGlvbih0aGlzLCBhdHRyKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMucGx1cyA9IGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgdmFyIFBsdXMgPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9udW1lcmljL1BsdXMuanMnKTtcbiAgICBpZiAodGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUobmV3IFBsdXModGhpcywgYXR0cikpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFBsdXModGhpcywgYXR0cik7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLnBvdyA9IGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgdmFyIFBvdyA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL251bWVyaWMvUG93ZXIuanMnKTtcbiAgICBpZiAodGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUobmV3IFBvdyh0aGlzLCBhdHRyKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUG93KHRoaXMsIGF0dHIpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cy5yb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgUm91bmQgPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9udW1lcmljL1JvdW5kLmpzJyk7XG4gICAgaWYgKHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKG5ldyBSb3VuZCh0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUm91bmQodGhpcyk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLnNpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgU2luID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvbnVtZXJpYy9TaW5lLmpzJyk7XG4gICAgaWYgKHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKG5ldyBTaW4odGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFNpbih0aGlzKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMuc3FydCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgU3FydCA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL251bWVyaWMvU3F1YXJlUm9vdC5qcycpO1xuICAgIGlmICh0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZShuZXcgU3FydCh0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3FydCh0aGlzKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMudGFuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBUYW4gPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9udW1lcmljL1RhbmdlbnQuanMnKTtcbiAgICBpZiAodGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUobmV3IFRhbih0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGFuKHRoaXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuYXZnID0gZnVuY3Rpb24oKXtcblxuICAgIHZhciBBdmVyYWdlID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvYWdncmVnYXRlL0F2ZXJhZ2UuanMnKTtcbiAgICByZXR1cm4gbmV3IEF2ZXJhZ2UodGhpcyk7XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzLnN0YW5kYXJkRGV2aWF0aW9uID0gZnVuY3Rpb24oKXtcblxuICAgIHZhciBTdGFuZGFyZERldmlhdGlvbiA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL2FnZ3JlZ2F0ZS9TdGFuZGFyZERldmlhdGlvbi5qcycpO1xuICAgIHJldHVybiBuZXcgU3RhbmRhcmREZXZpYXRpb24odGhpcyk7XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzLnN1bSA9IGZ1bmN0aW9uKCl7XG5cbiAgICB2YXIgU3VtID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvYWdncmVnYXRlL1N1bS5qcycpO1xuICAgIHJldHVybiBuZXcgU3VtKHRoaXMpO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cy52YXJpYW5jZSA9IGZ1bmN0aW9uKCl7XG5cbiAgICB2YXIgVmFyaWFuY2UgPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9hZ2dyZWdhdGUvVmFyaWFuY2UuanMnKTtcbiAgICByZXR1cm4gbmV3IFZhcmlhbmNlKHRoaXMpO1xuXG59O1xuXG4iLCIvKipcbiAqIEBjbGFzcyBNaXhpbnMuU2l6ZUNvbXBhcmFibGVcbiAqL1xuXG4vKipcbiAqIEBtZW1iZXIgTWl4aW5zLlNpemVDb21wYXJhYmxlXG4gKi9cbm1vZHVsZS5leHBvcnRzLmd0ID0gZnVuY3Rpb24gKGF0dHIpIHtcbiAgICB2YXIgR3JlYXRlclRoYW4gPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9jb21wYXJhYmxlL0dyZWF0ZXJUaGFuLmpzJyk7XG4gICAgcmV0dXJuIG5ldyBHcmVhdGVyVGhhbih0aGlzLCBhdHRyKTtcbn07XG5cbi8qKlxuICogQG1lbWJlciBNaXhpbnMuU2l6ZUNvbXBhcmFibGVcbiAqL1xubW9kdWxlLmV4cG9ydHMuZ3RlID0gZnVuY3Rpb24gKGF0dHIpIHtcbiAgICB2YXIgR3JlYXRlclRoYW5FcXVhbCA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL2NvbXBhcmFibGUvR3JlYXRlclRoYW5FcXVhbC5qcycpO1xuICAgIHJldHVybiBuZXcgR3JlYXRlclRoYW5FcXVhbCh0aGlzLCBhdHRyKTtcbn07XG5cbi8qKlxuICogQG1lbWJlciBNaXhpbnMuU2l6ZUNvbXBhcmFibGVcbiAqL1xubW9kdWxlLmV4cG9ydHMuc3QgPSBmdW5jdGlvbiAoYXR0cikge1xuICAgIHZhciBTbWFsbGVyVGhhbiA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL2NvbXBhcmFibGUvU21hbGxlclRoYW4uanMnKTtcbiAgICByZXR1cm4gbmV3IFNtYWxsZXJUaGFuKHRoaXMsIGF0dHIpO1xufTtcblxuLyoqXG4gKiBAbWVtYmVyIE1peGlucy5TaXplQ29tcGFyYWJsZVxuICovXG5tb2R1bGUuZXhwb3J0cy5zdGUgPSBmdW5jdGlvbiAoYXR0cikge1xuICAgIHZhciBTbWFsbGVyVGhhbkVxdWFsID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvY29tcGFyYWJsZS9TbWFsbGVyVGhhbkVxdWFsLmpzJyk7XG4gICAgcmV0dXJuIG5ldyBTbWFsbGVyVGhhbkVxdWFsKHRoaXMsIGF0dHIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMubWF4ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgTWF4aW11bSA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL2FnZ3JlZ2F0ZS9NYXhpbXVtJyk7XG5cbiAgICByZXR1cm4gbmV3IE1heGltdW0odGhpcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5taW4gPSBmdW5jdGlvbigpe1xuICAgIHZhciBNaW5pbXVtID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvYWdncmVnYXRlL01pbmltdW0nKTtcblxuICAgIHJldHVybiBuZXcgTWluaW11bSh0aGlzKTtcbn07IiwiXG5cbm1vZHVsZS5leHBvcnRzLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgTGVuZ3RoID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvc3RyaW5nL0xlbmd0aC5qcycpO1xuICAgIGlmICh0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZShuZXcgTGVuZ3RoKHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMZW5ndGgodGhpcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5sb3dlcmNhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIExvd2VyY2FzZSA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL3N0cmluZy9Mb3dlcmNhc2UuanMnKTtcbiAgICBpZiAodGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUobmV3IExvd2VyY2FzZSh0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTG93ZXJjYXNlKHRoaXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMudGVzdCA9IGZ1bmN0aW9uIChyZWdleCkge1xuICAgIHZhciBUZXN0ID0gcmVxdWlyZSgnLi8uLi9mdW5jdGlvbnMvc3RyaW5nL1Rlc3QuanMnKTtcbiAgICBpZiAodGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUobmV3IFRlc3QodGhpcywgcmVnZXgpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXN0KHRoaXMsIHJlZ2V4KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnN1YnN0ciA9IGZ1bmN0aW9uIChpbmRleCwgbGVuKSB7XG4gICAgdmFyIFN1YnN0cmluZyA9IHJlcXVpcmUoJy4vLi4vZnVuY3Rpb25zL3N0cmluZy9TdWJzdHJpbmcuanMnKTtcbiAgICBpZiAodGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja05lZ2F0ZWRBdHRyaWJ1dGUobmV3IFN1YnN0cmluZyh0aGlzLCBpbmRleCwgbGVuKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3Vic3RyaW5nKHRoaXMsIGluZGV4LCBsZW4pO1xufTtcblxubW9kdWxlLmV4cG9ydHMudXBwZXJjYXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBVcHBlcmNhc2UgPSByZXF1aXJlKCcuLy4uL2Z1bmN0aW9ucy9zdHJpbmcvVXBwZXJjYXNlLmpzJyk7XG4gICAgaWYgKHRoaXMuX2NoZWNrTmVnYXRlZEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tOZWdhdGVkQXR0cmlidXRlKG5ldyBVcHBlcmNhc2UodGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVwcGVyY2FzZSh0aGlzKTtcbn07IiwidmFyIFR5cGUgPSByZXF1aXJlKCcuLy4uL1R5cGUnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbnZhciBUQm9vbGVhbiA9IFR5cGUuZXh0ZW5kKC8qKlxuICogQGNsYXNzIFR5cGVzLkJvb2xlYW5cbiAqIEBleHRlbmRzIFR5cGVcbiAqXG4gKiBSZXByZXNlbnRzIGEgQm9vbGVhbiBUeXBlXG4gKlxuICogVGhpcyBjbGFzcyBzaG91bGQgbm90IGJlIGluc3RhbnRpYXRlZC4gSXQgaXMgb25seSB1c2VkIHRvIGRlZmluZVxuICogcmVsYXRpb24gaGVhZGVyIGF0dHJpYnV0ZSB0eXBlcyBvciBmdW5jdGlvbiByZXR1cm4gdHlwZXMuXG4gKlxuICove1xuXG5cblxufSwge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtib29sZWFufFR5cGVzLkJvb2xlYW59IGJvb2xlYW4xXG4gICAgICogQHBhcmFtIHtib29sZWFufFR5cGVzLkJvb2xlYW59IGJvb2xlYW4yXG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqXG4gICAgICogTWV0aG9kIHRvIGNoZWNrIGlmIHR3byBib29sZWFuIG9iamVjdCBhcmUgZXF1YWxcbiAgICAgKlxuICAgICAqL1xuICAgIGVxdWFsOiBmdW5jdGlvbiAoYm9vbGVhbjEsIGJvb2xlYW4yKSB7XG5cbiAgICAgICAgcmV0dXJuIGJvb2xlYW4xID09PSBib29sZWFuMjtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YXJpYWJsZSB0byBjb2VyY2UgdG8gQm9vbGVhbiB0eXBlXG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGNvZXJjZSA6IGZ1bmN0aW9uKHZhbHVlKXtcblxuICAgICAgICB2YXIgbG93ZXJDYXNlVmFsdWU7XG5cbiAgICAgICAgaWYoXy5pc0Jvb2xlYW4odmFsdWUpKXtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMCl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDEpe1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pc1N0cmluZyh2YWx1ZSkpe1xuXG4gICAgICAgICAgICBsb3dlckNhc2VWYWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIGlmKGxvd2VyQ2FzZVZhbHVlID09PSAndHJ1ZScgfHwgbG93ZXJDYXNlVmFsdWUgPT09ICd0Jyl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYobG93ZXJDYXNlVmFsdWUgPT09ICdmYWxzZScgfHwgbG93ZXJDYXNlVmFsdWUgPT09ICdmJyl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKlxuICAgICAqIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQm9vbGVhbiB0eXBlXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdCb29sZWFuJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJvb2xlYW5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIGJvb2xlYW5cbiAgICAgKi9cbiAgICB2YWx1ZSA6IGZ1bmN0aW9uKGJvb2xlYW4pe1xuXG4gICAgICAgIHJldHVybiBib29sZWFuO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1peGlucyBmb3IgQm9vbGVhbnNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgcGF5bG9hZCA6IFtcbiAgICAgICAgcmVxdWlyZSgnLi8uLi9taXhpbnMvY29tcGFyYWJsZScpLFxuICAgICAgICByZXF1aXJlKCcuLy4uL21peGlucy9jb25uZWN0YWJsZScpLFxuICAgICAgICByZXF1aXJlKCcuLy4uL21peGlucy9ub3QnKVxuICAgIF0sXG5cbiAgICB0eXBlIDogJ0Jvb2xlYW4nXG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRCb29sZWFuO1xuXG4iLCJ2YXIgT2JqZWN0ID0gcmVxdWlyZSgnLi9PYmplY3QnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbnZhciBEYXRlID0gT2JqZWN0LmV4dGVuZCh7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgVHlwZXMuRGF0ZVxuICAgICAqIEBleHRlbmRzIFR5cGVcbiAgICAgKlxuICAgICAqIFJlcHJlc2VudHMgYSBEYXRlIHR5cGUuXG4gICAgICpcbiAgICAgKiBTaG91bGQgbm90IGJlIGluc3RhbnRpYXRlZC4gT25seSB1c2VkIHRvIHJlcHJlc2VudFxuICAgICAqIHJlbGF0aW9uIGhlYWRlciBhdHRyaWJ1dGUgdHlwZXMgb3IgZnVuY3Rpb24gcmV0dXJuIHR5cGVzLlxuICAgICAqL1xuXG59LCB7XG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgbWV0aG9kIGZvciBEYXRlcy5cbiAgICAgKiBAcGFyYW0ge0RhdGV8VHlwZXMuRGF0ZX0gZGF0ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSA6IGZ1bmN0aW9uKGRhdGUpe1xuXG4gICAgICAgIHJldHVybiBkYXRlLmdldFRpbWUoKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb2VyY2VzIGFuIGFyYml0cmFyeSBvYmplY3QgaW50byBhIGRhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8RGF0ZXxUeXBlcy5EYXRlfSB2YWx1ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJucyB7RGF0ZX1cbiAgICAgKi9cbiAgICBjb2VyY2UgOiBmdW5jdGlvbih2YWx1ZSl7XG5cbiAgICAgICAgaWYoXy5pc1N0cmluZyh2YWx1ZSkpe1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChfLmlzTnVtYmVyKHZhbHVlKSl7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIHJlc3VsdC5zZXRUaW1lKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSBpZihfLmlzRGF0ZSh2YWx1ZSkpe1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdHdvIGRhdGVzIGFyZSBlcXVhbFxuICAgICAqIEBwYXJhbSB7RGF0ZXxUeXBlcy5EYXRlfSBkYXRlMVxuICAgICAqIEBwYXJhbSB7RGF0ZXxUeXBlcy5EYXRlfSBkYXRlMlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBlcXVhbDogZnVuY3Rpb24gKGRhdGUxLCBkYXRlMikge1xuXG4gICAgICAgIHJldHVybiBkYXRlMSA9PT0gZGF0ZTI7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBEYXRlIHR5cGVcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ0RhdGUnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZhbHVlIG9mIGEgZGF0ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0gZGF0ZVxuICAgICAqIEByZXR1cm5zIHtEYXRlfVxuICAgICAqL1xuICAgIHZhbHVlIDogZnVuY3Rpb24oZGF0ZSl7XG5cbiAgICAgICAgcmV0dXJuIGRhdGU7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWl4aW5zIGZvciBkYXRlc1xuICAgICAqL1xuICAgIHBheWxvYWQgOiBbXG4gICAgICAgIHJlcXVpcmUoJy4vLi4vbWl4aW5zL2NvbXBhcmFibGUnKSxcbiAgICAgICAgcmVxdWlyZSgnLi8uLi9taXhpbnMvc2l6ZS1jb21wYXJhYmxlJyksXG4gICAgICAgIHJlcXVpcmUoJy4vLi4vbWl4aW5zL25vdCcpLFxuICAgICAgICByZXF1aXJlKCcuLy4uL21peGlucy9kYXRlJylcbiAgICBdLFxuXG4gICAgdHlwZSA6ICdEYXRlJ1xuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRlO1xuXG4iLCJ2YXIgTnVtZXJpYyA9IHJlcXVpcmUoJy4vTnVtZXJpYy5qcycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxudmFyIEZsb2F0ID0gTnVtZXJpYy5leHRlbmQoe1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIFR5cGVzLkZsb2F0XG4gICAgICogQGV4dGVuZHMgVHlwZXMuTnVtZXJpY1xuICAgICAqXG4gICAgICogUmVwcmVzZW50cyBhIEZsb2F0IHR5cGUuXG4gICAgICpcbiAgICAgKiBUaGlzIGNsYXNzIHNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkLiBJdCBpcyBvbmx5IHVzZWRcbiAgICAgKiB0byByZXByZXNlbnQgcmVsYXRpb24gaGVhZGVyIGF0dHJpYnV0ZSB0eXBlcyBvciBmdW5jdGlvbiByZXR1cm4gdHlwZXMuXG4gICAgICovXG5cbn0sIHtcblxuICAgIC8qKlxuICAgICAqIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgRmxvYXQgdHlwZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnRmxvYXQnXG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQ29lcmNlcyBhbiBhcmJpdHJhcnkgdmFsdWUgdG8gRmxvYXQgdHlwZVxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgY29lcmNlIDogZnVuY3Rpb24odmFsdWUpe1xuXG4gICAgICAgIGlmIChfLmlzTnVtYmVyKHZhbHVlKSB8fCBfLmlzU3RyaW5nKHZhbHVlKSl7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBwcmltaXRpdmUgOiB0cnVlLFxuXG4gICAgdHlwZSA6ICdGbG9hdCdcblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmxvYXQ7XG5cbiIsInZhciBUTnVtZXJpYyA9IHJlcXVpcmUoJy4vTnVtZXJpYy5qcycpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxudmFyIEludGVnZXIgPSBUTnVtZXJpYy5leHRlbmQoe1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIFR5cGVzLkludGVnZXJcbiAgICAgKiBAZXh0ZW5kcyBUeXBlcy5OdW1lcmljXG4gICAgICpcbiAgICAgKiBSZXByZXNlbnRzIGFuIEludGVnZXIgdHlwZS5cbiAgICAgKlxuICAgICAqIFRoaXMgY2xhc3Mgc2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQuIEl0IGlzIG9ubHkgdXNlZFxuICAgICAqIHRvIHJlcHJlc2VudCByZWxhdGlvbiBoZWFkZXIgYXR0cmlidXRlIHR5cGVzIG9yIGZ1bmN0aW9uIHJldHVybiB0eXBlcy5cbiAgICAgKi9cblxufSwge1xuXG4gICAgLyoqXG4gICAgICogQ29lcmNlcyBhbiBhcmJpdHJhcnkgdmFsdWUgdG8gSW50ZWdlciB0eXBlXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBjb2VyY2UgOiBmdW5jdGlvbih2YWx1ZSl7XG5cbiAgICAgICAgaWYgKF8uaXNOdW1iZXIodmFsdWUpIHx8IF8uaXNTdHJpbmcodmFsdWUpKXtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIEludGVnZXIgVHlwZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdJbnRlZ2VyJ1xuICAgIH0sXG5cbiAgICBwcmltaXRpdmUgOiB0cnVlLFxuXG4gICAgdHlwZSA6ICdJbnRlZ2VyJ1xuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlZ2VyO1xuXG4iLCJ2YXIgVHlwZSA9IHJlcXVpcmUoJy4vLi4vVHlwZScpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxudmFyIE51bWVyaWMgPSBUeXBlLmV4dGVuZCh7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgVHlwZXMuTnVtZXJpY1xuICAgICAqXG4gICAgICogUmVwcmVzZW50cyBhIE51bWVyaWMgdHlwZS5cbiAgICAgKlxuICAgICAqIFRoaXMgY2xhc3Mgc2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQuIEl0IGlzIG9ubHkgdXNlZFxuICAgICAqIHRvIHJlcHJlc2VudCByZWxhdGlvbiBoZWFkZXIgYXR0cmlidXRlIHR5cGVzIG9yIGZ1bmN0aW9uIHJldHVybiB0eXBlcy5cbiAgICAgKi9cblxufSwge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICpcbiAgICAgKiBDb2VyY2VzIGFuIGFyYml0cmFyeSB2YWx1ZSB0byB0eXBlIGZsb2F0XG4gICAgICpcbiAgICAgKi9cbiAgICBjb2VyY2UgOiBmdW5jdGlvbih2YWx1ZSl7XG5cbiAgICAgICAgaWYoXy5pc051bWJlcih2YWx1ZSkpe1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcodmFsdWUpKXtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1peGlucyBmb3IgTnVtZXJpYyB0eXBlc1xuICAgICAqL1xuICAgIHBheWxvYWQgOiBbXG4gICAgICAgIHJlcXVpcmUoJy4vLi4vbWl4aW5zL2NvbXBhcmFibGUnKSxcbiAgICAgICAgcmVxdWlyZSgnLi8uLi9taXhpbnMvc2l6ZS1jb21wYXJhYmxlJyksXG4gICAgICAgIHJlcXVpcmUoJy4vLi4vbWl4aW5zL251bWVyaWMnKSxcbiAgICAgICAgcmVxdWlyZSgnLi8uLi9taXhpbnMvY29ubmVjdGFibGUnKSxcbiAgICAgICAgcmVxdWlyZSgnLi8uLi9taXhpbnMvbm90JylcbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIE51bWVyaWMgb2JqZWN0XG4gICAgICogQHBhcmFtIG51bWVyaWNcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICB2YWx1ZSA6IGZ1bmN0aW9uKG51bWVyaWMpe1xuXG4gICAgICAgIHJldHVybiBudW1lcmljO1xuXG4gICAgfSxcblxuICAgIGVxdWFsOiBmdW5jdGlvbiAobnVtZXJpYzEsIG51bWVyaWMyKSB7XG5cbiAgICAgICAgcmV0dXJuIChudW1lcmljMSA9PT0gbnVtZXJpYzIpO1xuXG4gICAgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTnVtZXJpYydcbiAgICB9LFxuXG4gICAgcHJpbWl0aXZlIDogdHJ1ZSxcblxuICAgIHR5cGUgOiAnTnVtZXJpYydcblxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBOdW1lcmljO1xuXG4iLCJ2YXIgVHlwZSA9IHJlcXVpcmUoJy4vLi4vVHlwZScpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxudmFyIFRPYmplY3QgPSBUeXBlLmV4dGVuZCh7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgVHlwZXMuT2JqZWN0XG4gICAgICogQGV4dGVuZHMgVHlwZVxuICAgICAqXG4gICAgICogUmVwcmVzZW50cyBhbiBPYmplY3QgVHlwZS5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IE9iamVjdCBpbnN0YW5jZXNcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICAgICAgVHlwZS5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcblxuICAgICAgICBpZihfLmlzT2JqZWN0KHZhbHVlKSl7XG4gICAgICAgICAgICBfLmV4dGVuZCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5hbWUgPSAnT2JqZWN0JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIE9iamVjdCB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICByZXR1cm4gJ09iamVjdCc7XG5cbiAgICB9XG5cbn0sIHtcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBjb2VyY2UgYW4gYXJiaXRyYXJ5IHZhbHVlIGludG8gYW4gT2JqZWN0IGluc3RhbmNlXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBjb2VyY2UgOiBmdW5jdGlvbih2YWx1ZSl7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1peGlucyBmb3IgT2JqZWN0IHR5cGVcbiAgICAgKi9cbiAgICBwYXlsb2FkIDogW1xuICAgICAgICByZXF1aXJlKCcuLy4uL21peGlucy9jb21wYXJhYmxlJyksXG4gICAgICAgIHJlcXVpcmUoJy4vLi4vbWl4aW5zL2Nvbm5lY3RhYmxlJyksXG4gICAgICAgIHJlcXVpcmUoJy4vLi4vbWl4aW5zL25vdCcpXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0gb2JqZWN0XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgdmFsdWUgOiBmdW5jdGlvbihvYmplY3Qpe1xuXG4gICAgICAgIHJldHVybiBvYmplY3Q7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGVzdHMgZm9yIGVxdWFsaXR5IGJldHdlZW4gdHdvIG9iamVjdHNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIG9iamVjdDFcbiAgICAgKiBAcGFyYW0gb2JqZWN0MlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGVxdWFsOiBmdW5jdGlvbiAob2JqZWN0MSwgb2JqZWN0Mikge1xuXG4gICAgICAgIHJldHVybiBfLmlzRXF1YWwob2JqZWN0MSwgb2JqZWN0Mik7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9iamVjdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgcmV0dXJuICdPYmplY3QnXG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IGlzIG5vdCBhIHByaW1pdGl2ZSB0eXBlXG4gICAgICovXG4gICAgcHJpbWl0aXZlIDogZmFsc2UsXG5cbiAgICB0eXBlIDogJ09iamVjdCdcblxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBUT2JqZWN0O1xuXG4iLCJ2YXIgVHlwZSA9IHJlcXVpcmUoJy4vLi4vVHlwZScpO1xudmFyIFRCb29sZWFuID0gcmVxdWlyZSgnLi9Cb29sZWFuJyk7XG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG52YXIgU3RyaW5nID0gVHlwZS5leHRlbmQoe1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzIFR5cGVzLlN0cmluZ1xuICAgICAqIEBleHRlbmRzIFR5cGVcbiAgICAgKlxuICAgICAqIFJlcHJlc2VudHMgYSBTdHJpbmcgQXR0cmlidXRlIFR5cGUuXG4gICAgICpcbiAgICAgKiBTaG91bGQgbm90IGJlIGluc3RhbnRpYXRlZC4gSXQgaXMgb25seVxuICAgICAqIHVzZWQgdG8gcmVwcmVzZW50IHJlbGF0aW9uIGhlYWRlciBhdHRyaWJ1dGUgdHlwZXMgb3IgZnVuY3Rpb24gcmV0dXJuIHR5cGVzLlxuICAgICAqXG4gICAgICovXG5cbn0sIHtcblxuICAgIGNvZXJjZSA6IGZ1bmN0aW9uKHZhbHVlKXtcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWl4aW5zIGZvciBTdHJpbmcgdHlwZXNcbiAgICAgKi9cbiAgICBwYXlsb2FkIDogW1xuICAgICAgICByZXF1aXJlKCcuLy4uL21peGlucy9jb21wYXJhYmxlJyksXG4gICAgICAgIHJlcXVpcmUoJy4vLi4vbWl4aW5zL3NpemUtY29tcGFyYWJsZScpLFxuICAgICAgICByZXF1aXJlKCcuLy4uL21peGlucy9jb25uZWN0YWJsZScpLFxuICAgICAgICByZXF1aXJlKCcuLy4uL21peGlucy9ub3QnKSxcbiAgICAgICAgcmVxdWlyZSgnLi8uLi9taXhpbnMvc3RyaW5nJyksXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBmb3IgZXF1YWxpdHkgYmV0d2VlbiB0d28gc3RyaW5nc1xuICAgICAqIEBwYXJhbSBzdHIxXG4gICAgICogQHBhcmFtIHN0cjJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBlcXVhbDogZnVuY3Rpb24gKHN0cjEsIHN0cjIpIHtcblxuICAgICAgICByZXR1cm4gc3RyMiA9PT0gc3RyMTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBTdHJpbmcgVHlwZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdTdHJpbmcnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0cmluZyBpcyBhIHByaW1pdGl2ZVxuICAgICAqL1xuICAgIHByaW1pdGl2ZSA6IHRydWUsXG5cbiAgICB0eXBlIDogJ1RTdHJpbmcnXG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmluZztcblxuIiwidmFyIFR5cGUgPSByZXF1aXJlKCcuLy4uL1R5cGUnKTtcbnZhciBUQm9vbGVhbiA9IHJlcXVpcmUoJy4vQm9vbGVhbicpO1xuXG52YXIgVFR5cGUgPSBUeXBlLmV4dGVuZCh7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgVHlwZXMuVHlwZVxuICAgICAqIEBleHRlbmRzIFR5cGVcbiAgICAgKlxuICAgICAqIFJlcHJlc2VudHMgYSBUeXBlIEF0dHJpYnV0ZSB0eXBlLlxuICAgICAqXG4gICAgICogU2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQuIEl0IGlzIG9ubHlcbiAgICAgKiB1c2VkIHRvIHJlcHJlc2VudCByZWxhdGlvbiBoZWFkZXIgYXR0cmlidXRlIHR5cGVzIG9yIGZ1bmN0aW9uIHJldHVybiB0eXBlcy5cbiAgICAgKlxuICAgICAqL1xuXG59LCB7XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0d28gVHlwZXMgYXJlIGVxdWFsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHlwZTFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0eXBlMlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGVxdWFsOiBmdW5jdGlvbiAodHlwZTEsIHR5cGUyKSB7XG5cbiAgICAgICAgcmV0dXJuICh0eXBlMSA9PT0gdHlwZTIpO1xuXG4gICAgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnVHlwZSdcbiAgICB9LFxuXG4gICAgdHlwZSA6ICdUeXBlJ1xuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUVHlwZTtcblxuIiwiLyoqXG4gKiBAY2xhc3MgQWZmaW5pdHlcbiAqIEB0eXBlIHtPYmplY3R9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG52YXIgYWZmaW5pdHkgPSB7fTtcblxuLy9yZWdpb24gVHlwZXNcblxuLyoqXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKiBAdHlwZSB7SW5kZXh9XG4gKi9cbmFmZmluaXR5LkluZGV4ID0gcmVxdWlyZSgnLi9hZmZpbml0eS9JbmRleC5qcycpO1xuXG4vKipcbiAqIEB0eXBlIHtUeXBlcy5UeXBlfSAgXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LlR5cGUgPSByZXF1aXJlKCcuL2FmZmluaXR5L3R5cGVzL1R5cGUuanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7U2V0fSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuU2V0ID0gcmVxdWlyZSgnLi9hZmZpbml0eS9TZXQuanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7UmVsYXRpb259IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5SZWxhdGlvbiA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvUmVsYXRpb24uanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7VHVwbGV9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5UdXBsZSA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvVHVwbGUuanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7SGVhZGVyfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuSGVhZGVyID0gcmVxdWlyZSgnLi9hZmZpbml0eS9IZWFkZXIuanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7QXR0cmlidXRlfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuQXR0cmlidXRlID0gcmVxdWlyZSgnLi9hZmZpbml0eS9BdHRyaWJ1dGUuanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7VHlwZXMuT2JqZWN0fSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuT2JqZWN0ID0gcmVxdWlyZSgnLi9hZmZpbml0eS90eXBlcy9PYmplY3QnKTtcblxuLyoqXG4gKiBAdHlwZSB7VHlwZXMuSW50ZWdlcn0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LkludGVnZXIgPSByZXF1aXJlKCcuL2FmZmluaXR5L3R5cGVzL0ludGVnZXInKTtcblxuLyoqXG4gKiBAdHlwZSB7VHlwZXMuRmxvYXR9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5GbG9hdCA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvdHlwZXMvRmxvYXQnKTtcblxuLyoqXG4gKiBAdHlwZSB7VHlwZXMuU3RyaW5nfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuU3RyaW5nID0gcmVxdWlyZSgnLi9hZmZpbml0eS90eXBlcy9TdHJpbmcnKTtcblxuLyoqXG4gKiBAdHlwZSB7VHlwZXMuQm9vbGVhbn0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LkJvb2xlYW4gPSByZXF1aXJlKCcuL2FmZmluaXR5L3R5cGVzL0Jvb2xlYW4nKTtcblxuLyoqXG4gKiBAdHlwZSB7VHlwZXMuRGF0ZX0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LkRhdGUgPSByZXF1aXJlKCcuL2FmZmluaXR5L3R5cGVzL0RhdGUnKTtcbi8vZW5kcmVnaW9uXG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ufSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuRnVuY3Rpb24gPSByZXF1aXJlKCcuL2FmZmluaXR5L0Z1bmN0aW9uLmpzJyk7XG5cbi8vcmVnaW9uIENvbm5lY3RpdmUgRnVuY3Rpb25zXG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5Db25uZWN0aXZlLkFuZH0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LkFuZCA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL2Nvbm5lY3RpdmUvQW5kLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5Db25uZWN0aXZlLk9yfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuT3IgPSByZXF1aXJlKCcuL2FmZmluaXR5L2Z1bmN0aW9ucy9jb25uZWN0aXZlL09yLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5Db25uZWN0aXZlLk5vdH0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5Lk5vdCA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL2Nvbm5lY3RpdmUvTm90LmpzJyk7XG4vL2VuZHJlZ2lvblxuXG4vL3JlZ2lvbiBDb21wYXJhdGl2ZSBGdW5jdGlvbnNcblxuLyoqXG4gKiBAdHlwZSB7RnVuY3Rpb25zLkNvbXBhcmFibGUuRXF1YWx9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5FcXVhbCA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL2NvbXBhcmFibGUvRXF1YWwuanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7RnVuY3Rpb25zLkNvbXBhcmFibGUuRXF1YWx9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5lcSA9IGZ1bmN0aW9uKGF0dHIxLCBhdHRyMil7XG4gICAgcmV0dXJuIG5ldyBhZmZpbml0eS5FcXVhbChhdHRyMSwgYXR0cjIpO1xufTtcblxuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuQ29tcGFyYWJsZS5HcmVhdGVyVGhhbn0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LkdyZWF0ZXJUaGFuID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvY29tcGFyYWJsZS9HcmVhdGVyVGhhbi5qcycpO1xuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuQ29tcGFyYWJsZS5HcmVhdGVyVGhhbn0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5Lmd0ID0gZnVuY3Rpb24oYXR0cjEsIGF0dHIyKXtcbiAgICByZXR1cm4gbmV3IGFmZmluaXR5LkdyZWF0ZXJUaGFuKGF0dHIxLCBhdHRyMik7XG59O1xuXG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5Db21wYXJhYmxlLkdyZWF0ZXJUaGFuRXF1YWx9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5HcmVhdGVyVGhhbkVxdWFsID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvY29tcGFyYWJsZS9HcmVhdGVyVGhhbkVxdWFsLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5Db21wYXJhYmxlLkdyZWF0ZXJUaGFuRXF1YWx9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5ndGUgPSBmdW5jdGlvbihhdHRyMSwgYXR0cjIpe1xuICAgIHJldHVybiBuZXcgYWZmaW5pdHkuR3JlYXRlclRoYW5FcXVhbChhdHRyMSwgYXR0cjIpO1xufTtcblxuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuQ29tcGFyYWJsZS5TbWFsbGVyVGhhbn0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LlNtYWxsZXJUaGFuID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvY29tcGFyYWJsZS9TbWFsbGVyVGhhbi5qcycpO1xuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuQ29tcGFyYWJsZS5TbWFsbGVyVGhhbn0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LnN0ID0gZnVuY3Rpb24oYXR0cjEsIGF0dHIyKXtcbiAgICByZXR1cm4gbmV3IGFmZmluaXR5LlNtYWxsZXJUaGFuKGF0dHIxLCBhdHRyMik7XG59O1xuXG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5Db21wYXJhYmxlLlNtYWxsZXJUaGFuRXF1YWx9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5TbWFsbGVyVGhhbkVxdWFsID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvY29tcGFyYWJsZS9TbWFsbGVyVGhhbkVxdWFsLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5Db21wYXJhYmxlLlNtYWxsZXJUaGFuRXF1YWx9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5zdGUgPSBmdW5jdGlvbihhdHRyMSwgYXR0cjIpe1xuICAgIHJldHVybiBuZXcgYWZmaW5pdHkuU21hbGxlclRoYW5FcXVhbChhdHRyMSwgYXR0cjIpO1xufTtcblxuLy9lbmRyZWdpb25cblxuLy9yZWdpb24gTnVtZXJpYyBGdW5jdGlvbnNcblxuLyoqXG4gKiBAdHlwZSB7RnVuY3Rpb25zLk51bWVyaWMuQWJzb2x1dGV9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5BYnNvbHV0ZSA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL251bWVyaWMvQWJzb2x1dGUuanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7RnVuY3Rpb25zLk51bWVyaWMuQ2VpbH0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LkNlaWwgPSByZXF1aXJlKCcuL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL0NlaWwuanMnKTtcbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5OdW1lcmljLkNvc2luZX0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LkNvc2luZSA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL251bWVyaWMvQ29zaW5lLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5OdW1lcmljLkRpdmlzaW9ufSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuRGl2aXNpb24gPSByZXF1aXJlKCcuL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL0RpdmlzaW9uLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5OdW1lcmljLkV4cG9uZW50aWFsfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuRXhwb25lbnRpYWwgPSByZXF1aXJlKCcuL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL0V4cG9uZW50aWFsLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5OdW1lcmljLkZsb29yfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuRmxvb3IgPSByZXF1aXJlKCcuL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL0Zsb29yLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5OdW1lcmljLk1pbnVzfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuTWludXMgPSByZXF1aXJlKCcuL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL01pbnVzLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5OdW1lcmljLk1vZHVsb30gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5Lk1vZHVsbyA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL251bWVyaWMvTW9kdWxvLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5OdW1lcmljLk11bHRpcGxpY2F0aW9ufSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuTXVsdGlwbGljYXRpb24gPSByZXF1aXJlKCcuL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL011bHRpcGxpY2F0aW9uLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5OdW1lcmljLlBsdXN9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5QbHVzID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvbnVtZXJpYy9QbHVzLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5OdW1lcmljLlBvd2VyfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuUG93ZXIgPSByZXF1aXJlKCcuL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL1Bvd2VyLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5OdW1lcmljLlJvdW5kfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuUm91bmQgPSByZXF1aXJlKCcuL2FmZmluaXR5L2Z1bmN0aW9ucy9udW1lcmljL1JvdW5kLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5OdW1lcmljLlNpbmV9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5TaW5lID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvbnVtZXJpYy9TaW5lLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5OdW1lcmljLlNxdWFyZVJvb3R9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5TcXVhcmVSb290ID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvbnVtZXJpYy9TcXVhcmVSb290LmpzJyk7XG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5OdW1lcmljLlRhbmdlbnR9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5UYW5nZW50ID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvbnVtZXJpYy9UYW5nZW50LmpzJyk7XG5cbi8qKlxuICogQHBhcmFtIGF0dHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnMuTnVtZXJpYy5BYnNvbHV0ZX1cbiAqL1xuYWZmaW5pdHkuYWJzID0gZnVuY3Rpb24oYXR0cil7XG4gICAgcmV0dXJuIG5ldyBhZmZpbml0eS5BYnNvbHV0ZShhdHRyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIGF0dHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnMuTnVtZXJpYy5DZWlsfVxuICovXG5hZmZpbml0eS5jZWlsID0gZnVuY3Rpb24oYXR0cil7XG4gICAgcmV0dXJuIG5ldyBhZmZpbml0eS5DZWlsKGF0dHIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gYXR0clxuICogQHJldHVybnMge0Z1bmN0aW9ucy5OdW1lcmljLkZsb29yfVxuICovXG5hZmZpbml0eS5mbG9vciA9IGZ1bmN0aW9uKGF0dHIpe1xuICAgIHJldHVybiBuZXcgYWZmaW5pdHkuRmxvb3IoYXR0cik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSBhdHRyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb25zLk51bWVyaWMuQ29zaW5lfVxuICovXG5hZmZpbml0eS5jb3MgPSBmdW5jdGlvbihhdHRyKXtcbiAgICByZXR1cm4gbmV3IGFmZmluaXR5LkNvc2luZShhdHRyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIGF0dHIxXG4gKiBAcGFyYW0gYXR0cjJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnMuTnVtZXJpYy5EaXZpc2lvbn1cbiAqL1xuYWZmaW5pdHkuZGl2ID0gZnVuY3Rpb24oYXR0cjEsIGF0dHIyKXtcbiAgICByZXR1cm4gbmV3IGFmZmluaXR5LkRpdmlzaW9uKGF0dHIxLCBhdHRyMik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSBhdHRyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb25zLk51bWVyaWMuRXhwb25lbnRpYWx9XG4gKi9cbmFmZmluaXR5LmV4cCA9IGZ1bmN0aW9uKGF0dHIpe1xuICAgIHJldHVybiBuZXcgYWZmaW5pdHkuRXhwb25lbnRpYWwoYXR0cik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSBhdHRyMVxuICogQHBhcmFtIGF0dHIyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb25zLk51bWVyaWMuTWludXN9XG4gKi9cbmFmZmluaXR5Lm1pbnVzID0gZnVuY3Rpb24oYXR0cjEsIGF0dHIyKXtcbiAgICByZXR1cm4gbmV3IGFmZmluaXR5Lk1pbnVzKGF0dHIxLCBhdHRyMik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSBhdHRyMVxuICogQHBhcmFtIGF0dHIyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb25zLk51bWVyaWMuTW9kdWxvfVxuICovXG5hZmZpbml0eS5tb2QgPSBmdW5jdGlvbihhdHRyMSwgYXR0cjIpe1xuICAgIHJldHVybiBuZXcgYWZmaW5pdHkuTW9kdWxvKGF0dHIxLCBhdHRyMik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSBhdHRyMVxuICogQHBhcmFtIGF0dHIyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb25zLk51bWVyaWMuTXVsdGlwbGljYXRpb259XG4gKi9cbmFmZmluaXR5LnRpbWVzID0gZnVuY3Rpb24oYXR0cjEsIGF0dHIyKXtcbiAgICByZXR1cm4gbmV3IGFmZmluaXR5Lk11bHRpcGxpY2F0aW9uKGF0dHIxLCBhdHRyMik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSBhdHRyMVxuICogQHBhcmFtIGF0dHIyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb25zLk51bWVyaWMuUGx1c31cbiAqL1xuYWZmaW5pdHkucGx1cyA9IGZ1bmN0aW9uKGF0dHIxLCBhdHRyMil7XG4gICAgcmV0dXJuIG5ldyBhZmZpbml0eS5QbHVzKGF0dHIxLCBhdHRyMik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSBhdHRyMVxuICogQHBhcmFtIGF0dHIyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb25zLk51bWVyaWMuUG93ZXJ9XG4gKi9cbmFmZmluaXR5LnBvdyA9IGZ1bmN0aW9uKGF0dHIxLCBhdHRyMil7XG4gICAgcmV0dXJuIG5ldyBhZmZpbml0eS5Qb3dlcihhdHRyMSwgYXR0cjIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gYXR0clxuICogQHJldHVybnMge0Z1bmN0aW9ucy5OdW1lcmljLlJvdW5kfVxuICovXG5hZmZpbml0eS5yb3VuZCA9IGZ1bmN0aW9uKGF0dHIpe1xuICAgIHJldHVybiBuZXcgYWZmaW5pdHkuUm91bmQoYXR0cik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSBhdHRyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb25zLk51bWVyaWMuU2luZX1cbiAqL1xuYWZmaW5pdHkuc2luID0gZnVuY3Rpb24oYXR0cil7XG4gICAgcmV0dXJuIG5ldyBhZmZpbml0eS5TaW5lKGF0dHIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gYXR0clxuICogQHJldHVybnMge0Z1bmN0aW9ucy5OdW1lcmljLlNxdWFyZVJvb3R9XG4gKi9cbmFmZmluaXR5LnNxcnQgPSBmdW5jdGlvbihhdHRyKXtcbiAgICByZXR1cm4gbmV3IGFmZmluaXR5LlNxdWFyZVJvb3QoYXR0cik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSBhdHRyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb25zLk51bWVyaWMuVGFuZ2VudH1cbiAqL1xuYWZmaW5pdHkudGFuID0gZnVuY3Rpb24oYXR0cil7XG4gICAgcmV0dXJuIG5ldyBhZmZpbml0eS5UYW5nZW50KGF0dHIpO1xufTtcbi8vZW5kcmVnaW9uXG5cbi8vcmVnaW9uIFN0cmluZyBGdW5jdGlvbnNcblxuLyoqXG4gKiBAdHlwZSB7RnVuY3Rpb25zLlN0cmluZy5MZW5ndGh9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5MZW5ndGggPSByZXF1aXJlKCcuL2FmZmluaXR5L2Z1bmN0aW9ucy9zdHJpbmcvTGVuZ3RoLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5TdHJpbmcuTG93ZXJjYXNlfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuTG93ZXJjYXNlID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvc3RyaW5nL0xvd2VyY2FzZS5qcycpO1xuXG4vKipcbiAqIEB0eXBlIHtGdW5jdGlvbnMuU3RyaW5nLlRlc3R9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5UZXN0ID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvc3RyaW5nL1Rlc3QuanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7RnVuY3Rpb25zLlN0cmluZy5TdWJzdHJpbmd9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5TdWJzdHJpbmcgPSByZXF1aXJlKCcuL2FmZmluaXR5L2Z1bmN0aW9ucy9zdHJpbmcvU3Vic3RyaW5nLmpzJyk7XG5cbi8qKlxuICogQHR5cGUge0Z1bmN0aW9ucy5TdHJpbmcuVXBwZXJjYXNlfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuVXBwZXJjYXNlID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvc3RyaW5nL1VwcGVyY2FzZS5qcycpO1xuXG4vKipcbiAqIEBwYXJhbSBhdHRyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb25zLlN0cmluZy5MZW5ndGh9XG4gKi9cbmFmZmluaXR5Lmxlbmd0aCA9IGZ1bmN0aW9uKGF0dHIpe1xuICAgIHJldHVybiBuZXcgYWZmaW5pdHkuTGVuZ3RoKGF0dHIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gYXR0clxuICogQHJldHVybnMge0Z1bmN0aW9ucy5TdHJpbmcuTG93ZXJjYXNlfVxuICovXG5hZmZpbml0eS5sb3dlcmNhc2UgPSBmdW5jdGlvbihhdHRyKXtcbiAgICByZXR1cm4gbmV3IGFmZmluaXR5Lkxvd2VyY2FzZShhdHRyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIGF0dHJcbiAqIEBwYXJhbSByZWdleFxuICogQHJldHVybnMge0Z1bmN0aW9ucy5TdHJpbmcuVGVzdH1cbiAqL1xuYWZmaW5pdHkudGVzdCA9IGZ1bmN0aW9uKGF0dHIsIHJlZ2V4KXtcbiAgICByZXR1cm4gbmV3IGFmZmluaXR5LlRlc3QoYXR0ciwgcmVnZXgpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gYXR0clxuICogQHBhcmFtIHN0YXJ0XG4gKiBAcGFyYW0gbGVuZ3RoXG4gKiBAcmV0dXJucyB7RnVuY3Rpb25zLlN0cmluZy5TdWJzdHJpbmd9XG4gKi9cbmFmZmluaXR5LnN1YnN0ciA9IGZ1bmN0aW9uKGF0dHIsIHN0YXJ0LCBsZW5ndGgpe1xuICAgIHJldHVybiBuZXcgYWZmaW5pdHkuTGVuZ3RoKGF0dHIsIHN0YXJ0LCBsZW5ndGgpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gYXR0clxuICogQHJldHVybnMge0Z1bmN0aW9ucy5TdHJpbmcuVXBwZXJjYXNlfVxuICovXG5hZmZpbml0eS51cHBlcmNhc2UgPSBmdW5jdGlvbihhdHRyKXtcbiAgICByZXR1cm4gbmV3IGFmZmluaXR5Lkxlbmd0aChhdHRyKTtcbn07XG4vL2VuZHJlZ2lvblxuXG4vL3JlZ2lvbiBUdXBsZSBGdW5jdGlvbnNcblxuLyoqXG4gKiBAdHlwZSB7RnVuY3Rpb25zLlR1cGxlLkF0dHJpYnV0ZVZhbHVlfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuVHVwbGVWYWx1ZSA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL3R1cGxlL0F0dHJpYnV0ZS5qcycpO1xuXG4vKipcbiAqIEBwYXJhbSByZWxhdGlvblxuICogQHBhcmFtIGF0dHJpYnV0ZU5hbWVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnMuVHVwbGUuQXR0cmlidXRlVmFsdWV9XG4gKi9cbmFmZmluaXR5LnZhbHVlID0gZnVuY3Rpb24ocmVsYXRpb24sIGF0dHJpYnV0ZU5hbWUpe1xuICAgIHZhciByZXN1bHQgPSBuZXcgYWZmaW5pdHkuVHVwbGVWYWx1ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICByZXN1bHQudHlwZShyZWxhdGlvbi5oZWFkZXIoKS5nZXQoYXR0cmlidXRlTmFtZSkpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuLy9lbmRyZWdpb25cblxuLy9yZWdpb24gRGF0ZSBGdW5jdGlvbnNcblxuYWZmaW5pdHkuRGF5T2ZNb250aCA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL2RhdGUvRGF5T2ZNb250aC5qcycpO1xuYWZmaW5pdHkuRGF5T2ZNb250aCA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL2RhdGUvRGF5T2ZNb250aC5qcycpO1xuYWZmaW5pdHkuRGF5T2ZXZWVrID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvZGF0ZS9EYXlPZldlZWsuanMnKTtcbmFmZmluaXR5LkRheU9mWWVhciA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL2RhdGUvRGF5T2ZZZWFyLmpzJyk7XG5hZmZpbml0eS5Ib3VycyA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL2RhdGUvSG91cnMuanMnKTtcbmFmZmluaXR5Lk1pbGxpc2Vjb25kcyA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL2RhdGUvTWlsbGlzZWNvbmRzLmpzJyk7XG5hZmZpbml0eS5NaW51dGVzID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvZGF0ZS9NaW51dGVzLmpzJyk7XG5hZmZpbml0eS5Nb250aCA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL2RhdGUvTW9udGguanMnKTtcbmFmZmluaXR5LlNlY29uZHMgPSByZXF1aXJlKCcuL2FmZmluaXR5L2Z1bmN0aW9ucy9kYXRlL1NlY29uZHMuanMnKTtcbmFmZmluaXR5LlRpbWVzdGFtcCA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvZnVuY3Rpb25zL2RhdGUvVGltZXN0YW1wLmpzJyk7XG5hZmZpbml0eS5XZWVrT2ZZZWFyID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvZGF0ZS9XZWVrT2ZZZWFyLmpzJyk7XG5hZmZpbml0eS5ZZWFyID0gcmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvZGF0ZS9ZZWFyLmpzJyk7XG4vL2VuZHJlZ2lvblxuXG5hZmZpbml0eS5jb3VudCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIG5ldyAocmVxdWlyZSgnLi9hZmZpbml0eS9mdW5jdGlvbnMvYWdncmVnYXRlL0NvdW50LmpzJykpO1xufTtcblxuLy9yZWdpb24gUmVsYXRpb25hbCBPcGVyYXRvcnNcblxuLyoqXG4gKiBAdHlwZSB7T3BlcmF0b3JzLkNvbXBvc2l0aW9ufSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuQ29tcG9zaXRpb24gPSByZXF1aXJlKCcuL2FmZmluaXR5L2FsZ2VicmEvQ29tcG9zaXRpb24uanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7T3BlcmF0b3JzLkRpZmZlcmVuY2V9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5EaWZmZXJlbmNlID0gcmVxdWlyZSgnLi9hZmZpbml0eS9hbGdlYnJhL0RpZmZlcmVuY2UuanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7T3BlcmF0b3JzLkV4dGVuc2lvbn0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LkV4dGVuc2lvbiA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvYWxnZWJyYS9FeHRlbnNpb24uanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7T3BlcmF0b3JzLkdyb3VwfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuR3JvdXAgPSByZXF1aXJlKCcuL2FmZmluaXR5L2FsZ2VicmEvR3JvdXAuanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7T3BlcmF0b3JzLkludGVyc2VjdGlvbn0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LkludGVyc2VjdGlvbiA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvYWxnZWJyYS9JbnRlcnNlY3Rpb24uanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7T3BlcmF0b3JzLkpvaW59IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5Kb2luID0gcmVxdWlyZSgnLi9hZmZpbml0eS9hbGdlYnJhL0pvaW4uanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7T3BlcmF0b3JzLlByb2R1Y3R9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5Qcm9kdWN0ID0gcmVxdWlyZSgnLi9hZmZpbml0eS9hbGdlYnJhL1Byb2R1Y3QuanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7T3BlcmF0b3JzLlByb2plY3Rpb259IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5Qcm9qZWN0aW9uID0gcmVxdWlyZSgnLi9hZmZpbml0eS9hbGdlYnJhL1Byb2plY3Rpb24uanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7T3BlcmF0b3JzLlJlbmFtZX0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LlJlbmFtZSA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvYWxnZWJyYS9SZW5hbWUuanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7T3BlcmF0b3JzLlJlc3RyaWN0aW9ufSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuUmVzdHJpY3Rpb24gPSByZXF1aXJlKCcuL2FmZmluaXR5L2FsZ2VicmEvUmVzdHJpY3Rpb24uanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7T3BlcmF0b3JzLlNlbWlEaWZmZXJlbmNlfSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuU2VtaURpZmZlcmVuY2UgPSByZXF1aXJlKCcuL2FmZmluaXR5L2FsZ2VicmEvU2VtaURpZmZlcmVuY2UuanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7T3BlcmF0b3JzLlNlbWlKb2lufSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuU2VtaUpvaW4gPSByZXF1aXJlKCcuL2FmZmluaXR5L2FsZ2VicmEvU2VtaUpvaW4uanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7T3BlcmF0b3JzLlVuZ3JvdXB9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5Vbmdyb3VwID0gcmVxdWlyZSgnLi9hZmZpbml0eS9hbGdlYnJhL1VuZ3JvdXAuanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7T3BlcmF0b3JzLlVuaW9ufSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuVW5pb24gPSByZXF1aXJlKCcuL2FmZmluaXR5L2FsZ2VicmEvVW5pb24uanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7T3BlcmF0b3JzLlVud3JhcH0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LlVud3JhcCA9IHJlcXVpcmUoJy4vYWZmaW5pdHkvYWxnZWJyYS9VbndyYXAuanMnKTtcblxuLyoqXG4gKiBAdHlwZSB7T3BlcmF0b3JzLldyYXB9IFxuICogQG1lbWJlciBBZmZpbml0eVxuICovXG5hZmZpbml0eS5XcmFwID0gcmVxdWlyZSgnLi9hZmZpbml0eS9hbGdlYnJhL1dyYXAuanMnKTtcbi8vZW5kcmVnaW9uXG5cbi8vcmVnaW9uIENvbnN0YW50c1xuXG4vKipcbiAqIEB0eXBlIHtSZWxhdGlvbn0gXG4gKiBAbWVtYmVyIEFmZmluaXR5XG4gKi9cbmFmZmluaXR5LlRBQkxFX0RVTSA9IG5ldyBhZmZpbml0eS5SZWxhdGlvbihbXSk7XG5cbi8qKlxuICogQHR5cGUge1JlbGF0aW9ufSBcbiAqIEBtZW1iZXIgQWZmaW5pdHlcbiAqL1xuYWZmaW5pdHkuVEFCTEVfREVFID0gbmV3IGFmZmluaXR5LlJlbGF0aW9uKFtdLCBbXG4gICAgW11cbl0pO1xuLy9lbmRyZWdpb25cblxubW9kdWxlLmV4cG9ydHMgPSBhZmZpbml0eTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBFdmVudEVtaXR0ZXIgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRXZlbnQgaGFuZGxlciB0byBiZSBjYWxsZWQuXG4gKiBAcGFyYW0ge01peGVkfSBjb250ZXh0IENvbnRleHQgZm9yIGZ1bmN0aW9uIGV4ZWN1dGlvbi5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IGVtaXQgb25jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIEV2ZW50RW1pdHRlciBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogRXZlbnRFbWl0dGVyIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHsgLyogTm90aGluZyB0byBzZXQgKi8gfVxuXG4vKipcbiAqIEhvbGRzIHRoZSBhc3NpZ25lZCBFdmVudEVtaXR0ZXJzIGJ5IG5hbWUuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBSZXR1cm4gYSBsaXN0IG9mIGFzc2lnbmVkIGV2ZW50IGxpc3RlbmVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50cyB0aGF0IHNob3VsZCBiZSBsaXN0ZWQuXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW2V2ZW50XSkgcmV0dXJuIFtdO1xuICBpZiAodGhpcy5fZXZlbnRzW2V2ZW50XS5mbikgcmV0dXJuIFt0aGlzLl9ldmVudHNbZXZlbnRdLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2V2ZW50c1tldmVudF0ubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgIGVlW2ldID0gdGhpcy5fZXZlbnRzW2V2ZW50XVtpXS5mbjtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogRW1pdCBhbiBldmVudCB0byBhbGwgcmVnaXN0ZXJlZCBldmVudCBsaXN0ZW5lcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBuYW1lIG9mIHRoZSBldmVudC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJbmRpY2F0aW9uIGlmIHdlJ3ZlIGVtaXR0ZWQgYW4gZXZlbnQuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1tldmVudF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2ZW50XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGxpc3RlbmVycy5mbikge1xuICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgbmV3IEV2ZW50TGlzdGVuZXIgZm9yIHRoZSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgTmFtZSBvZiB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge0Z1bmN0b259IGZuIENhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtNaXhlZH0gY29udGV4dCBUaGUgY29udGV4dCBvZiB0aGUgZnVuY3Rpb24uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCB0aGlzKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cykgdGhpcy5fZXZlbnRzID0ge307XG4gIGlmICghdGhpcy5fZXZlbnRzW2V2ZW50XSkgdGhpcy5fZXZlbnRzW2V2ZW50XSA9IGxpc3RlbmVyO1xuICBlbHNlIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1tldmVudF0uZm4pIHRoaXMuX2V2ZW50c1tldmVudF0ucHVzaChsaXN0ZW5lcik7XG4gICAgZWxzZSB0aGlzLl9ldmVudHNbZXZlbnRdID0gW1xuICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50XSwgbGlzdGVuZXJcbiAgICBdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBFdmVudExpc3RlbmVyIHRoYXQncyBvbmx5IGNhbGxlZCBvbmNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBOYW1lIG9mIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtNaXhlZH0gY29udGV4dCBUaGUgY29udGV4dCBvZiB0aGUgZnVuY3Rpb24uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgdGhpcywgdHJ1ZSk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHt9O1xuICBpZiAoIXRoaXMuX2V2ZW50c1tldmVudF0pIHRoaXMuX2V2ZW50c1tldmVudF0gPSBsaXN0ZW5lcjtcbiAgZWxzZSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHNbZXZlbnRdLmZuKSB0aGlzLl9ldmVudHNbZXZlbnRdLnB1c2gobGlzdGVuZXIpO1xuICAgIGVsc2UgdGhpcy5fZXZlbnRzW2V2ZW50XSA9IFtcbiAgICAgIHRoaXMuX2V2ZW50c1tldmVudF0sIGxpc3RlbmVyXG4gICAgXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgZXZlbnQgd2Ugd2FudCB0byByZW1vdmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgdGhhdCB3ZSBuZWVkIHRvIGZpbmQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25jZSBsaXN0ZW5lcnMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBvbmNlKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbZXZlbnRdKSByZXR1cm4gdGhpcztcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2ZW50XVxuICAgICwgZXZlbnRzID0gW107XG5cbiAgaWYgKGZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5mbiAmJiAobGlzdGVuZXJzLmZuICE9PSBmbiB8fCAob25jZSAmJiAhbGlzdGVuZXJzLm9uY2UpKSkge1xuICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzKTtcbiAgICB9XG4gICAgaWYgKCFsaXN0ZW5lcnMuZm4pIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8IChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkpIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvL1xuICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gIC8vXG4gIGlmIChldmVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fZXZlbnRzW2V2ZW50XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1tldmVudF07XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgb3Igb25seSB0aGUgbGlzdGVuZXJzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgZXZlbnQgd2FudCB0byByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICBpZiAoIXRoaXMuX2V2ZW50cykgcmV0dXJuIHRoaXM7XG5cbiAgaWYgKGV2ZW50KSBkZWxldGUgdGhpcy5fZXZlbnRzW2V2ZW50XTtcbiAgZWxzZSB0aGlzLl9ldmVudHMgPSB7fTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiBkb2Vzbid0IGFwcGx5IGFueW1vcmUuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyMiA9IEV2ZW50RW1pdHRlcjtcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIzID0gRXZlbnRFbWl0dGVyO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBMby1EYXNoIDIuNC4xIChDdXN0b20gQnVpbGQpIDxodHRwOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gLW8gLi9kaXN0L2xvZGFzaC5qc2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTMgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuNS4yIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxMyBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG47KGZ1bmN0aW9uKCkge1xuXG4gIC8qKiBVc2VkIGFzIGEgc2FmZSByZWZlcmVuY2UgZm9yIGB1bmRlZmluZWRgIGluIHByZSBFUzUgZW52aXJvbm1lbnRzICovXG4gIHZhciB1bmRlZmluZWQ7XG5cbiAgLyoqIFVzZWQgdG8gcG9vbCBhcnJheXMgYW5kIG9iamVjdHMgdXNlZCBpbnRlcm5hbGx5ICovXG4gIHZhciBhcnJheVBvb2wgPSBbXSxcbiAgICAgIG9iamVjdFBvb2wgPSBbXTtcblxuICAvKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzICovXG4gIHZhciBpZENvdW50ZXIgPSAwO1xuXG4gIC8qKiBVc2VkIHRvIHByZWZpeCBrZXlzIHRvIGF2b2lkIGlzc3VlcyB3aXRoIGBfX3Byb3RvX19gIGFuZCBwcm9wZXJ0aWVzIG9uIGBPYmplY3QucHJvdG90eXBlYCAqL1xuICB2YXIga2V5UHJlZml4ID0gK25ldyBEYXRlICsgJyc7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNpemUgd2hlbiBvcHRpbWl6YXRpb25zIGFyZSBlbmFibGVkIGZvciBsYXJnZSBhcnJheXMgKi9cbiAgdmFyIGxhcmdlQXJyYXlTaXplID0gNzU7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIG1heCBzaXplIG9mIHRoZSBgYXJyYXlQb29sYCBhbmQgYG9iamVjdFBvb2xgICovXG4gIHZhciBtYXhQb29sU2l6ZSA9IDQwO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBhbmQgdGVzdCB3aGl0ZXNwYWNlICovXG4gIHZhciB3aGl0ZXNwYWNlID0gKFxuICAgIC8vIHdoaXRlc3BhY2VcbiAgICAnIFxcdFxceDBCXFxmXFx4QTBcXHVmZWZmJyArXG5cbiAgICAvLyBsaW5lIHRlcm1pbmF0b3JzXG4gICAgJ1xcblxcclxcdTIwMjhcXHUyMDI5JyArXG5cbiAgICAvLyB1bmljb2RlIGNhdGVnb3J5IFwiWnNcIiBzcGFjZSBzZXBhcmF0b3JzXG4gICAgJ1xcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDAnXG4gICk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZSAqL1xuICB2YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIEVTNiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXG4gICAqIGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWxpdGVyYWxzLXN0cmluZy1saXRlcmFsc1xuICAgKi9cbiAgdmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCByZWdleHAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMgKi9cbiAgdmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdGVkIG5hbWVkIGZ1bmN0aW9ucyAqL1xuICB2YXIgcmVGdW5jTmFtZSA9IC9eXFxzKmZ1bmN0aW9uWyBcXG5cXHJcXHRdK1xcdy87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggXCJpbnRlcnBvbGF0ZVwiIHRlbXBsYXRlIGRlbGltaXRlcnMgKi9cbiAgdmFyIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIHdoaXRlc3BhY2UgYW5kIHplcm9zIHRvIGJlIHJlbW92ZWQgKi9cbiAgdmFyIHJlTGVhZGluZ1NwYWNlc0FuZFplcm9zID0gUmVnRXhwKCdeWycgKyB3aGl0ZXNwYWNlICsgJ10qMCsoPz0uJCknKTtcblxuICAvKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMgKi9cbiAgdmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgZnVuY3Rpb25zIGNvbnRhaW5pbmcgYSBgdGhpc2AgcmVmZXJlbmNlICovXG4gIHZhciByZVRoaXMgPSAvXFxidGhpc1xcYi87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdW5lc2NhcGVkIGNoYXJhY3RlcnMgaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzICovXG4gIHZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdFxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuICAvKiogVXNlZCB0byBhc3NpZ24gZGVmYXVsdCBgY29udGV4dGAgb2JqZWN0IHByb3BlcnRpZXMgKi9cbiAgdmFyIGNvbnRleHRQcm9wcyA9IFtcbiAgICAnQXJyYXknLCAnQm9vbGVhbicsICdEYXRlJywgJ0Z1bmN0aW9uJywgJ01hdGgnLCAnTnVtYmVyJywgJ09iamVjdCcsXG4gICAgJ1JlZ0V4cCcsICdTdHJpbmcnLCAnXycsICdhdHRhY2hFdmVudCcsICdjbGVhclRpbWVvdXQnLCAnaXNGaW5pdGUnLCAnaXNOYU4nLFxuICAgICdwYXJzZUludCcsICdzZXRUaW1lb3V0J1xuICBdO1xuXG4gIC8qKiBVc2VkIHRvIG1ha2UgdGVtcGxhdGUgc291cmNlVVJMcyBlYXNpZXIgdG8gaWRlbnRpZnkgKi9cbiAgdmFyIHRlbXBsYXRlQ291bnRlciA9IDA7XG5cbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCBzaG9ydGN1dHMgKi9cbiAgdmFyIGFyZ3NDbGFzcyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgICAgYXJyYXlDbGFzcyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBib29sQ2xhc3MgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgICBkYXRlQ2xhc3MgPSAnW29iamVjdCBEYXRlXScsXG4gICAgICBmdW5jQ2xhc3MgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgICAgbnVtYmVyQ2xhc3MgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICAgIG9iamVjdENsYXNzID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgICByZWdleHBDbGFzcyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgICAgc3RyaW5nQ2xhc3MgPSAnW29iamVjdCBTdHJpbmddJztcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBvYmplY3QgY2xhc3NpZmljYXRpb25zIHRoYXQgYF8uY2xvbmVgIHN1cHBvcnRzICovXG4gIHZhciBjbG9uZWFibGVDbGFzc2VzID0ge307XG4gIGNsb25lYWJsZUNsYXNzZXNbZnVuY0NsYXNzXSA9IGZhbHNlO1xuICBjbG9uZWFibGVDbGFzc2VzW2FyZ3NDbGFzc10gPSBjbG9uZWFibGVDbGFzc2VzW2FycmF5Q2xhc3NdID1cbiAgY2xvbmVhYmxlQ2xhc3Nlc1tib29sQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tkYXRlQ2xhc3NdID1cbiAgY2xvbmVhYmxlQ2xhc3Nlc1tudW1iZXJDbGFzc10gPSBjbG9uZWFibGVDbGFzc2VzW29iamVjdENsYXNzXSA9XG4gIGNsb25lYWJsZUNsYXNzZXNbcmVnZXhwQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tzdHJpbmdDbGFzc10gPSB0cnVlO1xuXG4gIC8qKiBVc2VkIGFzIGFuIGludGVybmFsIGBfLmRlYm91bmNlYCBvcHRpb25zIG9iamVjdCAqL1xuICB2YXIgZGVib3VuY2VPcHRpb25zID0ge1xuICAgICdsZWFkaW5nJzogZmFsc2UsXG4gICAgJ21heFdhaXQnOiAwLFxuICAgICd0cmFpbGluZyc6IGZhbHNlXG4gIH07XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yIGBfX2JpbmREYXRhX19gICovXG4gIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICdjb25maWd1cmFibGUnOiBmYWxzZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IG51bGwsXG4gICAgJ3dyaXRhYmxlJzogZmFsc2VcbiAgfTtcblxuICAvKiogVXNlZCB0byBkZXRlcm1pbmUgaWYgdmFsdWVzIGFyZSBvZiB0aGUgbGFuZ3VhZ2UgdHlwZSBPYmplY3QgKi9cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgICdib29sZWFuJzogZmFsc2UsXG4gICAgJ2Z1bmN0aW9uJzogdHJ1ZSxcbiAgICAnb2JqZWN0JzogdHJ1ZSxcbiAgICAnbnVtYmVyJzogZmFsc2UsXG4gICAgJ3N0cmluZyc6IGZhbHNlLFxuICAgICd1bmRlZmluZWQnOiBmYWxzZVxuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzICovXG4gIHZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgIFwiJ1wiOiBcIidcIixcbiAgICAnXFxuJzogJ24nLFxuICAgICdcXHInOiAncicsXG4gICAgJ1xcdCc6ICd0JyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgKi9cbiAgdmFyIHJvb3QgPSAob2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93KSB8fCB0aGlzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AgKi9cbiAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAgKi9cbiAgdmFyIGZyZWVNb2R1bGUgPSBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbiAgLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYCAqL1xuICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cyAmJiBmcmVlRXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlIGFuZCB1c2UgaXQgYXMgYHJvb3RgICovXG4gIHZhciBmcmVlR2xvYmFsID0gb2JqZWN0VHlwZXNbdHlwZW9mIGdsb2JhbF0gJiYgZ2xvYmFsO1xuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBiaW5hcnkgc2VhcmNoZXNcbiAgICogb3IgYGZyb21JbmRleGAgY29uc3RyYWludHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUgb3IgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gKGZyb21JbmRleCB8fCAwKSAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb250YWluc2AgZm9yIGNhY2hlIG9iamVjdHMgdGhhdCBtaW1pY3MgdGhlIHJldHVyblxuICAgKiBzaWduYXR1cmUgb2YgYF8uaW5kZXhPZmAgYnkgcmV0dXJuaW5nIGAwYCBpZiB0aGUgdmFsdWUgaXMgZm91bmQsIGVsc2UgYC0xYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgMGAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FjaGVJbmRleE9mKGNhY2hlLCB2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGNhY2hlID0gY2FjaGUuY2FjaGU7XG5cbiAgICBpZiAodHlwZSA9PSAnYm9vbGVhbicgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhY2hlW3ZhbHVlXSA/IDAgOiAtMTtcbiAgICB9XG4gICAgaWYgKHR5cGUgIT0gJ251bWJlcicgJiYgdHlwZSAhPSAnc3RyaW5nJykge1xuICAgICAgdHlwZSA9ICdvYmplY3QnO1xuICAgIH1cbiAgICB2YXIga2V5ID0gdHlwZSA9PSAnbnVtYmVyJyA/IHZhbHVlIDoga2V5UHJlZml4ICsgdmFsdWU7XG4gICAgY2FjaGUgPSAoY2FjaGUgPSBjYWNoZVt0eXBlXSkgJiYgY2FjaGVba2V5XTtcblxuICAgIHJldHVybiB0eXBlID09ICdvYmplY3QnXG4gICAgICA/IChjYWNoZSAmJiBiYXNlSW5kZXhPZihjYWNoZSwgdmFsdWUpID4gLTEgPyAwIDogLTEpXG4gICAgICA6IChjYWNoZSA/IDAgOiAtMSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGdpdmVuIHZhbHVlIHRvIHRoZSBjb3JyZXNwb25kaW5nIGNhY2hlIG9iamVjdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYWRkIHRvIHRoZSBjYWNoZS5cbiAgICovXG4gIGZ1bmN0aW9uIGNhY2hlUHVzaCh2YWx1ZSkge1xuICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGUsXG4gICAgICAgIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICBpZiAodHlwZSA9PSAnYm9vbGVhbicgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgY2FjaGVbdmFsdWVdID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgIT0gJ251bWJlcicgJiYgdHlwZSAhPSAnc3RyaW5nJykge1xuICAgICAgICB0eXBlID0gJ29iamVjdCc7XG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdHlwZSA9PSAnbnVtYmVyJyA/IHZhbHVlIDoga2V5UHJlZml4ICsgdmFsdWUsXG4gICAgICAgICAgdHlwZUNhY2hlID0gY2FjaGVbdHlwZV0gfHwgKGNhY2hlW3R5cGVdID0ge30pO1xuXG4gICAgICBpZiAodHlwZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAodHlwZUNhY2hlW2tleV0gfHwgKHR5cGVDYWNoZVtrZXldID0gW10pKS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVDYWNoZVtrZXldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5tYXhgIGFuZCBgXy5taW5gIGFzIHRoZSBkZWZhdWx0IGNhbGxiYWNrIHdoZW4gYSBnaXZlblxuICAgKiBjb2xsZWN0aW9uIGlzIGEgc3RyaW5nIHZhbHVlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIGNoYXJhY3RlciB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2RlIHVuaXQgb2YgZ2l2ZW4gY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhckF0Q2FsbGJhY2sodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBzb3J0QnlgIHRvIGNvbXBhcmUgdHJhbnNmb3JtZWQgYGNvbGxlY3Rpb25gIGVsZW1lbnRzLCBzdGFibGUgc29ydGluZ1xuICAgKiB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBiYC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBhYC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3Igb2YgYDFgIG9yIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKGEsIGIpIHtcbiAgICB2YXIgYWMgPSBhLmNyaXRlcmlhLFxuICAgICAgICBiYyA9IGIuY3JpdGVyaWEsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFjLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhY1tpbmRleF0sXG4gICAgICAgICAgb3RoZXIgPSBiY1tpbmRleF07XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICAgICAgaWYgKHZhbHVlID4gb3RoZXIgfHwgdHlwZW9mIHZhbHVlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgb3RoZXIgfHwgdHlwZW9mIG90aGVyID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgICAvLyB0aGF0IGNhdXNlcyBpdCwgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLCB0byByZXR1cm4gdGhlIHNhbWUgdmFsdWUgZm9yXG4gICAgLy8gYGFgIGFuZCBgYmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gICAgLy9cbiAgICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAgIC8vIFNlZSBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MFxuICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2FjaGUgb2JqZWN0IHRvIG9wdGltaXplIGxpbmVhciBzZWFyY2hlcyBvZiBsYXJnZSBhcnJheXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICogQHJldHVybnMge251bGx8T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBvYmplY3Qgb3IgYG51bGxgIGlmIGNhY2hpbmcgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQ2FjaGUoYXJyYXkpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBmaXJzdCA9IGFycmF5WzBdLFxuICAgICAgICBtaWQgPSBhcnJheVsobGVuZ3RoIC8gMikgfCAwXSxcbiAgICAgICAgbGFzdCA9IGFycmF5W2xlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGZpcnN0ICYmIHR5cGVvZiBmaXJzdCA9PSAnb2JqZWN0JyAmJlxuICAgICAgICBtaWQgJiYgdHlwZW9mIG1pZCA9PSAnb2JqZWN0JyAmJiBsYXN0ICYmIHR5cGVvZiBsYXN0ID09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBjYWNoZSA9IGdldE9iamVjdCgpO1xuICAgIGNhY2hlWydmYWxzZSddID0gY2FjaGVbJ251bGwnXSA9IGNhY2hlWyd0cnVlJ10gPSBjYWNoZVsndW5kZWZpbmVkJ10gPSBmYWxzZTtcblxuICAgIHZhciByZXN1bHQgPSBnZXRPYmplY3QoKTtcbiAgICByZXN1bHQuYXJyYXkgPSBhcnJheTtcbiAgICByZXN1bHQuY2FjaGUgPSBjYWNoZTtcbiAgICByZXN1bHQucHVzaCA9IGNhY2hlUHVzaDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaChhcnJheVtpbmRleF0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYHRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkXG4gICAqIHN0cmluZyBsaXRlcmFscy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlU3RyaW5nQ2hhcihtYXRjaCkge1xuICAgIHJldHVybiAnXFxcXCcgKyBzdHJpbmdFc2NhcGVzW21hdGNoXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGFycmF5IGZyb20gdGhlIGFycmF5IHBvb2wgb3IgY3JlYXRlcyBhIG5ldyBvbmUgaWYgdGhlIHBvb2wgaXMgZW1wdHkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGFycmF5IGZyb20gdGhlIHBvb2wuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRBcnJheSgpIHtcbiAgICByZXR1cm4gYXJyYXlQb29sLnBvcCgpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gb2JqZWN0IGZyb20gdGhlIG9iamVjdCBwb29sIG9yIGNyZWF0ZXMgYSBuZXcgb25lIGlmIHRoZSBwb29sIGlzIGVtcHR5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgb2JqZWN0IGZyb20gdGhlIHBvb2wuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRPYmplY3QoKSB7XG4gICAgcmV0dXJuIG9iamVjdFBvb2wucG9wKCkgfHwge1xuICAgICAgJ2FycmF5JzogbnVsbCxcbiAgICAgICdjYWNoZSc6IG51bGwsXG4gICAgICAnY3JpdGVyaWEnOiBudWxsLFxuICAgICAgJ2ZhbHNlJzogZmFsc2UsXG4gICAgICAnaW5kZXgnOiAwLFxuICAgICAgJ251bGwnOiBmYWxzZSxcbiAgICAgICdudW1iZXInOiBudWxsLFxuICAgICAgJ29iamVjdCc6IG51bGwsXG4gICAgICAncHVzaCc6IG51bGwsXG4gICAgICAnc3RyaW5nJzogbnVsbCxcbiAgICAgICd0cnVlJzogZmFsc2UsXG4gICAgICAndW5kZWZpbmVkJzogZmFsc2UsXG4gICAgICAndmFsdWUnOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgZ2l2ZW4gYXJyYXkgYmFjayB0byB0aGUgYXJyYXkgcG9vbC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gcmVsZWFzZS5cbiAgICovXG4gIGZ1bmN0aW9uIHJlbGVhc2VBcnJheShhcnJheSkge1xuICAgIGFycmF5Lmxlbmd0aCA9IDA7XG4gICAgaWYgKGFycmF5UG9vbC5sZW5ndGggPCBtYXhQb29sU2l6ZSkge1xuICAgICAgYXJyYXlQb29sLnB1c2goYXJyYXkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgZ2l2ZW4gb2JqZWN0IGJhY2sgdG8gdGhlIG9iamVjdCBwb29sLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byByZWxlYXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVsZWFzZU9iamVjdChvYmplY3QpIHtcbiAgICB2YXIgY2FjaGUgPSBvYmplY3QuY2FjaGU7XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICByZWxlYXNlT2JqZWN0KGNhY2hlKTtcbiAgICB9XG4gICAgb2JqZWN0LmFycmF5ID0gb2JqZWN0LmNhY2hlID0gb2JqZWN0LmNyaXRlcmlhID0gb2JqZWN0Lm9iamVjdCA9IG9iamVjdC5udW1iZXIgPSBvYmplY3Quc3RyaW5nID0gb2JqZWN0LnZhbHVlID0gbnVsbDtcbiAgICBpZiAob2JqZWN0UG9vbC5sZW5ndGggPCBtYXhQb29sU2l6ZSkge1xuICAgICAgb2JqZWN0UG9vbC5wdXNoKG9iamVjdCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNsaWNlcyB0aGUgYGNvbGxlY3Rpb25gIGZyb20gdGhlIGBzdGFydGAgaW5kZXggdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLFxuICAgKiB0aGUgYGVuZGAgaW5kZXguXG4gICAqXG4gICAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBpbnN0ZWFkIG9mIGBBcnJheSNzbGljZWAgdG8gc3VwcG9ydCBub2RlIGxpc3RzXG4gICAqIGluIElFIDwgOSBhbmQgdG8gZW5zdXJlIGRlbnNlIGFycmF5cyBhcmUgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzbGljZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIGluZGV4LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gICAgaWYgKHR5cGVvZiBlbmQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVuZCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGVuZCAtIHN0YXJ0IHx8IDAsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCA8IDAgPyAwIDogbGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBsb2Rhc2hgIGZ1bmN0aW9uIHVzaW5nIHRoZSBnaXZlbiBjb250ZXh0IG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD1yb290XSBUaGUgY29udGV4dCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCkge1xuICAgIC8vIEF2b2lkIGlzc3VlcyB3aXRoIHNvbWUgRVMzIGVudmlyb25tZW50cyB0aGF0IGF0dGVtcHQgdG8gdXNlIHZhbHVlcywgbmFtZWRcbiAgICAvLyBhZnRlciBidWlsdC1pbiBjb25zdHJ1Y3RvcnMgbGlrZSBgT2JqZWN0YCwgZm9yIHRoZSBjcmVhdGlvbiBvZiBsaXRlcmFscy5cbiAgICAvLyBFUzUgY2xlYXJzIHRoaXMgdXAgYnkgc3RhdGluZyB0aGF0IGxpdGVyYWxzIG11c3QgdXNlIGJ1aWx0LWluIGNvbnN0cnVjdG9ycy5cbiAgICAvLyBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI3gxMS4xLjUuXG4gICAgY29udGV4dCA9IGNvbnRleHQgPyBfLmRlZmF1bHRzKHJvb3QuT2JqZWN0KCksIGNvbnRleHQsIF8ucGljayhyb290LCBjb250ZXh0UHJvcHMpKSA6IHJvb3Q7XG5cbiAgICAvKiogTmF0aXZlIGNvbnN0cnVjdG9yIHJlZmVyZW5jZXMgKi9cbiAgICB2YXIgQXJyYXkgPSBjb250ZXh0LkFycmF5LFxuICAgICAgICBCb29sZWFuID0gY29udGV4dC5Cb29sZWFuLFxuICAgICAgICBEYXRlID0gY29udGV4dC5EYXRlLFxuICAgICAgICBGdW5jdGlvbiA9IGNvbnRleHQuRnVuY3Rpb24sXG4gICAgICAgIE1hdGggPSBjb250ZXh0Lk1hdGgsXG4gICAgICAgIE51bWJlciA9IGNvbnRleHQuTnVtYmVyLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0Lk9iamVjdCxcbiAgICAgICAgUmVnRXhwID0gY29udGV4dC5SZWdFeHAsXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHQuU3RyaW5nLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0LlR5cGVFcnJvcjtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGBBcnJheWAgbWV0aG9kIHJlZmVyZW5jZXMuXG4gICAgICpcbiAgICAgKiBOb3JtYWxseSBgQXJyYXkucHJvdG90eXBlYCB3b3VsZCBzdWZmaWNlLCBob3dldmVyLCB1c2luZyBhbiBhcnJheSBsaXRlcmFsXG4gICAgICogYXZvaWRzIGlzc3VlcyBpbiBOYXJ3aGFsLlxuICAgICAqL1xuICAgIHZhciBhcnJheVJlZiA9IFtdO1xuXG4gICAgLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyAqL1xuICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAvKiogVXNlZCB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCBgX2AgcmVmZXJlbmNlIGluIGBub0NvbmZsaWN0YCAqL1xuICAgIHZhciBvbGREYXNoID0gY29udGV4dC5fO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgaW50ZXJuYWwgW1tDbGFzc11dIG9mIHZhbHVlcyAqL1xuICAgIHZhciB0b1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZSAqL1xuICAgIHZhciByZU5hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICAgICAgU3RyaW5nKHRvU3RyaW5nKVxuICAgICAgICAucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKVxuICAgICAgICAucmVwbGFjZSgvdG9TdHJpbmd8IGZvciBbXlxcXV0rL2csICcuKj8nKSArICckJ1xuICAgICk7XG5cbiAgICAvKiogTmF0aXZlIG1ldGhvZCBzaG9ydGN1dHMgKi9cbiAgICB2YXIgY2VpbCA9IE1hdGguY2VpbCxcbiAgICAgICAgY2xlYXJUaW1lb3V0ID0gY29udGV4dC5jbGVhclRpbWVvdXQsXG4gICAgICAgIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgZm5Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyxcbiAgICAgICAgZ2V0UHJvdG90eXBlT2YgPSBpc05hdGl2ZShnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZikgJiYgZ2V0UHJvdG90eXBlT2YsXG4gICAgICAgIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHksXG4gICAgICAgIHB1c2ggPSBhcnJheVJlZi5wdXNoLFxuICAgICAgICBzZXRUaW1lb3V0ID0gY29udGV4dC5zZXRUaW1lb3V0LFxuICAgICAgICBzcGxpY2UgPSBhcnJheVJlZi5zcGxpY2UsXG4gICAgICAgIHVuc2hpZnQgPSBhcnJheVJlZi51bnNoaWZ0O1xuXG4gICAgLyoqIFVzZWQgdG8gc2V0IG1ldGEgZGF0YSBvbiBmdW5jdGlvbnMgKi9cbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAvLyBJRSA4IG9ubHkgYWNjZXB0cyBET00gZWxlbWVudHNcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBvID0ge30sXG4gICAgICAgICAgICBmdW5jID0gaXNOYXRpdmUoZnVuYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgJiYgZnVuYyxcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMobywgbywgbykgJiYgZnVuYztcbiAgICAgIH0gY2F0Y2goZSkgeyB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0oKSk7XG5cbiAgICAvKiBOYXRpdmUgbWV0aG9kIHNob3J0Y3V0cyBmb3IgbWV0aG9kcyB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcyAqL1xuICAgIHZhciBuYXRpdmVDcmVhdGUgPSBpc05hdGl2ZShuYXRpdmVDcmVhdGUgPSBPYmplY3QuY3JlYXRlKSAmJiBuYXRpdmVDcmVhdGUsXG4gICAgICAgIG5hdGl2ZUlzQXJyYXkgPSBpc05hdGl2ZShuYXRpdmVJc0FycmF5ID0gQXJyYXkuaXNBcnJheSkgJiYgbmF0aXZlSXNBcnJheSxcbiAgICAgICAgbmF0aXZlSXNGaW5pdGUgPSBjb250ZXh0LmlzRmluaXRlLFxuICAgICAgICBuYXRpdmVJc05hTiA9IGNvbnRleHQuaXNOYU4sXG4gICAgICAgIG5hdGl2ZUtleXMgPSBpc05hdGl2ZShuYXRpdmVLZXlzID0gT2JqZWN0LmtleXMpICYmIG5hdGl2ZUtleXMsXG4gICAgICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgICAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbixcbiAgICAgICAgbmF0aXZlUGFyc2VJbnQgPSBjb250ZXh0LnBhcnNlSW50LFxuICAgICAgICBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbTtcblxuICAgIC8qKiBVc2VkIHRvIGxvb2t1cCBhIGJ1aWx0LWluIGNvbnN0cnVjdG9yIGJ5IFtbQ2xhc3NdXSAqL1xuICAgIHZhciBjdG9yQnlDbGFzcyA9IHt9O1xuICAgIGN0b3JCeUNsYXNzW2FycmF5Q2xhc3NdID0gQXJyYXk7XG4gICAgY3RvckJ5Q2xhc3NbYm9vbENsYXNzXSA9IEJvb2xlYW47XG4gICAgY3RvckJ5Q2xhc3NbZGF0ZUNsYXNzXSA9IERhdGU7XG4gICAgY3RvckJ5Q2xhc3NbZnVuY0NsYXNzXSA9IEZ1bmN0aW9uO1xuICAgIGN0b3JCeUNsYXNzW29iamVjdENsYXNzXSA9IE9iamVjdDtcbiAgICBjdG9yQnlDbGFzc1tudW1iZXJDbGFzc10gPSBOdW1iZXI7XG4gICAgY3RvckJ5Q2xhc3NbcmVnZXhwQ2xhc3NdID0gUmVnRXhwO1xuICAgIGN0b3JCeUNsYXNzW3N0cmluZ0NsYXNzXSA9IFN0cmluZztcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIG9iamVjdCB3aGljaCB3cmFwcyB0aGUgZ2l2ZW4gdmFsdWUgdG8gZW5hYmxlIGludHVpdGl2ZVxuICAgICAqIG1ldGhvZCBjaGFpbmluZy5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uIHRvIExvLURhc2ggbWV0aG9kcywgd3JhcHBlcnMgYWxzbyBoYXZlIHRoZSBmb2xsb3dpbmcgYEFycmF5YCBtZXRob2RzOlxuICAgICAqIGBjb25jYXRgLCBgam9pbmAsIGBwb3BgLCBgcHVzaGAsIGByZXZlcnNlYCwgYHNoaWZ0YCwgYHNsaWNlYCwgYHNvcnRgLCBgc3BsaWNlYCxcbiAgICAgKiBhbmQgYHVuc2hpZnRgXG4gICAgICpcbiAgICAgKiBDaGFpbmluZyBpcyBzdXBwb3J0ZWQgaW4gY3VzdG9tIGJ1aWxkcyBhcyBsb25nIGFzIHRoZSBgdmFsdWVgIG1ldGhvZCBpc1xuICAgICAqIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseSBpbmNsdWRlZCBpbiB0aGUgYnVpbGQuXG4gICAgICpcbiAgICAgKiBUaGUgY2hhaW5hYmxlIHdyYXBwZXIgZnVuY3Rpb25zIGFyZTpcbiAgICAgKiBgYWZ0ZXJgLCBgYXNzaWduYCwgYGJpbmRgLCBgYmluZEFsbGAsIGBiaW5kS2V5YCwgYGNoYWluYCwgYGNvbXBhY3RgLFxuICAgICAqIGBjb21wb3NlYCwgYGNvbmNhdGAsIGBjb3VudEJ5YCwgYGNyZWF0ZWAsIGBjcmVhdGVDYWxsYmFja2AsIGBjdXJyeWAsXG4gICAgICogYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmVyYCwgYGRlbGF5YCwgYGRpZmZlcmVuY2VgLCBgZmlsdGVyYCwgYGZsYXR0ZW5gLFxuICAgICAqIGBmb3JFYWNoYCwgYGZvckVhY2hSaWdodGAsIGBmb3JJbmAsIGBmb3JJblJpZ2h0YCwgYGZvck93bmAsIGBmb3JPd25SaWdodGAsXG4gICAgICogYGZ1bmN0aW9uc2AsIGBncm91cEJ5YCwgYGluZGV4QnlgLCBgaW5pdGlhbGAsIGBpbnRlcnNlY3Rpb25gLCBgaW52ZXJ0YCxcbiAgICAgKiBgaW52b2tlYCwgYGtleXNgLCBgbWFwYCwgYG1heGAsIGBtZW1vaXplYCwgYG1lcmdlYCwgYG1pbmAsIGBvYmplY3RgLCBgb21pdGAsXG4gICAgICogYG9uY2VgLCBgcGFpcnNgLCBgcGFydGlhbGAsIGBwYXJ0aWFsUmlnaHRgLCBgcGlja2AsIGBwbHVja2AsIGBwdWxsYCwgYHB1c2hgLFxuICAgICAqIGByYW5nZWAsIGByZWplY3RgLCBgcmVtb3ZlYCwgYHJlc3RgLCBgcmV2ZXJzZWAsIGBzaHVmZmxlYCwgYHNsaWNlYCwgYHNvcnRgLFxuICAgICAqIGBzb3J0QnlgLCBgc3BsaWNlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aW1lc2AsIGB0b0FycmF5YCwgYHRyYW5zZm9ybWAsXG4gICAgICogYHVuaW9uYCwgYHVuaXFgLCBgdW5zaGlmdGAsIGB1bnppcGAsIGB2YWx1ZXNgLCBgd2hlcmVgLCBgd2l0aG91dGAsIGB3cmFwYCxcbiAgICAgKiBhbmQgYHppcGBcbiAgICAgKlxuICAgICAqIFRoZSBub24tY2hhaW5hYmxlIHdyYXBwZXIgZnVuY3Rpb25zIGFyZTpcbiAgICAgKiBgY2xvbmVgLCBgY2xvbmVEZWVwYCwgYGNvbnRhaW5zYCwgYGVzY2FwZWAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsXG4gICAgICogYGZpbmRLZXlgLCBgZmluZExhc3RgLCBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBoYXNgLCBgaWRlbnRpdHlgLFxuICAgICAqIGBpbmRleE9mYCwgYGlzQXJndW1lbnRzYCwgYGlzQXJyYXlgLCBgaXNCb29sZWFuYCwgYGlzRGF0ZWAsIGBpc0VsZW1lbnRgLFxuICAgICAqIGBpc0VtcHR5YCwgYGlzRXF1YWxgLCBgaXNGaW5pdGVgLCBgaXNGdW5jdGlvbmAsIGBpc05hTmAsIGBpc051bGxgLCBgaXNOdW1iZXJgLFxuICAgICAqIGBpc09iamVjdGAsIGBpc1BsYWluT2JqZWN0YCwgYGlzUmVnRXhwYCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGpvaW5gLFxuICAgICAqIGBsYXN0SW5kZXhPZmAsIGBtaXhpbmAsIGBub0NvbmZsaWN0YCwgYHBhcnNlSW50YCwgYHBvcGAsIGByYW5kb21gLCBgcmVkdWNlYCxcbiAgICAgKiBgcmVkdWNlUmlnaHRgLCBgcmVzdWx0YCwgYHNoaWZ0YCwgYHNpemVgLCBgc29tZWAsIGBzb3J0ZWRJbmRleGAsIGBydW5JbkNvbnRleHRgLFxuICAgICAqIGB0ZW1wbGF0ZWAsIGB1bmVzY2FwZWAsIGB1bmlxdWVJZGAsIGFuZCBgdmFsdWVgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBmdW5jdGlvbnMgYGZpcnN0YCBhbmQgYGxhc3RgIHJldHVybiB3cmFwcGVkIHZhbHVlcyB3aGVuIGBuYCBpc1xuICAgICAqIHByb3ZpZGVkLCBvdGhlcndpc2UgdGhleSByZXR1cm4gdW53cmFwcGVkIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEV4cGxpY2l0IGNoYWluaW5nIGNhbiBiZSBlbmFibGVkIGJ5IHVzaW5nIHRoZSBgXy5jaGFpbmAgbWV0aG9kLlxuICAgICAqXG4gICAgICogQG5hbWUgX1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICAgICAqXG4gICAgICogLy8gcmV0dXJucyBhbiB1bndyYXBwZWQgdmFsdWVcbiAgICAgKiB3cmFwcGVkLnJlZHVjZShmdW5jdGlvbihzdW0sIG51bSkge1xuICAgICAqICAgcmV0dXJuIHN1bSArIG51bTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiAvLyByZXR1cm5zIGEgd3JhcHBlZCB2YWx1ZVxuICAgICAqIHZhciBzcXVhcmVzID0gd3JhcHBlZC5tYXAoZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtICogbnVtO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcy52YWx1ZSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9kYXNoKHZhbHVlKSB7XG4gICAgICAvLyBkb24ndCB3cmFwIGlmIGFscmVhZHkgd3JhcHBlZCwgZXZlbiBpZiB3cmFwcGVkIGJ5IGEgZGlmZmVyZW50IGBsb2Rhc2hgIGNvbnN0cnVjdG9yXG4gICAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fd3JhcHBlZF9fJykpXG4gICAgICAgPyB2YWx1ZVxuICAgICAgIDogbmV3IGxvZGFzaFdyYXBwZXIodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgZmFzdCBwYXRoIGZvciBjcmVhdGluZyBgbG9kYXNoYCB3cmFwcGVyIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNoYWluQWxsIEEgZmxhZyB0byBlbmFibGUgY2hhaW5pbmcgZm9yIGFsbCBtZXRob2RzXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZGFzaFdyYXBwZXIodmFsdWUsIGNoYWluQWxsKSB7XG4gICAgICB0aGlzLl9fY2hhaW5fXyA9ICEhY2hhaW5BbGw7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgfVxuICAgIC8vIGVuc3VyZSBgbmV3IGxvZGFzaFdyYXBwZXJgIGlzIGFuIGluc3RhbmNlIG9mIGBsb2Rhc2hgXG4gICAgbG9kYXNoV3JhcHBlci5wcm90b3R5cGUgPSBsb2Rhc2gucHJvdG90eXBlO1xuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHVzZWQgdG8gZmxhZyBlbnZpcm9ubWVudHMgZmVhdHVyZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICB2YXIgc3VwcG9ydCA9IGxvZGFzaC5zdXBwb3J0ID0ge307XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgZnVuY3Rpb25zIGNhbiBiZSBkZWNvbXBpbGVkIGJ5IGBGdW5jdGlvbiN0b1N0cmluZ2BcbiAgICAgKiAoYWxsIGJ1dCBQUzMgYW5kIG9sZGVyIE9wZXJhIG1vYmlsZSBicm93c2VycyAmIGF2b2lkZWQgaW4gV2luZG93cyA4IGFwcHMpLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0LmZ1bmNEZWNvbXAgPSAhaXNOYXRpdmUoY29udGV4dC5XaW5SVEVycm9yKSAmJiByZVRoaXMudGVzdChydW5JbkNvbnRleHQpO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIGBGdW5jdGlvbiNuYW1lYCBpcyBzdXBwb3J0ZWQgKGFsbCBidXQgSUUpLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0LmZ1bmNOYW1lcyA9IHR5cGVvZiBGdW5jdGlvbi5uYW1lID09ICdzdHJpbmcnO1xuXG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBMby1EYXNoIGFyZSBzaW1pbGFyIHRvIHRob3NlIGluXG4gICAgICogZW1iZWRkZWQgUnVieSAoRVJCKS4gQ2hhbmdlIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlXG4gICAgICogZGVsaW1pdGVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnZXNjYXBlJzogLzwlLShbXFxzXFxTXSs/KSU+L2csXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdldmFsdWF0ZSc6IC88JShbXFxzXFxTXSs/KSU+L2csXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAgICovXG4gICAgICAndmFyaWFibGUnOiAnJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgT2JqZWN0XG4gICAgICAgKi9cbiAgICAgICdpbXBvcnRzJzoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuICAgICAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgJ18nOiBsb2Rhc2hcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5iaW5kYCB0aGF0IGNyZWF0ZXMgdGhlIGJvdW5kIGZ1bmN0aW9uIGFuZFxuICAgICAqIHNldHMgaXRzIG1ldGEgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYmluZERhdGEgVGhlIGJpbmQgZGF0YSBhcnJheS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQmluZChiaW5kRGF0YSkge1xuICAgICAgdmFyIGZ1bmMgPSBiaW5kRGF0YVswXSxcbiAgICAgICAgICBwYXJ0aWFsQXJncyA9IGJpbmREYXRhWzJdLFxuICAgICAgICAgIHRoaXNBcmcgPSBiaW5kRGF0YVs0XTtcblxuICAgICAgZnVuY3Rpb24gYm91bmQoKSB7XG4gICAgICAgIC8vIGBGdW5jdGlvbiNiaW5kYCBzcGVjXG4gICAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMy40LjVcbiAgICAgICAgaWYgKHBhcnRpYWxBcmdzKSB7XG4gICAgICAgICAgLy8gYXZvaWQgYGFyZ3VtZW50c2Agb2JqZWN0IGRlb3B0aW1pemF0aW9ucyBieSB1c2luZyBgc2xpY2VgIGluc3RlYWRcbiAgICAgICAgICAvLyBvZiBgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGxgIGFuZCBub3QgYXNzaWduaW5nIGBhcmd1bWVudHNgIHRvIGFcbiAgICAgICAgICAvLyB2YXJpYWJsZSBhcyBhIHRlcm5hcnkgZXhwcmVzc2lvblxuICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UocGFydGlhbEFyZ3MpO1xuICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtaW1pYyB0aGUgY29uc3RydWN0b3IncyBgcmV0dXJuYCBiZWhhdmlvclxuICAgICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDEzLjIuMlxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIGBuZXcgYm91bmRgIGlzIGFuIGluc3RhbmNlIG9mIGBmdW5jYFxuICAgICAgICAgIHZhciB0aGlzQmluZGluZyA9IGJhc2VDcmVhdGUoZnVuYy5wcm90b3R5cGUpLFxuICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzIHx8IGFyZ3VtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzIHx8IGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBzZXRCaW5kRGF0YShib3VuZCwgYmluZERhdGEpO1xuICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCB3aXRob3V0IGFyZ3VtZW50IGp1Z2dsaW5nIG9yIHN1cHBvcnRcbiAgICAgKiBmb3IgYHRoaXNBcmdgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcD1mYWxzZV0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyBjbG9uZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBpc0RlZXAsIGNhbGxiYWNrLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaW5zcGVjdCBbW0NsYXNzXV1cbiAgICAgIHZhciBpc09iaiA9IGlzT2JqZWN0KHZhbHVlKTtcbiAgICAgIGlmIChpc09iaikge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICAgIGlmICghY2xvbmVhYmxlQ2xhc3Nlc1tjbGFzc05hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdG9yID0gY3RvckJ5Q2xhc3NbY2xhc3NOYW1lXTtcbiAgICAgICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgICAgICBjYXNlIGJvb2xDbGFzczpcbiAgICAgICAgICBjYXNlIGRhdGVDbGFzczpcbiAgICAgICAgICAgIHJldHVybiBuZXcgY3RvcigrdmFsdWUpO1xuXG4gICAgICAgICAgY2FzZSBudW1iZXJDbGFzczpcbiAgICAgICAgICBjYXNlIHN0cmluZ0NsYXNzOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHZhbHVlKTtcblxuICAgICAgICAgIGNhc2UgcmVnZXhwQ2xhc3M6XG4gICAgICAgICAgICByZXN1bHQgPSBjdG9yKHZhbHVlLnNvdXJjZSwgcmVGbGFncy5leGVjKHZhbHVlKSk7XG4gICAgICAgICAgICByZXN1bHQubGFzdEluZGV4ID0gdmFsdWUubGFzdEluZGV4O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gY29ycmVzcG9uZGluZyBjbG9uZVxuICAgICAgICB2YXIgaW5pdGVkU3RhY2sgPSAhc3RhY2tBO1xuICAgICAgICBzdGFja0EgfHwgKHN0YWNrQSA9IGdldEFycmF5KCkpO1xuICAgICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IGdldEFycmF5KCkpO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gaXNBcnIgPyBjdG9yKHZhbHVlLmxlbmd0aCkgOiB7fTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBpc0FyciA/IHNsaWNlKHZhbHVlKSA6IGFzc2lnbih7fSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gYWRkIGFycmF5IHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYFxuICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnaW5kZXgnKSkge1xuICAgICAgICAgIHJlc3VsdC5pbmRleCA9IHZhbHVlLmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnaW5wdXQnKSkge1xuICAgICAgICAgIHJlc3VsdC5pbnB1dCA9IHZhbHVlLmlucHV0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBleGl0IGZvciBzaGFsbG93IGNsb25lXG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgLy8gYWRkIHRoZSBzb3VyY2UgdmFsdWUgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzXG4gICAgICAvLyBhbmQgYXNzb2NpYXRlIGl0IHdpdGggaXRzIGNsb25lXG4gICAgICBzdGFja0EucHVzaCh2YWx1ZSk7XG4gICAgICBzdGFja0IucHVzaChyZXN1bHQpO1xuXG4gICAgICAvLyByZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAoaXNBcnIgPyBmb3JFYWNoIDogZm9yT3duKSh2YWx1ZSwgZnVuY3Rpb24ob2JqVmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGJhc2VDbG9uZShvYmpWYWx1ZSwgaXNEZWVwLCBjYWxsYmFjaywgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpbml0ZWRTdGFjaykge1xuICAgICAgICByZWxlYXNlQXJyYXkoc3RhY2tBKTtcbiAgICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAgICAgKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QocHJvdG90eXBlKSA/IG5hdGl2ZUNyZWF0ZShwcm90b3R5cGUpIDoge307XG4gICAgfVxuICAgIC8vIGZhbGxiYWNrIGZvciBicm93c2VycyB3aXRob3V0IGBPYmplY3QuY3JlYXRlYFxuICAgIGlmICghbmF0aXZlQ3JlYXRlKSB7XG4gICAgICBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBPYmplY3QoKSB7fVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocHJvdG90eXBlKSB7XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KHByb3RvdHlwZSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IE9iamVjdDtcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0IHx8IGNvbnRleHQuT2JqZWN0KCk7XG4gICAgICAgIH07XG4gICAgICB9KCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZUNhbGxiYWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNyZWF0aW5nXG4gICAgICogXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPWlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0aGUgY2FsbGJhY2sgYWNjZXB0cy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ3JlYXRlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIG5vIGB0aGlzQXJnYCBvciBhbHJlYWR5IGJvdW5kIGJ5IGBGdW5jdGlvbiNiaW5kYFxuICAgICAgaWYgKHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnIHx8ICEoJ3Byb3RvdHlwZScgaW4gZnVuYykpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9XG4gICAgICB2YXIgYmluZERhdGEgPSBmdW5jLl9fYmluZERhdGFfXztcbiAgICAgIGlmICh0eXBlb2YgYmluZERhdGEgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHN1cHBvcnQuZnVuY05hbWVzKSB7XG4gICAgICAgICAgYmluZERhdGEgPSAhZnVuYy5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGJpbmREYXRhID0gYmluZERhdGEgfHwgIXN1cHBvcnQuZnVuY0RlY29tcDtcbiAgICAgICAgaWYgKCFiaW5kRGF0YSkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBmblRvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgICAgICAgaWYgKCFzdXBwb3J0LmZ1bmNOYW1lcykge1xuICAgICAgICAgICAgYmluZERhdGEgPSAhcmVGdW5jTmFtZS50ZXN0KHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghYmluZERhdGEpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrcyBpZiBgZnVuY2AgcmVmZXJlbmNlcyB0aGUgYHRoaXNgIGtleXdvcmQgYW5kIHN0b3JlcyB0aGUgcmVzdWx0XG4gICAgICAgICAgICBiaW5kRGF0YSA9IHJlVGhpcy50ZXN0KHNvdXJjZSk7XG4gICAgICAgICAgICBzZXRCaW5kRGF0YShmdW5jLCBiaW5kRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBleGl0IGVhcmx5IGlmIHRoZXJlIGFyZSBubyBgdGhpc2AgcmVmZXJlbmNlcyBvciBgZnVuY2AgaXMgYm91bmRcbiAgICAgIGlmIChiaW5kRGF0YSA9PT0gZmFsc2UgfHwgKGJpbmREYXRhICE9PSB0cnVlICYmIGJpbmREYXRhWzFdICYgMSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGFyZ0NvdW50KSB7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGEsIGIpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJpbmQoZnVuYywgdGhpc0FyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGNyZWF0ZVdyYXBwZXJgIHRoYXQgY3JlYXRlcyB0aGUgd3JhcHBlciBhbmRcbiAgICAgKiBzZXRzIGl0cyBtZXRhIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGJpbmREYXRhIFRoZSBiaW5kIGRhdGEgYXJyYXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNyZWF0ZVdyYXBwZXIoYmluZERhdGEpIHtcbiAgICAgIHZhciBmdW5jID0gYmluZERhdGFbMF0sXG4gICAgICAgICAgYml0bWFzayA9IGJpbmREYXRhWzFdLFxuICAgICAgICAgIHBhcnRpYWxBcmdzID0gYmluZERhdGFbMl0sXG4gICAgICAgICAgcGFydGlhbFJpZ2h0QXJncyA9IGJpbmREYXRhWzNdLFxuICAgICAgICAgIHRoaXNBcmcgPSBiaW5kRGF0YVs0XSxcbiAgICAgICAgICBhcml0eSA9IGJpbmREYXRhWzVdO1xuXG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIDEsXG4gICAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIDIsXG4gICAgICAgICAgaXNDdXJyeSA9IGJpdG1hc2sgJiA0LFxuICAgICAgICAgIGlzQ3VycnlCb3VuZCA9IGJpdG1hc2sgJiA4LFxuICAgICAgICAgIGtleSA9IGZ1bmM7XG5cbiAgICAgIGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcztcbiAgICAgICAgaWYgKHBhcnRpYWxBcmdzKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShwYXJ0aWFsQXJncyk7XG4gICAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFsUmlnaHRBcmdzIHx8IGlzQ3VycnkpIHtcbiAgICAgICAgICBhcmdzIHx8IChhcmdzID0gc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgICAgaWYgKHBhcnRpYWxSaWdodEFyZ3MpIHtcbiAgICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgcGFydGlhbFJpZ2h0QXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0N1cnJ5ICYmIGFyZ3MubGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICAgIGJpdG1hc2sgfD0gMTYgJiB+MzI7XG4gICAgICAgICAgICByZXR1cm4gYmFzZUNyZWF0ZVdyYXBwZXIoW2Z1bmMsIChpc0N1cnJ5Qm91bmQgPyBiaXRtYXNrIDogYml0bWFzayAmIH4zKSwgYXJncywgbnVsbCwgdGhpc0FyZywgYXJpdHldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXJncyB8fCAoYXJncyA9IGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChpc0JpbmRLZXkpIHtcbiAgICAgICAgICBmdW5jID0gdGhpc0JpbmRpbmdba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKGZ1bmMucHJvdG90eXBlKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICB9XG4gICAgICBzZXRCaW5kRGF0YShib3VuZCwgYmluZERhdGEpO1xuICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRpZmZlcmVuY2VgIHRoYXQgYWNjZXB0cyBhIHNpbmdsZSBhcnJheVxuICAgICAqIG9mIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgYXJyYXkgb2YgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICBpc0xhcmdlID0gbGVuZ3RoID49IGxhcmdlQXJyYXlTaXplICYmIGluZGV4T2YgPT09IGJhc2VJbmRleE9mLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgICB2YXIgY2FjaGUgPSBjcmVhdGVDYWNoZSh2YWx1ZXMpO1xuICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICBpbmRleE9mID0gY2FjaGVJbmRleE9mO1xuICAgICAgICAgIHZhbHVlcyA9IGNhY2hlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzTGFyZ2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAoaW5kZXhPZih2YWx1ZXMsIHZhbHVlKSA8IDApIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICAgIHJlbGVhc2VPYmplY3QodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgb3IgYHRoaXNBcmdgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU2hhbGxvdz1mYWxzZV0gQSBmbGFnIHRvIHJlc3RyaWN0IGZsYXR0ZW5pbmcgdG8gYSBzaW5nbGUgbGV2ZWwuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3Q9ZmFsc2VdIEEgZmxhZyB0byByZXN0cmljdCBmbGF0dGVuaW5nIHRvIGFycmF5cyBhbmQgYGFyZ3VtZW50c2Agb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc3RhcnQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBpc1NoYWxsb3csIGlzU3RyaWN0LCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBpbmRleCA9IChmcm9tSW5kZXggfHwgMCkgLSAxLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PSAnbnVtYmVyJ1xuICAgICAgICAgICAgJiYgKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgICAvLyByZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAgICAgaWYgKCFpc1NoYWxsb3cpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZUZsYXR0ZW4odmFsdWUsIGlzU2hhbGxvdywgaXNTdHJpY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsSW5kZXggPSAtMSxcbiAgICAgICAgICAgICAgdmFsTGVuZ3RoID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICAgICAgICByZXNJbmRleCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgICAgICByZXN1bHQubGVuZ3RoICs9IHZhbExlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoKyt2YWxJbmRleCA8IHZhbExlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWVbdmFsSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAsIHdpdGhvdXQgc3VwcG9ydCBmb3IgYHRoaXNBcmdgIGJpbmRpbmcsXG4gICAgICogdGhhdCBhbGxvd3MgcGFydGlhbCBcIl8ud2hlcmVcIiBzdHlsZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBhIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gYiBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXNXaGVyZT1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIHBlcmZvcm1pbmcgcGFydGlhbCBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIGBhYCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIFRyYWNrcyB0cmF2ZXJzZWQgYGJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbChhLCBiLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIC8vIHVzZWQgdG8gaW5kaWNhdGUgdGhhdCB3aGVuIGNvbXBhcmluZyBvYmplY3RzLCBgYWAgaGFzIGF0IGxlYXN0IHRoZSBwcm9wZXJ0aWVzIG9mIGBiYFxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjayhhLCBiKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIGlkZW50aWNhbCB2YWx1ZXNcbiAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIC8vIHRyZWF0IGArMGAgdnMuIGAtMGAgYXMgbm90IGVxdWFsXG4gICAgICAgIHJldHVybiBhICE9PSAwIHx8ICgxIC8gYSA9PSAxIC8gYik7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBhLFxuICAgICAgICAgIG90aGVyVHlwZSA9IHR5cGVvZiBiO1xuXG4gICAgICAvLyBleGl0IGVhcmx5IGZvciB1bmxpa2UgcHJpbWl0aXZlIHZhbHVlc1xuICAgICAgaWYgKGEgPT09IGEgJiZcbiAgICAgICAgICAhKGEgJiYgb2JqZWN0VHlwZXNbdHlwZV0pICYmXG4gICAgICAgICAgIShiICYmIG9iamVjdFR5cGVzW290aGVyVHlwZV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXZvaWRpbmcgRVMzJ3MgRnVuY3Rpb24jY2FsbCBiZWhhdmlvclxuICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4zLjQuNFxuICAgICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgICB9XG4gICAgICAvLyBjb21wYXJlIFtbQ2xhc3NdXSBuYW1lc1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwoYSksXG4gICAgICAgICAgb3RoZXJDbGFzcyA9IHRvU3RyaW5nLmNhbGwoYik7XG5cbiAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJnc0NsYXNzKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IG9iamVjdENsYXNzO1xuICAgICAgfVxuICAgICAgaWYgKG90aGVyQ2xhc3MgPT0gYXJnc0NsYXNzKSB7XG4gICAgICAgIG90aGVyQ2xhc3MgPSBvYmplY3RDbGFzcztcbiAgICAgIH1cbiAgICAgIGlmIChjbGFzc05hbWUgIT0gb3RoZXJDbGFzcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgICBjYXNlIGJvb2xDbGFzczpcbiAgICAgICAgY2FzZSBkYXRlQ2xhc3M6XG4gICAgICAgICAgLy8gY29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1iZXJzLCBkYXRlcyB0byBtaWxsaXNlY29uZHMgYW5kIGJvb2xlYW5zXG4gICAgICAgICAgLy8gdG8gYDFgIG9yIGAwYCB0cmVhdGluZyBpbnZhbGlkIGRhdGVzIGNvZXJjZWQgdG8gYE5hTmAgYXMgbm90IGVxdWFsXG4gICAgICAgICAgcmV0dXJuICthID09ICtiO1xuXG4gICAgICAgIGNhc2UgbnVtYmVyQ2xhc3M6XG4gICAgICAgICAgLy8gdHJlYXQgYE5hTmAgdnMuIGBOYU5gIGFzIGVxdWFsXG4gICAgICAgICAgcmV0dXJuIChhICE9ICthKVxuICAgICAgICAgICAgPyBiICE9ICtiXG4gICAgICAgICAgICAvLyBidXQgdHJlYXQgYCswYCB2cy4gYC0wYCBhcyBub3QgZXF1YWxcbiAgICAgICAgICAgIDogKGEgPT0gMCA/ICgxIC8gYSA9PSAxIC8gYikgOiBhID09ICtiKTtcblxuICAgICAgICBjYXNlIHJlZ2V4cENsYXNzOlxuICAgICAgICBjYXNlIHN0cmluZ0NsYXNzOlxuICAgICAgICAgIC8vIGNvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgKGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMTAuNi40KVxuICAgICAgICAgIC8vIHRyZWF0IHN0cmluZyBwcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCBpbnN0YW5jZXMgYXMgZXF1YWxcbiAgICAgICAgICByZXR1cm4gYSA9PSBTdHJpbmcoYik7XG4gICAgICB9XG4gICAgICB2YXIgaXNBcnIgPSBjbGFzc05hbWUgPT0gYXJyYXlDbGFzcztcbiAgICAgIGlmICghaXNBcnIpIHtcbiAgICAgICAgLy8gdW53cmFwIGFueSBgbG9kYXNoYCB3cmFwcGVkIHZhbHVlc1xuICAgICAgICB2YXIgYVdyYXBwZWQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICAgICAgYldyYXBwZWQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgICAgIGlmIChhV3JhcHBlZCB8fCBiV3JhcHBlZCkge1xuICAgICAgICAgIHJldHVybiBiYXNlSXNFcXVhbChhV3JhcHBlZCA/IGEuX193cmFwcGVkX18gOiBhLCBiV3JhcHBlZCA/IGIuX193cmFwcGVkX18gOiBiLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV4aXQgZm9yIGZ1bmN0aW9ucyBhbmQgRE9NIG5vZGVzXG4gICAgICAgIGlmIChjbGFzc05hbWUgIT0gb2JqZWN0Q2xhc3MpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW4gb2xkZXIgdmVyc2lvbnMgb2YgT3BlcmEsIGBhcmd1bWVudHNgIG9iamVjdHMgaGF2ZSBgQXJyYXlgIGNvbnN0cnVjdG9yc1xuICAgICAgICB2YXIgY3RvckEgPSBhLmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgY3RvckIgPSBiLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIC8vIG5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsXG4gICAgICAgIGlmIChjdG9yQSAhPSBjdG9yQiAmJlxuICAgICAgICAgICAgICAhKGlzRnVuY3Rpb24oY3RvckEpICYmIGN0b3JBIGluc3RhbmNlb2YgY3RvckEgJiYgaXNGdW5jdGlvbihjdG9yQikgJiYgY3RvckIgaW5zdGFuY2VvZiBjdG9yQikgJiZcbiAgICAgICAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGFzc3VtZSBjeWNsaWMgc3RydWN0dXJlcyBhcmUgZXF1YWxcbiAgICAgIC8vIHRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWMgc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xXG4gICAgICAvLyBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gIChodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEyLjMpXG4gICAgICB2YXIgaW5pdGVkU3RhY2sgPSAhc3RhY2tBO1xuICAgICAgc3RhY2tBIHx8IChzdGFja0EgPSBnZXRBcnJheSgpKTtcbiAgICAgIHN0YWNrQiB8fCAoc3RhY2tCID0gZ2V0QXJyYXkoKSk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PSBhKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdID09IGI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBzaXplID0gMDtcbiAgICAgIHJlc3VsdCA9IHRydWU7XG5cbiAgICAgIC8vIGFkZCBgYWAgYW5kIGBiYCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHNcbiAgICAgIHN0YWNrQS5wdXNoKGEpO1xuICAgICAgc3RhY2tCLnB1c2goYik7XG5cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cylcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICAvLyBjb21wYXJlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeVxuICAgICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgICAgc2l6ZSA9IGIubGVuZ3RoO1xuICAgICAgICByZXN1bHQgPSBzaXplID09IGxlbmd0aDtcblxuICAgICAgICBpZiAocmVzdWx0IHx8IGlzV2hlcmUpIHtcbiAgICAgICAgICAvLyBkZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzXG4gICAgICAgICAgd2hpbGUgKHNpemUtLSkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gYltzaXplXTtcblxuICAgICAgICAgICAgaWYgKGlzV2hlcmUpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoKHJlc3VsdCA9IGJhc2VJc0VxdWFsKGFbaW5kZXhdLCB2YWx1ZSwgY2FsbGJhY2ssIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKSkpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghKHJlc3VsdCA9IGJhc2VJc0VxdWFsKGFbc2l6ZV0sIHZhbHVlLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBkZWVwIGNvbXBhcmUgb2JqZWN0cyB1c2luZyBgZm9ySW5gLCBpbnN0ZWFkIG9mIGBmb3JPd25gLCB0byBhdm9pZCBgT2JqZWN0LmtleXNgXG4gICAgICAgIC8vIHdoaWNoLCBpbiB0aGlzIGNhc2UsIGlzIG1vcmUgY29zdGx5XG4gICAgICAgIGZvckluKGIsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGIpIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXkpKSB7XG4gICAgICAgICAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIHByb3BlcnRpZXMuXG4gICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgICAvLyBkZWVwIGNvbXBhcmUgZWFjaCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgICAgICAgIHJldHVybiAocmVzdWx0ID0gaGFzT3duUHJvcGVydHkuY2FsbChhLCBrZXkpICYmIGJhc2VJc0VxdWFsKGFba2V5XSwgdmFsdWUsIGNhbGxiYWNrLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAmJiAhaXNXaGVyZSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBib3RoIG9iamVjdHMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllc1xuICAgICAgICAgIGZvckluKGEsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGEpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGtleSkpIHtcbiAgICAgICAgICAgICAgLy8gYHNpemVgIHdpbGwgYmUgYC0xYCBpZiBgYWAgaGFzIG1vcmUgcHJvcGVydGllcyB0aGFuIGBiYFxuICAgICAgICAgICAgICByZXR1cm4gKHJlc3VsdCA9IC0tc2l6ZSA+IC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2tBLnBvcCgpO1xuICAgICAgc3RhY2tCLnBvcCgpO1xuXG4gICAgICBpZiAoaW5pdGVkU3RhY2spIHtcbiAgICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQSk7XG4gICAgICAgIHJlbGVhc2VBcnJheShzdGFja0IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBhcmd1bWVudCBqdWdnbGluZyBvciBzdXBwb3J0XG4gICAgICogZm9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2luZyBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyB2YWx1ZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICAoaXNBcnJheShzb3VyY2UpID8gZm9yRWFjaCA6IGZvck93bikoc291cmNlLCBmdW5jdGlvbihzb3VyY2UsIGtleSkge1xuICAgICAgICB2YXIgZm91bmQsXG4gICAgICAgICAgICBpc0FycixcbiAgICAgICAgICAgIHJlc3VsdCA9IHNvdXJjZSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoKGlzQXJyID0gaXNBcnJheShzb3VyY2UpKSB8fCBpc1BsYWluT2JqZWN0KHNvdXJjZSkpKSB7XG4gICAgICAgICAgLy8gYXZvaWQgbWVyZ2luZyBwcmV2aW91c2x5IG1lcmdlZCBjeWNsaWMgc291cmNlc1xuICAgICAgICAgIHZhciBzdGFja0xlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHN0YWNrTGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIGlmICgoZm91bmQgPSBzdGFja0Fbc3RhY2tMZW5ndGhdID09IHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBzdGFja0Jbc3RhY2tMZW5ndGhdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgdmFyIGlzU2hhbGxvdztcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSwgc291cmNlKTtcbiAgICAgICAgICAgICAgaWYgKChpc1NoYWxsb3cgPSB0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzU2hhbGxvdykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGlzQXJyXG4gICAgICAgICAgICAgICAgPyAoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdKVxuICAgICAgICAgICAgICAgIDogKGlzUGxhaW5PYmplY3QodmFsdWUpID8gdmFsdWUgOiB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGQgYHNvdXJjZWAgYW5kIGFzc29jaWF0ZWQgYHZhbHVlYCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHNcbiAgICAgICAgICAgIHN0YWNrQS5wdXNoKHNvdXJjZSk7XG4gICAgICAgICAgICBzdGFja0IucHVzaCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAgICAgICBpZiAoIWlzU2hhbGxvdykge1xuICAgICAgICAgICAgICBiYXNlTWVyZ2UodmFsdWUsIHNvdXJjZSwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSwgc291cmNlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IGFyZ3VtZW50IGp1Z2dsaW5nIG9yIHN1cHBvcnRcbiAgICAgKiBmb3IgcmV0dXJuaW5nIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGEgcmFuZG9tIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZG9tKG1pbiwgbWF4KSB7XG4gICAgICByZXR1cm4gbWluICsgZmxvb3IobmF0aXZlUmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAqIG9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NvcnRlZD1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIHRoYXQgYGFycmF5YCBpcyBzb3J0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGlzU29ydGVkLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHZhciBpc0xhcmdlID0gIWlzU29ydGVkICYmIGxlbmd0aCA+PSBsYXJnZUFycmF5U2l6ZSAmJiBpbmRleE9mID09PSBiYXNlSW5kZXhPZixcbiAgICAgICAgICBzZWVuID0gKGNhbGxiYWNrIHx8IGlzTGFyZ2UpID8gZ2V0QXJyYXkoKSA6IHJlc3VsdDtcblxuICAgICAgaWYgKGlzTGFyZ2UpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gY3JlYXRlQ2FjaGUoc2Vlbik7XG4gICAgICAgIGluZGV4T2YgPSBjYWNoZUluZGV4T2Y7XG4gICAgICAgIHNlZW4gPSBjYWNoZTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gY2FsbGJhY2sgPyBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGFycmF5KSA6IHZhbHVlO1xuXG4gICAgICAgIGlmIChpc1NvcnRlZFxuICAgICAgICAgICAgICA/ICFpbmRleCB8fCBzZWVuW3NlZW4ubGVuZ3RoIC0gMV0gIT09IGNvbXB1dGVkXG4gICAgICAgICAgICAgIDogaW5kZXhPZihzZWVuLCBjb21wdXRlZCkgPCAwXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sgfHwgaXNMYXJnZSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgICByZWxlYXNlQXJyYXkoc2Vlbi5hcnJheSk7XG4gICAgICAgIHJlbGVhc2VPYmplY3Qoc2Vlbik7XG4gICAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHJlbGVhc2VBcnJheShzZWVuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWdncmVnYXRlcyBhIGNvbGxlY3Rpb24sIGNyZWF0aW5nIGFuIG9iamVjdCBjb21wb3NlZFxuICAgICAqIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiB0aHJvdWdoIGEgY2FsbGJhY2suIFRoZSBnaXZlbiBgc2V0dGVyYCBmdW5jdGlvbiBzZXRzIHRoZSBrZXlzIGFuZCB2YWx1ZXNcbiAgICAgKiBvZiB0aGUgY29tcG9zZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIHNldHRlciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3Ioc2V0dGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgICAgc2V0dGVyKHJlc3VsdCwgdmFsdWUsIGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbiksIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICAgICAgc2V0dGVyKHJlc3VsdCwgdmFsdWUsIGNhbGxiYWNrKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pLCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGVpdGhlciBjdXJyaWVzIG9yIGludm9rZXMgYGZ1bmNgXG4gICAgICogd2l0aCBhbiBvcHRpb25hbCBgdGhpc2AgYmluZGluZyBhbmQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gcmVmZXJlbmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIG1ldGhvZCBmbGFncyB0byBjb21wb3NlLlxuICAgICAqICBUaGUgYml0bWFzayBtYXkgYmUgY29tcG9zZWQgb2YgdGhlIGZvbGxvd2luZyBmbGFnczpcbiAgICAgKiAgMSAtIGBfLmJpbmRgXG4gICAgICogIDIgLSBgXy5iaW5kS2V5YFxuICAgICAqICA0IC0gYF8uY3VycnlgXG4gICAgICogIDggLSBgXy5jdXJyeWAgKGJvdW5kKVxuICAgICAqICAxNiAtIGBfLnBhcnRpYWxgXG4gICAgICogIDMyIC0gYF8ucGFydGlhbFJpZ2h0YFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsQXJnc10gQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2VcbiAgICAgKiAgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbFJpZ2h0QXJnc10gQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZVxuICAgICAqICBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVXcmFwcGVyKGZ1bmMsIGJpdG1hc2ssIHBhcnRpYWxBcmdzLCBwYXJ0aWFsUmlnaHRBcmdzLCB0aGlzQXJnLCBhcml0eSkge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiAxLFxuICAgICAgICAgIGlzQmluZEtleSA9IGJpdG1hc2sgJiAyLFxuICAgICAgICAgIGlzQ3VycnkgPSBiaXRtYXNrICYgNCxcbiAgICAgICAgICBpc0N1cnJ5Qm91bmQgPSBiaXRtYXNrICYgOCxcbiAgICAgICAgICBpc1BhcnRpYWwgPSBiaXRtYXNrICYgMTYsXG4gICAgICAgICAgaXNQYXJ0aWFsUmlnaHQgPSBiaXRtYXNrICYgMzI7XG5cbiAgICAgIGlmICghaXNCaW5kS2V5ICYmICFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAoaXNQYXJ0aWFsICYmICFwYXJ0aWFsQXJncy5sZW5ndGgpIHtcbiAgICAgICAgYml0bWFzayAmPSB+MTY7XG4gICAgICAgIGlzUGFydGlhbCA9IHBhcnRpYWxBcmdzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNQYXJ0aWFsUmlnaHQgJiYgIXBhcnRpYWxSaWdodEFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfjMyO1xuICAgICAgICBpc1BhcnRpYWxSaWdodCA9IHBhcnRpYWxSaWdodEFyZ3MgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBiaW5kRGF0YSA9IGZ1bmMgJiYgZnVuYy5fX2JpbmREYXRhX187XG4gICAgICBpZiAoYmluZERhdGEgJiYgYmluZERhdGEgIT09IHRydWUpIHtcbiAgICAgICAgLy8gY2xvbmUgYGJpbmREYXRhYFxuICAgICAgICBiaW5kRGF0YSA9IHNsaWNlKGJpbmREYXRhKTtcbiAgICAgICAgaWYgKGJpbmREYXRhWzJdKSB7XG4gICAgICAgICAgYmluZERhdGFbMl0gPSBzbGljZShiaW5kRGF0YVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpbmREYXRhWzNdKSB7XG4gICAgICAgICAgYmluZERhdGFbM10gPSBzbGljZShiaW5kRGF0YVszXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGB0aGlzQmluZGluZ2AgaXMgbm90IHByZXZpb3VzbHkgYm91bmRcbiAgICAgICAgaWYgKGlzQmluZCAmJiAhKGJpbmREYXRhWzFdICYgMSkpIHtcbiAgICAgICAgICBiaW5kRGF0YVs0XSA9IHRoaXNBcmc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGlmIHByZXZpb3VzbHkgYm91bmQgYnV0IG5vdCBjdXJyZW50bHkgKHN1YnNlcXVlbnQgY3VycmllZCBmdW5jdGlvbnMpXG4gICAgICAgIGlmICghaXNCaW5kICYmIGJpbmREYXRhWzFdICYgMSkge1xuICAgICAgICAgIGJpdG1hc2sgfD0gODtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgY3VycmllZCBhcml0eSBpZiBub3QgeWV0IHNldFxuICAgICAgICBpZiAoaXNDdXJyeSAmJiAhKGJpbmREYXRhWzFdICYgNCkpIHtcbiAgICAgICAgICBiaW5kRGF0YVs1XSA9IGFyaXR5O1xuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGVuZCBwYXJ0aWFsIGxlZnQgYXJndW1lbnRzXG4gICAgICAgIGlmIChpc1BhcnRpYWwpIHtcbiAgICAgICAgICBwdXNoLmFwcGx5KGJpbmREYXRhWzJdIHx8IChiaW5kRGF0YVsyXSA9IFtdKSwgcGFydGlhbEFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGVuZCBwYXJ0aWFsIHJpZ2h0IGFyZ3VtZW50c1xuICAgICAgICBpZiAoaXNQYXJ0aWFsUmlnaHQpIHtcbiAgICAgICAgICB1bnNoaWZ0LmFwcGx5KGJpbmREYXRhWzNdIHx8IChiaW5kRGF0YVszXSA9IFtdKSwgcGFydGlhbFJpZ2h0QXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgZmxhZ3NcbiAgICAgICAgYmluZERhdGFbMV0gfD0gYml0bWFzaztcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIuYXBwbHkobnVsbCwgYmluZERhdGEpO1xuICAgICAgfVxuICAgICAgLy8gZmFzdCBwYXRoIGZvciBgXy5iaW5kYFxuICAgICAgdmFyIGNyZWF0ZXIgPSAoYml0bWFzayA9PSAxIHx8IGJpdG1hc2sgPT09IDE3KSA/IGJhc2VCaW5kIDogYmFzZUNyZWF0ZVdyYXBwZXI7XG4gICAgICByZXR1cm4gY3JlYXRlcihbZnVuYywgYml0bWFzaywgcGFydGlhbEFyZ3MsIHBhcnRpYWxSaWdodEFyZ3MsIHRoaXNBcmcsIGFyaXR5XSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlSHRtbENoYXIobWF0Y2gpIHtcbiAgICAgIHJldHVybiBodG1sRXNjYXBlc1ttYXRjaF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJpbmRleE9mXCIgZnVuY3Rpb24uIElmIHRoZSBgXy5pbmRleE9mYCBtZXRob2QgaXNcbiAgICAgKiBjdXN0b21pemVkLCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBjdXN0b20gbWV0aG9kLCBvdGhlcndpc2UgaXQgcmV0dXJuc1xuICAgICAqIHRoZSBgYmFzZUluZGV4T2ZgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIFwiaW5kZXhPZlwiIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEluZGV4T2YoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gKHJlc3VsdCA9IGxvZGFzaC5pbmRleE9mKSA9PT0gaW5kZXhPZiA/IGJhc2VJbmRleE9mIDogcmVzdWx0O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyAmJiByZU5hdGl2ZS50ZXN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGB0aGlzYCBiaW5kaW5nIGRhdGEgb24gYSBnaXZlbiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gc2V0IGRhdGEgb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWUgVGhlIGRhdGEgYXJyYXkgdG8gc2V0LlxuICAgICAqL1xuICAgIHZhciBzZXRCaW5kRGF0YSA9ICFkZWZpbmVQcm9wZXJ0eSA/IG5vb3AgOiBmdW5jdGlvbihmdW5jLCB2YWx1ZSkge1xuICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IHZhbHVlO1xuICAgICAgZGVmaW5lUHJvcGVydHkoZnVuYywgJ19fYmluZERhdGFfXycsIGRlc2NyaXB0b3IpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIG9mIGBpc1BsYWluT2JqZWN0YCB3aGljaCBjaGVja3MgaWYgYSBnaXZlbiB2YWx1ZVxuICAgICAqIGlzIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3RvciwgYXNzdW1pbmcgb2JqZWN0cyBjcmVhdGVkXG4gICAgICogYnkgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yIGhhdmUgbm8gaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcyBhbmQgdGhhdFxuICAgICAqIHRoZXJlIGFyZSBubyBgT2JqZWN0LnByb3RvdHlwZWAgZXh0ZW5zaW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaGltSXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgdmFyIGN0b3IsXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICAvLyBhdm9pZCBub24gT2JqZWN0IG9iamVjdHMsIGBhcmd1bWVudHNgIG9iamVjdHMsIGFuZCBET00gZWxlbWVudHNcbiAgICAgIGlmICghKHZhbHVlICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IG9iamVjdENsYXNzKSB8fFxuICAgICAgICAgIChjdG9yID0gdmFsdWUuY29uc3RydWN0b3IsIGlzRnVuY3Rpb24oY3RvcikgJiYgIShjdG9yIGluc3RhbmNlb2YgY3RvcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEluIG1vc3QgZW52aXJvbm1lbnRzIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzIGFyZSBpdGVyYXRlZCBiZWZvcmVcbiAgICAgIC8vIGl0cyBpbmhlcml0ZWQgcHJvcGVydGllcy4gSWYgdGhlIGxhc3QgaXRlcmF0ZWQgcHJvcGVydHkgaXMgYW4gb2JqZWN0J3NcbiAgICAgIC8vIG93biBwcm9wZXJ0eSB0aGVuIHRoZXJlIGFyZSBubyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgZm9ySW4odmFsdWUsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHlwZW9mIHJlc3VsdCA9PSAndW5kZWZpbmVkJyB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCByZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYHVuZXNjYXBlYCB0byBjb252ZXJ0IEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byB1bmVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlSHRtbENoYXIobWF0Y2gpIHtcbiAgICAgIHJldHVybiBodG1sVW5lc2NhcGVzW21hdGNoXTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAoZnVuY3Rpb24oKSB7IHJldHVybiBfLmlzQXJndW1lbnRzKGFyZ3VtZW50cyk7IH0pKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICAgICAgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc0NsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAoZnVuY3Rpb24oKSB7IHJldHVybiBfLmlzQXJyYXkoYXJndW1lbnRzKTsgfSkoKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09ICdudW1iZXInICYmXG4gICAgICAgIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFycmF5Q2xhc3MgfHwgZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgYE9iamVjdC5rZXlzYCB3aGljaCBwcm9kdWNlcyBhbiBhcnJheSBvZiB0aGVcbiAgICAgKiBnaXZlbiBvYmplY3QncyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgdmFyIHNoaW1LZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gb2JqZWN0LCByZXN1bHQgPSBbXTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICBpZiAoIShvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0XSkpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGZvciAoaW5kZXggaW4gaXRlcmFibGUpIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChpdGVyYWJsZSwgaW5kZXgpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY29tcG9zZWQgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmtleXMoeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSk7XG4gICAgICogLy8gPT4gWydvbmUnLCAndHdvJywgJ3RocmVlJ10gKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgdmFyIGtleXMgPSAhbmF0aXZlS2V5cyA/IHNoaW1LZXlzIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllczpcbiAgICAgKlxuICAgICAqIFRob3VnaCB0aGUgYD5gIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlIGA+YCBhbmQgYC9gXG4gICAgICogZG9uJ3QgcmVxdWlyZSBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZyB1bmxlc3MgdGhleSdyZSBwYXJ0XG4gICAgICogb2YgYSB0YWcgb3IgYW4gdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLlxuICAgICAqIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKVxuICAgICAqL1xuICAgIHZhciBodG1sRXNjYXBlcyA9IHtcbiAgICAgICcmJzogJyZhbXA7JyxcbiAgICAgICc8JzogJyZsdDsnLFxuICAgICAgJz4nOiAnJmd0OycsXG4gICAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAgIFwiJ1wiOiAnJiMzOTsnXG4gICAgfTtcblxuICAgIC8qKiBVc2VkIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzICovXG4gICAgdmFyIGh0bWxVbmVzY2FwZXMgPSBpbnZlcnQoaHRtbEVzY2FwZXMpO1xuXG4gICAgLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzICovXG4gICAgdmFyIHJlRXNjYXBlZEh0bWwgPSBSZWdFeHAoJygnICsga2V5cyhodG1sVW5lc2NhcGVzKS5qb2luKCd8JykgKyAnKScsICdnJyksXG4gICAgICAgIHJlVW5lc2NhcGVkSHRtbCA9IFJlZ0V4cCgnWycgKyBrZXlzKGh0bWxFc2NhcGVzKS5qb2luKCcnKSArICddJywgJ2cnKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgdG8gdGhlIGRlc3RpbmF0aW9uXG4gICAgICogb2JqZWN0LiBTdWJzZXF1ZW50IHNvdXJjZXMgd2lsbCBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXNcbiAgICAgKiBzb3VyY2VzLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgdG8gcHJvZHVjZSB0aGVcbiAgICAgKiBhc3NpZ25lZCB2YWx1ZXMuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0d29cbiAgICAgKiBhcmd1bWVudHM7IChvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAYWxpYXMgZXh0ZW5kXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ25hbWUnOiAnZnJlZCcgfSwgeyAnZW1wbG95ZXInOiAnc2xhdGUnIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcsICdlbXBsb3llcic6ICdzbGF0ZScgfVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ24sIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgKiAgIHJldHVybiB0eXBlb2YgYSA9PSAndW5kZWZpbmVkJyA/IGIgOiBhO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnYmFybmV5JyB9O1xuICAgICAqIGRlZmF1bHRzKG9iamVjdCwgeyAnbmFtZSc6ICdmcmVkJywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdlbXBsb3llcic6ICdzbGF0ZScgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ24gPSBmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBpbmRleCwgaXRlcmFibGUgPSBvYmplY3QsIHJlc3VsdCA9IGl0ZXJhYmxlO1xuICAgICAgaWYgKCFpdGVyYWJsZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IDAsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IHR5cGVvZiBndWFyZCA9PSAnbnVtYmVyJyA/IDIgOiBhcmdzLmxlbmd0aDtcbiAgICAgIGlmIChhcmdzTGVuZ3RoID4gMyAmJiB0eXBlb2YgYXJnc1thcmdzTGVuZ3RoIC0gMl0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBiYXNlQ3JlYXRlQ2FsbGJhY2soYXJnc1stLWFyZ3NMZW5ndGggLSAxXSwgYXJnc1thcmdzTGVuZ3RoLS1dLCAyKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJnc0xlbmd0aCA+IDIgJiYgdHlwZW9mIGFyZ3NbYXJnc0xlbmd0aCAtIDFdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBhcmdzWy0tYXJnc0xlbmd0aF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIGl0ZXJhYmxlID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICBpZiAoaXRlcmFibGUgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSkge1xuICAgICAgICB2YXIgb3duSW5kZXggPSAtMSxcbiAgICAgICAgICAgIG93blByb3BzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSAmJiBrZXlzKGl0ZXJhYmxlKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG93blByb3BzID8gb3duUHJvcHMubGVuZ3RoIDogMDtcblxuICAgICAgICB3aGlsZSAoKytvd25JbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGluZGV4ID0gb3duUHJvcHNbb3duSW5kZXhdO1xuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBjYWxsYmFjayA/IGNhbGxiYWNrKHJlc3VsdFtpbmRleF0sIGl0ZXJhYmxlW2luZGV4XSkgOiBpdGVyYWJsZVtpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHZhbHVlYC4gSWYgYGlzRGVlcGAgaXMgYHRydWVgIG5lc3RlZCBvYmplY3RzIHdpbGwgYWxzb1xuICAgICAqIGJlIGNsb25lZCwgb3RoZXJ3aXNlIHRoZXkgd2lsbCBiZSBhc3NpZ25lZCBieSByZWZlcmVuY2UuIElmIGEgY2FsbGJhY2tcbiAgICAgKiBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZXMuIElmIHRoZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGAgY2xvbmluZyB3aWxsIGJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLlxuICAgICAqIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcD1mYWxzZV0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKGNoYXJhY3RlcnMpO1xuICAgICAqIHNoYWxsb3dbMF0gPT09IGNoYXJhY3RlcnNbMF07XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lKGNoYXJhY3RlcnMsIHRydWUpO1xuICAgICAqIGRlZXBbMF0gPT09IGNoYXJhY3RlcnNbMF07XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8ubWl4aW4oe1xuICAgICAqICAgJ2Nsb25lJzogXy5wYXJ0aWFsUmlnaHQoXy5jbG9uZSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICAgcmV0dXJuIF8uaXNFbGVtZW50KHZhbHVlKSA/IHZhbHVlLmNsb25lTm9kZShmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICogICB9KVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIGNsb25lID0gXy5jbG9uZShkb2N1bWVudC5ib2R5KTtcbiAgICAgKiBjbG9uZS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmUodmFsdWUsIGlzRGVlcCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIC8vIGFsbG93cyB3b3JraW5nIHdpdGggXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMgd2l0aG91dCB1c2luZyB0aGVpciBgaW5kZXhgXG4gICAgICAvLyBhbmQgYGNvbGxlY3Rpb25gIGFyZ3VtZW50cyBmb3IgYGlzRGVlcGAgYW5kIGBjYWxsYmFja2BcbiAgICAgIGlmICh0eXBlb2YgaXNEZWVwICE9ICdib29sZWFuJyAmJiBpc0RlZXAgIT0gbnVsbCkge1xuICAgICAgICB0aGlzQXJnID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrID0gaXNEZWVwO1xuICAgICAgICBpc0RlZXAgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIGlzRGVlcCwgdHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicgJiYgYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlZXAgY2xvbmUgb2YgYHZhbHVlYC4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlXG4gICAgICogZXhlY3V0ZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlcy4gSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBjbG9uaW5nIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0b1xuICAgICAqIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlIHN0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtLiBGdW5jdGlvbnNcbiAgICAgKiBhbmQgRE9NIG5vZGVzIGFyZSAqKm5vdCoqIGNsb25lZC4gVGhlIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFuZFxuICAgICAqIG9iamVjdHMgY3JlYXRlZCBieSBjb25zdHJ1Y3RvcnMgb3RoZXIgdGhhbiBgT2JqZWN0YCBhcmUgY2xvbmVkIHRvIHBsYWluIGBPYmplY3RgIG9iamVjdHMuXG4gICAgICogU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjaW50ZXJuYWwtc3RydWN0dXJlZC1jbG9uaW5nLWFsZ29yaXRobS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAoY2hhcmFjdGVycyk7XG4gICAgICogZGVlcFswXSA9PT0gY2hhcmFjdGVyc1swXTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIHZpZXcgPSB7XG4gICAgICogICAnbGFiZWwnOiAnZG9jcycsXG4gICAgICogICAnbm9kZSc6IGVsZW1lbnRcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGNsb25lID0gXy5jbG9uZURlZXAodmlldywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzRWxlbWVudCh2YWx1ZSkgPyB2YWx1ZS5jbG9uZU5vZGUodHJ1ZSkgOiB1bmRlZmluZWQ7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjbG9uZS5ub2RlID09IHZpZXcubm9kZTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIHRydWUsIHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nICYmIGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gYHByb3RvdHlwZWAgb2JqZWN0LiBJZiBhXG4gICAgICogYHByb3BlcnRpZXNgIG9iamVjdCBpcyBwcm92aWRlZCBpdHMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgYXNzaWduZWRcbiAgICAgKiB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgKiAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQ2lyY2xlLnByb3RvdHlwZSA9IF8uY3JlYXRlKFNoYXBlLnByb3RvdHlwZSwgeyAnY29uc3RydWN0b3InOiBDaXJjbGUgfSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBDaXJjbGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgU2hhcGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gcHJvcGVydGllcyA/IGFzc2lnbihyZXN1bHQsIHByb3BlcnRpZXMpIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICAgICAqIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBPbmNlIGFcbiAgICAgKiBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgZGVmYXVsdHMgb2YgdGhlIHNhbWUgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZV0gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBBbGxvd3Mgd29ya2luZyB3aXRoIGBfLnJlZHVjZWAgd2l0aG91dCB1c2luZyBpdHNcbiAgICAgKiAgYGtleWAgYW5kIGBvYmplY3RgIGFyZ3VtZW50cyBhcyBzb3VyY2VzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnYmFybmV5JyB9O1xuICAgICAqIF8uZGVmYXVsdHMob2JqZWN0LCB7ICduYW1lJzogJ2ZyZWQnLCAnZW1wbG95ZXInOiAnc2xhdGUnIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzID0gZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIGd1YXJkKSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gb2JqZWN0LCByZXN1bHQgPSBpdGVyYWJsZTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBhcmdzSW5kZXggPSAwLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSB0eXBlb2YgZ3VhcmQgPT0gJ251bWJlcicgPyAyIDogYXJncy5sZW5ndGg7XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIGl0ZXJhYmxlID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICBpZiAoaXRlcmFibGUgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSkge1xuICAgICAgICB2YXIgb3duSW5kZXggPSAtMSxcbiAgICAgICAgICAgIG93blByb3BzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSAmJiBrZXlzKGl0ZXJhYmxlKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG93blByb3BzID8gb3duUHJvcHMubGVuZ3RoIDogMDtcblxuICAgICAgICB3aGlsZSAoKytvd25JbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGluZGV4ID0gb3duUHJvcHNbb3duSW5kZXhdO1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0W2luZGV4XSA9PSAndW5kZWZpbmVkJykgcmVzdWx0W2luZGV4XSA9IGl0ZXJhYmxlW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEluZGV4YCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBrZXkgb2YgdGhlXG4gICAgICogZmlyc3QgZWxlbWVudCB0aGF0IHBhc3NlcyB0aGUgY2FsbGJhY2sgY2hlY2ssIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyXG4gICAgICogIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG9cbiAgICAgKiAgY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiB7ICAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgICdmcmVkJzogeyAgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZEtleShjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leScgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRLZXkoY2hhcmFjdGVycywgeyAnYWdlJzogMSB9KTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEtleShjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRLZXkob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRLZXlgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXJcbiAgICAgKiAgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0b1xuICAgICAqICBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6IHsgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6IHsgICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0S2V5KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPCA0MDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiByZXR1cm5zIGBwZWJibGVzYCwgYXNzdW1pbmcgYF8uZmluZEtleWAgcmV0dXJucyBgYmFybmV5YFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEtleShjaGFyYWN0ZXJzLCB7ICdhZ2UnOiA0MCB9KTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RLZXkoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEtleShvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgZm9yT3duUmlnaHQob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0LFxuICAgICAqIGV4ZWN1dGluZyB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBrZXksIG9iamVjdCkuIENhbGxiYWNrcyBtYXkgZXhpdFxuICAgICAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBTaGFwZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHRoaXMueCArPSB4O1xuICAgICAqICAgdGhpcy55ICs9IHk7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZm9ySW4obmV3IFNoYXBlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ3gnLCAneScsIGFuZCAnbW92ZScgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgdmFyIGZvckluID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCwgaXRlcmFibGUgPSBjb2xsZWN0aW9uLCByZXN1bHQgPSBpdGVyYWJsZTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICBpZiAoIW9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0pIHJldHVybiByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrICYmIHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnID8gY2FsbGJhY2sgOiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICBmb3IgKGluZGV4IGluIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pID09PSBmYWxzZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckluYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogU2hhcGUucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICB0aGlzLnggKz0geDtcbiAgICAgKiAgIHRoaXMueSArPSB5O1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZvckluUmlnaHQobmV3IFNoYXBlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ21vdmUnLCAneScsIGFuZCAneCcgYXNzdW1pbmcgYF8uZm9ySW4gYCBsb2dzICd4JywgJ3knLCBhbmQgJ21vdmUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ySW5SaWdodChvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcGFpcnMgPSBbXTtcblxuICAgICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHBhaXJzLnB1c2goa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHBhaXJzLmxlbmd0aDtcbiAgICAgIGNhbGxiYWNrID0gYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoY2FsbGJhY2socGFpcnNbbGVuZ3RoLS1dLCBwYWlyc1tsZW5ndGhdLCBvYmplY3QpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3QsIGV4ZWN1dGluZyB0aGUgY2FsbGJhY2tcbiAgICAgKiBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGtleSwgb2JqZWN0KS4gQ2FsbGJhY2tzIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieVxuICAgICAqIGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvck93bih7ICcwJzogJ3plcm8nLCAnMSc6ICdvbmUnLCAnbGVuZ3RoJzogMiB9LCBmdW5jdGlvbihudW0sIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICcwJywgJzEnLCBhbmQgJ2xlbmd0aCcgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgdmFyIGZvck93biA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gY29sbGVjdGlvbiwgcmVzdWx0ID0gaXRlcmFibGU7XG4gICAgICBpZiAoIWl0ZXJhYmxlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgaWYgKCFvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdKSByZXR1cm4gcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayAmJiB0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrIDogYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgdmFyIG93bkluZGV4ID0gLTEsXG4gICAgICAgICAgICBvd25Qcm9wcyA9IG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0gJiYga2V5cyhpdGVyYWJsZSksXG4gICAgICAgICAgICBsZW5ndGggPSBvd25Qcm9wcyA/IG93blByb3BzLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgd2hpbGUgKCsrb3duSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpbmRleCA9IG93blByb3BzW293bkluZGV4XTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2soaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbikgPT09IGZhbHNlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yT3duYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yT3duUmlnaHQoeyAnMCc6ICd6ZXJvJywgJzEnOiAnb25lJywgJ2xlbmd0aCc6IDIgfSwgZnVuY3Rpb24obnVtLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnbGVuZ3RoJywgJzEnLCBhbmQgJzAnIGFzc3VtaW5nIGBfLmZvck93bmAgbG9ncyAnMCcsICcxJywgYW5kICdsZW5ndGgnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yT3duUmlnaHQob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgY2FsbGJhY2sgPSBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tsZW5ndGhdO1xuICAgICAgICBpZiAoY2FsbGJhY2sob2JqZWN0W2tleV0sIGtleSwgb2JqZWN0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc29ydGVkIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIG9mIGFsbCBlbnVtZXJhYmxlIHByb3BlcnRpZXMsXG4gICAgICogb3duIGFuZCBpbmhlcml0ZWQsIG9mIGBvYmplY3RgIHRoYXQgaGF2ZSBmdW5jdGlvbiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgbWV0aG9kc1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHRoYXQgaGF2ZSBmdW5jdGlvbiB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZnVuY3Rpb25zKF8pO1xuICAgICAqIC8vID0+IFsnYWxsJywgJ2FueScsICdiaW5kJywgJ2JpbmRBbGwnLCAnY2xvbmUnLCAnY29tcGFjdCcsICdjb21wb3NlJywgLi4uXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9ucyhvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQuc29ydCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IG5hbWUgZXhpc3RzIGFzIGEgZGlyZWN0IHByb3BlcnR5IG9mIGBvYmplY3RgLFxuICAgICAqIGluc3RlYWQgb2YgYW4gaW5oZXJpdGVkIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYga2V5IGlzIGEgZGlyZWN0IHByb3BlcnR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaGFzKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCAnYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXMob2JqZWN0LCBrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPyBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBpbnZlcnRlZCBrZXlzIGFuZCB2YWx1ZXMgb2YgdGhlIGdpdmVuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjcmVhdGVkIGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnZlcnQoeyAnZmlyc3QnOiAnZnJlZCcsICdzZWNvbmQnOiAnYmFybmV5JyB9KTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogJ2ZpcnN0JywgJ2Jhcm5leSc6ICdzZWNvbmQnIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZlcnQob2JqZWN0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIHJlc3VsdFtvYmplY3Rba2V5XV0gPSBrZXk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYm9vbGVhbiB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgYm9vbGVhbiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZSB8fFxuICAgICAgICB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYm9vbENsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZGF0ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgZGF0ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZShuZXcgRGF0ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBkYXRlQ2xhc3MgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgRE9NIGVsZW1lbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLm5vZGVUeXBlID09PSAxIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGVtcHR5LiBBcnJheXMsIHN0cmluZ3MsIG9yIGBhcmd1bWVudHNgIG9iamVjdHMgd2l0aCBhXG4gICAgICogbGVuZ3RoIG9mIGAwYCBhbmQgb2JqZWN0cyB3aXRoIG5vIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIGNvbnNpZGVyZWRcbiAgICAgKiBcImVtcHR5XCIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSgnJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwodmFsdWUpLFxuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblxuICAgICAgaWYgKChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcyB8fCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IGFyZ3NDbGFzcyApIHx8XG4gICAgICAgICAgKGNsYXNzTmFtZSA9PSBvYmplY3RDbGFzcyAmJiB0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInICYmIGlzRnVuY3Rpb24odmFsdWUuc3BsaWNlKSkpIHtcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICB9XG4gICAgICBmb3JPd24odmFsdWUsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKHJlc3VsdCA9IGZhbHNlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gICAgICogZXF1aXZhbGVudCB0byBlYWNoIG90aGVyLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWRcbiAgICAgKiB0byBjb21wYXJlIHZhbHVlcy4gSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGAgY29tcGFyaXNvbnMgd2lsbFxuICAgICAqIGJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOyAoYSwgYikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gYSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IGIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICAgKiB2YXIgY29weSA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICAgKlxuICAgICAqIG9iamVjdCA9PSBjb3B5O1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwob2JqZWN0LCBjb3B5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgd29yZHMgPSBbJ2hlbGxvJywgJ2dvb2RieWUnXTtcbiAgICAgKiB2YXIgb3RoZXJXb3JkcyA9IFsnaGknLCAnZ29vZGJ5ZSddO1xuICAgICAqXG4gICAgICogXy5pc0VxdWFsKHdvcmRzLCBvdGhlcldvcmRzLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICogICB2YXIgcmVHcmVldCA9IC9eKD86aGVsbG98aGkpJC9pLFxuICAgICAqICAgICAgIGFHcmVldCA9IF8uaXNTdHJpbmcoYSkgJiYgcmVHcmVldC50ZXN0KGEpLFxuICAgICAqICAgICAgIGJHcmVldCA9IF8uaXNTdHJpbmcoYikgJiYgcmVHcmVldC50ZXN0KGIpO1xuICAgICAqXG4gICAgICogICByZXR1cm4gKGFHcmVldCB8fCBiR3JlZXQpID8gKGFHcmVldCA9PSBiR3JlZXQpIDogdW5kZWZpbmVkO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VxdWFsKGEsIGIsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWwoYSwgYiwgdHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicgJiYgYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMsIG9yIGNhbiBiZSBjb2VyY2VkIHRvLCBhIGZpbml0ZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIGlzIG5vdCB0aGUgc2FtZSBhcyBuYXRpdmUgYGlzRmluaXRlYCB3aGljaCB3aWxsIHJldHVybiB0cnVlIGZvclxuICAgICAqIGJvb2xlYW5zIGFuZCBlbXB0eSBzdHJpbmdzLiBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4xLjIuNS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGZpbml0ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKC0xMDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoJzEwJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSh0cnVlKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgnJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGaW5pdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBuYXRpdmVJc0Zpbml0ZSh2YWx1ZSkgJiYgIW5hdGl2ZUlzTmFOKHBhcnNlRmxvYXQodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oXyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgbGFuZ3VhZ2UgdHlwZSBvZiBPYmplY3QuXG4gICAgICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdCh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgLy8gY2hlY2sgaWYgdGhlIHZhbHVlIGlzIHRoZSBFQ01BU2NyaXB0IGxhbmd1YWdlIHR5cGUgb2YgT2JqZWN0XG4gICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDhcbiAgICAgIC8vIGFuZCBhdm9pZCBhIFY4IGJ1Z1xuICAgICAgLy8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MVxuICAgICAgcmV0dXJuICEhKHZhbHVlICYmIG9iamVjdFR5cGVzW3R5cGVvZiB2YWx1ZV0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBOYU5gLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBpcyBub3QgdGhlIHNhbWUgYXMgbmF0aXZlIGBpc05hTmAgd2hpY2ggd2lsbCByZXR1cm4gYHRydWVgIGZvclxuICAgICAqIGB1bmRlZmluZWRgIGFuZCBvdGhlciBub24tbnVtZXJpYyB2YWx1ZXMuIFNlZSBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi40LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hTihOYU4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4obmV3IE51bWJlcihOYU4pKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBpc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG4gICAgICAvLyBgTmFOYCBhcyBhIHByaW1pdGl2ZSBpcyB0aGUgb25seSB2YWx1ZSB0aGF0IGlzIG5vdCBlcXVhbCB0byBpdHNlbGZcbiAgICAgIC8vIChwZXJmb3JtIHRoZSBbW0NsYXNzXV0gY2hlY2sgZmlyc3QgdG8gYXZvaWQgZXJyb3JzIHdpdGggc29tZSBob3N0IG9iamVjdHMgaW4gSUUpXG4gICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlICE9ICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBgbnVsbGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bGwobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bGwodW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgbnVtYmVyLlxuICAgICAqXG4gICAgICogTm90ZTogYE5hTmAgaXMgY29uc2lkZXJlZCBhIG51bWJlci4gU2VlIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4OC41LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcig4LjQgKiA1KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHxcbiAgICAgICAgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IG51bWJlckNsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QobmV3IFNoYXBlKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICB2YXIgaXNQbGFpbk9iamVjdCA9ICFnZXRQcm90b3R5cGVPZiA/IHNoaW1Jc1BsYWluT2JqZWN0IDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICghKHZhbHVlICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IG9iamVjdENsYXNzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YsXG4gICAgICAgICAgb2JqUHJvdG8gPSBpc05hdGl2ZSh2YWx1ZU9mKSAmJiAob2JqUHJvdG8gPSBnZXRQcm90b3R5cGVPZih2YWx1ZU9mKSkgJiYgZ2V0UHJvdG90eXBlT2Yob2JqUHJvdG8pO1xuXG4gICAgICByZXR1cm4gb2JqUHJvdG9cbiAgICAgICAgPyAodmFsdWUgPT0gb2JqUHJvdG8gfHwgZ2V0UHJvdG90eXBlT2YodmFsdWUpID09IG9ialByb3RvKVxuICAgICAgICA6IHNoaW1Jc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKC9mcmVkLyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUmVnRXhwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IHJlZ2V4cENsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygnZnJlZCcpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICAgICB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3RyaW5nQ2xhc3MgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICd1bmRlZmluZWQnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyBgb2JqZWN0YCBhbmQgdmFsdWVzIGdlbmVyYXRlZCBieVxuICAgICAqIHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJvdWdoIHRoZSBjYWxsYmFjay5cbiAgICAgKiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggdmFsdWVzIG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggYGNhbGxiYWNrYCBleGVjdXRpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwVmFsdWVzKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogM30gLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAqIDM7IH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAzLCAnYic6IDYsICdjJzogOSB9XG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IHtcbiAgICAgKiAgICdmcmVkJzogeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXBWYWx1ZXMoY2hhcmFjdGVycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICBmb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2JqZWN0KHMpLCB0aGF0XG4gICAgICogZG9uJ3QgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBpbnRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlc1xuICAgICAqIHdpbGwgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuIElmIGEgY2FsbGJhY2sgaXNcbiAgICAgKiBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uXG4gICAgICogYW5kIHNvdXJjZSBwcm9wZXJ0aWVzLiBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgdW5kZWZpbmVkYCBtZXJnaW5nIHdpbGxcbiAgICAgKiBiZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czsgKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZV0gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnaW5nIHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbmFtZXMgPSB7XG4gICAgICogICAnY2hhcmFjdGVycyc6IFtcbiAgICAgKiAgICAgeyAnbmFtZSc6ICdiYXJuZXknIH0sXG4gICAgICogICAgIHsgJ25hbWUnOiAnZnJlZCcgfVxuICAgICAqICAgXVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgYWdlcyA9IHtcbiAgICAgKiAgICdjaGFyYWN0ZXJzJzogW1xuICAgICAqICAgICB7ICdhZ2UnOiAzNiB9LFxuICAgICAqICAgICB7ICdhZ2UnOiA0MCB9XG4gICAgICogICBdXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2UobmFtZXMsIGFnZXMpO1xuICAgICAqIC8vID0+IHsgJ2NoYXJhY3RlcnMnOiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSwgeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH1dIH1cbiAgICAgKlxuICAgICAqIHZhciBmb29kID0ge1xuICAgICAqICAgJ2ZydWl0cyc6IFsnYXBwbGUnXSxcbiAgICAgKiAgICd2ZWdldGFibGVzJzogWydiZWV0J11cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIG90aGVyRm9vZCA9IHtcbiAgICAgKiAgICdmcnVpdHMnOiBbJ2JhbmFuYSddLFxuICAgICAqICAgJ3ZlZ2V0YWJsZXMnOiBbJ2NhcnJvdCddXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2UoZm9vZCwgb3RoZXJGb29kLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICogICByZXR1cm4gXy5pc0FycmF5KGEpID8gYS5jb25jYXQoYikgOiB1bmRlZmluZWQ7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnZnJ1aXRzJzogWydhcHBsZScsICdiYW5hbmEnXSwgJ3ZlZ2V0YWJsZXMnOiBbJ2JlZXQnLCAnY2Fycm90XSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2Uob2JqZWN0KSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBsZW5ndGggPSAyO1xuXG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cbiAgICAgIC8vIGFsbG93cyB3b3JraW5nIHdpdGggYF8ucmVkdWNlYCBhbmQgYF8ucmVkdWNlUmlnaHRgIHdpdGhvdXQgdXNpbmdcbiAgICAgIC8vIHRoZWlyIGBpbmRleGAgYW5kIGBjb2xsZWN0aW9uYCBhcmd1bWVudHNcbiAgICAgIGlmICh0eXBlb2YgYXJnc1syXSAhPSAnbnVtYmVyJykge1xuICAgICAgICBsZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGggPiAzICYmIHR5cGVvZiBhcmdzW2xlbmd0aCAtIDJdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYmFzZUNyZWF0ZUNhbGxiYWNrKGFyZ3NbLS1sZW5ndGggLSAxXSwgYXJnc1tsZW5ndGgtLV0sIDIpO1xuICAgICAgfSBlbHNlIGlmIChsZW5ndGggPiAyICYmIHR5cGVvZiBhcmdzW2xlbmd0aCAtIDFdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBhcmdzWy0tbGVuZ3RoXTtcbiAgICAgIH1cbiAgICAgIHZhciBzb3VyY2VzID0gc2xpY2UoYXJndW1lbnRzLCAxLCBsZW5ndGgpLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgc3RhY2tBID0gZ2V0QXJyYXkoKSxcbiAgICAgICAgICBzdGFja0IgPSBnZXRBcnJheSgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2VzW2luZGV4XSwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgIH1cbiAgICAgIHJlbGVhc2VBcnJheShzdGFja0EpO1xuICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQik7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGBvYmplY3RgIGV4Y2x1ZGluZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICogUHJvcGVydHkgbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXMgb2ZcbiAgICAgKiBwcm9wZXJ0eSBuYW1lcy4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIGZvciBlYWNoXG4gICAgICogcHJvcGVydHkgb2YgYG9iamVjdGAgb21pdHRpbmcgdGhlIHByb3BlcnRpZXMgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXlcbiAgICAgKiBmb3IuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnwuLi5zdHJpbmd8c3RyaW5nW119IFtjYWxsYmFja10gVGhlIHByb3BlcnRpZXMgdG8gb21pdCBvciB0aGVcbiAgICAgKiAgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aG91dCB0aGUgb21pdHRlZCBwcm9wZXJ0aWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm9taXQoeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnIH1cbiAgICAgKlxuICAgICAqIF8ub21pdCh7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcic7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gb21pdChvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHByb3BzID0gW107XG4gICAgICAgIGZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgIHByb3BzLnB1c2goa2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb3BzID0gYmFzZURpZmZlcmVuY2UocHJvcHMsIGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgZmFsc2UsIDEpKTtcblxuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICAgIGlmICghY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdHdvIGRpbWVuc2lvbmFsIGFycmF5IG9mIGFuIG9iamVjdCdzIGtleS12YWx1ZSBwYWlycyxcbiAgICAgKiBpLmUuIGBbW2tleTEsIHZhbHVlMV0sIFtrZXkyLCB2YWx1ZTJdXWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBuZXcgYXJyYXkgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhaXJzKHsgJ2Jhcm5leSc6IDM2LCAnZnJlZCc6IDQwIH0pO1xuICAgICAqIC8vID0+IFtbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgNDBdXSAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWlycyhvYmplY3QpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gW2tleSwgb2JqZWN0W2tleV1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgb2JqZWN0YCBjb21wb3NlZCBvZiB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICogUHJvcGVydHkgbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXMgb2ZcbiAgICAgKiBwcm9wZXJ0eSBuYW1lcy4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIGZvciBlYWNoXG4gICAgICogcHJvcGVydHkgb2YgYG9iamVjdGAgcGlja2luZyB0aGUgcHJvcGVydGllcyB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleVxuICAgICAqIGZvci4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufC4uLnN0cmluZ3xzdHJpbmdbXX0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlclxuICAgICAqICBpdGVyYXRpb24gb3IgcHJvcGVydHkgbmFtZXMgdG8gcGljaywgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgcHJvcGVydHlcbiAgICAgKiAgbmFtZXMgb3IgYXJyYXlzIG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5waWNrKHsgJ25hbWUnOiAnZnJlZCcsICdfdXNlcmlkJzogJ2ZyZWQxJyB9LCAnbmFtZScpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcgfVxuICAgICAqXG4gICAgICogXy5waWNrKHsgJ25hbWUnOiAnZnJlZCcsICdfdXNlcmlkJzogJ2ZyZWQxJyB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICByZXR1cm4ga2V5LmNoYXJBdCgwKSAhPSAnXyc7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcGljayhvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBwcm9wcyA9IGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgZmFsc2UsIDEpLFxuICAgICAgICAgICAgbGVuZ3RoID0gaXNPYmplY3Qob2JqZWN0KSA/IHByb3BzLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIGFsdGVybmF0aXZlIHRvIGBfLnJlZHVjZWAgdGhpcyBtZXRob2QgdHJhbnNmb3JtcyBgb2JqZWN0YCB0byBhIG5ld1xuICAgICAqIGBhY2N1bXVsYXRvcmAgb2JqZWN0IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgcnVubmluZyBlYWNoIG9mIGl0cyBvd25cbiAgICAgKiBlbnVtZXJhYmxlIHByb3BlcnRpZXMgdGhyb3VnaCBhIGNhbGxiYWNrLCB3aXRoIGVhY2ggY2FsbGJhY2sgZXhlY3V0aW9uXG4gICAgICogcG90ZW50aWFsbHkgbXV0YXRpbmcgdGhlIGBhY2N1bXVsYXRvcmAgb2JqZWN0LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czsgKGFjY3VtdWxhdG9yLCB2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqIENhbGxiYWNrcyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGN1c3RvbSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzcXVhcmVzID0gXy50cmFuc2Zvcm0oWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwXSwgZnVuY3Rpb24ocmVzdWx0LCBudW0pIHtcbiAgICAgKiAgIG51bSAqPSBudW07XG4gICAgICogICBpZiAobnVtICUgMikge1xuICAgICAqICAgICByZXR1cm4gcmVzdWx0LnB1c2gobnVtKSA8IDM7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzEsIDksIDI1XVxuICAgICAqXG4gICAgICogdmFyIG1hcHBlZCA9IF8udHJhbnNmb3JtKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCBmdW5jdGlvbihyZXN1bHQsIG51bSwga2V5KSB7XG4gICAgICogICByZXN1bHRba2V5XSA9IG51bSAqIDM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDMsICdiJzogNiwgJ2MnOiA5IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0ob2JqZWN0LCBjYWxsYmFjaywgYWNjdW11bGF0b3IsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkob2JqZWN0KTtcbiAgICAgIGlmIChhY2N1bXVsYXRvciA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc0Fycikge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGN0b3IgPSBvYmplY3QgJiYgb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgICBwcm90byA9IGN0b3IgJiYgY3Rvci5wcm90b3R5cGU7XG5cbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGJhc2VDcmVhdGUocHJvdG8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDQpO1xuICAgICAgICAoaXNBcnIgPyBmb3JFYWNoIDogZm9yT3duKShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIG9iamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY29tcG9zZWQgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy52YWx1ZXMoeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gb2JqZWN0W3Byb3BzW2luZGV4XV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBmcm9tIHRoZSBzcGVjaWZpZWQgaW5kZXhlcywgb3Iga2V5cywgb2YgdGhlXG4gICAgICogYGNvbGxlY3Rpb25gLiBJbmRleGVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzXG4gICAgICogb2YgaW5kZXhlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdfHN0cmluZ3xzdHJpbmdbXSl9IFtpbmRleF0gVGhlIGluZGV4ZXMgb2YgYGNvbGxlY3Rpb25gXG4gICAgICogICB0byByZXRyaWV2ZSwgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgaW5kZXhlcyBvciBhcnJheXMgb2YgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgY29ycmVzcG9uZGluZyB0byB0aGVcbiAgICAgKiAgcHJvdmlkZWQgaW5kZXhlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hdChbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddLCBbMCwgMiwgNF0pO1xuICAgICAqIC8vID0+IFsnYScsICdjJywgJ2UnXVxuICAgICAqXG4gICAgICogXy5hdChbJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnXSwgMCwgMik7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF0KGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgcHJvcHMgPSBiYXNlRmxhdHRlbihhcmdzLCB0cnVlLCBmYWxzZSwgMSksXG4gICAgICAgICAgbGVuZ3RoID0gKGFyZ3NbMl0gJiYgYXJnc1syXVthcmdzWzFdXSA9PT0gY29sbGVjdGlvbikgPyAxIDogcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGNvbGxlY3Rpb25bcHJvcHNbaW5kZXhdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gdmFsdWUgaXMgcHJlc2VudCBpbiBhIGNvbGxlY3Rpb24gdXNpbmcgc3RyaWN0IGVxdWFsaXR5XG4gICAgICogZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQgaXMgdXNlZCBhcyB0aGVcbiAgICAgKiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGluY2x1ZGVcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBjaGVjayBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHRhcmdldGAgZWxlbWVudCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvbnRhaW5zKFsxLCAyLCAzXSwgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5jb250YWlucyhbMSwgMiwgM10sIDEsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmNvbnRhaW5zKHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9LCAnZnJlZCcpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uY29udGFpbnMoJ3BlYmJsZXMnLCAnZWInKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udGFpbnMoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgZnJvbUluZGV4ID0gKGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgoMCwgbGVuZ3RoICsgZnJvbUluZGV4KSA6IGZyb21JbmRleCkgfHwgMDtcbiAgICAgIGlmIChpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHJlc3VsdCA9IGluZGV4T2YoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpID4gLTE7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmVzdWx0ID0gKGlzU3RyaW5nKGNvbGxlY3Rpb24pID8gY29sbGVjdGlvbi5pbmRleE9mKHRhcmdldCwgZnJvbUluZGV4KSA6IGluZGV4T2YoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpKSA+IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKCsraW5kZXggPj0gZnJvbUluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gIShyZXN1bHQgPSB2YWx1ZSA9PT0gdGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocm91Z2ggdGhlIGNhbGxiYWNrLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZVxuICAgICAqIG9mIGVhY2gga2V5IGlzIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGtleSB3YXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrLlxuICAgICAqIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs0LjMsIDYuMSwgNi40XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBNYXRoLmZsb29yKG51bSk7IH0pO1xuICAgICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs0LjMsIDYuMSwgNi40XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLmZsb29yKG51bSk7IH0sIE1hdGgpO1xuICAgICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IDIsICc1JzogMSB9XG4gICAgICovXG4gICAgdmFyIGNvdW50QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpID8gcmVzdWx0W2tleV0rKyA6IHJlc3VsdFtrZXldID0gMSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkgdmFsdWUgZm9yICoqYWxsKiogZWxlbWVudHMgb2ZcbiAgICAgKiBhIGNvbGxlY3Rpb24uIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgYWxsXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzc2VkIHRoZSBjYWxsYmFjayBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmV2ZXJ5KFt0cnVlLCAxLCBudWxsLCAneWVzJ10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZXZlcnkoY2hhcmFjdGVycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZXZlcnkoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmVyeShjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gISFjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIChyZXN1bHQgPSAhIWNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAgICAgKiB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleSBmb3IuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgc2VsZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBlbGVtZW50cyB0aGF0IHBhc3NlZCB0aGUgY2FsbGJhY2sgY2hlY2suXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBldmVucyA9IF8uZmlsdGVyKFsxLCAyLCAzLCA0LCA1LCA2XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gJSAyID09IDA7IH0pO1xuICAgICAqIC8vID0+IFsyLCA0LCA2XVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmlsdGVyKGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1dXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbHRlcihjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0XG4gICAgICogdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkgZm9yLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGRldGVjdCwgZmluZFdoZXJlXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZChjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kKGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDEgfSk7XG4gICAgICogLy8gPT4gIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxLCAnYmxvY2tlZCc6IGZhbHNlIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3QoWzEsIDIsIDMsIDRdLCBmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gJSAyID09IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgZm9yRWFjaFJpZ2h0KGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYSBjb2xsZWN0aW9uLCBleGVjdXRpbmcgdGhlIGNhbGxiYWNrIGZvciBlYWNoXG4gICAgICogZWxlbWVudC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuIENhbGxiYWNrcyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnlcbiAgICAgKiBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogTm90ZTogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgYGxlbmd0aGAgcHJvcGVydHlcbiAgICAgKiBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgYF8uZm9ySW5gIG9yIGBfLmZvck93bmBcbiAgICAgKiBtYXkgYmUgdXNlZCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBlYWNoXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fHN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS5mb3JFYWNoKGZ1bmN0aW9uKG51bSkgeyBjb25zb2xlLmxvZyhudW0pOyB9KS5qb2luKCcsJyk7XG4gICAgICogLy8gPT4gbG9ncyBlYWNoIG51bWJlciBhbmQgcmV0dXJucyAnMSwyLDMnXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSwgZnVuY3Rpb24obnVtKSB7IGNvbnNvbGUubG9nKG51bSk7IH0pO1xuICAgICAqIC8vID0+IGxvZ3MgZWFjaCBudW1iZXIgYW5kIHJldHVybnMgdGhlIG9iamVjdCAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrICYmIHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnID8gY2FsbGJhY2sgOiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2soY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yRWFjaGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBlYWNoUmlnaHRcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLmZvckVhY2hSaWdodChmdW5jdGlvbihudW0pIHsgY29uc29sZS5sb2cobnVtKTsgfSkuam9pbignLCcpO1xuICAgICAqIC8vID0+IGxvZ3MgZWFjaCBudW1iZXIgZnJvbSByaWdodCB0byBsZWZ0IGFuZCByZXR1cm5zICczLDIsMSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoUmlnaHQoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayAmJiB0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrIDogYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjayhjb2xsZWN0aW9uW2xlbmd0aF0sIGxlbmd0aCwgY29sbGVjdGlvbikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcm9wcyA9IGtleXMoY29sbGVjdGlvbik7XG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBrZXkgPSBwcm9wcyA/IHByb3BzWy0tbGVuZ3RoXSA6IC0tbGVuZ3RoO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjb2xsZWN0aW9uW2tleV0sIGtleSwgY29sbGVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGEgY29sbGVjdGlvbiB0aHJvdWdoIHRoZSBjYWxsYmFjay4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVcbiAgICAgKiBvZiBlYWNoIGtleSBpcyBhbiBhcnJheSBvZiB0aGUgZWxlbWVudHMgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS5cbiAgICAgKiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ncm91cEJ5KFs0LjIsIDYuMSwgNi40XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBNYXRoLmZsb29yKG51bSk7IH0pO1xuICAgICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjRdIH1cbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNC4yLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gdGhpcy5mbG9vcihudW0pOyB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi40XSB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmdyb3VwQnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogWydvbmUnLCAndHdvJ10sICc1JzogWyd0aHJlZSddIH1cbiAgICAgKi9cbiAgICB2YXIgZ3JvdXBCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkgPyByZXN1bHRba2V5XSA6IHJlc3VsdFtrZXldID0gW10pLnB1c2godmFsdWUpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIHRoZSBjb2xsZWN0aW9uIHRocm91Z2ggdGhlIGdpdmVuIGNhbGxiYWNrLiBUaGUgY29ycmVzcG9uZGluZ1xuICAgICAqIHZhbHVlIG9mIGVhY2gga2V5IGlzIHRoZSBsYXN0IGVsZW1lbnQgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS5cbiAgICAgKiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBrZXlzID0gW1xuICAgICAqICAgeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sXG4gICAgICogICB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uaW5kZXhCeShrZXlzLCAnZGlyJyk7XG4gICAgICogLy8gPT4geyAnbGVmdCc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAncmlnaHQnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKlxuICAgICAqIF8uaW5kZXhCeShrZXlzLCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoa2V5LmNvZGUpOyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICpcbiAgICAgKiBfLmluZGV4QnkoY2hhcmFjdGVycywgZnVuY3Rpb24oa2V5KSB7IHRoaXMuZnJvbUNoYXJDb2RlKGtleS5jb2RlKTsgfSwgU3RyaW5nKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICovXG4gICAgdmFyIGluZGV4QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBuYW1lZCBieSBgbWV0aG9kTmFtZWAgb24gZWFjaCBlbGVtZW50IGluIHRoZSBgY29sbGVjdGlvbmBcbiAgICAgKiByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC4gQWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICAgKiB3aWxsIGJlIHByb3ZpZGVkIHRvIGVhY2ggaW52b2tlZCBtZXRob2QuIElmIGBtZXRob2ROYW1lYCBpcyBhIGZ1bmN0aW9uIGl0XG4gICAgICogd2lsbCBiZSBpbnZva2VkIGZvciwgYW5kIGB0aGlzYCBib3VuZCB0bywgZWFjaCBlbGVtZW50IGluIHRoZSBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlIG9yXG4gICAgICogIHRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnZva2UoW1s1LCAxLCA3XSwgWzMsIDIsIDFdXSwgJ3NvcnQnKTtcbiAgICAgKiAvLyA9PiBbWzEsIDUsIDddLCBbMSwgMiwgM11dXG4gICAgICpcbiAgICAgKiBfLmludm9rZShbMTIzLCA0NTZdLCBTdHJpbmcucHJvdG90eXBlLnNwbGl0LCAnJyk7XG4gICAgICogLy8gPT4gW1snMScsICcyJywgJzMnXSwgWyc0JywgJzUnLCAnNiddXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludm9rZShjb2xsZWN0aW9uLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMiksXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBpc0Z1bmMgPSB0eXBlb2YgbWV0aG9kTmFtZSA9PSAnZnVuY3Rpb24nLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyA/IGxlbmd0aCA6IDApO1xuXG4gICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IChpc0Z1bmMgPyBtZXRob2ROYW1lIDogdmFsdWVbbWV0aG9kTmFtZV0pLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvblxuICAgICAqIHRocm91Z2ggdGhlIGNhbGxiYWNrLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGNvbGxlY3RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggYGNhbGxiYWNrYCBleGVjdXRpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gKiAzOyB9KTtcbiAgICAgKiAvLyA9PiBbMywgNiwgOV1cbiAgICAgKlxuICAgICAqIF8ubWFwKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICogMzsgfSk7XG4gICAgICogLy8gPT4gWzMsIDYsIDldIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcChjaGFyYWN0ZXJzLCAnbmFtZScpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGNhbGxiYWNrKGNvbGxlY3Rpb25baW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGNhbGxiYWNrKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGEgY29sbGVjdGlvbi4gSWYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkgb3JcbiAgICAgKiBmYWxzZXkgYC1JbmZpbml0eWAgaXMgcmV0dXJuZWQuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZFxuICAgICAqIGZvciBlYWNoIHZhbHVlIGluIHRoZSBjb2xsZWN0aW9uIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2ggdGhlIHZhbHVlXG4gICAgICogaXMgcmFua2VkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWF4KFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gOFxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1heChjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHsgcmV0dXJuIGNoci5hZ2U7IH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9O1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXgoY2hhcmFjdGVycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9O1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGNvbXB1dGVkID0gLUluZmluaXR5LFxuICAgICAgICAgIHJlc3VsdCA9IGNvbXB1dGVkO1xuXG4gICAgICAvLyBhbGxvd3Mgd29ya2luZyB3aXRoIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAgd2l0aG91dCB1c2luZ1xuICAgICAgLy8gdGhlaXIgYGluZGV4YCBhcmd1bWVudCBhcyBhIGNhbGxiYWNrXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicgJiYgdGhpc0FyZyAmJiB0aGlzQXJnW2NhbGxiYWNrXSA9PT0gY29sbGVjdGlvbikge1xuICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2sgPT0gbnVsbCAmJiBpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICBpZiAodmFsdWUgPiByZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgPSAoY2FsbGJhY2sgPT0gbnVsbCAmJiBpc1N0cmluZyhjb2xsZWN0aW9uKSlcbiAgICAgICAgICA/IGNoYXJBdENhbGxiYWNrXG4gICAgICAgICAgOiBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIGlmIChjdXJyZW50ID4gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGNvbXB1dGVkID0gY3VycmVudDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgbWluaW11bSB2YWx1ZSBvZiBhIGNvbGxlY3Rpb24uIElmIHRoZSBjb2xsZWN0aW9uIGlzIGVtcHR5IG9yXG4gICAgICogZmFsc2V5IGBJbmZpbml0eWAgaXMgcmV0dXJuZWQuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZFxuICAgICAqIGZvciBlYWNoIHZhbHVlIGluIHRoZSBjb2xsZWN0aW9uIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2ggdGhlIHZhbHVlXG4gICAgICogaXMgcmFua2VkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWluKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1pbihjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHsgcmV0dXJuIGNoci5hZ2U7IH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1pbihjaGFyYWN0ZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaW4oY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBjb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICAgIHJlc3VsdCA9IGNvbXB1dGVkO1xuXG4gICAgICAvLyBhbGxvd3Mgd29ya2luZyB3aXRoIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAgd2l0aG91dCB1c2luZ1xuICAgICAgLy8gdGhlaXIgYGluZGV4YCBhcmd1bWVudCBhcyBhIGNhbGxiYWNrXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicgJiYgdGhpc0FyZyAmJiB0aGlzQXJnW2NhbGxiYWNrXSA9PT0gY29sbGVjdGlvbikge1xuICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2sgPT0gbnVsbCAmJiBpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICBpZiAodmFsdWUgPCByZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgPSAoY2FsbGJhY2sgPT0gbnVsbCAmJiBpc1N0cmluZyhjb2xsZWN0aW9uKSlcbiAgICAgICAgICA/IGNoYXJBdENhbGxiYWNrXG4gICAgICAgICAgOiBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIGlmIChjdXJyZW50IDwgY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGNvbXB1dGVkID0gY3VycmVudDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgb2YgYSBzcGVjaWZpZWQgcHJvcGVydHkgZnJvbSBhbGwgZWxlbWVudHMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBwbHVjay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucGx1Y2soY2hhcmFjdGVycywgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICB2YXIgcGx1Y2sgPSBtYXA7XG5cbiAgICAvKipcbiAgICAgKiBSZWR1Y2VzIGEgY29sbGVjdGlvbiB0byBhIHZhbHVlIHdoaWNoIGlzIHRoZSBhY2N1bXVsYXRlZCByZXN1bHQgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvbiB0aHJvdWdoIHRoZSBjYWxsYmFjaywgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gICAgICogY2FsbGJhY2sgZXhlY3V0aW9uIGNvbnN1bWVzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzIGV4ZWN1dGlvbi4gSWZcbiAgICAgKiBgYWNjdW11bGF0b3JgIGlzIG5vdCBwcm92aWRlZCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgY29sbGVjdGlvbiB3aWxsIGJlXG4gICAgICogdXNlZCBhcyB0aGUgaW5pdGlhbCBgYWNjdW11bGF0b3JgIHZhbHVlLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czsgKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBmb2xkbCwgaW5qZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gSW5pdGlhbCB2YWx1ZSBvZiB0aGUgYWNjdW11bGF0b3IuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc3VtID0gXy5yZWR1Y2UoWzEsIDIsIDNdLCBmdW5jdGlvbihzdW0sIG51bSkge1xuICAgICAqICAgcmV0dXJuIHN1bSArIG51bTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiB2YXIgbWFwcGVkID0gXy5yZWR1Y2UoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sIGZ1bmN0aW9uKHJlc3VsdCwgbnVtLCBrZXkpIHtcbiAgICAgKiAgIHJlc3VsdFtrZXldID0gbnVtICogMztcbiAgICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAzLCAnYic6IDYsICdjJzogOSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCBhY2N1bXVsYXRvciwgdGhpc0FyZykge1xuICAgICAgaWYgKCFjb2xsZWN0aW9uKSByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgICB2YXIgbm9hY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDQpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKG5vYWNjdW0pIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGNvbGxlY3Rpb25bKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCBjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBub2FjY3VtXG4gICAgICAgICAgICA/IChub2FjY3VtID0gZmFsc2UsIHZhbHVlKVxuICAgICAgICAgICAgOiBjYWxsYmFjayhhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJlZHVjZWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBmb2xkclxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIEluaXRpYWwgdmFsdWUgb2YgdGhlIGFjY3VtdWxhdG9yLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGxpc3QgPSBbWzAsIDFdLCBbMiwgM10sIFs0LCA1XV07XG4gICAgICogdmFyIGZsYXQgPSBfLnJlZHVjZVJpZ2h0KGxpc3QsIGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEuY29uY2F0KGIpOyB9LCBbXSk7XG4gICAgICogLy8gPT4gWzQsIDUsIDIsIDMsIDAsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlUmlnaHQoY29sbGVjdGlvbiwgY2FsbGJhY2ssIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbm9hY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDQpO1xuICAgICAgZm9yRWFjaFJpZ2h0KGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBhY2N1bXVsYXRvciA9IG5vYWNjdW1cbiAgICAgICAgICA/IChub2FjY3VtID0gZmFsc2UsIHZhbHVlKVxuICAgICAgICAgIDogY2FsbGJhY2soYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uZmlsdGVyYCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBlbGVtZW50cyBvZiBhXG4gICAgICogY29sbGVjdGlvbiB0aGF0IHRoZSBjYWxsYmFjayBkb2VzICoqbm90KiogcmV0dXJuIHRydWV5IGZvci5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBlbGVtZW50cyB0aGF0IGZhaWxlZCB0aGUgY2FsbGJhY2sgY2hlY2suXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvZGRzID0gXy5yZWplY3QoWzEsIDIsIDMsIDQsIDUsIDZdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAlIDIgPT0gMDsgfSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDVdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5yZWplY3QoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVqZWN0KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlamVjdChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgcmV0dXJuIGZpbHRlcihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuICFjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgcmFuZG9tIGVsZW1lbnQgb3IgYG5gIHJhbmRvbSBlbGVtZW50cyBmcm9tIGEgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gQWxsb3dzIHdvcmtpbmcgd2l0aCBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgXG4gICAgICogIHdpdGhvdXQgdXNpbmcgdGhlaXIgYGluZGV4YCBhcmd1bWVudHMgYXMgYG5gLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIHNhbXBsZShzKSBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zYW1wbGUoWzEsIDIsIDMsIDRdLCAyKTtcbiAgICAgKiAvLyA9PiBbMywgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW1wbGUoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uICYmIHR5cGVvZiBjb2xsZWN0aW9uLmxlbmd0aCAhPSAnbnVtYmVyJykge1xuICAgICAgICBjb2xsZWN0aW9uID0gdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgICAgfVxuICAgICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkge1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb25bYmFzZVJhbmRvbSgwLCBjb2xsZWN0aW9uLmxlbmd0aCAtIDEpXSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzaHVmZmxlKGNvbGxlY3Rpb24pO1xuICAgICAgcmVzdWx0Lmxlbmd0aCA9IG5hdGl2ZU1pbihuYXRpdmVNYXgoMCwgbiksIHJlc3VsdC5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHNodWZmbGVkIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZSBGaXNoZXItWWF0ZXNcbiAgICAgKiBzaHVmZmxlLiBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXItWWF0ZXNfc2h1ZmZsZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBzaHVmZmxlZCBjb2xsZWN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNodWZmbGUoWzEsIDIsIDMsIDQsIDUsIDZdKTtcbiAgICAgKiAvLyA9PiBbNCwgMSwgNiwgMywgNSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyA/IGxlbmd0aCA6IDApO1xuXG4gICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciByYW5kID0gYmFzZVJhbmRvbSgwLCArK2luZGV4KTtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHJlc3VsdFtyYW5kXTtcbiAgICAgICAgcmVzdWx0W3JhbmRdID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2l6ZSBvZiB0aGUgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBgY29sbGVjdGlvbi5sZW5ndGhgIGZvciBhcnJheXNcbiAgICAgKiBhbmQgYXJyYXktbGlrZSBvYmplY3RzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYGNvbGxlY3Rpb24ubGVuZ3RoYCBvciBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaXplKFsxLCAyXSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zaXplKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uc2l6ZSgncGViYmxlcycpO1xuICAgICAqIC8vID0+IDdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgPyBsZW5ndGggOiBrZXlzKGNvbGxlY3Rpb24pLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYSB0cnVleSB2YWx1ZSBmb3IgKiphbnkqKiBlbGVtZW50IG9mIGFcbiAgICAgKiBjb2xsZWN0aW9uLiBUaGUgZnVuY3Rpb24gcmV0dXJucyBhcyBzb29uIGFzIGl0IGZpbmRzIGEgcGFzc2luZyB2YWx1ZSBhbmRcbiAgICAgKiBkb2VzIG5vdCBpdGVyYXRlIG92ZXIgdGhlIGVudGlyZSBjb2xsZWN0aW9uLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGFueVxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VkIHRoZSBjYWxsYmFjayBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvbWUoW251bGwsIDAsICd5ZXMnLCBmYWxzZV0sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvbWUoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvbWUoY2hhcmFjdGVycywgeyAnYWdlJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvbWUoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKChyZXN1bHQgPSBjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuICEocmVzdWx0ID0gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24gdGhyb3VnaCB0aGUgY2FsbGJhY2suIFRoaXMgbWV0aG9kXG4gICAgICogcGVyZm9ybXMgYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgd2lsbCBwcmVzZXJ2ZSB0aGUgb3JpZ2luYWwgc29ydCBvcmRlclxuICAgICAqIG9mIGVxdWFsIGVsZW1lbnRzLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjb2xsZWN0aW9uXG4gICAgICogd2lsbCBiZSBzb3J0ZWQgYnkgZWFjaCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBzb3J0ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBNYXRoLnNpbihudW0pOyB9KTtcbiAgICAgKiAvLyA9PiBbMywgMSwgMl1cbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLnNpbihudW0pOyB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiBbMywgMSwgMl1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAyNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDMwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXAoXy5zb3J0QnkoY2hhcmFjdGVycywgJ2FnZScpLCBfLnZhbHVlcyk7XG4gICAgICogLy8gPT4gW1snYmFybmV5JywgMjZdLCBbJ2ZyZWQnLCAzMF0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCA0MF1dXG4gICAgICpcbiAgICAgKiAvLyBzb3J0aW5nIGJ5IG11bHRpcGxlIHByb3BlcnRpZXNcbiAgICAgKiBfLm1hcChfLnNvcnRCeShjaGFyYWN0ZXJzLCBbJ25hbWUnLCAnYWdlJ10pLCBfLnZhbHVlcyk7XG4gICAgICogLy8gPSA+IFtbJ2Jhcm5leScsIDI2XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDMwXSwgWydmcmVkJywgNDBdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRCeShjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNBcnIgPSBpc0FycmF5KGNhbGxiYWNrKSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgPyBsZW5ndGggOiAwKTtcblxuICAgICAgaWYgKCFpc0Fycikge1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB9XG4gICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IHJlc3VsdFsrK2luZGV4XSA9IGdldE9iamVjdCgpO1xuICAgICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgICBvYmplY3QuY3JpdGVyaWEgPSBtYXAoY2FsbGJhY2ssIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKG9iamVjdC5jcml0ZXJpYSA9IGdldEFycmF5KCkpWzBdID0gY2FsbGJhY2sodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0LmluZGV4ID0gaW5kZXg7XG4gICAgICAgIG9iamVjdC52YWx1ZSA9IHZhbHVlO1xuICAgICAgfSk7XG5cbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICByZXN1bHQuc29ydChjb21wYXJlQXNjZW5kaW5nKTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgb2JqZWN0ID0gcmVzdWx0W2xlbmd0aF07XG4gICAgICAgIHJlc3VsdFtsZW5ndGhdID0gb2JqZWN0LnZhbHVlO1xuICAgICAgICBpZiAoIWlzQXJyKSB7XG4gICAgICAgICAgcmVsZWFzZUFycmF5KG9iamVjdC5jcml0ZXJpYSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVsZWFzZU9iamVjdChvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgYGNvbGxlY3Rpb25gIHRvIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgY29udmVydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAoZnVuY3Rpb24oKSB7IHJldHVybiBfLnRvQXJyYXkoYXJndW1lbnRzKS5zbGljZSgxKTsgfSkoMSwgMiwgMywgNCk7XG4gICAgICogLy8gPT4gWzIsIDMsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9BcnJheShjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiAmJiB0eXBlb2YgY29sbGVjdGlvbi5sZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlKGNvbGxlY3Rpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBvZiBlYWNoIGVsZW1lbnQgaW4gYSBgY29sbGVjdGlvbmAgdG8gdGhlIGdpdmVuXG4gICAgICogYHByb3BlcnRpZXNgIG9iamVjdCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50cyB0aGF0IGhhdmUgZXF1aXZhbGVudFxuICAgICAqIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIGdpdmVuIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdwZXRzJzogWydob3BweSddIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ3BldHMnOiBbJ2JhYnkgcHVzcycsICdkaW5vJ10gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLndoZXJlKGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ3BldHMnOiBbJ2hvcHB5J10gfV1cbiAgICAgKlxuICAgICAqIF8ud2hlcmUoY2hhcmFjdGVycywgeyAncGV0cyc6IFsnZGlubyddIH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdwZXRzJzogWydiYWJ5IHB1c3MnLCAnZGlubyddIH1dXG4gICAgICovXG4gICAgdmFyIHdoZXJlID0gZmlsdGVyO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHdpdGggYWxsIGZhbHNleSB2YWx1ZXMgcmVtb3ZlZC4gVGhlIHZhbHVlcyBgZmFsc2VgLCBgbnVsbGAsXG4gICAgICogYDBgLCBgXCJcImAsIGB1bmRlZmluZWRgLCBhbmQgYE5hTmAgYXJlIGFsbCBmYWxzZXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb21wYWN0KFswLCAxLCBmYWxzZSwgMiwgJycsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgZXhjbHVkaW5nIGFsbCB2YWx1ZXMgb2YgdGhlIHByb3ZpZGVkIGFycmF5cyB1c2luZyBzdHJpY3RcbiAgICAgKiBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIGFycmF5cyBvZiB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2UoWzEsIDIsIDMsIDQsIDVdLCBbNSwgMiwgMTBdKTtcbiAgICAgKiAvLyA9PiBbMSwgMywgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaWZmZXJlbmNlKGFycmF5KSB7XG4gICAgICByZXR1cm4gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSwgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCB0aGF0IHBhc3NlcyB0aGUgY2FsbGJhY2sgY2hlY2ssIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYmxvY2tlZCc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kSW5kZXgoY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA8IDIwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEluZGV4KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEluZGV4KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEluZGV4YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgoY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA+IDMwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RJbmRleChjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RJbmRleChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGZpcnN0IGVsZW1lbnQgb3IgZmlyc3QgYG5gIGVsZW1lbnRzIG9mIGFuIGFycmF5LiBJZiBhIGNhbGxiYWNrXG4gICAgICogaXMgcHJvdmlkZWQgZWxlbWVudHMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXkgYXJlIHJldHVybmVkIGFzIGxvbmdcbiAgICAgKiBhcyB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBoZWFkLCB0YWtlXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxudW1iZXJ8c3RyaW5nfSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGVsZW1lbnQgb3IgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZXR1cm4uIElmIGEgcHJvcGVydHkgbmFtZSBvclxuICAgICAqICBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiXG4gICAgICogIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQocykgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maXJzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uZmlyc3QoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8uZmlyc3QoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gPCAzO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYmxvY2tlZCc6IGZhbHNlLCAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnbmEnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maXJzdChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICdibG9ja2VkJzogdHJ1ZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmZpcnN0KGNoYXJhY3RlcnMsIHsgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KSwgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaXJzdChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBuID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ251bWJlcicgJiYgY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKG4gPT0gbnVsbCB8fCB0aGlzQXJnKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ID8gYXJyYXlbMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGljZShhcnJheSwgMCwgbmF0aXZlTWluKG5hdGl2ZU1heCgwLCBuKSwgbGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxhdHRlbnMgYSBuZXN0ZWQgYXJyYXkgKHRoZSBuZXN0aW5nIGNhbiBiZSB0byBhbnkgZGVwdGgpLiBJZiBgaXNTaGFsbG93YFxuICAgICAqIGlzIHRydWV5LCB0aGUgYXJyYXkgd2lsbCBvbmx5IGJlIGZsYXR0ZW5lZCBhIHNpbmdsZSBsZXZlbC4gSWYgYSBjYWxsYmFja1xuICAgICAqIGlzIHByb3ZpZGVkIGVhY2ggZWxlbWVudCBvZiB0aGUgYXJyYXkgaXMgcGFzc2VkIHRocm91Z2ggdGhlIGNhbGxiYWNrIGJlZm9yZVxuICAgICAqIGZsYXR0ZW5pbmcuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTaGFsbG93PWZhbHNlXSBBIGZsYWcgdG8gcmVzdHJpY3QgZmxhdHRlbmluZyB0byBhIHNpbmdsZSBsZXZlbC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbihbMSwgWzJdLCBbMywgW1s0XV1dXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdO1xuICAgICAqXG4gICAgICogXy5mbGF0dGVuKFsxLCBbMl0sIFszLCBbWzRdXV1dLCB0cnVlKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgW1s0XV1dO1xuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzMCwgJ3BldHMnOiBbJ2hvcHB5J10gfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAncGV0cyc6IFsnYmFieSBwdXNzJywgJ2Rpbm8nXSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmxhdHRlbihjaGFyYWN0ZXJzLCAncGV0cycpO1xuICAgICAqIC8vID0+IFsnaG9wcHknLCAnYmFieSBwdXNzJywgJ2Rpbm8nXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXksIGlzU2hhbGxvdywgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIC8vIGp1Z2dsZSBhcmd1bWVudHNcbiAgICAgIGlmICh0eXBlb2YgaXNTaGFsbG93ICE9ICdib29sZWFuJyAmJiBpc1NoYWxsb3cgIT0gbnVsbCkge1xuICAgICAgICB0aGlzQXJnID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrID0gKHR5cGVvZiBpc1NoYWxsb3cgIT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnICYmIHRoaXNBcmdbaXNTaGFsbG93XSA9PT0gYXJyYXkpID8gbnVsbCA6IGlzU2hhbGxvdztcbiAgICAgICAgaXNTaGFsbG93ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBhcnJheSA9IG1hcChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKGFycmF5LCBpc1NoYWxsb3cpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgdXNpbmdcbiAgICAgKiBzdHJpY3QgZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLiBJZiB0aGUgYXJyYXkgaXMgYWxyZWFkeSBzb3J0ZWRcbiAgICAgKiBwcm92aWRpbmcgYHRydWVgIGZvciBgZnJvbUluZGV4YCB3aWxsIHJ1biBhIGZhc3RlciBiaW5hcnkgc2VhcmNoLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbSBvciBgdHJ1ZWBcbiAgICAgKiAgdG8gcGVyZm9ybSBhIGJpbmFyeSBzZWFyY2ggb24gYSBzb3J0ZWQgYXJyYXkuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUgb3IgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAzLCAxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAzLCAxLCAyLCAzXSwgMiwgMyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAxLCAyLCAyLCAzLCAzXSwgMiwgdHJ1ZSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICAgIGZyb21JbmRleCA9IChmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KDAsIGxlbmd0aCArIGZyb21JbmRleCkgOiBmcm9tSW5kZXggfHwgMCk7XG4gICAgICB9IGVsc2UgaWYgKGZyb21JbmRleCkge1xuICAgICAgICB2YXIgaW5kZXggPSBzb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gYXJyYXlbaW5kZXhdID09PSB2YWx1ZSA/IGluZGV4IDogLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgbGFzdCBlbGVtZW50IG9yIGxhc3QgYG5gIGVsZW1lbnRzIG9mIGFuIGFycmF5LiBJZiBhXG4gICAgICogY2FsbGJhY2sgaXMgcHJvdmlkZWQgZWxlbWVudHMgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkgYXJlIGV4Y2x1ZGVkIGZyb21cbiAgICAgKiB0aGUgcmVzdWx0IGFzIGxvbmcgYXMgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkuIFRoZSBjYWxsYmFjayBpcyBib3VuZFxuICAgICAqIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fG51bWJlcnxzdHJpbmd9IFtjYWxsYmFjaz0xXSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBlbGVtZW50IG9yIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZXhjbHVkZS4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yXG4gICAgICogIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCJcbiAgICAgKiAgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluaXRpYWwoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtID4gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiBmYWxzZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ25hJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uaW5pdGlhbChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICAnYmxvY2tlZCc6IGZhbHNlLCAnZW1wbG95ZXInOiAnc2xhdGUnIH1dXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uaW5pdGlhbChjaGFyYWN0ZXJzLCB7ICdlbXBsb3llcic6ICduYScgfSksICduYW1lJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdGlhbChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBuID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ251bWJlcicgJiYgY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaW5kZXggPSBsZW5ndGg7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgd2hpbGUgKGluZGV4LS0gJiYgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gKGNhbGxiYWNrID09IG51bGwgfHwgdGhpc0FyZykgPyAxIDogY2FsbGJhY2sgfHwgbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGljZShhcnJheSwgMCwgbmF0aXZlTWluKG5hdGl2ZU1heCgwLCBsZW5ndGggLSBuKSwgbGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHByZXNlbnQgaW4gYWxsIHByb3ZpZGVkIGFycmF5cyB1c2luZ1xuICAgICAqIHN0cmljdCBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5XSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHNoYXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uKFsxLCAyLCAzXSwgWzUsIDIsIDEsIDRdLCBbMiwgMV0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludGVyc2VjdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgICAgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgY2FjaGVzID0gZ2V0QXJyYXkoKSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIHRydXN0SW5kZXhPZiA9IGluZGV4T2YgPT09IGJhc2VJbmRleE9mLFxuICAgICAgICAgIHNlZW4gPSBnZXRBcnJheSgpO1xuXG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50c1thcmdzSW5kZXhdO1xuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSB7XG4gICAgICAgICAgYXJncy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBjYWNoZXMucHVzaCh0cnVzdEluZGV4T2YgJiYgdmFsdWUubGVuZ3RoID49IGxhcmdlQXJyYXlTaXplICYmXG4gICAgICAgICAgICBjcmVhdGVDYWNoZShhcmdzSW5kZXggPyBhcmdzW2FyZ3NJbmRleF0gOiBzZWVuKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBhcnJheSA9IGFyZ3NbMF0sXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gY2FjaGVzWzBdO1xuICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICBpZiAoKGNhY2hlID8gY2FjaGVJbmRleE9mKGNhY2hlLCB2YWx1ZSkgOiBpbmRleE9mKHNlZW4sIHZhbHVlKSkgPCAwKSB7XG4gICAgICAgICAgYXJnc0luZGV4ID0gYXJnc0xlbmd0aDtcbiAgICAgICAgICAoY2FjaGUgfHwgc2VlbikucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgd2hpbGUgKC0tYXJnc0luZGV4KSB7XG4gICAgICAgICAgICBjYWNoZSA9IGNhY2hlc1thcmdzSW5kZXhdO1xuICAgICAgICAgICAgaWYgKChjYWNoZSA/IGNhY2hlSW5kZXhPZihjYWNoZSwgdmFsdWUpIDogaW5kZXhPZihhcmdzW2FyZ3NJbmRleF0sIHZhbHVlKSkgPCAwKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChhcmdzTGVuZ3RoLS0pIHtcbiAgICAgICAgY2FjaGUgPSBjYWNoZXNbYXJnc0xlbmd0aF07XG4gICAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICAgIHJlbGVhc2VPYmplY3QoY2FjaGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWxlYXNlQXJyYXkoY2FjaGVzKTtcbiAgICAgIHJlbGVhc2VBcnJheShzZWVuKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9yIGxhc3QgYG5gIGVsZW1lbnRzIG9mIGFuIGFycmF5LiBJZiBhIGNhbGxiYWNrIGlzXG4gICAgICogcHJvdmlkZWQgZWxlbWVudHMgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkgYXJlIHJldHVybmVkIGFzIGxvbmcgYXMgdGhlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyB0cnVleS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8bnVtYmVyfHN0cmluZ30gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBlbGVtZW50IG9yIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmV0dXJuLiBJZiBhIHByb3BlcnR5IG5hbWUgb3JcbiAgICAgKiAgb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIlxuICAgICAqICBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQocykgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLmxhc3QoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gPiAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYmxvY2tlZCc6IGZhbHNlLCAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnbmEnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmxhc3QoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKSwgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmxhc3QoY2hhcmFjdGVycywgeyAnZW1wbG95ZXInOiAnbmEnIH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICdlbXBsb3llcic6ICduYScgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0KGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIG4gPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnbnVtYmVyJyAmJiBjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICB3aGlsZSAoaW5kZXgtLSAmJiBjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKG4gPT0gbnVsbCB8fCB0aGlzQXJnKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGljZShhcnJheSwgbmF0aXZlTWF4KDAsIGxlbmd0aCAtIG4pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgdXNpbmcgc3RyaWN0XG4gICAgICogZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQgaXMgdXNlZFxuICAgICAqIGFzIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUgb3IgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDMsIDEsIDIsIDNdLCAyLCAzKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBpbmRleCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGluZGV4ID0gKGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgoMCwgaW5kZXggKyBmcm9tSW5kZXgpIDogbmF0aXZlTWluKGZyb21JbmRleCwgaW5kZXggLSAxKSkgKyAxO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBwcm92aWRlZCB2YWx1ZXMgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgdXNpbmcgc3RyaWN0IGVxdWFsaXR5IGZvclxuICAgICAqIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVdIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgMywgMSwgMiwgM107XG4gICAgICogXy5wdWxsKGFycmF5LCAyLCAzKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbChhcnJheSkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgYXJnc0luZGV4ID0gMCxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgdmFsdWUgPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleC0tLCAxKTtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXG4gICAgICogYHN0YXJ0YCB1cCB0byBidXQgbm90IGluY2x1ZGluZyBgZW5kYC4gSWYgYHN0YXJ0YCBpcyBsZXNzIHRoYW4gYHN0b3BgIGFcbiAgICAgKiB6ZXJvLWxlbmd0aCByYW5nZSBpcyBjcmVhdGVkIHVubGVzcyBhIG5lZ2F0aXZlIGBzdGVwYCBpcyBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyByYW5nZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5nZSg0KTtcbiAgICAgKiAvLyA9PiBbMCwgMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIDIwLCA1KTtcbiAgICAgKiAvLyA9PiBbMCwgNSwgMTAsIDE1XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAtNCwgLTEpO1xuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA0LCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5nZShzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICBzdGFydCA9ICtzdGFydCB8fCAwO1xuICAgICAgc3RlcCA9IHR5cGVvZiBzdGVwID09ICdudW1iZXInID8gc3RlcCA6ICgrc3RlcCB8fCAxKTtcblxuICAgICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgICAvLyB1c2UgYEFycmF5KGxlbmd0aClgIHNvIGVuZ2luZXMgbGlrZSBDaGFrcmEgYW5kIFY4IGF2b2lkIHNsb3dlciBtb2Rlc1xuICAgICAgLy8gaHR0cDovL3lvdXR1LmJlL1hBcUlwR1U4WlprI3Q9MTdtMjVzXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoMCwgY2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgdGhhdCB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleSBmb3JcbiAgICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDQsIDUsIDZdO1xuICAgICAqIHZhciBldmVucyA9IF8ucmVtb3ZlKGFycmF5LCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAlIDIgPT0gMDsgfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDVdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhldmVucyk7XG4gICAgICogLy8gPT4gWzIsIDQsIDZdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgtLSwgMSk7XG4gICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmluaXRpYWxgIHRoaXMgbWV0aG9kIGdldHMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvclxuICAgICAqIGZpcnN0IGBuYCBlbGVtZW50cyBvZiBhbiBhcnJheS4gSWYgYSBjYWxsYmFjayBmdW5jdGlvbiBpcyBwcm92aWRlZCBlbGVtZW50c1xuICAgICAqIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5IGFyZSBleGNsdWRlZCBmcm9tIHRoZSByZXN1bHQgYXMgbG9uZyBhcyB0aGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIHRydWV5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGRyb3AsIHRhaWxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fG51bWJlcnxzdHJpbmd9IFtjYWxsYmFjaz0xXSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBlbGVtZW50IG9yIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZXhjbHVkZS4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yXG4gICAgICogIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCJcbiAgICAgKiAgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8ucmVzdChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogXy5yZXN0KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtIDwgMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2Jsb2NrZWQnOiBmYWxzZSwgICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgJ2VtcGxveWVyJzogJ25hJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5yZXN0KGNoYXJhY3RlcnMsICdibG9ja2VkJyksICduYW1lJyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5yZXN0KGNoYXJhY3RlcnMsIHsgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAnZW1wbG95ZXInOiAnbmEnIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ251bWJlcicgJiYgY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbiA9IDAsXG4gICAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gKGNhbGxiYWNrID09IG51bGwgfHwgdGhpc0FyZykgPyAxIDogbmF0aXZlTWF4KDAsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGljZShhcnJheSwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaCBhIHZhbHVlXG4gICAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYSBnaXZlbiBzb3J0ZWQgYXJyYXkgaW4gb3JkZXIgdG8gbWFpbnRhaW4gdGhlIHNvcnRcbiAgICAgKiBvcmRlciBvZiB0aGUgYXJyYXkuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCBmb3JcbiAgICAgKiBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyIHNvcnQgcmFua2luZy4gVGhlXG4gICAgICogY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWzIwLCAzMCwgNTBdLCA0MCk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb3J0ZWRJbmRleChbeyAneCc6IDIwIH0sIHsgJ3gnOiAzMCB9LCB7ICd4JzogNTAgfV0sIHsgJ3gnOiA0MCB9LCAneCcpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIHZhciBkaWN0ID0ge1xuICAgICAqICAgJ3dvcmRUb051bWJlcic6IHsgJ3R3ZW50eSc6IDIwLCAndGhpcnR5JzogMzAsICdmb3VydHknOiA0MCwgJ2ZpZnR5JzogNTAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFsndHdlbnR5JywgJ3RoaXJ0eScsICdmaWZ0eSddLCAnZm91cnR5JywgZnVuY3Rpb24od29yZCkge1xuICAgICAqICAgcmV0dXJuIGRpY3Qud29yZFRvTnVtYmVyW3dvcmRdO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWyd0d2VudHknLCAndGhpcnR5JywgJ2ZpZnR5J10sICdmb3VydHknLCBmdW5jdGlvbih3b3JkKSB7XG4gICAgICogICByZXR1cm4gdGhpcy53b3JkVG9OdW1iZXJbd29yZF07XG4gICAgICogfSwgZGljdCk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IGxvdztcblxuICAgICAgLy8gZXhwbGljaXRseSByZWZlcmVuY2UgYGlkZW50aXR5YCBmb3IgYmV0dGVyIGlubGluaW5nIGluIEZpcmVmb3hcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDEpIDogaWRlbnRpdHk7XG4gICAgICB2YWx1ZSA9IGNhbGxiYWNrKHZhbHVlKTtcblxuICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMTtcbiAgICAgICAgKGNhbGxiYWNrKGFycmF5W21pZF0pIDwgdmFsdWUpXG4gICAgICAgICAgPyBsb3cgPSBtaWQgKyAxXG4gICAgICAgICAgOiBoaWdoID0gbWlkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvdztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBvZiB0aGUgcHJvdmlkZWQgYXJyYXlzIHVzaW5nXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXldIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaW9uKFsxLCAyLCAzXSwgWzUsIDIsIDEsIDRdLCBbMiwgMV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA1LCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaW9uKCkge1xuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkdXBsaWNhdGUtdmFsdWUtZnJlZSB2ZXJzaW9uIG9mIGFuIGFycmF5IHVzaW5nIHN0cmljdCBlcXVhbGl0eVxuICAgICAqIGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC4gSWYgdGhlIGFycmF5IGlzIHNvcnRlZCwgcHJvdmlkaW5nXG4gICAgICogYHRydWVgIGZvciBgaXNTb3J0ZWRgIHdpbGwgdXNlIGEgZmFzdGVyIGFsZ29yaXRobS4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZFxuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIGlzIHBhc3NlZCB0aHJvdWdoIHRoZSBjYWxsYmFjayBiZWZvcmUgdW5pcXVlbmVzc1xuICAgICAqIGlzIGNvbXB1dGVkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHVuaXF1ZVxuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NvcnRlZD1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIHRoYXQgYGFycmF5YCBpcyBzb3J0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBkdXBsaWNhdGUtdmFsdWUtZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxKFsxLCAyLCAxLCAzLCAxXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWzEsIDEsIDIsIDIsIDNdLCB0cnVlKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udW5pcShbJ0EnLCAnYicsICdDJywgJ2EnLCAnQicsICdjJ10sIGZ1bmN0aW9uKGxldHRlcikgeyByZXR1cm4gbGV0dGVyLnRvTG93ZXJDYXNlKCk7IH0pO1xuICAgICAqIC8vID0+IFsnQScsICdiJywgJ0MnXVxuICAgICAqXG4gICAgICogXy51bmlxKFsxLCAyLjUsIDMsIDEuNSwgMiwgMy41XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLmZsb29yKG51bSk7IH0sIE1hdGgpO1xuICAgICAqIC8vID0+IFsxLCAyLjUsIDNdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnVuaXEoW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXEoYXJyYXksIGlzU29ydGVkLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgLy8ganVnZ2xlIGFyZ3VtZW50c1xuICAgICAgaWYgKHR5cGVvZiBpc1NvcnRlZCAhPSAnYm9vbGVhbicgJiYgaXNTb3J0ZWQgIT0gbnVsbCkge1xuICAgICAgICB0aGlzQXJnID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrID0gKHR5cGVvZiBpc1NvcnRlZCAhPSAnZnVuY3Rpb24nICYmIHRoaXNBcmcgJiYgdGhpc0FyZ1tpc1NvcnRlZF0gPT09IGFycmF5KSA/IG51bGwgOiBpc1NvcnRlZDtcbiAgICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlVW5pcShhcnJheSwgaXNTb3J0ZWQsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgcHJvdmlkZWQgdmFsdWVzIHVzaW5nIHN0cmljdCBlcXVhbGl0eSBmb3JcbiAgICAgKiBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsdGVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53aXRob3V0KFsxLCAyLCAxLCAwLCAzLCAxLCA0XSwgMCwgMSk7XG4gICAgICogLy8gPT4gWzIsIDMsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2l0aG91dChhcnJheSkge1xuICAgICAgcmV0dXJuIGJhc2VEaWZmZXJlbmNlKGFycmF5LCBzbGljZShhcmd1bWVudHMsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHRoYXQgaXMgdGhlIHN5bW1ldHJpYyBkaWZmZXJlbmNlIG9mIHRoZSBwcm92aWRlZCBhcnJheXMuXG4gICAgICogU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3ltbWV0cmljX2RpZmZlcmVuY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5XSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3IoWzEsIDIsIDNdLCBbNSwgMiwgMSwgNF0pO1xuICAgICAqIC8vID0+IFszLCA1LCA0XVxuICAgICAqXG4gICAgICogXy54b3IoWzEsIDIsIDVdLCBbMiwgMywgNV0sIFszLCA0LCA1XSk7XG4gICAgICogLy8gPT4gWzEsIDQsIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24geG9yKCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgaWYgKGlzQXJyYXkoYXJyYXkpIHx8IGlzQXJndW1lbnRzKGFycmF5KSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRcbiAgICAgICAgICAgID8gYmFzZVVuaXEoYmFzZURpZmZlcmVuY2UocmVzdWx0LCBhcnJheSkuY29uY2F0KGJhc2VEaWZmZXJlbmNlKGFycmF5LCByZXN1bHQpKSlcbiAgICAgICAgICAgIDogYXJyYXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQgfHwgW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLCB0aGUgZmlyc3Qgb2Ygd2hpY2ggY29udGFpbnMgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgdGhlIHNlY29uZCBvZiB3aGljaCBjb250YWlucyB0aGUgc2Vjb25kXG4gICAgICogZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHVuemlwXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheV0gQXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwKFsnZnJlZCcsICdiYXJuZXknXSwgWzMwLCA0MF0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2ZyZWQnLCAzMCwgdHJ1ZV0sIFsnYmFybmV5JywgNDAsIGZhbHNlXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXAoKSB7XG4gICAgICB2YXIgYXJyYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50cyA6IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gbWF4KHBsdWNrKGFycmF5LCAnbGVuZ3RoJykpIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGggPCAwID8gMCA6IGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBwbHVjayhhcnJheSwgaW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBmcm9tIGFycmF5cyBvZiBga2V5c2AgYW5kIGB2YWx1ZXNgLiBQcm92aWRlXG4gICAgICogZWl0aGVyIGEgc2luZ2xlIHR3byBkaW1lbnNpb25hbCBhcnJheSwgaS5lLiBgW1trZXkxLCB2YWx1ZTFdLCBba2V5MiwgdmFsdWUyXV1gXG4gICAgICogb3IgdHdvIGFycmF5cywgb25lIG9mIGBrZXlzYCBhbmQgb25lIG9mIGNvcnJlc3BvbmRpbmcgYHZhbHVlc2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgb2JqZWN0XG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGtleXMgVGhlIGFycmF5IG9mIGtleXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlcz1bXV0gVGhlIGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgZ2l2ZW4ga2V5cyBhbmRcbiAgICAgKiAgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0KFsnZnJlZCcsICdiYXJuZXknXSwgWzMwLCA0MF0pO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiAzMCwgJ2Jhcm5leSc6IDQwIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXBPYmplY3Qoa2V5cywgdmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBrZXlzID8ga2V5cy5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICBpZiAoIXZhbHVlcyAmJiBsZW5ndGggJiYgIWlzQXJyYXkoa2V5c1swXSkpIHtcbiAgICAgICAgdmFsdWVzID0gW107XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5KSB7XG4gICAgICAgICAgcmVzdWx0W2tleVswXV0gPSBrZXlbMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBleGVjdXRlcyBgZnVuY2AsIHdpdGggIHRoZSBgdGhpc2AgYmluZGluZyBhbmRcbiAgICAgKiBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIG9ubHkgYWZ0ZXIgYmVpbmcgY2FsbGVkIGBuYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCBiZWZvcmVcbiAgICAgKiAgYGZ1bmNgIGlzIGV4ZWN1dGVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXZlcyA9IFsncHJvZmlsZScsICdzZXR0aW5ncyddO1xuICAgICAqXG4gICAgICogdmFyIGRvbmUgPSBfLmFmdGVyKHNhdmVzLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnRG9uZSBzYXZpbmchJyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goc2F2ZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgKiAgIGFzeW5jU2F2ZSh7ICd0eXBlJzogdHlwZSwgJ2NvbXBsZXRlJzogZG9uZSB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdEb25lIHNhdmluZyEnLCBhZnRlciBhbGwgc2F2ZXMgaGF2ZSBjb21wbGV0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZnRlcihuLCBmdW5jKSB7XG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA8IDEpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHByZXBlbmRzIGFueSBhZGRpdGlvbmFsIGBiaW5kYCBhcmd1bWVudHMgdG8gdGhvc2VcbiAgICAgKiBwcm92aWRlZCB0byB0aGUgYm91bmQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IGZ1bmN0aW9uKGdyZWV0aW5nKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLm5hbWU7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGZ1bmMgPSBfLmJpbmQoZnVuYywgeyAnbmFtZSc6ICdmcmVkJyB9LCAnaGknKTtcbiAgICAgKiBmdW5jKCk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluZChmdW5jLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDJcbiAgICAgICAgPyBjcmVhdGVXcmFwcGVyKGZ1bmMsIDE3LCBzbGljZShhcmd1bWVudHMsIDIpLCBudWxsLCB0aGlzQXJnKVxuICAgICAgICA6IGNyZWF0ZVdyYXBwZXIoZnVuYywgMSwgbnVsbCwgbnVsbCwgdGhpc0FyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmluZHMgbWV0aG9kcyBvZiBhbiBvYmplY3QgdG8gdGhlIG9iamVjdCBpdHNlbGYsIG92ZXJ3cml0aW5nIHRoZSBleGlzdGluZ1xuICAgICAqIG1ldGhvZC4gTWV0aG9kIG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzXG4gICAgICogb2YgbWV0aG9kIG5hbWVzLiBJZiBubyBtZXRob2QgbmFtZXMgYXJlIHByb3ZpZGVkIGFsbCB0aGUgZnVuY3Rpb24gcHJvcGVydGllc1xuICAgICAqIG9mIGBvYmplY3RgIHdpbGwgYmUgYm91bmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJpbmQgYW5kIGFzc2lnbiB0aGUgYm91bmQgbWV0aG9kcyB0by5cbiAgICAgKiBAcGFyYW0gey4uLnN0cmluZ30gW21ldGhvZE5hbWVdIFRoZSBvYmplY3QgbWV0aG9kIG5hbWVzIHRvXG4gICAgICogIGJpbmQsIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIG1ldGhvZCBuYW1lcyBvciBhcnJheXMgb2YgbWV0aG9kIG5hbWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB2aWV3ID0ge1xuICAgICAqICAgJ2xhYmVsJzogJ2RvY3MnLFxuICAgICAqICAgJ29uQ2xpY2snOiBmdW5jdGlvbigpIHsgY29uc29sZS5sb2coJ2NsaWNrZWQgJyArIHRoaXMubGFiZWwpOyB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uYmluZEFsbCh2aWV3KTtcbiAgICAgKiBqUXVlcnkoJyNkb2NzJykub24oJ2NsaWNrJywgdmlldy5vbkNsaWNrKTtcbiAgICAgKiAvLyA9PiBsb2dzICdjbGlja2VkIGRvY3MnLCB3aGVuIHRoZSBidXR0b24gaXMgY2xpY2tlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmRBbGwob2JqZWN0KSB7XG4gICAgICB2YXIgZnVuY3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgZmFsc2UsIDEpIDogZnVuY3Rpb25zKG9iamVjdCksXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBmdW5jcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBmdW5jc1tpbmRleF07XG4gICAgICAgIG9iamVjdFtrZXldID0gY3JlYXRlV3JhcHBlcihvYmplY3Rba2V5XSwgMSwgbnVsbCwgbnVsbCwgb2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYG9iamVjdFtrZXldYFxuICAgICAqIGFuZCBwcmVwZW5kcyBhbnkgYWRkaXRpb25hbCBgYmluZEtleWAgYXJndW1lbnRzIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBib3VuZFxuICAgICAqIGZ1bmN0aW9uLiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYF8uYmluZGAgYnkgYWxsb3dpbmcgYm91bmQgZnVuY3Rpb25zIHRvXG4gICAgICogcmVmZXJlbmNlIG1ldGhvZHMgdGhhdCB3aWxsIGJlIHJlZGVmaW5lZCBvciBkb24ndCB5ZXQgZXhpc3QuXG4gICAgICogU2VlIGh0dHA6Ly9taWNoYXV4LmNhL2FydGljbGVzL2xhenktZnVuY3Rpb24tZGVmaW5pdGlvbi1wYXR0ZXJuLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0aGUgbWV0aG9kIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAnbmFtZSc6ICdmcmVkJyxcbiAgICAgKiAgICdncmVldCc6IGZ1bmN0aW9uKGdyZWV0aW5nKSB7XG4gICAgICogICAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMubmFtZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCAnaGknKTtcbiAgICAgKiBmdW5jKCk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICpcbiAgICAgKiBvYmplY3QuZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZykge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJ3lhICcgKyB0aGlzLm5hbWUgKyAnISc7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGZ1bmMoKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kS2V5KG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDJcbiAgICAgICAgPyBjcmVhdGVXcmFwcGVyKGtleSwgMTksIHNsaWNlKGFyZ3VtZW50cywgMiksIG51bGwsIG9iamVjdClcbiAgICAgICAgOiBjcmVhdGVXcmFwcGVyKGtleSwgMywgbnVsbCwgbnVsbCwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyxcbiAgICAgKiB3aGVyZSBlYWNoIGZ1bmN0aW9uIGNvbnN1bWVzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgICAgKiBGb3IgZXhhbXBsZSwgY29tcG9zaW5nIHRoZSBmdW5jdGlvbnMgYGYoKWAsIGBnKClgLCBhbmQgYGgoKWAgcHJvZHVjZXMgYGYoZyhoKCkpKWAuXG4gICAgICogRWFjaCBmdW5jdGlvbiBpcyBleGVjdXRlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY29tcG9zZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gW2Z1bmNdIEZ1bmN0aW9ucyB0byBjb21wb3NlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2VkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcmVhbE5hbWVNYXAgPSB7XG4gICAgICogICAncGViYmxlcyc6ICdwZW5lbG9wZSdcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGZvcm1hdCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgKiAgIG5hbWUgPSByZWFsTmFtZU1hcFtuYW1lLnRvTG93ZXJDYXNlKCldIHx8IG5hbWU7XG4gICAgICogICByZXR1cm4gbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSkudG9Mb3dlckNhc2UoKTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGdyZWV0ID0gZnVuY3Rpb24oZm9ybWF0dGVkKSB7XG4gICAgICogICByZXR1cm4gJ0hpeWEgJyArIGZvcm1hdHRlZCArICchJztcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIHdlbGNvbWUgPSBfLmNvbXBvc2UoZ3JlZXQsIGZvcm1hdCk7XG4gICAgICogd2VsY29tZSgncGViYmxlcycpO1xuICAgICAqIC8vID0+ICdIaXlhIFBlbmVsb3BlISdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlKCkge1xuICAgICAgdmFyIGZ1bmNzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGxlbmd0aCA9IGZ1bmNzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jc1tsZW5ndGhdKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBsZW5ndGggPSBmdW5jcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgYXJncyA9IFtmdW5jc1tsZW5ndGhdLmFwcGx5KHRoaXMsIGFyZ3MpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJnc1swXTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHdoaWNoIGFjY2VwdHMgb25lIG9yIG1vcmUgYXJndW1lbnRzIG9mIGBmdW5jYCB0aGF0IHdoZW5cbiAgICAgKiBpbnZva2VkIGVpdGhlciBleGVjdXRlcyBgZnVuY2AgcmV0dXJuaW5nIGl0cyByZXN1bHQsIGlmIGFsbCBgZnVuY2AgYXJndW1lbnRzXG4gICAgICogaGF2ZSBiZWVuIHByb3ZpZGVkLCBvciByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBvciBtb3JlIG9mIHRoZVxuICAgICAqIHJlbWFpbmluZyBgZnVuY2AgYXJndW1lbnRzLCBhbmQgc28gb24uIFRoZSBhcml0eSBvZiBgZnVuY2AgY2FuIGJlIHNwZWNpZmllZFxuICAgICAqIGlmIGBmdW5jLmxlbmd0aGAgaXMgbm90IHN1ZmZpY2llbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnkoZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgY29uc29sZS5sb2coYSArIGIgKyBjKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSkoMikoMyk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyKSgzKTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IDZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXJyeShmdW5jLCBhcml0eSkge1xuICAgICAgYXJpdHkgPSB0eXBlb2YgYXJpdHkgPT0gJ251bWJlcicgPyBhcml0eSA6ICgrYXJpdHkgfHwgZnVuYy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgNCwgbnVsbCwgbnVsbCwgbnVsbCwgYXJpdHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgZGVsYXkgdGhlIGV4ZWN1dGlvbiBvZiBgZnVuY2AgdW50aWwgYWZ0ZXJcbiAgICAgKiBgd2FpdGAgbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIGl0IHdhcyBpbnZva2VkLlxuICAgICAqIFByb3ZpZGUgYW4gb3B0aW9ucyBvYmplY3QgdG8gaW5kaWNhdGUgdGhhdCBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb25cbiAgICAgKiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFN1YnNlcXVlbnQgY2FsbHNcbiAgICAgKiB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGNhbGwuXG4gICAgICpcbiAgICAgKiBOb3RlOiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgIGBmdW5jYCB3aWxsIGJlIGNhbGxlZFxuICAgICAqIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gaXNcbiAgICAgKiBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXSBTcGVjaWZ5IGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XSBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgY2FsbGVkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV0gU3BlY2lmeSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBhdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4XG4gICAgICogdmFyIGxhenlMYXlvdXQgPSBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKTtcbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgbGF6eUxheW91dCk7XG4gICAgICpcbiAgICAgKiAvLyBleGVjdXRlIGBzZW5kTWFpbGAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxsc1xuICAgICAqIGpRdWVyeSgnI3Bvc3Rib3gnKS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAgICAgKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAgICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBlbnN1cmUgYGJhdGNoTG9nYCBpcyBleGVjdXRlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxsc1xuICAgICAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAgICAgKiBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwge1xuICAgICAqICAgJ21heFdhaXQnOiAxMDAwXG4gICAgICogfSwgZmFsc2UpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhcmdzLFxuICAgICAgICAgIG1heFRpbWVvdXRJZCxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgc3RhbXAsXG4gICAgICAgICAgdGhpc0FyZyxcbiAgICAgICAgICB0aW1lb3V0SWQsXG4gICAgICAgICAgdHJhaWxpbmdDYWxsLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwLFxuICAgICAgICAgIG1heFdhaXQgPSBmYWxzZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgd2FpdCA9IG5hdGl2ZU1heCgwLCB3YWl0KSB8fCAwO1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlO1xuICAgICAgICB0cmFpbGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gb3B0aW9ucy5sZWFkaW5nO1xuICAgICAgICBtYXhXYWl0ID0gJ21heFdhaXQnIGluIG9wdGlvbnMgJiYgKG5hdGl2ZU1heCh3YWl0LCBvcHRpb25zLm1heFdhaXQpIHx8IDApO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cbiAgICAgIHZhciBkZWxheWVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdygpIC0gc3RhbXApO1xuICAgICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQobWF4VGltZW91dElkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGlzQ2FsbGVkID0gdHJhaWxpbmdDYWxsO1xuICAgICAgICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICAgIGxhc3RDYWxsZWQgPSBub3coKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgICBpZiAoIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgbWF4RGVsYXllZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4VGltZW91dElkID0gdGltZW91dElkID0gdHJhaWxpbmdDYWxsID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodHJhaWxpbmcgfHwgKG1heFdhaXQgIT09IHdhaXQpKSB7XG4gICAgICAgICAgbGFzdENhbGxlZCA9IG5vdygpO1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgaWYgKCF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBzdGFtcCA9IG5vdygpO1xuICAgICAgICB0aGlzQXJnID0gdGhpcztcbiAgICAgICAgdHJhaWxpbmdDYWxsID0gdHJhaWxpbmcgJiYgKHRpbWVvdXRJZCB8fCAhbGVhZGluZyk7XG5cbiAgICAgICAgaWYgKG1heFdhaXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIGxlYWRpbmdDYWxsID0gbGVhZGluZyAmJiAhdGltZW91dElkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghbWF4VGltZW91dElkICYmICFsZWFkaW5nKSB7XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZW1haW5pbmcgPSBtYXhXYWl0IC0gKHN0YW1wIC0gbGFzdENhbGxlZCksXG4gICAgICAgICAgICAgIGlzQ2FsbGVkID0gcmVtYWluaW5nIDw9IDA7XG5cbiAgICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICAgIGlmIChtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgbWF4VGltZW91dElkID0gY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICghbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBtYXhUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KG1heERlbGF5ZWQsIHJlbWFpbmluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbGxlZCAmJiB0aW1lb3V0SWQpIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGltZW91dElkICYmIHdhaXQgIT09IG1heFdhaXQpIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHdhaXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xuICAgICAgICAgIGlzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbGxlZCAmJiAhdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmZXJzIGV4ZWN1dGluZyB0aGUgYGZ1bmNgIGZ1bmN0aW9uIHVudGlsIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzIGNsZWFyZWQuXG4gICAgICogQWRkaXRpb25hbCBhcmd1bWVudHMgd2lsbCBiZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlZmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZlcihmdW5jdGlvbih0ZXh0KSB7IGNvbnNvbGUubG9nKHRleHQpOyB9LCAnZGVmZXJyZWQnKTtcbiAgICAgKiAvLyBsb2dzICdkZWZlcnJlZCcgYWZ0ZXIgb25lIG9yIG1vcmUgbWlsbGlzZWNvbmRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmZXIoZnVuYykge1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOyB9LCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgYGZ1bmNgIGZ1bmN0aW9uIGFmdGVyIGB3YWl0YCBtaWxsaXNlY29uZHMuIEFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgICogd2lsbCBiZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGV4ZWN1dGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVsYXkoZnVuY3Rpb24odGV4dCkgeyBjb25zb2xlLmxvZyh0ZXh0KTsgfSwgMTAwMCwgJ2xhdGVyJyk7XG4gICAgICogLy8gPT4gbG9ncyAnbGF0ZXInIGFmdGVyIG9uZSBzZWNvbmRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWxheShmdW5jLCB3YWl0KSB7XG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH0sIHdhaXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gICAgICogcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHRcbiAgICAgKiBiYXNlZCBvbiB0aGUgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlXG4gICAgICogZmlyc3QgYXJndW1lbnQgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBUaGUgYGZ1bmNgIGlzIGV4ZWN1dGVkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKiBUaGUgcmVzdWx0IGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIEEgZnVuY3Rpb24gdXNlZCB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6aW5nIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZmlib25hY2NpID0gXy5tZW1vaXplKGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuIDwgMiA/IG4gOiBmaWJvbmFjY2kobiAtIDEpICsgZmlib25hY2NpKG4gLSAyKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGZpYm9uYWNjaSg5KVxuICAgICAqIC8vID0+IDM0XG4gICAgICpcbiAgICAgKiB2YXIgZGF0YSA9IHtcbiAgICAgKiAgICdmcmVkJzogeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogLy8gbW9kaWZ5aW5nIHRoZSByZXN1bHQgY2FjaGVcbiAgICAgKiB2YXIgZ2V0ID0gXy5tZW1vaXplKGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuIGRhdGFbbmFtZV07IH0sIF8uaWRlbnRpdHkpO1xuICAgICAqIGdldCgncGViYmxlcycpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKlxuICAgICAqIGdldC5jYWNoZS5wZWJibGVzLm5hbWUgPSAncGVuZWxvcGUnO1xuICAgICAqIGdldCgncGViYmxlcycpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAncGVuZWxvcGUnLCAnYWdlJzogMSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGUsXG4gICAgICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXlQcmVmaXggKyBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoY2FjaGUsIGtleSlcbiAgICAgICAgICA/IGNhY2hlW2tleV1cbiAgICAgICAgICA6IChjYWNoZVtrZXldID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgIH1cbiAgICAgIG1lbW9pemVkLmNhY2hlID0ge307XG4gICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgcmVzdHJpY3RlZCB0byBleGVjdXRlIGBmdW5jYCBvbmNlLiBSZXBlYXQgY2FsbHMgdG9cbiAgICAgKiB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBjYWxsLiBUaGUgYGZ1bmNgIGlzIGV4ZWN1dGVkXG4gICAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGluaXRpYWxpemUgPSBfLm9uY2UoY3JlYXRlQXBwbGljYXRpb24pO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogLy8gYGluaXRpYWxpemVgIGV4ZWN1dGVzIGBjcmVhdGVBcHBsaWNhdGlvbmAgb25jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICAgICAgdmFyIHJhbixcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAocmFuKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIGBmdW5jYCB2YXJpYWJsZSBzbyB0aGUgZnVuY3Rpb24gbWF5IGJlIGdhcmJhZ2UgY29sbGVjdGVkXG4gICAgICAgIGZ1bmMgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGludm9rZXMgYGZ1bmNgIHdpdGggYW55IGFkZGl0aW9uYWxcbiAgICAgKiBgcGFydGlhbGAgYXJndW1lbnRzIHByZXBlbmRlZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLiBUaGlzXG4gICAgICogbWV0aG9kIGlzIHNpbWlsYXIgdG8gYF8uYmluZGAgZXhjZXB0IGl0IGRvZXMgKipub3QqKiBhbHRlciB0aGUgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcsIG5hbWUpIHsgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTsgfTtcbiAgICAgKiB2YXIgaGkgPSBfLnBhcnRpYWwoZ3JlZXQsICdoaScpO1xuICAgICAqIGhpKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFydGlhbChmdW5jKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihmdW5jLCAxNiwgc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wYXJ0aWFsYCBleGNlcHQgdGhhdCBgcGFydGlhbGAgYXJndW1lbnRzIGFyZVxuICAgICAqIGFwcGVuZGVkIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzRGVlcCA9IF8ucGFydGlhbFJpZ2h0KF8ubWVyZ2UsIF8uZGVmYXVsdHMpO1xuICAgICAqXG4gICAgICogdmFyIG9wdGlvbnMgPSB7XG4gICAgICogICAndmFyaWFibGUnOiAnZGF0YScsXG4gICAgICogICAnaW1wb3J0cyc6IHsgJ2pxJzogJCB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGRlZmF1bHRzRGVlcChvcHRpb25zLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuICAgICAqXG4gICAgICogb3B0aW9ucy52YXJpYWJsZVxuICAgICAqIC8vID0+ICdkYXRhJ1xuICAgICAqXG4gICAgICogb3B0aW9ucy5pbXBvcnRzXG4gICAgICogLy8gPT4geyAnXyc6IF8sICdqcSc6ICQgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnRpYWxSaWdodChmdW5jKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihmdW5jLCAzMiwgbnVsbCwgc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gZXhlY3V0ZWQsIHdpbGwgb25seSBjYWxsIHRoZSBgZnVuY2AgZnVuY3Rpb25cbiAgICAgKiBhdCBtb3N0IG9uY2UgcGVyIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFByb3ZpZGUgYW4gb3B0aW9ucyBvYmplY3QgdG9cbiAgICAgKiBpbmRpY2F0ZSB0aGF0IGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZVxuICAgICAqIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGxcbiAgICAgKiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgY2FsbC5cbiAgICAgKlxuICAgICAqIE5vdGU6IElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAgYGZ1bmNgIHdpbGwgYmUgY2FsbGVkXG4gICAgICogb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhlIHRocm90dGxlZCBmdW5jdGlvbiBpc1xuICAgICAqIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBleGVjdXRpb25zIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXSBTcGVjaWZ5IGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV0gU3BlY2lmeSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBhdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nXG4gICAgICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCk7XG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIHRocm90dGxlZCk7XG4gICAgICpcbiAgICAgKiAvLyBleGVjdXRlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXNcbiAgICAgKiBqUXVlcnkoJy5pbnRlcmFjdGl2ZScpLm9uKCdjbGljaycsIF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7XG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgICAqIH0pKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgICBsZWFkaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuICAgICAgZGVib3VuY2VPcHRpb25zLmxlYWRpbmcgPSBsZWFkaW5nO1xuICAgICAgZGVib3VuY2VPcHRpb25zLm1heFdhaXQgPSB3YWl0O1xuICAgICAgZGVib3VuY2VPcHRpb25zLnRyYWlsaW5nID0gdHJhaWxpbmc7XG5cbiAgICAgIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCBkZWJvdW5jZU9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIGB2YWx1ZWAgdG8gdGhlIHdyYXBwZXIgZnVuY3Rpb24gYXMgaXRzXG4gICAgICogZmlyc3QgYXJndW1lbnQuIEFkZGl0aW9uYWwgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBmdW5jdGlvbiBhcmUgYXBwZW5kZWRcbiAgICAgKiB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgd3JhcHBlciBmdW5jdGlvbi4gVGhlIHdyYXBwZXIgaXMgZXhlY3V0ZWQgd2l0aFxuICAgICAqIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBwZXIgVGhlIHdyYXBwZXIgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBwID0gXy53cmFwKF8uZXNjYXBlLCBmdW5jdGlvbihmdW5jLCB0ZXh0KSB7XG4gICAgICogICByZXR1cm4gJzxwPicgKyBmdW5jKHRleHQpICsgJzwvcD4nO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogcCgnRnJlZCwgV2lsbWEsICYgUGViYmxlcycpO1xuICAgICAqIC8vID0+ICc8cD5GcmVkLCBXaWxtYSwgJmFtcDsgUGViYmxlczwvcD4nXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcCh2YWx1ZSwgd3JhcHBlcikge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIod3JhcHBlciwgMTYsIFt2YWx1ZV0pO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICduYW1lJzogJ2ZyZWQnIH07XG4gICAgICogdmFyIGdldHRlciA9IF8uY29uc3RhbnQob2JqZWN0KTtcbiAgICAgKiBnZXR0ZXIoKSA9PT0gb2JqZWN0O1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgY2FsbGJhY2sgYm91bmQgdG8gYW4gb3B0aW9uYWwgYHRoaXNBcmdgLiBJZiBgZnVuY2AgaXMgYSBwcm9wZXJ0eVxuICAgICAqIG5hbWUgdGhlIGNyZWF0ZWQgY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIGZvciBhIGdpdmVuIGVsZW1lbnQuXG4gICAgICogSWYgYGZ1bmNgIGlzIGFuIG9iamVjdCB0aGUgY3JlYXRlZCBjYWxsYmFjayB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzXG4gICAgICogdGhhdCBjb250YWluIHRoZSBlcXVpdmFsZW50IG9iamVjdCBwcm9wZXJ0aWVzLCBvdGhlcndpc2UgaXQgd2lsbCByZXR1cm4gYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPWlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0aGUgY2FsbGJhY2sgYWNjZXB0cy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB3cmFwIHRvIGNyZWF0ZSBjdXN0b20gY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAqIF8uY3JlYXRlQ2FsbGJhY2sgPSBfLndyYXAoXy5jcmVhdGVDYWxsYmFjaywgZnVuY3Rpb24oZnVuYywgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgKiAgIHZhciBtYXRjaCA9IC9eKC4rPylfXyhbZ2xddCkoLispJC8uZXhlYyhjYWxsYmFjayk7XG4gICAgICogICByZXR1cm4gIW1hdGNoID8gZnVuYyhjYWxsYmFjaywgdGhpc0FyZykgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgKiAgICAgcmV0dXJuIG1hdGNoWzJdID09ICdndCcgPyBvYmplY3RbbWF0Y2hbMV1dID4gbWF0Y2hbM10gOiBvYmplY3RbbWF0Y2hbMV1dIDwgbWF0Y2hbM107XG4gICAgICogICB9O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIoY2hhcmFjdGVycywgJ2FnZV9fZ3QzOCcpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgZnVuYztcbiAgICAgIGlmIChmdW5jID09IG51bGwgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBiYXNlQ3JlYXRlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpO1xuICAgICAgfVxuICAgICAgLy8gaGFuZGxlIFwiXy5wbHVja1wiIHN0eWxlIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgIGlmICh0eXBlICE9ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eShmdW5jKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wcyA9IGtleXMoZnVuYyksXG4gICAgICAgICAga2V5ID0gcHJvcHNbMF0sXG4gICAgICAgICAgYSA9IGZ1bmNba2V5XTtcblxuICAgICAgLy8gaGFuZGxlIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgIGlmIChwcm9wcy5sZW5ndGggPT0gMSAmJiBhID09PSBhICYmICFpc09iamVjdChhKSkge1xuICAgICAgICAvLyBmYXN0IHBhdGggdGhlIGNvbW1vbiBjYXNlIG9mIHByb3ZpZGluZyBhbiBvYmplY3Qgd2l0aCBhIHNpbmdsZVxuICAgICAgICAvLyBwcm9wZXJ0eSBjb250YWluaW5nIGEgcHJpbWl0aXZlIHZhbHVlXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICB2YXIgYiA9IG9iamVjdFtrZXldO1xuICAgICAgICAgIHJldHVybiBhID09PSBiICYmIChhICE9PSAwIHx8ICgxIC8gYSA9PSAxIC8gYikpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gYmFzZUlzRXF1YWwob2JqZWN0W3Byb3BzW2xlbmd0aF1dLCBmdW5jW3Byb3BzW2xlbmd0aF1dLCBudWxsLCB0cnVlKSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBgJmAsIGA8YCwgYD5gLCBgXCJgLCBhbmQgYCdgIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gICAgICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlKCdGcmVkLCBXaWxtYSwgJiBQZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQsIFdpbG1hLCAmYW1wOyBQZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcgPT0gbnVsbCA/ICcnIDogU3RyaW5nKHN0cmluZykucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBwcm92aWRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgICAqIF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0O1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgZnVuY3Rpb24gcHJvcGVydGllcyBvZiBhIHNvdXJjZSBvYmplY3QgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBJZiBgb2JqZWN0YCBpcyBhIGZ1bmN0aW9uIG1ldGhvZHMgd2lsbCBiZSBhZGRlZCB0byBpdHMgcHJvdG90eXBlIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IFtvYmplY3Q9bG9kYXNoXSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgZnVuY3Rpb25zIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoYWluPXRydWVdIFNwZWNpZnkgd2hldGhlciB0aGUgZnVuY3Rpb25zIGFkZGVkIGFyZSBjaGFpbmFibGUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gICAgICogICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICdjYXBpdGFsaXplJzogY2FwaXRhbGl6ZSB9KTtcbiAgICAgKiBfLmNhcGl0YWxpemUoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKlxuICAgICAqIF8oJ2ZyZWQnKS5jYXBpdGFsaXplKCkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAnY2FwaXRhbGl6ZSc6IGNhcGl0YWxpemUgfSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcbiAgICAgKiBfKCdmcmVkJykuY2FwaXRhbGl6ZSgpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1peGluKG9iamVjdCwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgY2hhaW4gPSB0cnVlLFxuICAgICAgICAgIG1ldGhvZE5hbWVzID0gc291cmNlICYmIGZ1bmN0aW9ucyhzb3VyY2UpO1xuXG4gICAgICBpZiAoIXNvdXJjZSB8fCAoIW9wdGlvbnMgJiYgIW1ldGhvZE5hbWVzLmxlbmd0aCkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMgPSBzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgY3RvciA9IGxvZGFzaFdyYXBwZXI7XG4gICAgICAgIHNvdXJjZSA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0ID0gbG9kYXNoO1xuICAgICAgICBtZXRob2ROYW1lcyA9IGZ1bmN0aW9ucyhzb3VyY2UpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGNoYWluID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpICYmICdjaGFpbicgaW4gb3B0aW9ucykge1xuICAgICAgICBjaGFpbiA9IG9wdGlvbnMuY2hhaW47XG4gICAgICB9XG4gICAgICB2YXIgY3RvciA9IG9iamVjdCxcbiAgICAgICAgICBpc0Z1bmMgPSBpc0Z1bmN0aW9uKGN0b3IpO1xuXG4gICAgICBmb3JFYWNoKG1ldGhvZE5hbWVzLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBmdW5jID0gb2JqZWN0W21ldGhvZE5hbWVdID0gc291cmNlW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAoaXNGdW5jKSB7XG4gICAgICAgICAgY3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcbiAgICAgICAgICAgICAgICBhcmdzID0gW3ZhbHVlXTtcblxuICAgICAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkob2JqZWN0LCBhcmdzKTtcbiAgICAgICAgICAgIGlmIChjaGFpbiB8fCBjaGFpbkFsbCkge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHJlc3VsdCAmJiBpc09iamVjdChyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGN0b3IocmVzdWx0KTtcbiAgICAgICAgICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IGNoYWluQWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnRzIHRoZSAnXycgdmFyaWFibGUgdG8gaXRzIHByZXZpb3VzIHZhbHVlIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvXG4gICAgICogdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBsb2Rhc2ggPSBfLm5vQ29uZmxpY3QoKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgICAgY29udGV4dC5fID0gb2xkRGFzaDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgbm8tb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgICAqIF8ubm9vcChvYmplY3QpID09PSB1bmRlZmluZWQ7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgICAvLyBubyBvcGVyYXRpb24gcGVyZm9ybWVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgVW5peCBlcG9jaFxuICAgICAqICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc3RhbXAgPSBfLm5vdygpO1xuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7IH0pO1xuICAgICAqIC8vID0+IGxvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgICAqL1xuICAgIHZhciBub3cgPSBpc05hdGl2ZShub3cgPSBEYXRlLm5vdykgJiYgbm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgaW50byBhbiBpbnRlZ2VyIG9mIHRoZSBzcGVjaWZpZWQgcmFkaXguXG4gICAgICogSWYgYHJhZGl4YCBpcyBgdW5kZWZpbmVkYCBvciBgMGAgYSBgcmFkaXhgIG9mIGAxMGAgaXMgdXNlZCB1bmxlc3MgdGhlXG4gICAgICogYHZhbHVlYCBpcyBhIGhleGFkZWNpbWFsLCBpbiB3aGljaCBjYXNlIGEgYHJhZGl4YCBvZiBgMTZgIGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBhdm9pZHMgZGlmZmVyZW5jZXMgaW4gbmF0aXZlIEVTMyBhbmQgRVM1IGBwYXJzZUludGBcbiAgICAgKiBpbXBsZW1lbnRhdGlvbnMuIFNlZSBodHRwOi8vZXM1LmdpdGh1Yi5pby8jRS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIHBhcnNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXhdIFRoZSByYWRpeCB1c2VkIHRvIGludGVycHJldCB0aGUgdmFsdWUgdG8gcGFyc2UuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbmV3IGludGVnZXIgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFyc2VJbnQoJzA4Jyk7XG4gICAgICogLy8gPT4gOFxuICAgICAqL1xuICAgIHZhciBwYXJzZUludCA9IG5hdGl2ZVBhcnNlSW50KHdoaXRlc3BhY2UgKyAnMDgnKSA9PSA4ID8gbmF0aXZlUGFyc2VJbnQgOiBmdW5jdGlvbih2YWx1ZSwgcmFkaXgpIHtcbiAgICAgIC8vIEZpcmVmb3ggPCAyMSBhbmQgT3BlcmEgPCAxNSBmb2xsb3cgdGhlIEVTMyBzcGVjaWZpZWQgaW1wbGVtZW50YXRpb24gb2YgYHBhcnNlSW50YFxuICAgICAgcmV0dXJuIG5hdGl2ZVBhcnNlSW50KGlzU3RyaW5nKHZhbHVlKSA/IHZhbHVlLnJlcGxhY2UocmVMZWFkaW5nU3BhY2VzQW5kWmVyb3MsICcnKSA6IHZhbHVlLCByYWRpeCB8fCAwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFwiXy5wbHVja1wiIHN0eWxlIGZ1bmN0aW9uLCB3aGljaCByZXR1cm5zIHRoZSBga2V5YCB2YWx1ZSBvZiBhXG4gICAgICogZ2l2ZW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHJldHJpZXZlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBnZXROYW1lID0gXy5wcm9wZXJ0eSgnbmFtZScpO1xuICAgICAqXG4gICAgICogXy5tYXAoY2hhcmFjdGVycywgZ2V0TmFtZSk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeShjaGFyYWN0ZXJzLCBnZXROYW1lKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSwgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eShrZXkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBgbWluYCBhbmQgYG1heGAgKGluY2x1c2l2ZSkuIElmIG9ubHkgb25lXG4gICAgICogYXJndW1lbnQgaXMgcHJvdmlkZWQgYSBudW1iZXIgYmV0d2VlbiBgMGAgYW5kIHRoZSBnaXZlbiBudW1iZXIgd2lsbCBiZVxuICAgICAqIHJldHVybmVkLiBJZiBgZmxvYXRpbmdgIGlzIHRydWV5IG9yIGVpdGhlciBgbWluYCBvciBgbWF4YCBhcmUgZmxvYXRzIGFcbiAgICAgKiBmbG9hdGluZy1wb2ludCBudW1iZXIgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkIG9mIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttaW49MF0gVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttYXg9MV0gVGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZmxvYXRpbmc9ZmFsc2VdIFNwZWNpZnkgcmV0dXJuaW5nIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYSByYW5kb20gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgwLCA1KTtcbiAgICAgKiAvLyA9PiBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSk7XG4gICAgICogLy8gPT4gYWxzbyBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgxLjIsIDUuMik7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAxLjIgYW5kIDUuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbShtaW4sIG1heCwgZmxvYXRpbmcpIHtcbiAgICAgIHZhciBub01pbiA9IG1pbiA9PSBudWxsLFxuICAgICAgICAgIG5vTWF4ID0gbWF4ID09IG51bGw7XG5cbiAgICAgIGlmIChmbG9hdGluZyA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWluID09ICdib29sZWFuJyAmJiBub01heCkge1xuICAgICAgICAgIGZsb2F0aW5nID0gbWluO1xuICAgICAgICAgIG1pbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW5vTWF4ICYmIHR5cGVvZiBtYXggPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSBtYXg7XG4gICAgICAgICAgbm9NYXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9NaW4gJiYgbm9NYXgpIHtcbiAgICAgICAgbWF4ID0gMTtcbiAgICAgIH1cbiAgICAgIG1pbiA9ICttaW4gfHwgMDtcbiAgICAgIGlmIChub01heCkge1xuICAgICAgICBtYXggPSBtaW47XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXggPSArbWF4IHx8IDA7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgfHwgbWluICUgMSB8fCBtYXggJSAxKSB7XG4gICAgICAgIHZhciByYW5kID0gbmF0aXZlUmFuZG9tKCk7XG4gICAgICAgIHJldHVybiBuYXRpdmVNaW4obWluICsgKHJhbmQgKiAobWF4IC0gbWluICsgcGFyc2VGbG9hdCgnMWUtJyArICgocmFuZCArJycpLmxlbmd0aCAtIDEpKSkpLCBtYXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VSYW5kb20obWluLCBtYXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSB2YWx1ZSBvZiBwcm9wZXJ0eSBga2V5YCBvbiBgb2JqZWN0YC4gSWYgYGtleWAgaXMgYSBmdW5jdGlvblxuICAgICAqIGl0IHdpbGwgYmUgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgb2JqZWN0YCBhbmQgaXRzIHJlc3VsdCByZXR1cm5lZCxcbiAgICAgKiBlbHNlIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpcyByZXR1cm5lZC4gSWYgYG9iamVjdGAgaXMgZmFsc2V5IHRoZW4gYHVuZGVmaW5lZGBcbiAgICAgKiBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byByZXNvbHZlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICdjaGVlc2UnOiAnY3J1bXBldHMnLFxuICAgICAqICAgJ3N0dWZmJzogZnVuY3Rpb24oKSB7XG4gICAgICogICAgIHJldHVybiAnbm9uc2Vuc2UnO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdjaGVlc2UnKTtcbiAgICAgKiAvLyA9PiAnY3J1bXBldHMnXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdzdHVmZicpO1xuICAgICAqIC8vID0+ICdub25zZW5zZSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN1bHQob2JqZWN0LCBrZXkpIHtcbiAgICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHZhbHVlKSA/IG9iamVjdFtrZXldKCkgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIG1pY3JvLXRlbXBsYXRpbmcgbWV0aG9kIHRoYXQgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzXG4gICAgICogd2hpdGVzcGFjZSwgYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gICAgICpcbiAgICAgKiBOb3RlOiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQsIGBfLnRlbXBsYXRlYCB1dGlsaXplcyBzb3VyY2VVUkxzIGZvciBlYXNpZXJcbiAgICAgKiBkZWJ1Z2dpbmcuIFNlZSBodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZTpcbiAgICAgKiBodHRwOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWU6XG4gICAgICogaHR0cDovL2RldmVsb3Blci5jaHJvbWUuY29tL3N0YWJsZS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsLmh0bWxcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZGF0YSBvYmplY3QgdXNlZCB0byBwb3B1bGF0ZSB0aGUgdGV4dC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXNjYXBlXSBUaGUgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlXSBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0c10gQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBsb2NhbCB2YXJpYWJsZXMuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlXSBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NvdXJjZVVSTF0gVGhlIHNvdXJjZVVSTCBvZiB0aGUgdGVtcGxhdGUncyBjb21waWxlZCBzb3VyY2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt2YXJpYWJsZV0gVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufHN0cmluZ30gUmV0dXJucyBhIGNvbXBpbGVkIGZ1bmN0aW9uIHdoZW4gbm8gYGRhdGFgIG9iamVjdFxuICAgICAqICBpcyBnaXZlbiwgZWxzZSBpdCByZXR1cm5zIHRoZSBpbnRlcnBvbGF0ZWQgdGV4dC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gbmFtZSAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ25hbWUnOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIEhUTUwgaW4gZGF0YSBwcm9wZXJ0eSB2YWx1ZXNcbiAgICAgKiBfLnRlbXBsYXRlKCc8Yj48JS0gdmFsdWUgJT48L2I+JywgeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xuICAgICAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlciB0byBnZW5lcmF0ZSBIVE1MXG4gICAgICogdmFyIGxpc3QgPSAnPCUgXy5mb3JFYWNoKHBlb3BsZSwgZnVuY3Rpb24obmFtZSkgeyAlPjxsaT48JS0gbmFtZSAlPjwvbGk+PCUgfSk7ICU+JztcbiAgICAgKiBfLnRlbXBsYXRlKGxpc3QsIHsgJ3Blb3BsZSc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBFUzYgZGVsaW1pdGVyIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBkZWZhdWx0IFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJcbiAgICAgKiBfLnRlbXBsYXRlKCdoZWxsbyAkeyBuYW1lIH0nLCB7ICduYW1lJzogJ3BlYmJsZXMnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnNcbiAgICAgKiBfLnRlbXBsYXRlKCc8JSBwcmludChcImhlbGxvIFwiICsgbmFtZSk7ICU+IScsIHsgJ25hbWUnOiAnYmFybmV5JyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnNcbiAgICAgKiBfLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG4gICAgICogICAnaW50ZXJwb2xhdGUnOiAve3soW1xcc1xcU10rPyl9fS9nXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8udGVtcGxhdGUoJ2hlbGxvIHt7IG5hbWUgfX0hJywgeyAnbmFtZSc6ICdtdXN0YWNoZScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgaW1wb3J0c2Agb3B0aW9uIHRvIGltcG9ydCBqUXVlcnlcbiAgICAgKiB2YXIgbGlzdCA9ICc8JSBqcS5lYWNoKHBlb3BsZSwgZnVuY3Rpb24obmFtZSkgeyAlPjxsaT48JS0gbmFtZSAlPjwvbGk+PCUgfSk7ICU+JztcbiAgICAgKiBfLnRlbXBsYXRlKGxpc3QsIHsgJ3Blb3BsZSc6IFsnZnJlZCcsICdiYXJuZXknXSB9LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSBuYW1lICU+JywgbnVsbCwgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICAgICAqIGNvbXBpbGVkKGRhdGEpO1xuICAgICAqIC8vID0+IGZpbmQgdGhlIHNvdXJjZSBvZiBcImdyZWV0aW5nLmpzdFwiIHVuZGVyIHRoZSBTb3VyY2VzIHRhYiBvciBSZXNvdXJjZXMgcGFuZWwgb2YgdGhlIHdlYiBpbnNwZWN0b3JcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgdmFyaWFibGVgIG9wdGlvbiB0byBlbnN1cmUgYSB3aXRoLXN0YXRlbWVudCBpc24ndCB1c2VkIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hpIDwlPSBkYXRhLm5hbWUgJT4hJywgbnVsbCwgeyAndmFyaWFibGUnOiAnZGF0YScgfSk7XG4gICAgICogY29tcGlsZWQuc291cmNlO1xuICAgICAqIC8vID0+IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgKiAgIHZhciBfX3QsIF9fcCA9ICcnLCBfX2UgPSBfLmVzY2FwZTtcbiAgICAgKiAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLm5hbWUgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAgICAgKiAgIHJldHVybiBfX3A7XG4gICAgICogfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAgICAgKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIGEgc3RhY2sgdHJhY2VcbiAgICAgKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihjd2QsICdqc3QuanMnKSwgJ1xcXG4gICAgICogICB2YXIgSlNUID0ge1xcXG4gICAgICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG4gICAgICogICB9O1xcXG4gICAgICogJyk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGVtcGxhdGUodGV4dCwgZGF0YSwgb3B0aW9ucykge1xuICAgICAgLy8gYmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxuICAgICAgLy8gaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy9cbiAgICAgIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanNcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1RcbiAgICAgIHZhciBzZXR0aW5ncyA9IGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzO1xuICAgICAgdGV4dCA9IFN0cmluZyh0ZXh0IHx8ICcnKTtcblxuICAgICAgLy8gYXZvaWQgbWlzc2luZyBkZXBlbmRlbmNpZXMgd2hlbiBgaXRlcmF0b3JUZW1wbGF0ZWAgaXMgbm90IGRlZmluZWRcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0cyh7fSwgb3B0aW9ucywgc2V0dGluZ3MpO1xuXG4gICAgICB2YXIgaW1wb3J0cyA9IGRlZmF1bHRzKHt9LCBvcHRpb25zLmltcG9ydHMsIHNldHRpbmdzLmltcG9ydHMpLFxuICAgICAgICAgIGltcG9ydHNLZXlzID0ga2V5cyhpbXBvcnRzKSxcbiAgICAgICAgICBpbXBvcnRzVmFsdWVzID0gdmFsdWVzKGltcG9ydHMpO1xuXG4gICAgICB2YXIgaXNFdmFsdWF0aW5nLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcblxuICAgICAgLy8gY29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyXG4gICAgICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxuICAgICAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICBpbnRlcnBvbGF0ZS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xuICAgICAgLCAnZycpO1xuXG4gICAgICB0ZXh0LnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgICAgIC8vIGVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgY2Fubm90IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFsc1xuICAgICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcblxuICAgICAgICAvLyByZXBsYWNlIGRlbGltaXRlcnMgd2l0aCBzbmlwcGV0c1xuICAgICAgICBpZiAoZXNjYXBlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgICAvLyB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIHByb2R1Y3RzIHJlcXVpcmVzIHJldHVybmluZyB0aGUgYG1hdGNoYFxuICAgICAgICAvLyBzdHJpbmcgaW4gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZVxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTtcblxuICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgICAgLy8gaWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkLCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgICAgIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpblxuICAgICAgdmFyIHZhcmlhYmxlID0gb3B0aW9ucy52YXJpYWJsZSxcbiAgICAgICAgICBoYXNWYXJpYWJsZSA9IHZhcmlhYmxlO1xuXG4gICAgICBpZiAoIWhhc1ZhcmlhYmxlKSB7XG4gICAgICAgIHZhcmlhYmxlID0gJ29iaic7XG4gICAgICAgIHNvdXJjZSA9ICd3aXRoICgnICsgdmFyaWFibGUgKyAnKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgICAgIH1cbiAgICAgIC8vIGNsZWFudXAgY29kZSBieSBzdHJpcHBpbmcgZW1wdHkgc3RyaW5nc1xuICAgICAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCAnJykgOiBzb3VyY2UpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsICckMScpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xuXG4gICAgICAvLyBmcmFtZSBjb2RlIGFzIHRoZSBmdW5jdGlvbiBib2R5XG4gICAgICBzb3VyY2UgPSAnZnVuY3Rpb24oJyArIHZhcmlhYmxlICsgJykge1xcbicgK1xuICAgICAgICAoaGFzVmFyaWFibGUgPyAnJyA6IHZhcmlhYmxlICsgJyB8fCAoJyArIHZhcmlhYmxlICsgJyA9IHt9KTtcXG4nKSArXG4gICAgICAgIFwidmFyIF9fdCwgX19wID0gJycsIF9fZSA9IF8uZXNjYXBlXCIgK1xuICAgICAgICAoaXNFdmFsdWF0aW5nXG4gICAgICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCJcbiAgICAgICAgICA6ICc7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgc291cmNlICtcbiAgICAgICAgJ3JldHVybiBfX3BcXG59JztcblxuICAgICAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAgLy8gaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybFxuICAgICAgdmFyIHNvdXJjZVVSTCA9ICdcXG4vKlxcbi8vIyBzb3VyY2VVUkw9JyArIChvcHRpb25zLnNvdXJjZVVSTCB8fCAnL2xvZGFzaC90ZW1wbGF0ZS9zb3VyY2VbJyArICh0ZW1wbGF0ZUNvdW50ZXIrKykgKyAnXScpICsgJ1xcbiovJztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEZ1bmN0aW9uKGltcG9ydHNLZXlzLCAncmV0dXJuICcgKyBzb3VyY2UgKyBzb3VyY2VVUkwpLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0KGRhdGEpO1xuICAgICAgfVxuICAgICAgLy8gcHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kLCBpblxuICAgICAgLy8gc3VwcG9ydGVkIGVudmlyb25tZW50cywgb3IgdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yXG4gICAgICAvLyBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMgZHVyaW5nIHRoZSBidWlsZCBwcm9jZXNzXG4gICAgICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2FsbGJhY2sgYG5gIHRpbWVzLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHNcbiAgICAgKiBvZiBlYWNoIGNhbGxiYWNrIGV4ZWN1dGlvbi4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggb25lIGFyZ3VtZW50OyAoaW5kZXgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gZXhlY3V0ZSB0aGUgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGBjYWxsYmFja2AgZXhlY3V0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZGljZVJvbGxzID0gXy50aW1lcygzLCBfLnBhcnRpYWwoXy5yYW5kb20sIDEsIDYpKTtcbiAgICAgKiAvLyA9PiBbMywgNiwgNF1cbiAgICAgKlxuICAgICAqIF8udGltZXMoMywgZnVuY3Rpb24obikgeyBtYWdlLmNhc3RTcGVsbChuKTsgfSk7XG4gICAgICogLy8gPT4gY2FsbHMgYG1hZ2UuY2FzdFNwZWxsKG4pYCB0aHJlZSB0aW1lcywgcGFzc2luZyBgbmAgb2YgYDBgLCBgMWAsIGFuZCBgMmAgcmVzcGVjdGl2ZWx5XG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIGZ1bmN0aW9uKG4pIHsgdGhpcy5jYXN0KG4pOyB9LCBtYWdlKTtcbiAgICAgKiAvLyA9PiBhbHNvIGNhbGxzIGBtYWdlLmNhc3RTcGVsbChuKWAgdGhyZWUgdGltZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aW1lcyhuLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgbiA9IChuID0gK24pID4gLTEgPyBuIDogMDtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gICAgICBjYWxsYmFjayA9IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGNhbGxiYWNrKGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8uZXNjYXBlYCB0aGlzIG1ldGhvZCBjb252ZXJ0cyB0aGUgSFRNTCBlbnRpdGllc1xuICAgICAqIGAmYW1wO2AsIGAmbHQ7YCwgYCZndDtgLCBgJnF1b3Q7YCwgYW5kIGAmIzM5O2AgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAgICAgKiBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHVuZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5lc2NhcGUoJ0ZyZWQsIEJhcm5leSAmYW1wOyBQZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQsIEJhcm5leSAmIFBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5lc2NhcGUoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nID09IG51bGwgPyAnJyA6IFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVFc2NhcGVkSHRtbCwgdW5lc2NhcGVIdG1sQ2hhcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBwcm92aWRlZCB0aGUgSUQgd2lsbCBiZSBhcHBlbmRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeF0gVGhlIHZhbHVlIHRvIHByZWZpeCB0aGUgSUQgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmlxdWUgSUQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoJ2NvbnRhY3RfJyk7XG4gICAgICogLy8gPT4gJ2NvbnRhY3RfMTA0J1xuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgpO1xuICAgICAqIC8vID0+ICcxMDUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gICAgICB2YXIgaWQgPSArK2lkQ291bnRlcjtcbiAgICAgIHJldHVybiBTdHJpbmcocHJlZml4ID09IG51bGwgPyAnJyA6IHByZWZpeCkgKyBpZDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3QgdGhhdCB3cmFwcyB0aGUgZ2l2ZW4gdmFsdWUgd2l0aCBleHBsaWNpdFxuICAgICAqIG1ldGhvZCBjaGFpbmluZyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgeW91bmdlc3QgPSBfLmNoYWluKGNoYXJhY3RlcnMpXG4gICAgICogICAgIC5zb3J0QnkoJ2FnZScpXG4gICAgICogICAgIC5tYXAoZnVuY3Rpb24oY2hyKSB7IHJldHVybiBjaHIubmFtZSArICcgaXMgJyArIGNoci5hZ2U7IH0pXG4gICAgICogICAgIC5maXJzdCgpXG4gICAgICogICAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+ICdwZWJibGVzIGlzIDEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hhaW4odmFsdWUpIHtcbiAgICAgIHZhbHVlID0gbmV3IGxvZGFzaFdyYXBwZXIodmFsdWUpO1xuICAgICAgdmFsdWUuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGBpbnRlcmNlcHRvcmAgd2l0aCB0aGUgYHZhbHVlYCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHRoZW5cbiAgICAgKiByZXR1cm5zIGB2YWx1ZWAuIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZFxuICAgICAqIGNoYWluIGluIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW5cbiAgICAgKiB0aGUgY2hhaW4uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzLCA0XSlcbiAgICAgKiAgLnRhcChmdW5jdGlvbihhcnJheSkgeyBhcnJheS5wb3AoKTsgfSlcbiAgICAgKiAgLnJldmVyc2UoKVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YXAodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBleHBsaWNpdCBtZXRob2QgY2hhaW5pbmcgb24gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG5hbWUgY2hhaW5cbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB3aXRob3V0IGV4cGxpY2l0IGNoYWluaW5nXG4gICAgICogXyhjaGFyYWN0ZXJzKS5maXJzdCgpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKlxuICAgICAqIC8vIHdpdGggZXhwbGljaXQgY2hhaW5pbmdcbiAgICAgKiBfKGNoYXJhY3RlcnMpLmNoYWluKClcbiAgICAgKiAgIC5maXJzdCgpXG4gICAgICogICAucGljaygnYWdlJylcbiAgICAgKiAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IHsgJ2FnZSc6IDM2IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2hhaW4oKSB7XG4gICAgICB0aGlzLl9fY2hhaW5fXyA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyB0aGUgYHRvU3RyaW5nYCByZXN1bHQgb2YgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB0b1N0cmluZ1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nIHJlc3VsdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnRvU3RyaW5nKCk7XG4gICAgICogLy8gPT4gJzEsMiwzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJUb1N0cmluZygpIHtcbiAgICAgIHJldHVybiBTdHJpbmcodGhpcy5fX3dyYXBwZWRfXyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB2YWx1ZU9mXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgdmFsdWVcbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnZhbHVlT2YoKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVmFsdWVPZigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fd3JhcHBlZF9fO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB3cmFwcGVkIHZhbHVlcyB3aGVuIGNoYWluaW5nXG4gICAgbG9kYXNoLmFmdGVyID0gYWZ0ZXI7XG4gICAgbG9kYXNoLmFzc2lnbiA9IGFzc2lnbjtcbiAgICBsb2Rhc2guYXQgPSBhdDtcbiAgICBsb2Rhc2guYmluZCA9IGJpbmQ7XG4gICAgbG9kYXNoLmJpbmRBbGwgPSBiaW5kQWxsO1xuICAgIGxvZGFzaC5iaW5kS2V5ID0gYmluZEtleTtcbiAgICBsb2Rhc2guY2hhaW4gPSBjaGFpbjtcbiAgICBsb2Rhc2guY29tcGFjdCA9IGNvbXBhY3Q7XG4gICAgbG9kYXNoLmNvbXBvc2UgPSBjb21wb3NlO1xuICAgIGxvZGFzaC5jb25zdGFudCA9IGNvbnN0YW50O1xuICAgIGxvZGFzaC5jb3VudEJ5ID0gY291bnRCeTtcbiAgICBsb2Rhc2guY3JlYXRlID0gY3JlYXRlO1xuICAgIGxvZGFzaC5jcmVhdGVDYWxsYmFjayA9IGNyZWF0ZUNhbGxiYWNrO1xuICAgIGxvZGFzaC5jdXJyeSA9IGN1cnJ5O1xuICAgIGxvZGFzaC5kZWJvdW5jZSA9IGRlYm91bmNlO1xuICAgIGxvZGFzaC5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgIGxvZGFzaC5kZWZlciA9IGRlZmVyO1xuICAgIGxvZGFzaC5kZWxheSA9IGRlbGF5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcbiAgICBsb2Rhc2guZmlsdGVyID0gZmlsdGVyO1xuICAgIGxvZGFzaC5mbGF0dGVuID0gZmxhdHRlbjtcbiAgICBsb2Rhc2guZm9yRWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmZvckVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZm9ySW4gPSBmb3JJbjtcbiAgICBsb2Rhc2guZm9ySW5SaWdodCA9IGZvckluUmlnaHQ7XG4gICAgbG9kYXNoLmZvck93biA9IGZvck93bjtcbiAgICBsb2Rhc2guZm9yT3duUmlnaHQgPSBmb3JPd25SaWdodDtcbiAgICBsb2Rhc2guZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5ncm91cEJ5ID0gZ3JvdXBCeTtcbiAgICBsb2Rhc2guaW5kZXhCeSA9IGluZGV4Qnk7XG4gICAgbG9kYXNoLmluaXRpYWwgPSBpbml0aWFsO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG4gICAgbG9kYXNoLmludmVydCA9IGludmVydDtcbiAgICBsb2Rhc2guaW52b2tlID0gaW52b2tlO1xuICAgIGxvZGFzaC5rZXlzID0ga2V5cztcbiAgICBsb2Rhc2gubWFwID0gbWFwO1xuICAgIGxvZGFzaC5tYXBWYWx1ZXMgPSBtYXBWYWx1ZXM7XG4gICAgbG9kYXNoLm1heCA9IG1heDtcbiAgICBsb2Rhc2gubWVtb2l6ZSA9IG1lbW9pemU7XG4gICAgbG9kYXNoLm1lcmdlID0gbWVyZ2U7XG4gICAgbG9kYXNoLm1pbiA9IG1pbjtcbiAgICBsb2Rhc2gub21pdCA9IG9taXQ7XG4gICAgbG9kYXNoLm9uY2UgPSBvbmNlO1xuICAgIGxvZGFzaC5wYWlycyA9IHBhaXJzO1xuICAgIGxvZGFzaC5wYXJ0aWFsID0gcGFydGlhbDtcbiAgICBsb2Rhc2gucGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0O1xuICAgIGxvZGFzaC5waWNrID0gcGljaztcbiAgICBsb2Rhc2gucGx1Y2sgPSBwbHVjaztcbiAgICBsb2Rhc2gucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICBsb2Rhc2gucHVsbCA9IHB1bGw7XG4gICAgbG9kYXNoLnJhbmdlID0gcmFuZ2U7XG4gICAgbG9kYXNoLnJlamVjdCA9IHJlamVjdDtcbiAgICBsb2Rhc2gucmVtb3ZlID0gcmVtb3ZlO1xuICAgIGxvZGFzaC5yZXN0ID0gcmVzdDtcbiAgICBsb2Rhc2guc2h1ZmZsZSA9IHNodWZmbGU7XG4gICAgbG9kYXNoLnNvcnRCeSA9IHNvcnRCeTtcbiAgICBsb2Rhc2gudGFwID0gdGFwO1xuICAgIGxvZGFzaC50aHJvdHRsZSA9IHRocm90dGxlO1xuICAgIGxvZGFzaC50aW1lcyA9IHRpbWVzO1xuICAgIGxvZGFzaC50b0FycmF5ID0gdG9BcnJheTtcbiAgICBsb2Rhc2gudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIGxvZGFzaC51bmlvbiA9IHVuaW9uO1xuICAgIGxvZGFzaC51bmlxID0gdW5pcTtcbiAgICBsb2Rhc2gudmFsdWVzID0gdmFsdWVzO1xuICAgIGxvZGFzaC53aGVyZSA9IHdoZXJlO1xuICAgIGxvZGFzaC53aXRob3V0ID0gd2l0aG91dDtcbiAgICBsb2Rhc2gud3JhcCA9IHdyYXA7XG4gICAgbG9kYXNoLnhvciA9IHhvcjtcbiAgICBsb2Rhc2guemlwID0gemlwO1xuICAgIGxvZGFzaC56aXBPYmplY3QgPSB6aXBPYmplY3Q7XG5cbiAgICAvLyBhZGQgYWxpYXNlc1xuICAgIGxvZGFzaC5jb2xsZWN0ID0gbWFwO1xuICAgIGxvZGFzaC5kcm9wID0gcmVzdDtcbiAgICBsb2Rhc2guZWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZXh0ZW5kID0gYXNzaWduO1xuICAgIGxvZGFzaC5tZXRob2RzID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5vYmplY3QgPSB6aXBPYmplY3Q7XG4gICAgbG9kYXNoLnNlbGVjdCA9IGZpbHRlcjtcbiAgICBsb2Rhc2gudGFpbCA9IHJlc3Q7XG4gICAgbG9kYXNoLnVuaXF1ZSA9IHVuaXE7XG4gICAgbG9kYXNoLnVuemlwID0gemlwO1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyB0byBgbG9kYXNoLnByb3RvdHlwZWBcbiAgICBtaXhpbihsb2Rhc2gpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBhZGQgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXMgd2hlbiBjaGFpbmluZ1xuICAgIGxvZGFzaC5jbG9uZSA9IGNsb25lO1xuICAgIGxvZGFzaC5jbG9uZURlZXAgPSBjbG9uZURlZXA7XG4gICAgbG9kYXNoLmNvbnRhaW5zID0gY29udGFpbnM7XG4gICAgbG9kYXNoLmVzY2FwZSA9IGVzY2FwZTtcbiAgICBsb2Rhc2guZXZlcnkgPSBldmVyeTtcbiAgICBsb2Rhc2guZmluZCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRJbmRleCA9IGZpbmRJbmRleDtcbiAgICBsb2Rhc2guZmluZEtleSA9IGZpbmRLZXk7XG4gICAgbG9kYXNoLmZpbmRMYXN0ID0gZmluZExhc3Q7XG4gICAgbG9kYXNoLmZpbmRMYXN0SW5kZXggPSBmaW5kTGFzdEluZGV4O1xuICAgIGxvZGFzaC5maW5kTGFzdEtleSA9IGZpbmRMYXN0S2V5O1xuICAgIGxvZGFzaC5oYXMgPSBoYXM7XG4gICAgbG9kYXNoLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgbG9kYXNoLmluZGV4T2YgPSBpbmRleE9mO1xuICAgIGxvZGFzaC5pc0FyZ3VtZW50cyA9IGlzQXJndW1lbnRzO1xuICAgIGxvZGFzaC5pc0FycmF5ID0gaXNBcnJheTtcbiAgICBsb2Rhc2guaXNCb29sZWFuID0gaXNCb29sZWFuO1xuICAgIGxvZGFzaC5pc0RhdGUgPSBpc0RhdGU7XG4gICAgbG9kYXNoLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbiAgICBsb2Rhc2guaXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgbG9kYXNoLmlzRXF1YWwgPSBpc0VxdWFsO1xuICAgIGxvZGFzaC5pc0Zpbml0ZSA9IGlzRmluaXRlO1xuICAgIGxvZGFzaC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgICBsb2Rhc2guaXNOYU4gPSBpc05hTjtcbiAgICBsb2Rhc2guaXNOdWxsID0gaXNOdWxsO1xuICAgIGxvZGFzaC5pc051bWJlciA9IGlzTnVtYmVyO1xuICAgIGxvZGFzaC5pc09iamVjdCA9IGlzT2JqZWN0O1xuICAgIGxvZGFzaC5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbiAgICBsb2Rhc2guaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbiAgICBsb2Rhc2guaXNTdHJpbmcgPSBpc1N0cmluZztcbiAgICBsb2Rhc2guaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcbiAgICBsb2Rhc2gubGFzdEluZGV4T2YgPSBsYXN0SW5kZXhPZjtcbiAgICBsb2Rhc2gubWl4aW4gPSBtaXhpbjtcbiAgICBsb2Rhc2gubm9Db25mbGljdCA9IG5vQ29uZmxpY3Q7XG4gICAgbG9kYXNoLm5vb3AgPSBub29wO1xuICAgIGxvZGFzaC5ub3cgPSBub3c7XG4gICAgbG9kYXNoLnBhcnNlSW50ID0gcGFyc2VJbnQ7XG4gICAgbG9kYXNoLnJhbmRvbSA9IHJhbmRvbTtcbiAgICBsb2Rhc2gucmVkdWNlID0gcmVkdWNlO1xuICAgIGxvZGFzaC5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5yZXN1bHQgPSByZXN1bHQ7XG4gICAgbG9kYXNoLnJ1bkluQ29udGV4dCA9IHJ1bkluQ29udGV4dDtcbiAgICBsb2Rhc2guc2l6ZSA9IHNpemU7XG4gICAgbG9kYXNoLnNvbWUgPSBzb21lO1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleCA9IHNvcnRlZEluZGV4O1xuICAgIGxvZGFzaC50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIGxvZGFzaC51bmVzY2FwZSA9IHVuZXNjYXBlO1xuICAgIGxvZGFzaC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuXG4gICAgLy8gYWRkIGFsaWFzZXNcbiAgICBsb2Rhc2guYWxsID0gZXZlcnk7XG4gICAgbG9kYXNoLmFueSA9IHNvbWU7XG4gICAgbG9kYXNoLmRldGVjdCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRXaGVyZSA9IGZpbmQ7XG4gICAgbG9kYXNoLmZvbGRsID0gcmVkdWNlO1xuICAgIGxvZGFzaC5mb2xkciA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5pbmNsdWRlID0gY29udGFpbnM7XG4gICAgbG9kYXNoLmluamVjdCA9IHJlZHVjZTtcblxuICAgIG1peGluKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHt9XG4gICAgICBmb3JPd24obG9kYXNoLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmICghbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICAgIHNvdXJjZVttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9KCksIGZhbHNlKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyBjYXBhYmxlIG9mIHJldHVybmluZyB3cmFwcGVkIGFuZCB1bndyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmdcbiAgICBsb2Rhc2guZmlyc3QgPSBmaXJzdDtcbiAgICBsb2Rhc2gubGFzdCA9IGxhc3Q7XG4gICAgbG9kYXNoLnNhbXBsZSA9IHNhbXBsZTtcblxuICAgIC8vIGFkZCBhbGlhc2VzXG4gICAgbG9kYXNoLnRha2UgPSBmaXJzdDtcbiAgICBsb2Rhc2guaGVhZCA9IGZpcnN0O1xuXG4gICAgZm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGNhbGxiYWNrYWJsZSA9IG1ldGhvZE5hbWUgIT09ICdzYW1wbGUnO1xuICAgICAgaWYgKCFsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdKSB7XG4gICAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV09IGZ1bmN0aW9uKG4sIGd1YXJkKSB7XG4gICAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmModGhpcy5fX3dyYXBwZWRfXywgbiwgZ3VhcmQpO1xuXG4gICAgICAgICAgcmV0dXJuICFjaGFpbkFsbCAmJiAobiA9PSBudWxsIHx8IChndWFyZCAmJiAhKGNhbGxiYWNrYWJsZSAmJiB0eXBlb2YgbiA9PSAnZnVuY3Rpb24nKSkpXG4gICAgICAgICAgICA/IHJlc3VsdFxuICAgICAgICAgICAgOiBuZXcgbG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICovXG4gICAgbG9kYXNoLlZFUlNJT04gPSAnMi40LjEnO1xuXG4gICAgLy8gYWRkIFwiQ2hhaW5pbmdcIiBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXJcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNoYWluID0gd3JhcHBlckNoYWluO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudG9TdHJpbmcgPSB3cmFwcGVyVG9TdHJpbmc7XG4gICAgbG9kYXNoLnByb3RvdHlwZS52YWx1ZSA9IHdyYXBwZXJWYWx1ZU9mO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudmFsdWVPZiA9IHdyYXBwZXJWYWx1ZU9mO1xuXG4gICAgLy8gYWRkIGBBcnJheWAgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXNcbiAgICBmb3JFYWNoKFsnam9pbicsICdwb3AnLCAnc2hpZnQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBhcnJheVJlZlttZXRob2ROYW1lXTtcbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMuX193cmFwcGVkX18sIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgcmV0dXJuIGNoYWluQWxsXG4gICAgICAgICAgPyBuZXcgbG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKVxuICAgICAgICAgIDogcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIGFkZCBgQXJyYXlgIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB0aGUgZXhpc3Rpbmcgd3JhcHBlZCB2YWx1ZVxuICAgIGZvckVhY2goWydwdXNoJywgJ3JldmVyc2UnLCAnc29ydCcsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlSZWZbbWV0aG9kTmFtZV07XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmMuYXBwbHkodGhpcy5fX3dyYXBwZWRfXywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gYWRkIGBBcnJheWAgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIG5ldyB3cmFwcGVkIHZhbHVlc1xuICAgIGZvckVhY2goWydjb25jYXQnLCAnc2xpY2UnLCAnc3BsaWNlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlSZWZbbWV0aG9kTmFtZV07XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgbG9kYXNoV3JhcHBlcihmdW5jLmFwcGx5KHRoaXMuX193cmFwcGVkX18sIGFyZ3VtZW50cyksIHRoaXMuX19jaGFpbl9fKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbG9kYXNoO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gZXhwb3NlIExvLURhc2hcbiAgdmFyIF8gPSBydW5JbkNvbnRleHQoKTtcblxuICAvLyBzb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzIGxpa2Ugci5qcyBjaGVjayBmb3IgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2UgdGhlIGZvbGxvd2luZzpcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gRXhwb3NlIExvLURhc2ggdG8gdGhlIGdsb2JhbCBvYmplY3QgZXZlbiB3aGVuIGFuIEFNRCBsb2FkZXIgaXMgcHJlc2VudCBpblxuICAgIC8vIGNhc2UgTG8tRGFzaCBpcyBsb2FkZWQgd2l0aCBhIFJlcXVpcmVKUyBzaGltIGNvbmZpZy5cbiAgICAvLyBTZWUgaHR0cDovL3JlcXVpcmVqcy5vcmcvZG9jcy9hcGkuaHRtbCNjb25maWctc2hpbVxuICAgIHJvb3QuXyA9IF87XG5cbiAgICAvLyBkZWZpbmUgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSBzbywgdGhyb3VnaCBwYXRoIG1hcHBpbmcsIGl0IGNhbiBiZVxuICAgIC8vIHJlZmVyZW5jZWQgYXMgdGhlIFwidW5kZXJzY29yZVwiIG1vZHVsZVxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG4gIC8vIGNoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGFuIGBleHBvcnRzYCBvYmplY3RcbiAgZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuICAgIC8vIGluIE5vZGUuanMgb3IgUmluZ29KU1xuICAgIGlmIChtb2R1bGVFeHBvcnRzKSB7XG4gICAgICAoZnJlZU1vZHVsZS5leHBvcnRzID0gXykuXyA9IF87XG4gICAgfVxuICAgIC8vIGluIE5hcndoYWwgb3IgUmhpbm8gLXJlcXVpcmVcbiAgICBlbHNlIHtcbiAgICAgIGZyZWVFeHBvcnRzLl8gPSBfO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBpbiBhIGJyb3dzZXIgb3IgUmhpbm9cbiAgICByb290Ll8gPSBfO1xuICB9XG59LmNhbGwodGhpcykpO1xuIl19
